{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap bc8be8c54f7a4484aca8","webpack:///./sources/OSG.js","webpack:///./sources/osgNameSpace.js","webpack:///./package.json","webpack:///./sources/osg/osg.js","webpack:///./sources/osg/AutoTransform.js","webpack:///./sources/osg/Utils.js","webpack:///./sources/osgUtil/osgPool.js","webpack:///./sources/osg/StateGraph.js","webpack:///./sources/osg/Timer.js","webpack:///./sources/osg/notify.js","webpack:///./sources/osg/Transform.js","webpack:///./sources/osg/Node.js","webpack:///./sources/osg/Object.js","webpack:///./sources/osg/BoundingBox.js","webpack:///./sources/osg/glMatrix.js","webpack:///./sources/osg/math.js","webpack:///./~/gl-matrix/src/gl-matrix.js","webpack:///./~/gl-matrix/src/gl-matrix/common.js","webpack:///./~/gl-matrix/src/gl-matrix/mat2.js","webpack:///./~/gl-matrix/src/gl-matrix/mat2d.js","webpack:///./~/gl-matrix/src/gl-matrix/mat3.js","webpack:///./~/gl-matrix/src/gl-matrix/mat4.js","webpack:///./~/gl-matrix/src/gl-matrix/quat.js","webpack:///./~/gl-matrix/src/gl-matrix/vec3.js","webpack:///./~/gl-matrix/src/gl-matrix/vec4.js","webpack:///./~/gl-matrix/src/gl-matrix/vec2.js","webpack:///./sources/config.js","webpack:///./sources/osg/BoundingSphere.js","webpack:///./sources/osg/StateSet.js","webpack:///./sources/osg/StateAttribute.js","webpack:///./sources/osg/NodeVisitor.js","webpack:///./sources/osg/MatrixMemoryPool.js","webpack:///./sources/osg/computeMatrixFromNodePath.js","webpack:///./sources/osg/transformEnums.js","webpack:///./sources/osg/ComputeBoundsVisitor.js","webpack:///./sources/osg/Geometry.js","webpack:///./sources/osg/WebGLCaps.js","webpack:///./sources/osgViewer/webgl-utils.js","webpack:///./sources/osg/Options.js","webpack:///./sources/osg/Texture.js","webpack:///./sources/osg/Uniform.js","webpack:///./sources/osg/Image.js","webpack:///./sources/osg/GLObject.js","webpack:///./sources/osg/TextureManager.js","webpack:///./sources/osg/DrawElements.js","webpack:///./sources/osg/primitiveSet.js","webpack:///./sources/osg/BufferArrayProxy.js","webpack:///./sources/osg/BufferArray.js","webpack:///./sources/osg/BillboardAttribute.js","webpack:///./sources/osg/BlendColor.js","webpack:///./sources/osg/BlendFunc.js","webpack:///./sources/osg/Camera.js","webpack:///./sources/osg/CullSettings.js","webpack:///./sources/osg/ColorMask.js","webpack:///./sources/osg/CullFace.js","webpack:///./sources/osg/CullingSet.js","webpack:///./sources/osg/Polytope.js","webpack:///./sources/osg/Plane.js","webpack:///./sources/osg/CullStack.js","webpack:///./sources/osg/CullVisitor.js","webpack:///./sources/osg/MatrixTransform.js","webpack:///./sources/osg/Projection.js","webpack:///./sources/osg/LightSource.js","webpack:///./sources/osg/RenderLeaf.js","webpack:///./sources/osg/RenderBin.js","webpack:///./sources/osg/RenderStage.js","webpack:///./sources/osg/FrameBufferObject.js","webpack:///./sources/osg/Lod.js","webpack:///./sources/osg/PagedLOD.js","webpack:///./sources/osgAnimation/Skeleton.js","webpack:///./sources/osgAnimation/UpdateSkeleton.js","webpack:///./sources/osgAnimation/Bone.js","webpack:///./sources/osgAnimation/UpdateBone.js","webpack:///./sources/osgAnimation/UpdateMatrixTransform.js","webpack:///./sources/osgAnimation/AnimationUpdateCallback.js","webpack:///./sources/osgAnimation/RigGeometry.js","webpack:///./sources/osgAnimation/MorphGeometry.js","webpack:///./sources/osgAnimation/MorphAttribute.js","webpack:///./sources/osgAnimation/UpdateRigGeometry.js","webpack:///./sources/osgAnimation/FindNearestParentSkeleton.js","webpack:///./sources/osgAnimation/RigTransformHardware.js","webpack:///./sources/osgAnimation/SkinningAttribute.js","webpack:///./sources/osgAnimation/CollectBoneVisitor.js","webpack:///./sources/osg/Depth.js","webpack:///./sources/osg/DrawArrayLengths.js","webpack:///./sources/osg/DrawArrays.js","webpack:///./sources/osg/EllipsoidModel.js","webpack:///./sources/osg/FrameStamp.js","webpack:///./sources/osg/ImageStream.js","webpack:///external {\"root\":\"P\",\"commonjs2\":\"bluebird\",\"commonjs\":\"bluebird\",\"amd\":\"bluebird\"}","webpack:///./sources/osg/KdTree.js","webpack:///./sources/osg/TriangleIndexFunctor.js","webpack:///./sources/osg/KdTreeLineSegmentIntersector.js","webpack:///./sources/osgUtil/TriangleLineSegmentIntersector.js","webpack:///./sources/osg/KdTreeSphereIntersector.js","webpack:///./sources/osgUtil/TriangleSphereIntersector.js","webpack:///./sources/osg/KdTreeBuilder.js","webpack:///./sources/osg/Light.js","webpack:///./sources/osg/LineWidth.js","webpack:///./sources/osg/Material.js","webpack:///./sources/osg/PointSizeAttribute.js","webpack:///./sources/osg/PrimitiveFunctor.js","webpack:///./sources/osg/Program.js","webpack:///./sources/osgShader/ShaderProcessor.js","webpack:///./sources/osgShader/shaderLib.js","webpack:///./sources/osgShader/node/functions.glsl","webpack:///./sources/osgShader/node/lights.glsl","webpack:///./sources/osgShader/node/skinning.glsl","webpack:///./sources/osgShader/node/textures.glsl","webpack:///./sources/osgShader/node/colorEncode.glsl","webpack:///./sources/osgShader/node/noise.glsl","webpack:///./sources/osgShader/node/billboard.glsl","webpack:///./sources/osgShadow/shaderLib.js","webpack:///./sources/osgShadow/shaders/shadowsCastFrag.glsl","webpack:///./sources/osgShadow/shaders/shadowsReceive.glsl","webpack:///./sources/osgShadow/shaders/shadowsReceiveMain.glsl","webpack:///./sources/osgShadow/shaders/shadowLinearSoft.glsl","webpack:///./sources/osgShadow/shaders/pcf.glsl","webpack:///./sources/osgShadow/shaders/tapPCF.glsl","webpack:///./sources/osgShadow/shaders/hash.glsl","webpack:///./sources/osg/Shader.js","webpack:///./sources/osg/shape.js","webpack:///./sources/osg/Stack.js","webpack:///./sources/osg/State.js","webpack:///./sources/osg/TextureCubeMap.js","webpack:///./sources/osg/UpdateVisitor.js","webpack:///./sources/osg/Viewport.js","webpack:///./sources/osg/Scissor.js","webpack:///./sources/osg/TimerGPU.js","webpack:///./sources/osgAnimation/osgAnimation.js","webpack:///./sources/osgAnimation/animation.js","webpack:///./sources/osgAnimation/channel.js","webpack:///./sources/osgAnimation/target.js","webpack:///./sources/osgAnimation/channelType.js","webpack:///./sources/osgAnimation/BasicAnimationManager.js","webpack:///./sources/osgAnimation/interpolator.js","webpack:///./sources/osgAnimation/CollectAnimationUpdateCallbackVisitor.js","webpack:///./sources/osgAnimation/UpdateMorph.js","webpack:///./sources/osgAnimation/easing.js","webpack:///./sources/osgAnimation/StackedMatrix.js","webpack:///./sources/osgAnimation/StackedQuaternion.js","webpack:///./sources/osgAnimation/StackedRotateAxis.js","webpack:///./sources/osgAnimation/StackedScale.js","webpack:///./sources/osgAnimation/StackedTranslate.js","webpack:///./sources/osgDB/osgDB.js","webpack:///./sources/osgDB/Input.js","webpack:///./sources/osgDB/requestFile.js","webpack:///./sources/osgDB/options.js","webpack:///./sources/osgDB/zlib.js","webpack:///external {\"root\":\"Zlib\",\"commonjs2\":\"zlib\",\"commonjs\":\"zlib\",\"amd\":\"zlib\"}","webpack:///./sources/osgDB/readerParser.js","webpack:///./sources/osgDB/Registry.js","webpack:///./sources/osgDB/DatabasePager.js","webpack:///./sources/osgWrappers/serializers/osg.js","webpack:///./sources/osgWrappers/serializers/osgAnimation.js","webpack:///./sources/osgWrappers/serializers/osgText.js","webpack:///./sources/osgText/Text.js","webpack:///./sources/osgDB/FileHelper.js","webpack:///./sources/osgGA/osgGA.js","webpack:///external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammer\"}","webpack:///./sources/osgGA/CADManipulator.js","webpack:///./sources/osgGA/Manipulator.js","webpack:///./sources/osgUtil/IntersectionVisitor.js","webpack:///./sources/osgUtil/LineSegmentIntersector.js","webpack:///./sources/osgUtil/PolytopeIntersector.js","webpack:///./sources/osgUtil/PolytopePrimitiveIntersector.js","webpack:///./sources/osgGA/CADManipulatorStandardMouseKeyboardController.js","webpack:///./sources/osgGA/OrbitManipulator.js","webpack:///./sources/osgGA/OrbitManipulatorDeviceOrientationController.js","webpack:///./sources/osgGA/FirstPersonManipulatorDeviceOrientationController.js","webpack:///./sources/osgGA/OrbitManipulatorGamePadController.js","webpack:///./sources/osgGA/OrbitManipulatorHammerController.js","webpack:///./sources/osgGA/OrbitManipulatorLeapMotionController.js","webpack:///./sources/osgGA/OrbitManipulatorStandardMouseKeyboardController.js","webpack:///./sources/osgGA/orbitManipulatorEnums.js","webpack:///./sources/osgGA/OrbitManipulatorWebVRController.js","webpack:///./sources/osgUtil/DelayInterpolator.js","webpack:///./sources/osgGA/CADManipulatorHammerController.js","webpack:///./sources/osgGA/FirstPersonManipulator.js","webpack:///./sources/osgGA/FirstPersonManipulatorHammerController.js","webpack:///./sources/osgGA/FirstPersonManipulatorWebVRController.js","webpack:///./sources/osgGA/FirstPersonManipulatorStandardMouseKeyboardController.js","webpack:///./sources/osgGA/SwitchManipulator.js","webpack:///./sources/osgUtil/osgUtil.js","webpack:///./sources/osgUtil/Composer.js","webpack:///./sources/osgUtil/debug.js","webpack:///./sources/osgUtil/DisplayNormalVisitor.js","webpack:///./sources/osgShader/ShaderGenerator.js","webpack:///./sources/osgShader/Compiler.js","webpack:///./sources/osgShader/nodeFactory.js","webpack:///./sources/osgShader/node/skinning.js","webpack:///./sources/osgShader/utils.js","webpack:///./sources/osgShader/osgShader.js","webpack:///./sources/osgShader/ShaderGeneratorProxy.js","webpack:///./sources/osgShadow/ShadowCastShaderGenerator.js","webpack:///./sources/osgShadow/ShadowCastCompiler.js","webpack:///./sources/osgUtil/DisplayGeometryVisitor.js","webpack:///./sources/osgShader/node.js","webpack:///./sources/osgShader/node/morph.js","webpack:///./sources/osgShader/node/Node.js","webpack:///./sources/osgShader/node/data.js","webpack:///./sources/osgShader/node/textures.js","webpack:///./sources/osgShader/node/functions.js","webpack:///./sources/osgShader/node/lights.js","webpack:///./sources/osgShader/node/operations.js","webpack:///./sources/osgShader/node/shadows.js","webpack:///./sources/osgShader/node/billboard.js","webpack:///./sources/osgShader/CompilerVertex.js","webpack:///./sources/osgShader/CompilerFragment.js","webpack:///./sources/osgUtil/DisplayGraph.js","webpack:///./sources/osgUtil/DisplayGraphRenderer.js","webpack:///./sources/osgUtil/DisplayGraphNode.js","webpack:///external {\"root\":\"$\",\"commonjs2\":\"jquery\",\"commonjs\":\"jquery\",\"amd\":\"jquery\"}","webpack:///./sources/osgViewer/Renderer.js","webpack:///./sources/osgViewer/View.js","webpack:///./sources/osgViewer/Scene.js","webpack:///./sources/osgUtil/NodeGizmo.js","webpack:///./sources/osgUtil/gizmoGeometry.js","webpack:///./sources/osgUtil/SphereIntersector.js","webpack:///./sources/osgUtil/TangentSpaceGenerator.js","webpack:///./sources/osgUtil/WebVRCustom.js","webpack:///./sources/osgUtil/WebVR.js","webpack:///./sources/osgViewer/osgViewer.js","webpack:///./sources/osgViewer/Viewer.js","webpack:///./sources/osgViewer/createStats.js","webpack:///./sources/osgViewer/eventProxy/eventProxy.js","webpack:///./sources/osgViewer/eventProxy/GamePad.js","webpack:///./sources/osgViewer/eventProxy/Hammer.js","webpack:///./sources/osgViewer/eventProxy/LeapMotion.js","webpack:///external {\"root\":\"Leap\",\"commonjs2\":\"leapjs\",\"commonjs\":\"leapjs\",\"amd\":\"leap\"}","webpack:///./sources/osgViewer/eventProxy/StandardMouseKeyboard.js","webpack:///./sources/osgViewer/eventProxy/WebVR.js","webpack:///./sources/osgUtil/webvr-1-1.js","webpack:///./sources/osgViewer/eventProxy/DeviceOrientation.js","webpack:///./sources/osgViewer/webgl-debug.js","webpack:///./sources/osgShadow/osgShadow.js","webpack:///./sources/osgShadow/ShadowCastAttribute.js","webpack:///./sources/osgShadow/ShadowCasterVisitor.js","webpack:///./sources/osgShadow/ShadowFrustumIntersection.js","webpack:///./sources/osgShadow/ShadowMap.js","webpack:///./sources/osgShadow/ShadowReceiveAttribute.js","webpack:///./sources/osgShadow/ShadowTechnique.js","webpack:///./sources/osgShadow/ShadowTexture.js","webpack:///./sources/osgShadow/ShadowMapAtlas.js","webpack:///./sources/osgShadow/ShadowTextureAtlas.js","webpack:///./sources/osgShadow/ShadowSettings.js","webpack:///./sources/osgShadow/ShadowedScene.js","webpack:///./sources/osgText/osgText.js","webpack:///./sources/osgWrappers/osgWrappers.js","webpack:///./sources/osgPlugins/osgPlugins.js","webpack:///./sources/osgPlugins/ReaderWriterGLTF.js","webpack:///./sources/osgPlugins/ReaderWriterZIP.js"],"names":[],"mappings":";;;;AAAA;AACA;AACA,qIAAqI,MAAM,0BAA0B,EAAE,YAAY,EAAE;AACrL;AACA;AACA;AACA,qIAAqI,MAAM,0BAA0B,EAAE,YAAY,EAAE;AACrL;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;ACvCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA,G;;;;;;ACzDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACzKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;;AAGL,EAAC;AACD;;AAEA;;;;;;;AC3UA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;AAED,8FAA6F;AAC7F,2DAA0D;AAC1D,iEAAgE;;AAEhE;;;;;;;ACvMA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAAyC,OAAO;;AAEhD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET,2CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;;;;;;;ACrJA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;;AAGA;;;AAGA;;;;;;;;ACvDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,qBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC3GA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;;AAED;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,uDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT;AACA,+CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;;AAGA,EAAC;AACD;;;AAGA;;;;;;;AC1fA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpDA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;AC7NA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC3iBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;ACpCA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;ACrEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;;AAEA,mC;AACA,sB;AACA,iB;AACA,iB;AACA,+B;AACA,sB;AACA,G;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnbA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,OAAO;AACpB;AACA,4B;AACA;AACA,G;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpdA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gB;AACA,qB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,KAAK;AACf,WAAU,KAAK;AACf;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAU,KAAK;AACf,WAAU,KAAK;AACf;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gB;AACA,qB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACzuBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,WAAU;AACV;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,WAAW,WAAW;AACpC;AACA;AACA;AACA;;AAEA,eAAc,WAAW,YAAY;AACrC;AACA;AACA;AACA;;AAEA,gBAAe,YAAY,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,oBAAmB,YAAY,YAAY;AAC3C,oBAAmB,YAAY,YAAY;AAC3C,oBAAmB,YAAY,aAAa;;AAE5C,sBAAqB,cAAc,cAAc;AACjD,sBAAqB,cAAc,cAAc;AACjD,sBAAqB,cAAc,eAAe;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB,eAAe,eAAe;AACpD,uBAAsB,eAAe,eAAe;AACpD,uBAAsB,eAAe,iBAAiB;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,aAAa;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,YAAY,YAAY;AACvC,gBAAe,YAAY,YAAY;AACvC,gBAAe,YAAY,aAAa;;AAExC;AACA,yBAAwB,yBAAyB;AACjD,6BAA4B,qBAAqB;AACjD,6BAA4B,yBAAyB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,aAAa;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA,mB;AACA;AACA;AACA;AACA,oC;AACA,oC;AACA,IAAG,iD;AACH;AACA;AACA;AACA,oC;AACA,oC;AACA,IAAG,6B;AACH;AACA;AACA,oC;AACA;AACA,oC;AACA,IAAG,O;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;ACvlEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA,gB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA,gB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA,gB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,O;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC;AACxC;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;;AAEA;;;;;;;ACvlBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,wBAAuB,OAAO;AAC9B,2BAA0B,iBAAiB;AAC3C;AACA,2BAA0B,iBAAiB;AAC3C;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,M;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxwBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,wBAAuB,OAAO;AAC9B,2BAA0B,iBAAiB,iBAAiB;AAC5D;AACA,2BAA0B,iBAAiB,iBAAiB;AAC5D;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChmBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,wBAAuB,OAAO;AAC9B,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,KAAK;AAChB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1kBA;;AAEA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAgC,OAAO;AACvC,oEAAmE;AACnE,4CAA2C;AAC3C,2EAA0E;AAC1E,6CAA4C;AAC5C;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;;;;;;ACvLA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;;AAGA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,kEAAiE,OAAO;AACxE;AACA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;;;;;;;AC7RA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;AC/IA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;AC5CA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAsC,QAAQ;;AAE9C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAAyC,OAAO;;AAEhD;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;ACnDA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,8CAA6C;;AAE7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;;AAGA,EAAC;;AAED;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,sDAAqD;AACrD,uBAAsB;AACtB;;AAEA,2DAA0D,OAAO;;AAEjE,yGAAwG;AACxG,mGAAkG;AAClG,uEAAsE;AACtE,sIAAqI;;AAErI;;AAEA,8EAA6E;;AAE7E;AACA,mGAAkG;;AAElG;AACA,MAAK;;AAEL;;AAEA;AACA,yDAAwD,gCAAgC;AACxF;;AAEA;AACA;AACA,wDAAuD;AACvD,uDAAsD;AACtD,6CAA4C;AAC5C,uCAAsC;AACtC,0CAAyC;AACzC,oBAAmB;AACnB,kDAAiD;AACjD;AACA;;;AAGA,iEAAgE;AAChE,gDAA+C,OAAO;AACtD,qEAAoE;;AAEpE;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAwD;AACxD;AACA,yEAAwE;AACxE,yCAAwC;AACxC,2FAA0F;AAC1F,+BAA8B;AAC9B;AACA,oDAAmD,OAAO;AAC1D,+DAA8D;AAC9D,6DAA4D;AAC5D,uDAAsD;AACtD,0DAAyD;AACzD,yCAAwC;AACxC;AACA,kCAAiC;;AAEjC;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wGAAuG,+BAA+B;AACtI;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,kEAAiE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;;;;;;ACpZA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA,mEAAkE;;AAElE;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD,SAAS;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACzbA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D,qBAAoB;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,OAAO;AACtB;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA,uCAAsC,aAAa,cAAc,gBAAgB,kBAAkB;AACnG;AACA,oDAAmD,aAAa,cAAc;AAC9E;AACA,+CAA8C,wBAAwB;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA,iBAAgB,cAAc;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,mBAAmB;AAC5C;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClNA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAkD;AAClD,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,sBAAqB;AACrB,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAS;AACT;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAiB;AACjB;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA,EAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACn2BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAkD,YAAY;AAC9D;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE,wFAAuF;AACvF,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACnOA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,aAAa;AACzC,iCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;AC7OA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;AClBA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,+CAA+C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,yCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AChRA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;;AAGA;;AAEA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACVA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AC1CA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC5KA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA,EAAC;;AAED;;;;;;;AC9BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AChDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;;AAEA,UAAS;;;AAGT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;;AAGT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAS;;AAET,MAAK;;AAEL;;AAEA;;;;;;;AC3PA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;;;;;;AC9FA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC3CA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA,EAAC;;AAED;;;;;;;AClDA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,gFAA+E;AAC/E,iFAAgF;AAChF,gFAA+E;AAC/E,iFAAgF;AAChF,gGAA+F;AAC/F,gGAA+F;AAC/F;AACA,MAAK;;;AAGL;AACA;AACA;AACA,8FAA6F;AAC7F,8FAA6F;AAC7F,8FAA6F;AAC7F,8FAA6F;AAC7F,8FAA6F;AAC7F,8FAA6F;AAC7F;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,4BAA4B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;;AAEA;AACA,yBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,yBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,6BAA4B,wCAAwC;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,4BAA4B;AACpD;AACA;AACA,2DAA0D;AAC1D,mFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,4BAA4B;AACpD;AACA;AACA,6CAA4C;AAC5C,kDAAiD;AACjD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,4BAA4B;AACpD;AACA;AACA,6CAA4C;AAC5C,kDAAiD;AACjD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,yBAAwB,4BAA4B;AACpD;AACA;AACA,6CAA4C;AAC5C,kDAAiD;AACjD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;;;;AAIA,EAAC;;AAED;;AAEA;;;;;;;AC5VA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,mDAAkD;AAClD;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,yBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;;AAGA,EAAC;;AAED;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;;;AAIL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,EAAC;;AAED;;;;;;;ACnYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,4DAA2D,QAAQ;AACnE;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,oEAAmE,QAAQ;AAC3E;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;ACtvBA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;;AAEA;;;;;;;ACvDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;AAEA;;;;;;;ACpDA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA,+DAA8D;AAC9D,wGAAuG;AACvG,sEAAqE;;AAErE;AACA,+DAA8D;AAC9D,wEAAuE;AACvE,oEAAmE;AACnE,8EAA6E;AAC7E,kCAAiC;AACjC;;AAEA;AACA,+DAA8D;AAC9D,sEAAqE;AACrE,kEAAiE;AACjE,4EAA2E;AAC3E,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA,0LAAyL,kCAAkC;AAC3N;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,kBAAiB;;AAEjB;AACA;;AAEA,kBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;;;;;;ACpNA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,yDAAwD,OAAO;AAC/D;AACA,+CAA8C,OAAO;AACrD;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,8DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;;AAGA;AACA,+CAA8C,OAAO;;AAErD;;AAEA,mDAAkD,QAAQ;;AAE1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACzTA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA,wDAAuD,OAAO;AAC9D;AACA;;AAEA;;AAEA,yDAAwD,OAAO;AAC/D;AACA;AACA,MAAK;;AAEL;AACA;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+DAA8D;;AAE9D;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAC;;;AAGD;;;;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iDAAgD,OAAO;;AAEvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,qCAAoC,8BAA8B;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,qCAAoC,8BAA8B;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC,wBAAwB;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL,EAAC;;AAED;AACA;;;;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;AACD;;AAEA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,SAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;AACD;;AAEA;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC9CA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,gDAA+C,OAAO;AACtD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AClDA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA2C,aAAa;AACxD;;AAEA;AACA;AACA,gDAA+C,UAAU;AACzD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,gBAAe;AACf,gBAAe;AACf;AACA;AACA;;;AAGA;;AAEA;;AAEA,wBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA4D,SAAS;;AAErE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA,uDAAsD,QAAQ;AAC9D;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAuD,WAAW;;AAElE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;AC1bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;;AAEvB,wBAAuB;AACvB,8CAA6C;AAC7C,2EAA0E;;AAE1E;AACA;;AAEA,qDAAoD;;AAEpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,qCAAoC;AACpC;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uDAAsD,OAAO;AAC7D;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA,mDAAkD,OAAO;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA,8CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;;AAEA,8CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;;;AAGA,EAAC;;AAED;;AAEA;;;;;;;AC5NA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;;AAEzB,qBAAoB;AACpB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,yBAAwB,aAAa;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACxGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACpDA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;AClCA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;;AAGL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;;AAGL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,+CAA8C,OAAO;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;AClIA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD;;AAEnD;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACrFA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACpCA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACvEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;AClDA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;;;;;;ACpDA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;AC9HA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;ACpCA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qDAAoD;AACpD,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,EAAC;;AAED;;AAEA;;;;;;;ACrEA,iD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC;AAClC,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,WAAW;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;AC/aA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAAyB,SAAS;AAClC;AACA;AACA;;AAEA;AACA,iCAAgC,WAAW;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,WAAW;AAC/C;AACA;AACA;;AAEA;AACA,kCAAiC,WAAW;AAC5C;AACA;AACA;;AAEA;AACA,kCAAiC,WAAW;AAC5C;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,WAAW;AAChD;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAwB,kBAAkB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC/FA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,UAAU;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;AC/NA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;ACvKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,UAAU;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;;AAED;;;;;;;ACxFA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;AACL,EAAC;;AAED;;;;;;;ACjPA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;AC7TA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACrBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,EAAC;;AAED;;;;;;;AC1GA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACxEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,EAAE;AAC9C,gDAA+C,EAAE;AACjD,yDAAwD,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,uCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA,6BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA,6BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA,6BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,0CAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB,kBAAkB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA,MAAK;AACL,oDAAmD;AACnD,mCAAkC,OAAO;AACzC,uDAAsD;AACtD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAkC,uCAAuC;AACzE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,mCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA,mDAAkD,OAAO;;AAEzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;;;;;;;ACxUA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB,qBAAoB;AACpB,yFAAwF,mCAAmC;AAC3H;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB,iCAAgC,iCAAiC;AACjE;AACA,qCAAoC,8BAA8B;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAgE;AAChE,iEAAgE;AAChE;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,2FAA0F;AAC1F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0EAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA,0uBAAyuB,yBAAyB,GAAG,sCAAsC,+DAA+D,GAAG,sCAAsC,oEAAoE,GAAG,uIAAuI,yBAAyB,GAAG,sCAAsC,+DAA+D,GAAG,sCAAsC,oEAAoE,GAAG,8GAA8G,iCAAiC,0CAA0C,GAAG,2LAA2L,4CAA4C,+CAA+C,qBAAqB,6CAA6C,4CAA4C,4CAA4C,yCAAyC,4BAA4B,GAAG,mIAAmI,sDAAsD,gBAAgB,+BAA+B,uFAAuF,8CAA8C,gCAAgC,kBAAkB,GAAG,8DAA8D,+CAA+C,qCAAqC,GAAG,C;;;;;;ACA7jF,oJAAmJ,wKAAwK,6CAA6C,qDAAqD,qDAAqD,GAAG,iOAAiO,gCAAgC,2BAA2B,0BAA0B,sBAAsB,2CAA2C,kCAAkC,6BAA6B,sBAAsB,OAAO,mLAAmL,mEAAmE,GAAG,2HAA2H,wDAAwD,GAAG,+0BAA+0B,sBAAsB,0DAA0D,kDAAkD,4DAA4D,kGAAkG,+BAA+B,+GAA+G,yCAAyC,+LAA+L,6EAA6E,iEAAiE,+BAA+B,sCAAsC,6BAA6B,eAAe,OAAO,oKAAoK,eAAe,iCAAiC,yFAAyF,oCAAoC,qCAAqC,0CAA0C,oFAAoF,2CAA2C,gJAAgJ,qFAAqF,mBAAmB,eAAe,WAAW,OAAO,uBAAuB,GAAG,mhBAAmhB,yDAAyD,kDAAkD,uCAAuC,uHAAuH,+BAA+B,+GAA+G,yEAAyE,4BAA4B,6BAA6B,kCAAkC,4EAA4E,mCAAmC,wIAAwI,sEAAsE,WAAW,OAAO,uBAAuB,GAAG,mdAAmd,wBAAwB,oEAAoE,kFAAkF,wBAAwB,yBAAyB,8BAA8B,wEAAwE,+BAA+B,oIAAoI,oDAAoD,OAAO,uBAAuB,GAAG,6YAA6Y,wBAAwB,sEAAsE,6CAA6C,uCAAuC,qFAAqF,yIAAyI,oFAAoF,wDAAwD,0DAA0D,iEAAiE,mGAAmG,8GAA8G,gDAAgD,GAAG,G;;;;;;ACAnoP,6LAA4L,oBAAoB,oBAAoB,2BAA2B,uCAAuC,sGAAsG,oBAAoB,oCAAoC,uCAAuC,6CAA6C,6CAA6C,uNAAuN,uCAAuC,6CAA6C,6CAA6C,wDAAwD,uCAAuC,6CAA6C,6CAA6C,wDAAwD,uCAAuC,6CAA6C,6CAA6C,wDAAwD,wBAAwB,GAAG,wOAAwO,gLAAgL,uCAAuC,uCAAuC,sBAAsB,MAAM,mFAAmF,0CAA0C,iCAAiC,iCAAiC,qGAAqG,6FAA6F,2FAA2F,2FAA2F,2FAA2F,uBAAuB,MAAM,sLAAsL,0CAA0C,iCAAiC,sFAAsF,qGAAqG,8HAA8H,uCAAuC,wCAAwC,wCAAwC,yCAAyC,uCAAuC,wCAAwC,wCAAwC,yCAAyC,uCAAuC,wCAAwC,wCAAwC,yCAAyC,uCAAuC,wCAAwC,wCAAwC,yCAAyC,yBAAyB,MAAM,G;;;;;;ACA5uH,8EAA6E,wCAAwC,GAAG,gEAAgE,yCAAyC,GAAG,sEAAsE,kCAAkC,GAAG,kEAAkE,sCAAsC,GAAG,G;;;;;;ACA1b,yDAAwD,4EAA4E,GAAG,qCAAqC,2DAA2D,uBAAuB,gEAAgE,iBAAiB,GAAG,2CAA2C,wEAAwE,GAAG,wCAAwC,+CAA+C,eAAe,6CAA6C,wCAAwC,+CAA+C,wCAAwC,iBAAiB,GAAG,G;;;;;;ACA9uB,uLAAsL,wBAAwB,wBAAwB,iEAAiE,2CAA2C,2CAA2C,2CAA2C,yCAAyC,gFAAgF,GAAG,0B;;;;;;ACApiB,0DAAyD,0IAA0I,6FAA6F,6FAA6F,mBAAmB,sHAAsH,sHAAsH,sHAAsH,qBAAqB,GAAG,2GAA2G,iDAAiD,sJAAsJ,GAAG,G;;;;;;ACA/jC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA,kKAAiK,uEAAuE,4HAA4H,wBAAwB,0EAA0E,iDAAiD,kCAAkC,GAAG,G;;;;;;ACA5hB,2KAA0K,wEAAwE,4CAA4C,WAAW,4EAA4E,2EAA2E,6CAA6C,WAAW,0EAA0E,wCAAwC,GAAG,sD;;;;;;ACA7mB,6DAA4D,mDAAmD,kBAAkB,mBAAmB,sBAAsB,GAAG,uCAAuC,sBAAsB,GAAG,yBAAyB,uBAAuB,8BAA8B,6BAA6B,gBAAgB,gBAAgB,mBAAmB,sEAAsE,kDAAkD,kFAAkF,wDAAwD,yDAAyD,uBAAuB,qMAAqM,0JAA0J,yDAAyD,qFAAqF,iGAAiG,sFAAsF,0DAA0D,8BAA8B,oCAAoC,SAAS,6BAA6B,6EAA6E,gDAAgD,6GAA6G,8BAA8B,qCAAqC,0HAA0H,4EAA4E,uCAAuC,8BAA8B,oCAAoC,SAAS,GAAG,4EAA4E,2HAA2H,gDAAgD,8CAA8C,yEAAyE,uEAAuE,kFAAkF,yLAAyL,+DAA+D,+BAA+B,6BAA6B,2CAA2C,6FAA6F,kFAAkF,4CAA4C,yHAAyH,6HAA6H,wEAAwE,+DAA+D,yDAAyD,4OAA4O,0DAA0D,OAAO,gGAAgG,6GAA6G,wHAAwH,gMAAgM,gUAAgU,kCAAkC,sIAAsI,KAAK,kBAAkB,G;;;;;;ACAn7J,kQAAiQ,qGAAqG,kCAAkC,KAAK,sMAAsM,uCAAuC,sDAAsD,wGAAwG,sGAAsG,sGAAsG,sGAAsG,iCAAiC,iCAAiC,+BAA+B,eAAe,KAAK,G;;;;;;ACA/rC,qwCAAowC,gFAAgF,K;;;;;;ACAp1C,qOAAoO,yBAAyB,yFAAyF,4DAA4D,0BAA0B,yBAAyB,yBAAyB,4IAA4I,0BAA0B,2BAA2B,yCAAyC,mDAAmD,0BAA0B,6BAA6B,0BAA0B,2BAA2B,oBAAoB,2DAA2D,+BAA+B,6BAA6B,6BAA6B,yDAAyD,2BAA2B,6BAA6B,0BAA0B,8BAA8B,2BAA2B,mDAAmD,4BAA4B,2BAA2B,4BAA4B,4BAA4B,8BAA8B,2BAA2B,0BAA0B,2BAA2B,2BAA2B,oBAAoB,mDAAmD,GAAG,oB;;;;;;ACAxkD,6SAA4S,qCAAqC,sCAAsC,oCAAoC,gCAAgC,GAAG,wCAAwC,wDAAwD,gCAAgC,oCAAoC,gCAAgC,GAAG,8JAA8J,sCAAsC,GAAG,0CAA0C,4DAA4D,sEAAsE,GAAG,iBAAiB,gIAAgI,uFAAuF,GAAG,oDAAoD,8IAA8I,yCAAyC,GAAG,gGAAgG,oFAAoF,GAAG,uB;;;;;;ACA3oD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAwE,8BAA8B,+BAA+B,iBAAiB,0EAA0E;AAChO,yEAAwE,kBAAkB,0CAA0C;;;;AAIpI;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA,4CAA2C;AAC3C,2CAA0C;AAC1C,oDAAmD;AACnD,qDAAoD;AACpD;AACA,0CAAyC;AACzC;AACA,uCAAsC;AACtC,iGAAgG;AAChG,uCAAsC;AACtC,uBAAsB;AACtB;;AAEA;AACA;AACA,4CAA2C;AAC3C;AACA,0CAAyC;;AAEzC,uCAAsC;AACtC,4CAA2C;AAC3C,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC,yBAAwB,eAAe;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,OAAO;AAC3B,yBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvwBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,iBAAiB;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,wEAAuE,iBAAiB;AACxF;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,0CAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA,0DAAyD;;AAEzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;;AAGL;;AAEA;;AAEA;AACA,0DAAyD;;AAEzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;;AAGL;;AAEA;AACA,0CAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,0CAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;;AAEA;;AAEA;;AAEA,uDAAsD,OAAO;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,sEAAqE,eAAe;;AAEpF;AACA;;AAEA;AACA;;AAEA,8DAA6D,OAAO;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;;;AAGA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;;AAEA;AACA,oDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,sDAAqD,iBAAiB;AACtE;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,yBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;;;AAGA,EAAC;;AAED;;;;;;;ACtqCA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB,OAAO;AAC3B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA,gCAA+B,UAAU;AACzC;AACA;AACA;AACA;;AAEA;AACA,qCAAoC,sCAAsC;AAC1E;;AAEA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA,UAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAa;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACrOA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gEAA+D,OAAO;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACnDA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACrEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAS;;AAET;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;;AAGA,EAAC;;AAED;;;;;;;AClEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4BAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,uDAAsD,eAAe;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA,MAAK;;AAEL;AACA;AACA,kCAAiC;AACjC,8CAA6C;AAC7C,4CAA2C;AAC3C,mCAAkC;AAClC,gCAA+B;;AAE/B;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA,yCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA,uDAAsD,gBAAgB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;;;AAGA;AACA,qBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;;AAEA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;ACjYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnDA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,qBAAoB,+BAA+B;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;;;;;;AClEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2FAA0F;AAC1F;;AAEA;AACA,4FAA2F;AAC3F;;AAEA;AACA,2FAA0F;AAC1F;;AAEA;AACA,gGAA+F;AAC/F;;AAEA;AACA,uGAAsG;AACtG;;AAEA;AACA,sGAAqG;AACrG;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,qBAAqB;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA;;AAEA,kBAAiB,qBAAqB;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;;;;;AC5PA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AClDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,QAAQ;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D,QAAQ;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,kEAAiE,QAAQ;AACzE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;;AAGL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8BAA6B;AAC7B;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,OAAO;AAC/B;AACA;AACA;;;AAGA;AACA;AACA,0EAAyE,QAAQ;AACjF;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL,+BAA8B;AAC9B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,8DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,8DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;;AAEA;;AAEA,iEAAgE,QAAQ;AACxE;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAuC;AACvC;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAS;;;AAGT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gEAA+D,QAAQ;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,+EAA8E,eAAe;AAC7F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA,iDAAgD,QAAQ;;AAExD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA,uDAAsD,QAAQ;AAC9D;AACA;AACA,mCAAkC;AAClC,mEAAkE;AAClE;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA,uDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA,iDAAgD,QAAQ;;AAExD;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;;AAEA,cAAa;AACb;;AAEA,cAAa;;AAEb;AACA;AACA;;AAEA;AACA,+DAA8D,QAAQ;;AAEtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA,+CAA8C,QAAQ;AACtD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;;AAEA,kDAAiD;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,2DAA0D,QAAQ;AAClE;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,iDAAgD,aAAa;AAC7D;AACA,yDAAwD,eAAe;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uDAAsD,gBAAgB;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;AACA;AACA,iCAAgC,aAAa;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACjsBA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,EAAC;;AAED;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAC;;;AAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvUA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA,iDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB,4BAA2B;AAC3B,uBAAsB;;AAEtB;AACA;AACA,qEAAoE;AACpE,2BAA0B;;AAE1B;AACA;;AAEA,iDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA6C,OAAO;;AAEpD;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,yBAAwB,cAAc;AACtC;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA,uDAAsD,cAAc;;AAEpE;AACA;AACA;AACA,8DAA6D,aAAa;;AAE1E;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;;AAEA;AACA,8CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAwB,cAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,8CAA6C,QAAQ;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA2B;AAC3B;AACA,mDAAkD,cAAc;;AAEhE;AACA;AACA;;AAEA,0DAAyD,aAAa;;AAEtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,eAAe;;AAEnC;;AAEA,qBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mDAAkD,cAAc;;AAEhE;AACA,6BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;AC7RA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA,SAAQ;;AAER,8CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,cAAa,kBAAkB;;AAE/B;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA,cAAa;;AAEb;;AAEA,UAAS;;AAET;AACA;;AAEA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA,kBAAiB;AACjB,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC/oBA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;;;;;;ACpEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC7BA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;ACzBA,kD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAoE,uDAAuD;AAC3H;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,mDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,4DAA2D,qBAAqB;AAChF;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACvQA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;;AAGA;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,kCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET,yBAAwB,+BAA+B;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb,6BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb,UAAS,oCAAoC;AAC7C;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,iDAAiD;AAC7E;AACA;AACA;AACA;AACA,yBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,EAAC;;AAED;;;;;;;AC1YA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,6DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,SAAS;AACrC;AACA;AACA,UAAS;AACT,MAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA0D,OAAO;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA8C,QAAQ;AACtD;AACA,4DAA2D,QAAQ;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA,MAAK;AACL;AACA;;;;;;;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,wBAAuB,6IAA6I;;AAEpK;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB,UAAU;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB,UAAU;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA6C,OAAO;AACpD;;AAEA;;AAEA;;AAEA;AACA,yDAAwD,QAAQ;AAChE;;AAEA;AACA;;AAEA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpeA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACzZA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA;;AAEA,yBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA;AACA,cAAa;;AAEb,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACzEA,kD;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,kDAAiD,OAAO;AACxD;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,yBAAwB,sBAAsB;AAC9C;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;;AAEA;;;;;;;AC9hBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA,kCAAiC;;AAEjC;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;ACvMA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7HA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,qDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,oDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC1JA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6BAA4B;AAC5B,wBAAuB;AACvB,4BAA2B;AAC3B;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yBAAwB,yBAAyB;AACjD;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,kDAAiD,uBAAuB;AACxE;AACA,6BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA,4EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA,sDAAqD,OAAO;AAC5D;AACA,wEAAuE;AACvE;AACA,+DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;;;;;;AClaA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B,4BAA2B;AAC3B,2BAA0B;AAC1B;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb;;AAEA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,kFAAiF;AACjF;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,+BAA8B;AAC9B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvYA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAA+B;AAC/B;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AC7BA;AACA;AACA;;AAEA,gCAA+B;;AAE/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2FAA0F;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;;AAEA;AACA,gCAA+B;AAC/B;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;AC9IA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;AChHA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAgC;AAChC;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;ACzKA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS,uCAAuC;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpLA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B,4BAA2B;AAC3B,2BAA0B;;AAE1B;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa;AACb;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,mDAAkD,OAAO;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,kDAAiD,OAAO;AACxD;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,yBAAwB,sBAAsB;AAC9C;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;ACxEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAgC;;AAEhC,mCAAkC;AAClC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAA+B;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,qCAAoC;AACpC,uCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAmC;AACnC;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;AACA;AACA;AACA;;AAEA;;;;;;;ACjSA;AACA;;;AAGA;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;;;;;;;ACdA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS,mFAAmF;AAC5F;AACA;AACA;AACA;AACA,UAAS,2DAA2D;AACpE;AACA;AACA;AACA;AACA,UAAS,2DAA2D;AACpE;AACA;AACA;AACA;AACA,UAAS,mFAAmF;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA,UAAS;AACT,qFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACzGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,6CAA4C,QAAQ;AACpD;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,6CAA4C,QAAQ;AACpD;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;;AAEA;AACA,gBAAe;AACf,sCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,8BAA6B;AAC7B,uBAAsB;AACtB,iDAAgD;AAChD,+BAA8B;AAC9B,OAAM;AACN;AACA;AACA;AACA,gEAA+D,mCAAmC;AAClG,8BAA6B;AAC7B,8BAA6B;AAC7B,iCAAgC;AAChC;AACA;;AAEA;AACA,uCAAsC;AACtC,2DAA0D;AAC1D,uBAAsB;AACtB,gEAA+D;AAC/D,iBAAgB;AAChB,OAAM;;AAEN;AACA,yCAAwC;AACxC,2CAA0C;AAC1C,gDAA+C;AAC/C,wCAAuC;AACvC,gCAA+B;AAC/B,wCAAuC;AACvC,gCAA+B;AAC/B,gDAA+C;AAC/C,OAAM;AACN;AACA,2CAA0C;AAC1C,6EAA4E;AAC5E,OAAM;AACN;AACA,2CAA0C;AAC1C,iDAAgD;AAChD,+DAA8D;AAC9D,OAAM;;AAEN;AACA,OAAM;AACN,sCAAqC;AACrC,gCAA+B;AAC/B,OAAM;;AAEN;AACA,OAAM;AACN,kCAAiC;AACjC,mCAAkC;AAClC,oCAAmC;AACnC,iBAAgB;AAChB,wBAAuB;AACvB,0BAAyB;AACzB,mBAAkB;AAClB,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,gBAAgB;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,6BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAsC,OAAO;;AAE7C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA,+DAA8D;AAC9D,MAAK;AACL;AACA;;;AAGA;;AAEA,8DAA6D;AAC7D,6CAA4C,sBAAsB,QAAQ,EAAE;AAC5E,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,oBAAoB;AAC5C;AACA,+EAA8E;AAC9E,+EAA8E;AAC9E;AACA,2DAA0D;;AAE1D;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D,sDAAqD;;AAErD,yBAAwB,oBAAoB;;AAE5C,uCAAsC;AACtC;AACA;;AAEA;;AAEA,kFAAiF;AACjF,kFAAiF;AACjF;AACA,6EAA4E;;AAE5E;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;;AAEjC,qFAAoF,2BAA2B,EAAE;AACjH,iDAAgD,YAAY,EAAE;;AAE9D;AACA,eAAc;AACd,2BAA0B;AAC1B;AACA,2CAA0C;AAC1C,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,+DAA8D;AAC9D;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,yCAAwC;AACxC,MAAK;AACL;AACA,4EAA2E;AAC3E,MAAK;AACL;AACA;AACA;AACA,8DAA6D;AAC7D,gDAA+C,0BAA0B,QAAQ,EAAE;AACnF,2CAA0C;AAC1C,6EAA4E;AAC5E,yBAAwB,gCAAgC;AACxD;;AAEA,yDAAwD;AACxD,+EAA8E;AAC9E,gEAA+D;AAC/D,+DAA8D;AAC9D,4CAA2C;AAC3C,6BAA4B;;AAE5B,yDAAwD;AACxD,+EAA8E;AAC9E,gEAA+D;AAC/D,+DAA8D;AAC9D,4CAA2C;AAC3C,6BAA4B;AAC5B;AACA,wCAAuC;AACvC;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC,kCAAiC;AACjC,sCAAqC;AACrC,mCAAkC;AAClC,sCAAqC;;AAErC,qFAAoF,2BAA2B,EAAE;AACjH,iDAAgD,YAAY,EAAE;;AAE9D,sCAAqC;AACrC;AACA;AACA;AACA,2CAA0C;AAC1C,kDAAiD;AACjD,2CAA0C;AAC1C,8BAA6B;AAC7B,eAAc;;AAEd;AACA,eAAc;AACd,2BAA0B;AAC1B,sCAAqC;AACrC,kEAAiE;AACjE,iEAAgE;AAChE,oCAAmC;AACnC,mCAAkC;;AAElC;AACA,2CAA0C;AAC1C,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,wEAAuE;AACvE;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,iEAAgE;AAChE,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kGAAiG;;AAEjG,oCAAmC;AACnC;AACA;AACA;AACA,iCAAgC,eAAe;AAC/C;;AAEA;;AAEA;AACA;;AAEA;AACA,2GAA0G;AAC1G,2GAA0G;AAC1G;AACA,UAAS;;AAET;AACA;AACA;AACA,iCAAgC,eAAe;AAC/C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2GAA0G;AAC1G,2GAA0G;AAC1G;AACA;AACA;AACA;AACA,kCAAiC;;AAEjC,qFAAoF,2BAA2B,EAAE;AACjH,iDAAgD,YAAY,EAAE;;AAE9D;AACA,eAAc;AACd,2BAA0B;AAC1B;AACA,sDAAqD;AACrD,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAA+D;AAC/D;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC,mCAAkC;AAClC;AACA,eAAc;AACd,iCAAgC;AAChC,iCAAgC;AAChC,kDAAiD;AACjD,kDAAiD;AACjD,uFAAsF;AACtF,mFAAkF;AAClF,wFAAuF;AACvF,oFAAmF;AACnF,yFAAwF;AACxF,oFAAmF;AACnF,wFAAuF;AACvF,mFAAkF;AAClF,kHAAiH;AACjH,kHAAiH;AACjH,gEAA+D;AAC/D,6CAA4C;AAC5C,8BAA6B;AAC7B,oCAAmC;AACnC,mDAAkD;AAClD,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC,qCAAoC;;AAEpC;AACA,eAAc;AACd,4GAA2G;AAC3G,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC,qCAAoC;;AAEpC;AACA,eAAc;AACd,6FAA4F;AAC5F,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B,2BAA2B;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,oCAAmC;AACnC,uCAAsC;AACtC,sCAAqC;AACrC,4CAA2C;AAC3C,6CAA4C;AAC5C,+BAA8B;AAC9B,sFAAqF;AACrF,uCAAsC;AACtC,eAAc;AACd;AACA;;AAEA;AACA,yBAAwB,eAAe;AACvC,uKAAsK;AACtK;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC;AACxC,yCAAwC;AACxC,sCAAqC;AACrC,yCAAwC;AACxC,kCAAiC,UAAU,qDAAqD;AAChG,mCAAkC,UAAU,0GAA0G;AACtJ,uCAAsC;AACtC;AACA,0BAAyB;AACzB,0BAAyB;AACzB,4BAA2B;AAC3B,6CAA4C;;;AAG5C;AACA,eAAc;AACd,uDAAsD;AACtD,8EAA6E;AAC7E,4EAA2E;AAC3E,wDAAuD;AACvD,4DAA2D;AAC3D,2BAA0B;AAC1B,eAAc;;AAEd;AACA,eAAc;AACd;AACA,2DAA0D;AAC1D,yDAAwD;AACxD,4BAA2B;AAC3B,iCAAgC;AAChC,yCAAwC;AACxC,wDAAuD;AACvD,0BAAyB;AACzB,iBAAgB;AAChB;AACA,yCAAwC;AACxC,qCAAoC;AACpC,8BAA6B,gBAAgB,OAAO;AACpD,mDAAkD;AAClD,8DAA6D;AAC7D,gDAA+C;AAC/C,oCAAmC;AACnC,6CAA4C;AAC5C,+CAA8C;AAC9C,uCAAsC;AACtC,8DAA6D;;AAE7D,8DAA6D;AAC7D,wCAAuC;AACvC,oDAAmD;;AAEnD,wEAAuE;AACvE,+FAA8F;AAC9F,qFAAoF;;AAEpF,gBAAe;AACf,iEAAgE;AAChE,wDAAuD;AACvD,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,oCAAmC;AACnC,uCAAsC;AACtC,uCAAsC;AACtC,sCAAqC;AACrC,sCAAqC;AACrC,4CAA2C;AAC3C,6CAA4C;AAC5C,+BAA8B;AAC9B,sFAAqF;AACrF,uCAAsC;AACtC,uCAAsC;AACtC,eAAc;AACd;AACA;;AAEA;AACA,yBAAwB,eAAe;AACvC,uKAAsK;AACtK;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC,yCAAwC;AACxC,yCAAwC;AACxC,sCAAqC;AACrC,yCAAwC;AACxC,kCAAiC,UAAU,qDAAqD;AAChG,mCAAkC,UAAU,0GAA0G;AACtJ,uCAAsC;AACtC;AACA,0BAAyB;AACzB,wCAAuC;AACvC,0BAAyB;AACzB,4BAA2B;AAC3B,6CAA4C;;AAE5C;;AAEA;AACA,eAAc;AACd,uDAAsD;AACtD,iDAAgD;AAChD,8EAA6E;AAC7E,0DAAyD;AACzD,4EAA2E;AAC3E,wDAAuD;AACvD,4DAA2D;AAC3D,2BAA0B;AAC1B,eAAc;;AAEd,2CAA0C;AAC1C,kDAAiD;AACjD,2CAA0C;AAC1C,uCAAsC;AACtC,8BAA6B;AAC7B,eAAc;;AAEd;AACA,eAAc;AACd;AACA,yDAAwD;AACxD,uCAAsC;AACtC,wDAAuD;AACvD,0BAAyB;AACzB,iBAAgB;AAChB,kEAAiE;AACjE,iEAAgE;AAChE,oCAAmC;AACnC,uEAAsE;AACtE,4CAA2C;AAC3C,uDAAsD;AACtD,uDAAsD;AACtD,yDAAwD;AACxD,0CAAyC;;AAEzC,sCAAqC;AACrC,wDAAuD;AACvD,0BAAyB;AACzB,iBAAgB;;AAEhB,4DAA2D;;AAE3D,6CAA4C;AAC5C,yCAAwC;;AAExC;AACA,yCAAwC;AACxC,qCAAoC;AACpC,8BAA6B,gBAAgB,OAAO;AACpD,mDAAkD;AAClD,8DAA6D;AAC7D,sDAAqD;AACrD,oCAAmC;AACnC,6CAA4C;AAC5C,+CAA8C;AAC9C,uCAAsC;AACtC,8DAA6D;;AAE7D,8DAA6D;AAC7D,wCAAuC;AACvC,oDAAmD;;AAEnD,qFAAoF;AACpF,+FAA8F;AAC9F,qFAAoF;;AAEpF,gBAAe;AACf,iEAAgE;AAChE,wDAAuD;AACvD,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACtjDA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,0CAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA,kGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,6CAA4C,UAAU;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,yBAAwB,gBAAgB;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,gBAAgB;AACxC;AACA;;AAEA,6BAA4B,cAAc;AAC1C;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,gDAA+C;;AAE/C;AACA,0DAAyD,cAAc;AACvE;AACA;;AAEA;AACA,uDAAsD;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;;AAEA;AACA;AACA,EAAC;;;AAGD;;;;;;;ACzRA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA,mDAAkD,OAAO;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAAyD,OAAO;AAChE;AACA;AACA,iDAAgD,OAAO;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;ACpOA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA0C;;AAE1C;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gDAA+C,OAAO;;AAEtD;;AAEA;AACA,sCAAqC;AACrC;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,yBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA,6CAA4C,QAAQ;AACpD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gHAA+G;AAC/G;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,6BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,OAAO;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,4CAA2C,QAAQ;AACnD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,4CAA2C,QAAQ;AACnD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,qBAAoB,aAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,oDAAmD,SAAS;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;;;AAGD;;;;;;;AC3tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;ACpEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;;;;;;AC1BA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAuC,OAAO;;AAE9C;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,OAAO;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAsB;;AAEtB;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;;;;ACzBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;ACvCA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;AChBA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA,gDAA+C,OAAO;;AAEtD;;AAEA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL,8CAA6C;;AAE7C;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAS;;AAET;;AAEA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,0CAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,0CAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAoC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;AChOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC7BA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA,qBAAoB;;AAEpB;AACA;;AAEA;;AAEA,UAAS;;AAET;AACA,yBAAwB,eAAe;AACvC;AACA,wBAAuB;;AAEvB,yBAAwB,eAAe;AACvC,0EAAyE;;AAEzE;AACA;;AAEA,kBAAiB,GAAG;AACpB;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,yBAAwB,OAAO;;AAE/B;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;;;;;;;AC1EA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA,+CAA8C,OAAO;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAAyC;AACzC,cAAa;AACb;AACA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA,kBAAiB,aAAa;AAC9B;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;;AAGA;;;;;;;AC9JA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS,OAAO;AAChB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yCAAwC;AACxC,UAAS;AACT,oCAAmC;AACnC;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C;AAC1C;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gDAA+C;AAC/C,UAAS;AACT,4CAA2C;AAC3C;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,0CAAyC;AACzC;;AAEA,EAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,wCAAuC;AACvC;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,wCAAuC;AACvC;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,2BAA0B;AAC1B;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,uEAAsE;;AAEtE;AACA;AACA;AACA;AACA,sEAAqE;;;AAGrE;AACA;AACA;AACA;AACA,uEAAsE;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9LA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;;;AAID;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;;;AAID;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;;;AAID;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9FA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/IA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;;AAID;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1QA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,yBAAwB;;AAExB;AACA,iEAAgE;;AAEhE,UAAS;AACT;AACA;;AAEA;AACA,qHAAoH;;AAEpH;AACA,iEAAgE;AAChE;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B;;AAE7B,yBAAwB,mBAAmB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7RA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;;;;;;;AC9GA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;;;;;;ACxBA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oGAAmG;AACnG;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iHAAgH;AAChH;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;;AAEb;;AAEA,wGAAuG;AACvG;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,gBAAgB;AACxC;;AAEA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvaA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,sGAAqG;AACrG;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;;AAEA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA2E;AAC3E;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA8D;AAC9D;AACA,+CAA8C;;AAE9C;AACA;AACA,0DAAyD;;AAEzD;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAuC;AACvC;AACA,4CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAS;;AAET;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAoB,0BAA0B;;AAE9C;AACA;;AAEA;AACA,6BAA4B,kCAAkC;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,yBAAwB,yBAAyB;;AAEjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;;;;;;AChmBA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,wBAAuB;AACvB,6BAA4B;AAC5B,4BAA2B;AAC3B,6BAA4B;AAC5B,wBAAuB;AACvB,qCAAoC;AACpC,yBAAwB;AACxB,WAAU;AACV,yCAAwC;AACxC;AACA,WAAU;AACV,6BAA4B;AAC5B,sBAAqB;AACrB,mBAAkB;AAClB,yCAAwC;AACxC,yCAAwC;AACxC,6CAA4C;AAC5C,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAwB,mBAAmB,iBAAiB,YAAY,cAAc,gBAAgB,aAAa,YAAY,OAAO,mBAAmB,KAAK,mBAAmB,UAAU,UAAU,iBAAiB,mBAAmB,WAAW,UAAU,WAAW,UAAU,oBAAoB,wFAAwF,2DAA2D,wDAAwD,uDAAuD,sDAAsD,kBAAkB,2BAA2B,wBAAwB,mBAAmB,0CAA0C,uCAAuC,kCAAkC,oCAAoC,aAAa,gBAAgB,0CAA0C,sBAAsB,wBAAwB,uBAAuB,0BAA0B,oBAAoB,aAAa,wBAAwB,0BAA0B,qBAAqB,sCAAsC,kBAAkB,eAAe,WAAW,6CAA6C,WAAW;AACtuC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpSA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wDAAuD,QAAQ;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAwD,QAAQ;AAChE;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD,QAAQ;AAC3D;AACA;AACA;;AAEA;AACA,wDAAuD,QAAQ;AAC/D;AACA;AACA;AACA,mDAAkD,QAAQ;AAC1D;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2EAA0E,kBAAkB;AAC5F,UAAS;AACT,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2EAA0E,kBAAkB;AAC5F,UAAS;AACT,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kFAAiF,kBAAkB;AACnG,UAAS;;AAET,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gFAA+E,kBAAkB;AACjG,UAAS;;AAET,MAAK;;AAEL;AACA;AACA,qDAAoD,QAAQ;;AAE5D;;AAEA;AACA;AACA;;AAEA,cAAa;AACb;AACA;;AAEA,cAAa;AACb;;AAEA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA,qDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;;AAEA;;;;;;;ACtOA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kFAAiF,kBAAkB;AACnG,UAAS;AACT,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0FAAyF,kBAAkB;AAC3G,cAAa;AACb;;AAEA;AACA,wFAAuF;AACvF,UAAS;AACT,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,wFAAuF,kBAAkB;AACzG,UAAS;;AAET;AACA,0FAAyF;AACzF,UAAS;AACT,MAAK;;AAEL;AACA;;AAEA,qDAAoD,QAAQ;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACxMA,6DAA4D,sDAAsD,6BAA6B;AAC/I,kD;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA,EAAC;;AAED;;;;;;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnVA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,EAAC;;AAED;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAgC;AAChC,iCAAgC;AAChC;AACA;AACA;AACA;AACA,qCAAoC;AACpC,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAA+B;AAC/B,mCAAkC;AAClC;;AAEA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAmC;;AAEnC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,6BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,2CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACxgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,4BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,wCAAuC;AACvC,yCAAwC;AACxC;AACA;AACA,2BAA0B;AAC1B,mFAAkF;AAClF,WAAU;AACV;;AAEA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,2BAA0B;AAC1B,kCAAiC;AACjC,WAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA,2BAA0B;AAC1B,iDAAgD;AAChD,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,oDAAmD;AACnD,WAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,wCAAuC;AACvC,yCAAwC;AACxC,mCAAkC;AAClC;AACA;AACA,2BAA0B;AAC1B,iCAAgC;AAChC,mFAAkF;AAClF,WAAU;AACV;;AAEA;AACA;AACA,+BAA8B;AAC9B,6BAA4B;AAC5B,mCAAkC;AAClC,qDAAoD;AACpD,qCAAoC;AACpC;AACA;AACA,2BAA0B;AAC1B;AACA,sBAAqB;AACrB,6CAA4C;AAC5C,gFAA+E;AAC/E,6BAA4B;AAC5B,0DAAyD;AACzD,+DAA8D;AAC9D,uDAAsD;AACtD,aAAY;AACZ,6BAA4B;AAC5B,0DAAyD;AACzD,8DAA6D;AAC7D,sDAAqD;AACrD,aAAY;AACZ,oDAAmD;AACnD,WAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,eAAe;AAC/B,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,eAAe;AAC/B,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB,qBAAqB;AACrC;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,oBAAoB;AACpC,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtUA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,6BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAwB,gBAAgB;AACxC;AACA;;AAEA,UAAS;;AAET,yBAAwB,oBAAoB;AAC5C;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAA+B;AAC/B;;AAEA,8BAA6B;AAC7B,gCAA+B;AAC/B,mCAAkC;AAClC,qCAAoC;AACpC,qCAAoC;AACpC,qCAAoC;;AAEpC,kCAAiC;;AAEjC;AACA,2BAA0B;AAC1B,+CAA8C;AAC9C,uDAAsD;AACtD,8DAA6D;AAC7D,+IAA8I;AAC9I,6EAA4E;AAC5E,yDAAwD;AACxD,0CAAyC;AACzC,qFAAoF;AACpF,sDAAqD;AACrD,qBAAoB;AACpB,aAAY;AACZ,0DAAyD;AACzD,4CAA2C;AAC3C,4EAA2E;AAC3E,qDAAoD;AACpD,wCAAuC;AACvC,gIAA+H;AAC/H,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA,kCAAiC;AACjC,wCAAuC;AACvC,yCAAwC;;AAExC,uBAAsB;AACtB;AACA,+FAA8F;AAC9F;AACA,sGAAqG;AACrG,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA,gCAA+B;AAC/B;AACA,8CAA6C;AAC7C,iHAAgH;AAChH,mEAAkE;AAClE,uBAAsB;AACtB,gDAA+C;AAC/C,+CAA8C;AAC9C,uBAAsB;AACtB,mDAAkD;AAClD,+CAA8C;AAC9C,uBAAsB;AACtB,oDAAmD;AACnD,+CAA8C;AAC9C,uBAAsB;AACtB;AACA,iEAAgE;AAChE,4FAA2F;AAC3F,0LAAyL;AACzL,uBAAsB;AACtB;AACA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;;AAGL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qFAAoF;AACpF,wFAAuF;;AAEvF,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;;AAEA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,MAAK;;;AAGL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACzmBA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;;AAGA,yBAAwB,oBAAoB,gBAAgB,eAAe,wBAAwB,iBAAiB,oBAAoB,cAAc,uDAAuD,SAAS,QAAQ,kBAAkB,EAAE,aAAa,WAAW,YAAY,kBAAkB,aAAa,oBAAoB,iBAAiB,EAAE,uBAAuB,qBAAqB,EAAE,8BAA8B,eAAe,EAAE,0BAA0B,oBAAoB,oBAAoB,EAAE,4BAA4B,cAAc,mBAAmB,WAAW,YAAY,EAAE,wBAAwB,oBAAoB,kBAAkB,EAAE,8BAA8B,oBAAoB,eAAe,aAAa,EAAE,6BAA6B,oBAAoB,SAAS,QAAQ,EAAE,+BAA+B,oBAAoB,aAAa,aAAa,aAAa,QAAQ,mBAAmB,EAAE,2BAA2B,oBAAoB,UAAU,EAAE;AACz9B;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL,kCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5FA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACnFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtEA,kD;;;;;;ACAA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AC3QA;AACA;AACA;AACA;AACA;AACA,4BAA+B;;;AAG/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;AACA;;;;;;;ACzIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;;;;;;AC1EA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AC1EA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAiB,iCAAiC;AAClD,kBAAiB,iCAAiC;AAClD,YAAW;AACX;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,gBAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,EAAE;AACjB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,EAAE;AACjB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,0BAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,uBAAuB;AACtC;AACA,gBAAe,qCAAqC;AACpD;AACA;AACA;AACA,gBAAe,gCAAgC;AAC/C;AACA;AACA,gBAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,4BAA4B;AACzD;AACA;AACA;AACA,8BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,uBAAuB;AAChE;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B,eAAe;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,2CAA2C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,EAAE;AACrB,qBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,qBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,EAAE;AACrB,qBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,qBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C,oBAAmB,qCAAqC;AACxD;AACA;AACA,oBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACxqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACjCA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,+DAA8D;AAC9D;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,oDAAmD,OAAO;;AAE1D;AACA;;AAEA;;AAEA;;AAEA,cAAa;;AAEb;;AAEA;;AAEA;;AAEA;;;AAGA,EAAC;;;AAGD;;AAEA;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA;;AAEA,qBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA,UAAS;;AAET,UAAS;;AAET;;;AAGA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA,EAAC;;AAED;;AAEA;;AAEA;;;;;;;AChiCA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;AC3MA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;;AAGL;AACA,0DAAyD;;AAEzD,sDAAqD;;AAErD;AACA;AACA;AACA;;AAEA,EAAC;;;AAGD;;AAEA;;;;;;;AC7EA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT,0DAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;;AAGL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;;AAGL;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;;AAGL;AACA;;AAEA;;AAEA;AACA;AACA,yBAAwB,yBAAyB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAqD,OAAO;;AAE5D;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA,sDAAqD,OAAO;AAC5D;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0DAAyD,OAAO;AAChE;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA,0DAAyD,OAAO;AAChE;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;;AAEL,EAAC;;AAED;;AAEA;;;;;;;AC1ZA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4DAA2D,OAAO;;AAElE;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4DAA2D,OAAO;;AAElE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA,4DAA2D,OAAO;AAClE;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;;;;;;ACvLA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,OAAM;AACN,OAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,6DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yBAAwB,mCAAmC;AAC3D;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;AACT;AACA;AACA;;;AAGA,EAAC;AACD;;AAEA;AACA;;AAEA;;;;;;;ACrIA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACXA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACTA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;;;AAIL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA,cAAa;AACb;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA,MAAK;;;AAGL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,oEAAoE;AACpF,iBAAgB,WAAW;AAC3B,iBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;;;AAIL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,cAAa;;AAEb;;AAEA;;AAEA;;AAEA;;AAEA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,yBAAwB,iCAAiC;;AAEzD;;AAEA;AACA;AACA,6BAA4B,8BAA8B;;AAE1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,4BAA4B;;AAExD;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;;AAET,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,yBAAwB,4BAA4B;AACpD;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA,yBAAwB,sBAAsB;;AAE9C;;AAEA,6BAA4B,4BAA4B;;AAExD;;AAEA;AACA,iCAAgC,sBAAsB;;AAEtD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,yBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,sBAAsB;;AAE9C;AACA;AACA;;AAEA;AACA;;AAEA,6BAA4B,2BAA2B;AACvD;AACA;AACA,iCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAwB,2BAA2B;;AAEnD;AACA;;AAEA;;AAEA;;AAEA,cAAa;;AAEb;;AAEA,cAAa;;AAEb;;AAEA,cAAa;;AAEb;;AAEA,cAAa;;AAEb;;AAEA,cAAa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAS;AACT,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA,yBAAwB,uBAAuB;;AAE/C;AACA;;AAEA;;AAEA;;AAEA;;AAEA,6BAA4B,kBAAkB;AAC9C;;AAEA;;AAEA,UAAS;AACT,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb,iCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B,sBAAsB;;AAElD;;AAEA;AACA;AACA,iCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAa;;AAEb,UAAS;AACT,MAAK;;AAEL;;AAEA;;AAEA;;;;;;;ACl2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAuD;;AAEvD;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,UAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA","file":"OSG.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bluebird\"), require(\"zlib\"), require(\"hammerjs\"), (function webpackLoadOptionalExternalModule() { try { return require(\"jquery\"); } catch(e) {} }()), require(\"leapjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"bluebird\", \"zlib\", \"hammer\", \"jquery\", \"leap\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OSG\"] = factory(require(\"bluebird\"), require(\"zlib\"), require(\"hammerjs\"), (function webpackLoadOptionalExternalModule() { try { return require(\"jquery\"); } catch(e) {} }()), require(\"leapjs\"));\n\telse\n\t\troot[\"OSG\"] = factory(root[\"P\"], root[\"Zlib\"], root[\"Hammer\"], root[\"$\"], root[\"Leap\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_90__, __WEBPACK_EXTERNAL_MODULE_150__, __WEBPACK_EXTERNAL_MODULE_160__, __WEBPACK_EXTERNAL_MODULE_213__, __WEBPACK_EXTERNAL_MODULE_230__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc8be8c54f7a4484aca8","'use strict';\nvar osgNameSpace = require( 'osgNameSpace' );\nvar osg = require( 'osg/osg' );\nvar osgAnimation = require( 'osgAnimation/osgAnimation' );\nvar osgDB = require( 'osgDB/osgDB' );\nvar osgGA = require( 'osgGA/osgGA' );\nvar osgUtil = require( 'osgUtil/osgUtil' );\nvar osgViewer = require( 'osgViewer/osgViewer' );\nvar osgShader = require( 'osgShader/osgShader' );\nvar osgShadow = require( 'osgShadow/osgShadow' );\nvar osgText = require( 'osgText/osgText' );\nvar osgWrappers = require( 'osgWrappers/osgWrappers' );\nvar osgPlugins = require( 'osgPlugins/osgPlugins' );\n\n\nvar openSceneGraph = osgNameSpace;\n\nopenSceneGraph.osg = osg;\nopenSceneGraph.osgAnimation = osgAnimation;\nopenSceneGraph.osgDB = osgDB;\nopenSceneGraph.osgGA = osgGA;\nopenSceneGraph.osgUtil = osgUtil;\nopenSceneGraph.osgViewer = osgViewer;\nopenSceneGraph.osgShader = osgShader;\nopenSceneGraph.osgShadow = osgShadow;\nopenSceneGraph.osgText = osgText;\nopenSceneGraph.osgWrappers = osgWrappers;\nopenSceneGraph.osgPlugins = osgPlugins;\n\nvar namespaces = [ 'osg', 'osgAnimation', 'osgDB', 'osgGA', 'osgUtil', 'osgViewer', 'osgShader', 'osgShadow', 'osgText', 'osgWrappers', 'osgPlugins' ];\n\n\n// for backward compatibility\nopenSceneGraph.globalify = function () {\n    namespaces.forEach( function ( namespace ) {\n        window[ namespace ] = openSceneGraph[ namespace ];\n    } );\n};\n\nmodule.exports = openSceneGraph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/OSG.js\n// module id = 1\n// module chunks = 0 1 2","'use strict';\n\nvar pkg = require( 'json-loader!../package.json' );\n\nmodule.exports = {\n    name: pkg.name,\n    version: pkg.version,\n    author: pkg.author\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgNameSpace.js\n// module id = 2\n// module chunks = 0 1 2","module.exports = {\n\t\"devDependencies\": {\n\t\t\"chai\": \"^3.5.0\",\n\t\t\"grunt-contrib-connect\": \"~0.9\",\n\t\t\"grunt-documentation\": \"*\",\n\t\t\"grunt-jsbeautifier\": \"^0.2.10\",\n\t\t\"grunt-mocha\": \"^1.0.2\",\n\t\t\"grunt-release\": \"^0.10.0\",\n\t\t\"mocha\": \"^2.5.3\",\n\t\t\"webpack-strip-block\": \"0.0.1\",\n\t\t\"grunt-plato\": \"~0.2.1\",\n\t\t\"grunt-update-submodules\": \"^0.4.1\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"grunt\": \">=0.4.0\"\n\t},\n\t\"dependencies\": {\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"grunt-lib-phantomjs\": \"^1.0.2\",\n\t\t\"webpack-dev-server\": \"^1.7.0\",\n\t\t\"webpack\": \"^1.7.3\",\n\t\t\"raw-loader\": \"^0.5.1\",\n\t\t\"path\": \"^0.11.14\",\n\t\t\"leapjs\": \"^0.6.4\",\n\t\t\"json-loader\": \"^0.5.4\",\n\t\t\"jquery\": \"^2.1.3\",\n\t\t\"hammerjs\": \"^2.0.4\",\n\t\t\"grunt-webpack\": \"^1.0.8\",\n\t\t\"grunt-shell\": \"*\",\n\t\t\"grunt-git\": \"*\",\n\t\t\"grunt-eslint\": \"*\",\n\t\t\"grunt-copy-to\": \"0.0.12\",\n\t\t\"grunt-contrib-uglify\": \"*\",\n\t\t\"grunt-contrib-jshint\": \"*\",\n\t\t\"grunt-contrib-copy\": \"*\",\n\t\t\"grunt-contrib-clean\": \"*\",\n\t\t\"grunt\": \"> 1.0.0\",\n\t\t\"glob\": \"*\",\n\t\t\"extend\": \"*\",\n\t\t\"eslint-plugin-private-variables\": \"*\",\n\t\t\"eslint\": \"*\"\n\t},\n\t\"contributors\": [\n\t\t\"Paul Cheyrou-Lagrèze <tuan.kuranes@gmail.com>\",\n\t\t\"Jordi Torres <jtorresfabra@gmail.com>\",\n\t\t\"Matt Fontaine <tehqin@gmail.com>\",\n\t\t\"Stephane Ginier <stephane.ginier@gmail.com>\"\n\t],\n\t\"version\": \"0.2.7\",\n\t\"author\": \"Cedric Pinson <trigrou@trigrou.com> (http://cedricpinson.com)\",\n\t\"license\": \"MIT\",\n\t\"description\": \"OpenSceneGraph implementation in javascript\",\n\t\"repository\": {\n\t\t\"url\": \"git@github.com:cedricpinson/osgjs.git\",\n\t\t\"type\": \"git\"\n\t},\n\t\"name\": \"OpenSceneGraph\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./package.json\n// module id = 3\n// module chunks = 0 1 2","'use strict';\n\nvar AutoTransform = require( 'osg/AutoTransform' );\nvar BillboardAttribute = require( 'osg/BillboardAttribute' );\nvar BlendColor = require( 'osg/BlendColor' );\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar BoundingSphere = require( 'osg/BoundingSphere' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar Camera = require( 'osg/Camera' );\nvar ColorMask = require( 'osg/ColorMask' );\nvar ComputeBoundsVisitor = require( 'osg/ComputeBoundsVisitor' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\nvar CullFace = require( 'osg/CullFace' );\nvar CullingSet = require( 'osg/CullingSet' );\nvar CullSettings = require( 'osg/CullSettings' );\nvar CullStack = require( 'osg/CullStack' );\nvar CullVisitor = require( 'osg/CullVisitor' );\nvar Depth = require( 'osg/Depth' );\nvar DrawArrayLengths = require( 'osg/DrawArrayLengths' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar EllipsoidModel = require( 'osg/EllipsoidModel' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar FrameStamp = require( 'osg/FrameStamp' );\nvar Geometry = require( 'osg/Geometry' );\nvar GLObject = require( 'osg/GLObject' );\nvar Image = require( 'osg/Image' );\nvar ImageStream = require( 'osg/ImageStream' );\nvar KdTree = require( 'osg/KdTree' );\nvar KdTreeBuilder = require( 'osg/KdTreeBuilder' );\nvar Light = require( 'osg/Light' );\nvar LightSource = require( 'osg/LightSource' );\nvar LineWidth = require( 'osg/LineWidth' );\nvar Lod = require( 'osg/Lod' );\nvar Material = require( 'osg/Material' );\nvar osgjsMath = require( 'osg/math' );\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Node = require( 'osg/Node' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Notify = require( 'osg/notify' );\nvar Object = require( 'osg/Object' );\nvar Options = require( 'osg/Options' );\nvar PagedLOD = require( 'osg/PagedLOD' );\nvar Polytope = require( 'osg/Polytope' );\nvar PointSizeAttribute = require( 'osg/PointSizeAttribute' );\nvar Plane = require( 'osg/Plane' );\nvar PrimitiveFunctor = require( 'osg/PrimitiveFunctor' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar Program = require( 'osg/Program' );\nvar Projection = require( 'osg/Projection' );\nvar RenderBin = require( 'osg/RenderBin' );\nvar RenderLeaf = require( 'osg/RenderLeaf' );\nvar RenderStage = require( 'osg/RenderStage' );\nvar Shader = require( 'osg/Shader' );\nvar Shape = require( 'osg/shape' );\nvar Stack = require( 'osg/Stack' );\nvar State = require( 'osg/State' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar StateGraph = require( 'osg/StateGraph' );\nvar StateSet = require( 'osg/StateSet' );\nvar Texture = require( 'osg/Texture' );\nvar TextureCubeMap = require( 'osg/TextureCubeMap' );\nvar Transform = require( 'osg/Transform' );\nvar TriangleIndexFunctor = require( 'osg/TriangleIndexFunctor' );\nvar Uniform = require( 'osg/Uniform' );\nvar UpdateVisitor = require( 'osg/UpdateVisitor' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Viewport = require( 'osg/Viewport' );\nvar osgPool = require( 'osgUtil/osgPool' );\nvar Scissor = require( 'osg/Scissor' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar Timer = require( 'osg/Timer' );\nvar TimerGPU = require( 'osg/TimerGPU' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\n\n\nvar osg = {};\nosg.AutoTransform = AutoTransform;\nosg.BillboardAttribute = BillboardAttribute;\nosg.BlendColor = BlendColor;\nosg.BlendFunc = BlendFunc;\nosg.BoundingBox = BoundingBox;\nosg.BoundingSphere = BoundingSphere;\nosg.BufferArray = BufferArray;\nosg.ColorMask = ColorMask;\nosg.Camera = Camera;\nosg.ColorMask = ColorMask;\nosg.ComputeBoundsVisitor = ComputeBoundsVisitor;\nMACROUTILS.objectMix( osg, ComputeMatrixFromNodePath );\nosg.CullFace = CullFace;\nosg.CullingSet = CullingSet;\nosg.CullSettings = CullSettings;\nosg.CullStack = CullStack;\nosg.CullVisitor = CullVisitor;\nosg.Depth = Depth;\nosg.DrawArrayLengths = DrawArrayLengths;\nosg.DrawArrays = DrawArrays;\nosg.DrawElements = DrawElements;\nosg.EllipsoidModel = EllipsoidModel;\nosg.WGS_84_RADIUS_EQUATOR = EllipsoidModel.WGS_84_RADIUS_EQUATOR;\nosg.WGS_84_RADIUS_POLAR = EllipsoidModel.WGS_84_RADIUS_POLAR;\nosg.FrameBufferObject = FrameBufferObject;\nosg.FrameStamp = FrameStamp;\nosg.Geometry = Geometry;\nosg.GLObject = GLObject;\nosg.Image = Image;\nosg.ImageStream = ImageStream;\nosg.KdTree = KdTree;\nosg.KdTreeBuilder = KdTreeBuilder;\nosg.Light = Light;\nosg.LightSource = LightSource;\nosg.LineWidth = LineWidth;\nosg.Lod = Lod;\nosg.Material = Material;\nMACROUTILS.objectMix( osg, osgjsMath );\nosg.MatrixTransform = MatrixTransform;\nosg.MatrixMemoryPool = MatrixMemoryPool;\nosg.Node = Node;\nosg.NodeVisitor = NodeVisitor;\nMACROUTILS.objectMix( osg, Notify );\nosg.Object = Object;\nosg.Options = Options;\nosg.PagedLOD = PagedLOD;\nosg.Plane = Plane;\nosg.PointSizeAttribute = PointSizeAttribute;\nosg.Polytope = Polytope;\nosg.PrimitiveSet = PrimitiveSet;\nosg.PrimitiveFunctor = PrimitiveFunctor;\nosg.Program = Program;\nosg.Projection = Projection;\nosg.RenderBin = RenderBin;\nosg.RenderLeaf = RenderLeaf;\nosg.RenderStage = RenderStage;\nosg.Shader = Shader;\nMACROUTILS.objectMix( osg, Shape );\nosg.Stack = Stack;\nosg.State = State;\nosg.StateAttribute = StateAttribute;\nosg.StateGraph = StateGraph;\nosg.StateSet = StateSet;\nosg.Scissor = Scissor;\nosg.Texture = Texture;\nosg.TextureCubeMap = TextureCubeMap;\nosg.Transform = Transform;\nosg.TriangleIndexFunctor = TriangleIndexFunctor;\nosg.Uniform = Uniform;\nosg.UpdateVisitor = UpdateVisitor;\nMACROUTILS.objectMix( osg, MACROUTILS );\nosg.Viewport = Viewport;\n\nvar glm = require( 'osg/glMatrix' );\nosg.vec2 = glm.vec2;\nosg.vec3 = glm.vec3;\nosg.vec4 = glm.vec4;\nosg.quat = glm.quat;\nosg.mat3 = glm.mat3;\nosg.mat4 = glm.mat4;\n\nosg.memoryPools = osgPool.memoryPools;\n\nosg.Transform.RELATIVE_RF = TransformEnums.RELATIVE_RF;\nosg.Transform.ABSOLUTE_RF = TransformEnums.ABSOLUTE_RF;\nosg.Timer = Timer;\nosg.TimerGPU = TimerGPU;\nosg.WebGLCaps = WebGLCaps;\n\n\nmodule.exports = osg;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/osg.js\n// module id = 4\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar Transform = require( 'osg/Transform' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar Node = require( 'osg/Node' );\n\n/** AutoTransform is a derived form of Transform that automatically\n * scales or rotates to keep its children aligned with screen coordinates.\n * W.r.t. AutorotateModes only rotate to screen is supported right now.\n * More AutorotateModes modes should be addressed in the future.\n * @class AutoTransform\n */\n\nvar AutoTransform = function () {\n    Transform.call( this );\n    this._matrix = mat4.create();\n    this._position = vec3.create();\n    this._matrixDirty = true;\n    this._scale = vec3.fromValues( 1.0, 1.0, 1.0 );\n    this._minimumScale = 0;\n    this._maximumScale = Number.MAX_VALUE;\n    this._rotation = quat.create();\n    this._pivotPoint = vec3.create();\n    this._autoScaleToScreen = false;\n    this._autoRotateToScreen = false;\n    this._cachedMatrix = mat4.create();\n    this._firstTimeToInitEyePoint = true;\n    this._autoScaleTransitionWidthRatio = 0.25;\n    this._billboardAttribute = undefined;\n    this._previousWidth = 0.0;\n    this._previousHeight = 0.0;\n    this._previousProjection = mat4.create();\n    this._previousModelView = mat4.create();\n    this._previousPosition = vec3.create();\n};\n\n/** @lends Autotransform.prototype */\nAutoTransform.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Transform.prototype, {\n\n    getMatrix: function () {\n        return this._matrix;\n    },\n\n    setMatrix: function ( m ) {\n        this._matrix = m;\n        this.dirtyBound();\n    },\n\n    setPosition: function ( pos ) {\n        this._position = pos;\n        this._matrixDirty = true;\n        this.dirtyBound();\n    },\n    getPosition: function () {\n        return this._position;\n    },\n\n    setRotation: function ( q ) {\n        this._rotation = q;\n        this._matrixDirty = true;\n        this.dirtyBound();\n    },\n\n    getRotation: function () {\n        return this._rotation;\n    },\n\n    setScale: function ( scale ) {\n        this.setScaleFromvec3( vec3.fromValues( scale, scale, scale ) );\n    },\n\n    setScaleFromvec3: function ( scaleVec ) {\n        this._scale = scaleVec;\n        this._matrixDirty = true;\n        this.dirtyBound();\n    },\n\n    getScale: function () {\n        return this._scale;\n    },\n\n    setMinimumScale: function ( minimumScale ) {\n        this._minimumScale = minimumScale;\n    },\n\n    getMinimumScale: function () {\n        return this._minimumScale;\n    },\n\n    setMaximumScale: function ( maximumScale ) {\n        this._maximumScale = maximumScale;\n    },\n\n    getMaximumScale: function () {\n        return this._maximumScale;\n    },\n\n    setAutoScaleToScreen: function ( autoScaleToScreen ) {\n        this._autoScaleToScreen = autoScaleToScreen;\n        this._matrixDirty = true;\n    },\n\n    getAutoScaleToScreen: function () {\n        return this._autoScaleToScreen;\n    },\n\n    setAutoRotateToScreen: function ( value ) {\n        this._autoRotateToScreen = value;\n    },\n\n    getAutoRotateToScreen: function () {\n        return this._autoRotateToScreen;\n    },\n\n    setAutoScaleTransitionWidthRatio: function ( autoScaleTransitionWidthRatio ) {\n        this._autoScaleTransitionWidthRatio = autoScaleTransitionWidthRatio;\n    },\n\n    getAutoScaleTransitionWidthRatio: function () {\n        return this._autoScaleTransitionWidthRatio;\n    },\n\n    // local to \"local world\" (not Global World)\n    computeLocalToWorldMatrix: function ( matrix /*, nodeVisitor */ ) {\n        if ( this._matrixDirty ) this.computeMatrix();\n        if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n            mat4.mul( matrix, matrix, this._matrix );\n        } else {\n            mat4.copy( matrix, this._matrix );\n        }\n    },\n\n    computeMatrix: ( function () {\n        var neg = vec3.create();\n        var tmpMat = mat4.create();\n        return function () {\n            if ( !this._matrixDirty ) return;\n            mat4.fromQuat( this._matrix, this._rotation );\n\n            mat4.fromTranslation( tmpMat, this._position );\n            mat4.mul( this._matrix, tmpMat, this._matrix );\n            mat4.scale( this._matrix, this._matrix, this._scale );\n            mat4.translate( this._matrix, this._matrix, vec3.neg( neg, this._pivotPoint ) );\n            this._matrixDirty = false;\n        };\n\n    } )(),\n\n    computeWorldToLocalMatrix: ( function () {\n        var neg = vec3.create();\n        var rotInverse = quat.create();\n        var scaleInverse = vec3.create();\n        var tmpMat = mat4.create();\n\n        return function ( matrix /*, nodeVisitor */ ) {\n            if ( this.scale[ 0 ] === 0.0 && this.scale[ 1 ] === 0.0 && this.scale[ 2 ] === 0.0 ) {\n                return false;\n            }\n            scaleInverse[ 0 ] = 1.0 / this._scale[ 0 ];\n            scaleInverse[ 1 ] = 1.0 / this._scale[ 1 ];\n            scaleInverse[ 2 ] = 1.0 / this._scale[ 2 ];\n            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n\n                mat4.fromTranslation( tmpMat, vec3.neg( neg, this._position ) );\n                mat4.mul( matrix, tmpMat, matrix );\n\n                if ( !quat.zeroRotation( this._rotation ) ) {\n                    mat4.fromQuat( tmpMat, quat.invert( rotInverse, this._rotation ) );\n                    mat4.mul( matrix, tmpMat, matrix );\n                }\n                mat4.fromScaling( tmpMat, scaleInverse );\n                mat4.mul( matrix, tmpMat, matrix );\n\n                mat4.fromTranslation( tmpMat, this._pivotPoint );\n                mat4.mul( matrix, tmpMat, matrix );\n\n            } else { // absolute\n                mat4.fromQuat( this._matrix, quat.invert( rotInverse, this._rotation ) );\n                mat4.translate( matrix, matrix, vec3.neg( neg, this._position ) );\n\n                mat4.fromScaling( tmpMat, scaleInverse );\n                mat4.mul( matrix, tmpMat, matrix );\n\n                mat4.fromTranslation( tmpMat, this._pivotPoint );\n                mat4.mul( matrix, tmpMat, matrix );\n\n            }\n            return true;\n        };\n    } )(),\n\n    computeBound: ( function () {\n        var matrix = mat4.create();\n        return function ( bSphere ) {\n            if ( this._autoScaleToScreen && this._firstTimeToInitEyePoint )\n                return bSphere;\n            Node.prototype.computeBound.call( this, bSphere );\n            if ( !bSphere.valid() ) {\n                return bSphere;\n            }\n            mat4.identity( matrix );\n            // local to local world (not Global World)\n            this.computeLocalToWorldMatrix( matrix );\n            //Matrix.transformBoundingSphere( matrix, bSphere, bSphere );\n            bSphere.transformMat4( bSphere, matrix );\n            return bSphere;\n        };\n    } )(),\n\n    accept: ( function () {\n\n        return function ( visitor ) {\n            if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {\n\n                var width = visitor.getViewport().width();\n                var height = visitor.getViewport().height();\n                var projMat = visitor.getCurrentProjectionMatrix();\n                var modelViewMat = visitor.getCurrentModelViewMatrix();\n                var position = this._position;\n                var doUpdate = this._firstTimeToInitEyePoint;\n                if ( !this._firstTimeToInitEyePoint ) {\n                    if ( width !== this._previousWidth || height !== this._previousHeight ) {\n                        doUpdate = true;\n                    } else if ( !mat4.exactEquals( projMat, this._previousProjection ) ) {\n                        doUpdate = true;\n                    } else if ( !mat4.exactEquals( modelViewMat, this._previousModelView ) ) {\n                        doUpdate = true;\n                    } else if ( !vec3.exactEquals( position, this._previousPosition ) ) {\n                        doUpdate = true;\n                    }\n                }\n                this._firstTimeToInitEyePoint = false;\n                if ( doUpdate ) {\n                    if ( this._autoScaleToScreen ) {\n                        var viewport = visitor.getViewport();\n                        var psvector = this.computePixelSizeVector( viewport, projMat, modelViewMat );\n                        var v = vec4.fromValues( this._position[ 0 ], this._position[ 1 ], this._position[ 2 ], 1.0 );\n                        var pixelSize = vec4.dot( v, psvector );\n                        pixelSize = 0.48 / pixelSize;\n                        var size = 1.0 / pixelSize;\n                        if ( this._autoScaleTransitionWidthRatio > 0.0 ) {\n                            var c, b, a;\n                            if ( this._minimumScale > 0.0 ) {\n                                var j = this._minimumScale;\n                                var i = ( this._maximumScale < Number.MAX_VALUE ) ?\n                                    this._minimumScale + ( this._maximumScale - this._minimumScale ) * this._autoScaleTransitionWidthRatio :\n                                    this._minimumScale * ( 1.0 + this._autoScaleTransitionWidthRatio );\n                                c = 1.0 / ( 4.0 * ( i - j ) );\n                                b = 1.0 - 2.0 * c * i;\n                                a = j + b * b / ( 4.0 * c );\n                                var k = -b / ( 2.0 * c );\n                                if ( size < k ) size = this._minimumScale;\n                                else if ( size < i ) size = a + b * size + c * ( size * size );\n                            }\n                            if ( this._maximumScale < Number.MAX_VALUE ) {\n                                var n = this._maximumScale;\n                                var m = ( this._minimumScale > 0.0 ) ?\n                                    this._maximumScale + ( this._minimumScale - this._maximumScale ) * this._autoScaleTransitionWidthRatio :\n                                    this._maximumScale * ( 1.0 - this._autoScaleTransitionWidthRatio );\n                                c = 1.0 / ( 4.0 * ( m - n ) );\n                                b = 1.0 - 2.0 * c * m;\n                                a = n + b * b / ( 4.0 * c );\n                                var p = -b / ( 2.0 * c );\n\n                                if ( size > p ) size = this._maximumScale;\n                                else if ( size > m ) size = a + b * size + c * ( size * size );\n                            }\n                        }\n                        this.setScale( size );\n                    }\n                    if ( this._autoRotateToScreen ) {\n                        var rotation = quat.create();\n                        mat4.getRotation( rotation, modelViewMat );\n                        this.setRotation( quat.invert( rotation, rotation ) );\n                    }\n                    this._previousWidth = width;\n                    this._previousHeight = height;\n                    vec3.copy( this._previousPosition, position );\n                    mat4.copy( this._previousProjection, projMat );\n                    mat4.copy( this._previousModelView, modelViewMat );\n                }\n            }\n\n            Node.prototype.accept.call( this, visitor );\n        };\n    } )(),\n\n    computePixelSizeVector: ( function () {\n        var scale00 = vec3.create();\n        var scale10 = vec3.create();\n        return function ( W, P, M ) {\n            // Where W = viewport, P = ProjectionMatrix, M = ModelViewMatrix\n            // Comment from OSG:\n            // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.\n            // here we do it in short hand with the knowledge of how the window matrix is formed\n            // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.\n\n            // scaling for horizontal pixels\n            var P00 = P[ 0 ] * W.width() * 0.5;\n            var P20_00 = P[ 8 ] * W.width() * 0.5 + P[ 11 ] * W.width() * 0.5;\n            vec3.set( scale00, M[ 0 ] * P00 + M[ 2 ] * P20_00,\n                M[ 4 ] * P00 + M[ 6 ] * P20_00,\n                M[ 8 ] * P00 + M[ 10 ] * P20_00 );\n\n            // scaling for vertical pixels\n            var P10 = P[ 5 ] * W.height() * 0.5;\n            var P20_10 = P[ 9 ] * W.height() * 0.5 + P[ 11 ] * W.height() * 0.5;\n            vec3.set( scale10, M[ 1 ] * P10 + M[ 2 ] * P20_10,\n                M[ 5 ] * P10 + M[ 6 ] * P20_10,\n                M[ 9 ] * P10 + M[ 10 ] * P20_10 );\n\n            var P23 = P[ 11 ];\n            var P33 = P[ 15 ];\n            var pixelSizeVector = vec4.fromValues( M[ 2 ] * P23, M[ 6 ] * P23, M[ 10 ] * P23, M[ 14 ] * P23 + M[ 15 ] * P33 );\n\n            var scaleRatio = 0.7071067811 / Math.sqrt( vec3.sqrLen( scale00 ) + vec3.sqrLen( scale10 ) );\n            vec4.scale( pixelSizeVector, pixelSizeVector, scaleRatio );\n            return pixelSizeVector;\n        };\n    } )()\n\n\n} ), 'osg', 'AutoTransform' );\nMACROUTILS.setTypeID( AutoTransform );\n\nmodule.exports = AutoTransform;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/AutoTransform.js\n// module id = 5\n// module chunks = 0 1 2","'use strict';\n\nvar osgPool = require( 'osgUtil/osgPool' );\nrequire( 'osg/StateGraph' );\nvar Timer = require( 'osg/Timer' );\nvar Notify = require( 'osg/notify' );\n\nvar Utils = {};\n\nUtils.init = function () {\n    var StateGraphClass = require( 'osg/StateGraph' );\n    osgPool.memoryPools.stateGraph = new osgPool.OsgObjectMemoryPool( StateGraphClass ).grow( 50 );\n};\n\n\nUtils.extend = function () {\n    // Save a reference to some core methods\n    var toString = window.Object.prototype.toString;\n    var hasOwnPropertyFunc = window.Object.prototype.hasOwnProperty;\n\n    var isFunction = function ( obj ) {\n        return toString.call( obj ) === '[object Function]';\n    };\n    var isArray = Utils.isArray;\n    var isPlainObject = function ( obj ) {\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don't pass through, as well\n        if ( !obj || toString.call( obj ) !== '[object Object]' || obj.nodeType || obj.setInterval ) {\n            return false;\n        }\n\n        // Not own constructor property must be Object\n        if ( obj.constructor && !hasOwnPropertyFunc.call( obj, 'constructor' ) && !hasOwnPropertyFunc.call( obj.constructor.prototype, 'isPrototypeOf' ) ) {\n            return false;\n        }\n\n        // Own properties are enumerated firstly, so to speed up,\n        // if last one is own, then all properties are own.\n\n        var key;\n        for ( key in obj ) {}\n\n        return key === undefined || hasOwnPropertyFunc.call( obj, key );\n    };\n\n    // copy reference to target object\n    var target = arguments[ 0 ] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false,\n        options, name, src, copy;\n\n    // Handle a deep copy situation\n    if ( typeof target === 'boolean' ) {\n        deep = target;\n        target = arguments[ 1 ] || {};\n        // skip the boolean and the target\n        i = 2;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== 'object' && !isFunction( target ) ) {\n        target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( length === i ) {\n        target = this;\n        --i;\n    }\n\n    for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( ( options = arguments[ i ] ) !== null ) {\n            // Extend the base object\n            for ( name in options ) {\n                src = target[ name ];\n                copy = options[ name ];\n\n                // Prevent never-ending loop\n                if ( target === copy ) {\n                    continue;\n                }\n\n                // Recurse if we're merging object literal values or arrays\n                if ( deep && copy && ( isPlainObject( copy ) || isArray( copy ) ) ) {\n                    var clone = src && ( isPlainObject( src ) || isArray( src ) ) ? src : isArray( copy ) ? [] : {};\n\n                    // Never move original objects, clone them\n                    target[ name ] = Utils.extend( deep, clone, copy );\n\n                    // Don't bring in undefined values\n                } else if ( copy !== undefined ) {\n                    target[ name ] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n\nUtils.objectInherit = function ( base /*, extras*/ ) {\n    function F() {}\n    F.prototype = base;\n    var obj = new F();\n\n    // let augment object with multiple arguement\n    for ( var i = 1; i < arguments.length; i++ ) {\n        Utils.objectMix( obj, arguments[ i ], false );\n    }\n    return obj;\n};\n\nUtils.objectMix = function ( obj, properties, test ) {\n    for ( var key in properties ) {\n        if ( !( test && obj[ key ] ) ) {\n            obj[ key ] = properties[ key ];\n        }\n    }\n    return obj;\n};\n\nUtils.objectType = {};\nUtils.objectType.type = 0;\nUtils.objectType.generate = function ( arg ) {\n    var t = Utils.objectType.type;\n    Utils.objectType[ t ] = arg;\n    Utils.objectType[ arg ] = t;\n    Utils.objectType.type += 1;\n    return t;\n};\n\nUtils.objectLibraryClass = function ( object, libName, className ) {\n    object.className = function () {\n        return className;\n    };\n    object.libraryName = function () {\n        return libName;\n    };\n    var libraryClassName = libName + '::' + className;\n    object.libraryClassName = function () {\n        return libraryClassName;\n    };\n\n    return object;\n};\n\nUtils.setTypeID = function ( classObject ) {\n    var className = classObject.prototype.libraryClassName();\n    var typeID = Utils.objectType.generate( className );\n    var getTypeID = function () {\n        return typeID;\n    };\n    classObject.typeID = classObject.prototype.typeID = typeID;\n    classObject.getTypeID = classObject.prototype.getTypeID = getTypeID;\n};\n\nUtils.createPrototypeClass = function ( Constructor, prototype, libraryName, className ) {\n\n    Constructor.prototype = prototype;\n    prototype.constructor = Constructor;\n\n    Utils.objectLibraryClass( prototype, libraryName, className );\n    Utils.setTypeID( Constructor );\n};\n\nUtils.Float32Array = typeof Float32Array !== 'undefined' ? Float32Array : null;\nUtils.Int32Array = typeof Int32Array !== 'undefined' ? Int32Array : null;\nUtils.Uint8Array = typeof Uint8Array !== 'undefined' ? Uint8Array : null;\nUtils.Uint16Array = typeof Uint16Array !== 'undefined' ? Uint16Array : null;\nUtils.Uint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : null;\n\nvar times = {};\n\n// we bind the function to Notify.console once and for all to avoid costly apply function\n\nUtils.time = ( Notify.console.time || function ( name ) {\n    times[ name ] = Timer.instance().tick();\n} ).bind( Notify.console );\n\nUtils.timeEnd = ( Notify.console.timeEnd || function ( name ) {\n\n    if ( times[ name ] === undefined )\n        return;\n\n    var duration = Timer.instance().deltaM( times[ name ], Timer.instance().tick() );\n\n    Notify.debug( name + ': ' + duration + 'ms' );\n    times[ name ] = undefined;\n\n} ).bind( Notify.console );\n\nUtils.timeStamp = ( Notify.console.timeStamp || Notify.console.markTimeline || function () {} ).bind( Notify.console );\nUtils.profile = ( Notify.console.profile || function () {} ).bind( Notify.console );\nUtils.profileEnd = ( Notify.console.profileEnd || function () {} ).bind( Notify.console );\n\nmodule.exports = Utils;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Utils.js\n// module id = 6\n// module chunks = 0 1 2","/**\n * Authors:\n *  Tuan.kuranes <tuan.kuranes@gmail.com> Jerome Etienne <Jerome.etienne@gmail.com>\n */\n\n'use strict';\nvar osgPool = {};\nosgPool.memoryPools = {};\n\n/*\n *  TODO: Add stats & reports for developper per application  finer calibration (max, min, average)\n *  TODO: Debug Mode: check if not putting object twice, etc.\n *  USAGE: osg.memoryPools.stateGraph = new OsgObjectMemoryPool(osg.StateGraph).grow(50);\n */\nosgPool.OsgObjectMemoryPool = function ( ObjectClassName ) {\n    return {\n        _memPool: [],\n        reset: function () {\n            this._memPool = [];\n            return this;\n        },\n        put: function ( obj ) {\n            this._memPool.push( obj );\n        },\n        get: function () {\n            if ( this._memPool.length > 0 ) {\n                return this._memPool.pop();\n            }\n            this.grow();\n            return this.get();\n        },\n        grow: function ( sizeAddParam ) {\n            var sizeAdd;\n            if ( sizeAddParam === undefined ) {\n                sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 20;\n            } else {\n                sizeAdd = sizeAddParam;\n            }\n            var i = this._memPool.length;\n            while ( i++ < sizeAdd ) this._memPool.push( new ObjectClassName() );\n            return this;\n        }\n    };\n};\n\n/*\n *  USAGE: osg.memoryPools.arrayPool = new OsgArrayMemoryPool();\n *  mymatrix = osg.memoryPools.arrayPool.get(16);\n *  // do use matrix, etc..\n *  osg.memoryPools.arrayPool.put(mymatrix);\n */\nosgPool.OsgArrayMemoryPool = function () {\n    return {\n        _mempoolofPools: [],\n        reset: function () {\n            this._memPoolofPools = {};\n            return this;\n        },\n        put: function ( obj ) {\n            if ( !this._memPoolofPools[ obj.length ] )\n                this._memPoolofPools[ obj.length ] = [];\n            this._memPoolofPools[ obj.length ].push( obj );\n        },\n        get: function ( arraySize ) {\n            if ( !this._memPoolofPools[ arraySize ] )\n                this._memPoolofPools[ arraySize ] = [];\n            else if ( this._memPoolofPools.length > 0 )\n                return this._memPool.pop();\n            this.grow( arraySize );\n            return this.get();\n        },\n        grow: function ( arraySize, sizeAdd ) {\n            if ( sizeAdd === undefined ) sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 5;\n            var i = this._memPool.length;\n            while ( i++ < sizeAdd ) this._memPool.push( new Array( arraySize ) );\n            return this;\n        }\n    };\n};\n/*\n *  USAGE: osg.memoryPools.OsgObjectMemoryStack = new OsgArrayMemoryStack(ctor);\n *         For a stack of object that you reset each frame.\n */\nosgPool.OsgObjectMemoryStack = function ( ObjectClassName ) {\n    return {\n        _current: 0,\n        _memPool: [ new ObjectClassName() ],\n        reset: function () {\n            this._current = 0;\n            return this;\n        },\n        get: function () {\n            var obj = this._memPool[ this._current++ ];\n            if ( this._current >= this._memPool.length ) {\n                this._memPool.push( new ObjectClassName() );\n            }\n            return obj;\n        }\n    };\n};\n\nmodule.exports = osgPool;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/osgPool.js\n// module id = 7\n// module chunks = 0 1 2","'use strict';\nvar osgPool = require( 'osgUtil/osgPool' );\n\n\nvar StateGraph = function () {\n    this.depth = 0;\n    this.children = {};\n    this.children.keys = [];\n    this.leafs = [];\n    this.stateset = undefined;\n    this.parent = undefined;\n};\n\nStateGraph.prototype = {\n\n    clean: function () {\n\n        this.leafs.length = 0;\n        this.stateset = undefined;\n        this.parent = undefined;\n        this.depth = 0;\n        var children = this.children;\n        var child;\n        var key, keys = children.keys;\n\n        for ( var i = 0, l = keys.length; i < l; i++ ) {\n\n            key = keys[ i ];\n            child = children[ key ];\n            child.clean();\n            osgPool.memoryPools.stateGraph.put( child );\n\n        }\n\n        this.children = {};\n        keys.length = 0;\n        this.children.keys = keys;\n    },\n\n    getStateSet: function () {\n        return this.stateset;\n    },\n\n    findOrInsert: function ( stateset ) {\n\n        var sg;\n        var stateSetID = stateset.getInstanceID();\n        var children = this.children;\n\n        if ( !children[ stateSetID ] ) {\n\n            //sg = new StateGraph();\n            sg = osgPool.memoryPools.stateGraph.get();\n\n            sg.parent = this;\n            sg.depth = this.depth + 1;\n            sg.stateset = stateset;\n            children[ stateSetID ] = sg;\n            children.keys.push( stateSetID );\n\n        } else {\n\n            sg = children[ stateSetID ];\n\n        }\n        return sg;\n    }\n\n};\n\nStateGraph.moveStateGraph = function ( state, sgCurrentArg, sgNewArg ) {\n\n    var stack = [];\n    var sgNew = sgNewArg;\n    var sgCurrent = sgCurrentArg;\n    var i, l;\n    if ( sgNew === sgCurrent || sgNew === undefined ) return;\n\n    if ( sgCurrent === undefined ) {\n        // push stateset from sgNew to root, and apply\n        // stateset from root to sgNew\n        do {\n            if ( sgNew.stateset !== undefined ) {\n                stack.push( sgNew.stateset );\n            }\n            sgNew = sgNew.parent;\n        } while ( sgNew );\n\n        for ( i = stack.length - 1, l = 0; i >= l; --i ) {\n            state.pushStateSet( stack[ i ] );\n        }\n        return;\n\n    } else if ( sgCurrent.parent === sgNew.parent ) {\n        // first handle the typical case which is two state groups\n        // are neighbours.\n\n        // state has changed so need to pop old state.\n        if ( sgCurrent.stateset !== undefined ) {\n            state.popStateSet();\n        }\n        // and push new state.\n        if ( sgNew.stateset !== undefined ) {\n            state.pushStateSet( sgNew.stateset );\n        }\n        return;\n    }\n\n    // need to pop back up to the same depth as the new state group.\n    while ( sgCurrent.depth > sgNew.depth ) {\n        if ( sgCurrent.stateset !== undefined ) {\n            state.popStateSet();\n        }\n        sgCurrent = sgCurrent.parent;\n    }\n\n    // use return path to trace back steps to sgNew.\n    stack = [];\n\n    // need to pop back up to the same depth as the curr state group.\n    while ( sgNew.depth > sgCurrent.depth ) {\n        if ( sgNew.stateset !== undefined ) {\n            stack.push( sgNew.stateset );\n        }\n        sgNew = sgNew.parent;\n    }\n\n    // now pop back up both parent paths until they agree.\n\n    // DRT - 10/22/02\n    // should be this to conform with above case where two StateGraph\n    // nodes have the same parent\n    while ( sgCurrent !== sgNew ) {\n        if ( sgCurrent.stateset !== undefined ) {\n            state.popStateSet();\n        }\n        sgCurrent = sgCurrent.parent;\n\n        if ( sgNew.stateset !== undefined ) {\n            stack.push( sgNew.stateset );\n        }\n        sgNew = sgNew.parent;\n    }\n\n    for ( i = stack.length - 1, l = 0; i >= l; --i ) {\n        state.pushStateSet( stack[ i ] );\n    }\n};\n\nmodule.exports = StateGraph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/StateGraph.js\n// module id = 8\n// module chunks = 0 1 2","// user performance if available or fallback\n\n'use strict';\nvar now = ( function () {\n\n    var w = window || global;\n\n    // if no window.performance\n    if ( w.performance === undefined ) {\n        return function () {\n            return Date.now();\n        };\n    }\n\n    var fn = w.performance.now || w.performance.mozNow || w.performance.msNow || w.performance.oNow || w.performance.webkitNow ||\n\n        function () {\n            return Date.now();\n        };\n    return function () {\n        return fn.apply( w.performance, arguments );\n    };\n} )();\n\n\nvar Timer = function () {};\n\nTimer.instance = function () {\n\n    if ( !Timer._instance )\n        Timer._instance = new Timer();\n\n    return Timer._instance;\n};\n\nTimer.prototype = {\n\n    // delta in seconds\n    deltaS: function ( t0, t1 ) {\n        return ( t1 - t0 ) / 1000.0;\n    },\n\n    // delta in milliseconds\n    deltaM: function ( t0, t1 ) {\n        return t1 - t0;\n    },\n\n    tick: function () {\n        return now();\n    }\n\n\n};\n\n\nmodule.exports = Timer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Timer.js\n// module id = 9\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = {};\n\n// must be uppercase and match loggers\nNotify.DEBUG = 0;\nNotify.INFO = 1;\nNotify.NOTICE = Notify.LOG = 2;\nNotify.WARN = 3;\nNotify.ERROR = 4;\n\nNotify.console = window.console;\n\n/** logging with readability in mind.\n * @param { level } what severity is that log (gives text color too )\n * @param { str } actual log text\n * @param { fold  } sometimes you want to hide looooong text\n */\nfunction logSub( level, str ) {\n\n    if ( !Notify.console ) return;\n\n    Notify.console[ level ]( str );\n    if ( Notify.traceLogCall && level !== 'error' ) console.trace();\n\n}\n\nfunction logSubFold( level, title, str ) {\n\n    if ( !Notify.console ) return;\n\n    if ( Notify.console.groupCollapsed ) Notify.console.groupCollapsed( title );\n    Notify.console[ level ]( str );\n    if ( Notify.traceLogCall && level !== 'error' ) console.trace();\n\n    if ( Notify.console.groupEnd ) Notify.console.groupEnd();\n\n}\n\nfunction unFlattenMatrix( m, rowMajor ) {\n    if ( rowMajor ) {\n        return [ m.slice( 0, 4 ), m.slice( 4, 8 ), m.slice( 8, 12 ), m.slice( 12, 16 ) ];\n    }\n\n    return [\n        [ m[ 0 ], m[ 4 ], m[ 8 ], m[ 12 ] ],\n        [ m[ 1 ], m[ 5 ], m[ 9 ], m[ 13 ] ],\n        [ m[ 2 ], m[ 6 ], m[ 10 ], m[ 14 ] ],\n        [ m[ 3 ], m[ 7 ], m[ 11 ], m[ 15 ] ]\n    ];\n}\n\nfunction logMatrix( m, rowMajor ) {\n    if ( Notify.console.table )\n        logSub( 'table', unFlattenMatrix( m, rowMajor ) );\n}\n\nfunction logMatrixFold( title, m, rowMajor ) {\n    if ( Notify.console.table )\n        logSubFold( 'table', title, unFlattenMatrix( m, rowMajor ) );\n}\n\nvar levelEntries = [ 'log', 'info', 'warn', 'error', 'debug' ];\nvar loggers = {};\nfor ( var i = 0; i < levelEntries.length; ++i ) {\n    var level = levelEntries[ i ];\n    loggers[ level ] = logSub.bind( Notify, level );\n    loggers[ level + 'Fold' ] = logSubFold.bind( Notify, level );\n    loggers[ level + 'Matrix' ] = logMatrix.bind( Notify );\n    loggers[ level + 'MatrixFold' ] = logMatrixFold.bind( Notify );\n}\n\nvar assert = function ( test, str ) {\n    if ( this.console !== undefined && !test ) {\n        this.console.assert( test, str );\n    }\n};\nNotify.assert = assert;\n\nNotify.setNotifyLevel = function ( logLevel ) {\n\n    var dummy = function () {};\n\n    for ( var i = 0; i < levelEntries.length; ++i ) {\n        var level = levelEntries[ i ];\n        var doDummy = logLevel > Notify[ level.toUpperCase() ];\n        Notify[ level ] = doDummy ? dummy : loggers[ level ];\n        Notify[ level + 'Fold' ] = doDummy ? dummy : loggers[ level + 'Fold' ];\n        Notify[ level + 'Matrix' ] = doDummy ? dummy : loggers[ level + 'Matrix' ];\n        Notify[ level + 'MatrixFold' ] = doDummy ? dummy : loggers[ level + 'MatrixFold' ];\n    }\n\n    // alias\n    Notify.notice = Notify.log;\n    Notify.noticeFold = Notify.logFold;\n    Notify.noticeMatrix = Notify.logMatrix;\n    Notify.noticeMatrixFold = Notify.logMatrixFold;\n};\n\nNotify.setNotifyLevel( Notify.NOTICE );\n\nNotify.reportWebGLError = false;\n\nNotify.setConsole = function ( replacement ) {\n    Notify.console = replacement;\n};\n\nmodule.exports = Notify;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/notify.js\n// module id = 10\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar TransformEnums = require( 'osg/transformEnums' );\n\n/**\n * Transform - base class for Transform type node ( Camera, MatrixTransform )\n * @class Transform\n * @inherits Node\n */\nvar Transform = function () {\n    Node.call( this );\n    this.referenceFrame = TransformEnums.RELATIVE_RF;\n};\n\n/** @lends Transform.prototype */\nTransform.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    setReferenceFrame: function ( value ) {\n        this.referenceFrame = value;\n    },\n    getReferenceFrame: function () {\n        return this.referenceFrame;\n    },\n\n    computeBoundingSphere: ( function () {\n        var matrix = mat4.create();\n        return function ( bSphere ) {\n            Node.prototype.computeBoundingSphere.call( this, bSphere );\n            if ( !bSphere.valid() ) {\n                return bSphere;\n            }\n\n            mat4.identity( matrix );\n            // local to local world (not Global World)\n            this.computeLocalToWorldMatrix( matrix );\n            bSphere.transformMat4( bSphere, matrix );\n            return bSphere;\n        };\n    } )()\n} );\n\nmodule.exports = Transform;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Transform.js\n// module id = 11\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar BoundingSphere = require( 'osg/BoundingSphere' );\nvar StateSet = require( 'osg/StateSet' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\nvar TransformEnums = require( 'osg/transformEnums' );\n\n\n/**\n *  Node that can contains child node\n *  @class Node\n */\nvar Node = function () {\n    Object.call( this );\n\n    this.children = [];\n    this._parents = [];\n    /*jshint bitwise: false */\n    this.nodeMask = ~0;\n    /*jshint bitwise: true */\n\n    this._boundingSphere = new BoundingSphere();\n    this._boundingSphereComputed = false;\n\n    this._boundingBox = new BoundingBox();\n    this._boundingBoxComputed = false;\n\n    this._updateCallbacks = [];\n    this._cullCallback = undefined;\n    this._cullingActive = true;\n    this._numChildrenWithCullingDisabled = 0;\n    this._numChildrenRequiringUpdateTraversal = 0;\n\n    // it's a tmp object for internal use, do not use\n    this._tmpBox = new BoundingBox();\n};\n\nNode._reservedMatrixStack = new MatrixMemoryPool();\nvar nodeGetMat = function () {\n    var mat = Node._reservedMatrixStack.get.bind( Node._reservedMatrixStack );\n    return mat4.identity( mat );\n};\n\n/** @lends Node.prototype */\nNode.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    /**\n      Return StateSet and create it if it does not exist yet\n      @type StateSet\n   */\n    getOrCreateStateSet: function () {\n        if ( !this.stateset ) this.setStateSet( new StateSet() );\n        return this.stateset;\n    },\n\n    getStateSet: function () {\n        return this.stateset;\n    },\n\n    accept: function ( nv ) {\n        if ( nv.validNodeMask( this ) ) {\n            nv.pushOntoNodePath( this );\n            nv.apply( this );\n            nv.popFromNodePath();\n        }\n    },\n\n    dirtyBound: function () {\n        if ( this._boundingSphereComputed === true || this._boundingBoxComputed === true ) {\n            this._boundingSphereComputed = false;\n            this._boundingBoxComputed = false;\n            var parents = this._parents;\n            for ( var i = 0, l = parents.length; i < l; i++ ) {\n                parents[ i ].dirtyBound();\n            }\n        }\n    },\n\n    setNodeMask: function ( mask ) {\n        this.nodeMask = mask;\n    },\n\n    getNodeMask: function () {\n        return this.nodeMask;\n    },\n\n    setStateSet: function ( stateSet ) {\n\n        if ( this.stateset === stateSet ) return;\n\n        var deltaUpdate = 0;\n\n        if ( this.stateset ) {\n            if ( this.stateset.requiresUpdateTraversal() ) deltaUpdate--;\n            this.stateset.removeParent( this );\n        }\n\n        if ( stateSet ) {\n            stateSet.addParent( this );\n            if ( stateSet.requiresUpdateTraversal() ) ++deltaUpdate;\n        }\n\n        if ( deltaUpdate !== 0 )\n            this.setNumChildrenRequiringUpdateTraversal( this.getNumChildrenRequiringUpdateTraversal() + deltaUpdate );\n\n        this.stateset = stateSet;\n    },\n\n    _updateNumChildrenRequeringUpdateTraversal: function ( delta ) {\n\n        if ( this._numChildrenRequiringUpdateTraversal === 0 && this._parents.length ) {\n            // the number of callbacks has changed, need to pass this\n            // on to parents so they know whether app traversal is\n            // required on this subgraph.\n            for ( var i = 0, l = this._parents.length; i < l; i++ ) {\n                var parent = this._parents[ i ];\n                var num = parent.getNumChildrenRequiringUpdateTraversal();\n                parent.setNumChildrenRequiringUpdateTraversal( num + delta );\n            }\n        }\n    },\n\n    setNumChildrenRequiringUpdateTraversal: function ( num ) {\n\n        // if no changes just return.\n        if ( this._numChildrenRequiringUpdateTraversal === num ) return;\n\n        // note, if _updateCallback is set then the\n        // parents won't be affected by any changes to\n        // _numChildrenRequiringUpdateTraversal so no need to inform them.\n        if ( !this._updateCallbacks.length && this._parents.length ) {\n\n            // need to pass on changes to parents.\n            var delta = 0;\n            if ( this._numChildrenRequiringUpdateTraversal > 0 ) --delta;\n            if ( num > 0 ) ++delta;\n\n            if ( delta !== 0 ) {\n                // the number of callbacks has changed, need to pass this\n                // on to parents so they know whether app traversal is\n                // required on this subgraph.\n                var parents = this._parents;\n                for ( var i = 0, l = parents.length; i < l; i++ ) {\n                    var parent = parents[ i ];\n                    var parentNum = parent.getNumChildrenRequiringUpdateTraversal();\n                    parent.setNumChildrenRequiringUpdateTraversal( parentNum + delta );\n                }\n            }\n        }\n\n        // finally update this objects value.\n        this._numChildrenRequiringUpdateTraversal = num;\n\n    },\n\n    getNumChildrenRequiringUpdateTraversal: function () {\n        return this._numChildrenRequiringUpdateTraversal;\n    },\n\n    /** Get update node callback, called during update traversal.\n      @type Oject\n   */\n    getUpdateCallback: function () {\n        return this._updateCallbacks[ 0 ];\n    },\n\n    addUpdateCallback: function ( cb ) {\n        var hasExistingCallback = Boolean( this._updateCallbacks.length );\n        this._updateCallbacks.push( cb );\n\n        // send the signal on first add\n        if ( !hasExistingCallback )\n            this._updateNumChildrenRequeringUpdateTraversal( 1 );\n    },\n\n    removeUpdateCallback: function ( cb ) {\n        var arrayIdx = this._updateCallbacks.indexOf( cb );\n        if ( arrayIdx === -1 ) return;\n        this._updateCallbacks.splice( arrayIdx, 1 );\n\n        // send the signal when no more callback\n        if ( !this._updateCallbacks.length )\n            this._updateNumChildrenRequeringUpdateTraversal( -1 );\n\n    },\n    getUpdateCallbackList: function () {\n        return this._updateCallbacks;\n    },\n\n\n    /**\n     <p>\n      Set cull node callback, called during cull traversal.\n      The Object must have the following method\n      cull(node, nodeVisitor) {}\n      note, callback is responsible for scenegraph traversal so\n      they must return true to traverse.\n      </p>\n      <p>\n      Here a dummy CullCallback example\n      </p>\n      @example\n      var DummyCullCallback = function() {};\n      DummyCullCallback.prototype = {\n          cull: function(node, nodeVisitor) {\n              return true;\n          }\n      };\n\n      @param Oject callback\n   */\n    setCullCallback: function ( cb ) {\n        this._cullCallback = cb;\n    },\n    getCullCallback: function () {\n        return this._cullCallback;\n    },\n\n    hasChild: function ( child ) {\n        for ( var i = 0, l = this.children.length; i < l; i++ ) {\n            if ( this.children[ i ] === child ) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    addChild: function ( child ) {\n\n        if ( this.children.indexOf( child ) !== -1 ) return undefined;\n\n        this.children.push( child );\n        child.addParent( this );\n        this.dirtyBound();\n\n        // could now require app traversal thanks to the new subgraph,\n        // so need to check and update if required.\n        if ( child.getNumChildrenRequiringUpdateTraversal() > 0 ||\n            child.getUpdateCallbackList().length ) {\n            this.setNumChildrenRequiringUpdateTraversal(\n                this.getNumChildrenRequiringUpdateTraversal() + 1\n            );\n        }\n\n        return child;\n    },\n\n    getChildren: function () {\n        return this.children;\n    },\n    getNumChildren: function () {\n        return this.children.length;\n    },\n    getChild: function ( num ) {\n        return this.children[ num ];\n    },\n    getParents: function () {\n        return this._parents;\n    },\n\n    addParent: function ( parent ) {\n        this._parents.push( parent );\n    },\n\n    removeParent: function ( parent ) {\n        var idx = this._parents.indexOf( parent );\n        if ( idx === -1 ) return;\n        this._parents.splice( idx, 1 );\n    },\n\n    removeChildren: function () {\n        var children = this.children;\n        var nbChildren = children.length;\n        if ( !nbChildren ) return;\n\n        var updateCallbackRemoved = 0;\n\n        for ( var i = 0; i < nbChildren; i++ ) {\n            var child = children[ i ];\n            child.removeParent( this );\n            if ( child.getNumChildrenRequiringUpdateTraversal() > 0 || child.getUpdateCallbackList().length ) ++updateCallbackRemoved;\n        }\n\n        children.length = 0;\n        if ( updateCallbackRemoved )\n            this.setNumChildrenRequiringUpdateTraversal( this.getNumChildrenRequiringUpdateTraversal() - updateCallbackRemoved );\n\n        this.dirtyBound();\n    },\n\n    // preserve order\n    removeChild: function ( child ) {\n\n        var children = this.children;\n        var id = children.indexOf( child );\n        if ( id === -1 ) return;\n\n        child.removeParent( this );\n        children.splice( id, 1 );\n\n        if ( child.getNumChildrenRequiringUpdateTraversal() > 0 || child.getUpdateCallbackList().length )\n            this.setNumChildrenRequiringUpdateTraversal( this.getNumChildrenRequiringUpdateTraversal() - 1 );\n\n    },\n\n    traverse: function ( visitor ) {\n        var children = this.children;\n        for ( var i = 0, l = children.length; i < l; i++ ) {\n            var child = children[ i ];\n            child.accept( visitor );\n        }\n    },\n\n    ascend: function ( visitor ) {\n        var parents = this._parents;\n        for ( var i = 0, l = parents.length; i < l; i++ ) {\n            var parent = parents[ i ];\n            parent.accept( visitor );\n        }\n    },\n\n    getBoundingBox: function () {\n        if ( !this._boundingBoxComputed ) {\n            this.computeBoundingBox( this._boundingBox );\n            this._boundingBoxComputed = true;\n        }\n        return this._boundingBox;\n    },\n\n    computeBoundingBox: function ( bbox ) {\n\n        // circular dependency... not sure if the global visitor instance should be instancied here\n        var ComputeBoundsVisitor = require( 'osg/ComputeBoundsVisitor' );\n        var cbv = ComputeBoundsVisitor.instance = ComputeBoundsVisitor.instance || new ComputeBoundsVisitor();\n        cbv.setNodeMaskOverride( ~0x0 ); // traverse everything to be consistent with computeBoundingSphere\n        cbv.reset();\n\n        cbv.apply( this );\n        bbox.copy( cbv.getBoundingBox() );\n        return bbox;\n    },\n\n    getBoundingSphere: function () {\n        return this.getBound();\n    },\n\n    getBound: function () {\n        if ( !this._boundingSphereComputed ) {\n            this.computeBoundingSphere( this._boundingSphere );\n            this._boundingSphereComputed = true;\n        }\n        return this._boundingSphere;\n    },\n\n    computeBoundingSphere: function ( bSphere ) {\n\n        var children = this.children;\n        var l = children.length;\n\n        bSphere.init();\n        if ( l === 0 ) return bSphere;\n\n        var cc, i;\n        var bb = this._tmpBox;\n        bb.init();\n        for ( i = 0; i < l; i++ ) {\n            cc = children[ i ];\n            if ( cc.referenceFrame !== TransformEnums.ABSOLUTE_RF ) {\n                bb.expandByBoundingSphere( cc.getBound() );\n            }\n        }\n        if ( !bb.valid() ) return bSphere;\n\n        bSphere.set( bb.center( bSphere.center() ), 0.0 );\n        for ( i = 0; i < l; i++ ) {\n            cc = children[ i ];\n            if ( cc.referenceFrame !== TransformEnums.ABSOLUTE_RF ) {\n                bSphere.expandRadiusBySphere( cc.getBound() );\n            }\n        }\n        return bSphere;\n    },\n\n    // matrixCreate allow user handling of garbage collection of matrices\n    getWorldMatrices: ( function () {\n        var CollectParentPaths = function () {\n            this.nodePaths = [];\n            this.halt = undefined;\n            NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );\n        };\n        CollectParentPaths.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n            reset: function () {\n                this.nodePath.length = 0;\n                this.nodePaths.length = 0;\n            },\n            apply: function ( node ) {\n                if ( node._parents.length === 0 || node === this.halt || node.referenceFrame === TransformEnums.ABSOLUTE_RF ) {\n                    // copy\n                    this.nodePaths.push( this.nodePath.slice( 0 ) );\n                } else {\n                    this.traverse( node );\n                }\n            }\n        } );\n        var collected = new CollectParentPaths();\n        collected.setNodeMaskOverride( ~0x0 ); // traverse everything\n\n        return function computeLocalToWorldList( halt, matrixCreate ) {\n            collected.reset();\n            collected.halt = halt;\n\n            this.accept( collected );\n            var matrixList = [];\n\n            var matrixGenerator = matrixCreate || mat4.create;\n            for ( var i = 0, l = collected.nodePaths.length; i < l; i++ ) {\n                var np = collected.nodePaths[ i ];\n                var m = matrixGenerator();\n                if ( np.length !== 0 ) {\n                    ComputeMatrixFromNodePath.computeLocalToWorld( np, true, m );\n                }\n                matrixList.push( m );\n            }\n\n            return matrixList;\n        };\n\n    } )(),\n\n    // same as getWorldMatrices GC: Perf WIN\n    getWorldMatrix: function ( halt, matrix ) {\n\n        // pass allocator on master\n        var matrixList = this.getWorldMatrices( halt, nodeGetMat );\n\n        if ( matrixList.length === 0 ) {\n\n            mat4.identity( matrix );\n\n        } else {\n\n            mat4.copy( matrix, matrixList[ 0 ] );\n\n        }\n\n        Node._reservedMatrixStack.reset();\n        return matrix;\n\n    },\n\n    setCullingActive: function ( value ) {\n        if ( this._cullingActive === value ) return;\n        if ( this._numChildrenWithCullingDisabled === 0 && this._parents.length > 0 ) {\n            var delta = 0;\n            if ( !this._cullingActive ) --delta;\n            if ( !value ) ++delta;\n            if ( delta !== 0 ) {\n                for ( var i = 0, k = this._parents.length; i < k; i++ ) {\n                    this._parents[ i ].setNumChildrenWithCullingDisabled( this._parents[ i ].getNumChildrenWithCullingDisabled() + delta );\n                }\n            }\n        }\n        this._cullingActive = value;\n    },\n\n    getCullingActive: function () {\n        return this._cullingActive;\n    },\n\n    isCullingActive: function () {\n        return this._numChildrenWithCullingDisabled === 0 && this._cullingActive && this.getBound().valid();\n    },\n\n    setNumChildrenWithCullingDisabled: function ( num ) {\n        if ( this._numChildrenWithCullingDisabled === num ) return;\n        if ( this._cullingActive && this._parents.length > 0 ) {\n            var delta = 0;\n            if ( this._numChildrenWithCullingDisabled > 0 ) --delta;\n            if ( num > 0 ) ++delta;\n            if ( delta !== 0 ) {\n                for ( var i = 0, k = this._parents.length; i < k; i++ ) {\n                    this._parents[ i ].setNumChildrenWithCullingDisabled( this._parents[ i ].getNumChildrenWithCullingDisabled() + delta );\n                }\n            }\n        }\n        this._numChildrenWithCullingDisabled = num;\n    },\n\n    getNumChildrenWithCullingDisabled: function () {\n        return this._numChildrenWithCullingDisabled;\n    },\n\n    releaseGLObjects: function () {\n        if ( this.stateset !== undefined ) this.stateset.releaseGLObjects();\n    }\n\n\n} ), 'osg', 'Node' );\nMACROUTILS.setTypeID( Node );\n\n\nmodule.exports = Node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Node.js\n// module id = 12\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\n\n/**\n *  Object class\n *  @class Object\n */\nvar Object = function () {\n    this._name = undefined;\n    this._userdata = undefined;\n    this._instanceID = Object.getInstanceID();\n};\n\n/** @lends Object.prototype */\nObject.prototype = MACROUTILS.objectLibraryClass( {\n\n    // this method works only if constructor is set correctly\n    // see issue https://github.com/cedricpinson/osgjs/issues/494\n    cloneType: function () {\n        var Constructor = this.constructor;\n        return new Constructor();\n    },\n\n    getInstanceID: function () {\n        return this._instanceID;\n    },\n\n    setName: function ( name ) {\n        this._name = name;\n    },\n\n    getName: function () {\n        return this._name;\n    },\n\n    setUserData: function ( data ) {\n        this._userdata = data;\n    },\n\n    getUserData: function () {\n        return this._userdata;\n    }\n}, 'osg', 'Object' );\n\n\n// get an instanceID for each object\nvar instanceID = 0;\nObject.getInstanceID = function () {\n    instanceID += 1;\n    return instanceID;\n};\n\nmodule.exports = Object;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Object.js\n// module id = 13\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\n\nvar BoundingBox = function () {\n    this._min = vec3.create();\n    this._max = vec3.create();\n    this.init();\n};\nBoundingBox.prototype = MACROUTILS.objectLibraryClass( {\n\n    init: function () {\n        vec3.copy( this._min, vec3.INFINITY );\n        vec3.copy( this._max, vec3.NEGATIVE_INFINITY );\n    },\n\n    copy: function ( bbox ) {\n        var min = this._min;\n        var bmin = bbox._min;\n        min[ 0 ] = bmin[ 0 ];\n        min[ 1 ] = bmin[ 1 ];\n        min[ 2 ] = bmin[ 2 ];\n\n        var max = this._max;\n        var bmax = bbox._max;\n        max[ 0 ] = bmax[ 0 ];\n        max[ 1 ] = bmax[ 1 ];\n        max[ 2 ] = bmax[ 2 ];\n    },\n\n    valid: function () {\n        return ( this._max[ 0 ] >= this._min[ 0 ] && this._max[ 1 ] >= this._min[ 1 ] && this._max[ 2 ] >= this._min[ 2 ] );\n    },\n\n    expandByBoundingSphere: function ( bs ) {\n        if ( !bs.valid() ) {\n            return;\n        }\n        var max = this._max;\n        var min = this._min;\n        var radius = bs._radius;\n        var x = bs._center[ 0 ];\n        var y = bs._center[ 1 ];\n        var z = bs._center[ 2 ];\n        min[ 0 ] = Math.min( min[ 0 ], x - radius );\n        min[ 1 ] = Math.min( min[ 1 ], y - radius );\n        min[ 2 ] = Math.min( min[ 2 ], z - radius );\n\n        max[ 0 ] = Math.max( max[ 0 ], x + radius );\n        max[ 1 ] = Math.max( max[ 1 ], y + radius );\n        max[ 2 ] = Math.max( max[ 2 ], z + radius );\n    },\n\n    expandByvec3: function ( v ) {\n        var min = this._min;\n        var max = this._max;\n        min[ 0 ] = Math.min( min[ 0 ], v[ 0 ] );\n        min[ 1 ] = Math.min( min[ 1 ], v[ 1 ] );\n        min[ 2 ] = Math.min( min[ 2 ], v[ 2 ] );\n\n        max[ 0 ] = Math.max( max[ 0 ], v[ 0 ] );\n        max[ 1 ] = Math.max( max[ 1 ], v[ 1 ] );\n        max[ 2 ] = Math.max( max[ 2 ], v[ 2 ] );\n    },\n\n    expandByBoundingBox: function ( bb ) {\n        if ( !bb.valid() )\n            return;\n\n        var min = this._min;\n        var max = this._max;\n        var bbmin = bb._min;\n        var bbmax = bb._max;\n\n        if ( bbmin[ 0 ] < min[ 0 ] ) min[ 0 ] = bbmin[ 0 ];\n        if ( bbmax[ 0 ] > max[ 0 ] ) max[ 0 ] = bbmax[ 0 ];\n\n        if ( bbmin[ 1 ] < min[ 1 ] ) min[ 1 ] = bbmin[ 1 ];\n        if ( bbmax[ 1 ] > max[ 1 ] ) max[ 1 ] = bbmax[ 1 ];\n\n        if ( bbmin[ 2 ] < min[ 2 ] ) min[ 2 ] = bbmin[ 2 ];\n        if ( bbmax[ 2 ] > max[ 2 ] ) max[ 2 ] = bbmax[ 2 ];\n    },\n\n    center: function ( result ) {\n        var min = this._min;\n        var max = this._max;\n        result[ 0 ] = ( min[ 0 ] + max[ 0 ] ) * 0.5;\n        result[ 1 ] = ( min[ 1 ] + max[ 1 ] ) * 0.5;\n        result[ 2 ] = ( min[ 2 ] + max[ 2 ] ) * 0.5;\n        return result;\n    },\n\n    radius: function () {\n        return Math.sqrt( this.radius2() );\n    },\n\n    radius2: function () {\n        var min = this._min;\n        var max = this._max;\n        var dx = max[ 0 ] - min[ 0 ];\n        var dy = max[ 1 ] - min[ 1 ];\n        var dz = max[ 2 ] - min[ 2 ];\n        return 0.25 * ( dx * dx + dy * dy + dz * dz );\n    },\n\n    getMin: function () {\n        return this._min;\n    },\n\n    getMax: function () {\n        return this._max;\n    },\n\n    setMin: function ( min ) {\n        vec3.copy( this._min, min );\n        return this;\n    },\n\n    setMax: function ( max ) {\n        vec3.copy( this._max, max );\n        return this;\n    },\n\n    xMax: function () {\n        return this._max[ 0 ];\n    },\n\n    yMax: function () {\n        return this._max[ 1 ];\n    },\n\n    zMax: function () {\n        return this._max[ 2 ];\n    },\n\n    xMin: function () {\n        return this._min[ 0 ];\n    },\n\n    yMin: function () {\n        return this._min[ 1 ];\n    },\n\n    zMin: function () {\n        return this._min[ 2 ];\n    },\n\n    corner: function ( pos, ret ) {\n        /*jshint bitwise: false */\n        if ( pos & 1 ) {\n            ret[ 0 ] = this._max[ 0 ];\n        } else {\n            ret[ 0 ] = this._min[ 0 ];\n        }\n        if ( pos & 2 ) {\n            ret[ 1 ] = this._max[ 1 ];\n        } else {\n            ret[ 1 ] = this._min[ 1 ];\n        }\n        if ( pos & 4 ) {\n            ret[ 2 ] = this._max[ 2 ];\n        } else {\n            ret[ 2 ] = this._min[ 2 ];\n        }\n        return ret;\n        /*jshint bitwise: true */\n    },\n\n    // http://dev.theomader.com/transform-bounding-boxes/\n    // https://github.com/erich666/GraphicsGems/blob/master/gems/TransBox.c\n    transformMat4: ( function () {\n        var tmpMin = vec3.create();\n        var tmpMax = vec3.create();\n        return function ( out, m ) {\n\n            var inMin = this.getMin();\n            var inMax = this.getMax();\n\n            /* Take care of translation by beginning at T. */\n            mat4.getTranslation( tmpMin, m );\n            vec3.copy( tmpMax, tmpMin );\n\n            /* Now find the extreme points by considering the product of the */\n            /* min and max with each component of M.  */\n            for ( var i = 0; i < 3; ++i ) {\n                var i4 = i * 4;\n                var mini = inMin[ i ];\n                var maxi = inMax[ i ];\n                for ( var j = 0; j < 3; ++j ) {\n                    var cm = m[ i4 + j ];\n                    var a = cm * maxi;\n                    var b = cm * mini;\n                    if ( a < b ) {\n                        tmpMin[ j ] += a;\n                        tmpMax[ j ] += b;\n                    } else {\n                        tmpMin[ j ] += b;\n                        tmpMax[ j ] += a;\n                    }\n                }\n            }\n            var outMax = out.getMax();\n            var outMin = out.getMin();\n\n            outMax[ 0 ] = tmpMax[ 0 ];\n            outMax[ 1 ] = tmpMax[ 1 ];\n            outMax[ 2 ] = tmpMax[ 2 ];\n\n            outMin[ 0 ] = tmpMin[ 0 ];\n            outMin[ 1 ] = tmpMin[ 1 ];\n            outMin[ 2 ] = tmpMin[ 2 ];\n\n            return out;\n        };\n    } )()\n\n}, 'osg', 'BoundingBox' );\n\nmodule.exports = BoundingBox;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BoundingBox.js\n// module id = 14\n// module chunks = 0 1 2","'use strict';\n\nvar mth = require( 'osg/math' );\nvar glm = require( 'gl-matrix' );\nvar config = require( 'config.js' );\nglm.glMatrix.setMatrixArrayType( config.ArrayType );\nglm.glMatrix.EPSILON = 1e-9;\n\n\nvar vec2 = glm.vec2;\nvar vec3 = glm.vec3;\nvar vec4 = glm.vec4;\nvar mat4 = glm.mat4;\nvar mat3 = glm.mat3;\nvar quat = glm.quat;\n\n// osg vec3 additions\n\nvec3.create32 = function () {\n    return new Float32Array( 3 );\n};\n\nvec3.create64 = function () {\n    return new Float64Array( 3 );\n};\n\nvec3.fromValues32 = function ( a, b, c ) {\n    var out = new Float32Array( 3 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    out[ 2 ] = c;\n    return out;\n};\n\nvec3.fromValues64 = function ( a, b, c ) {\n    var out = new Float64Array( 3 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    out[ 2 ] = c;\n    return out;\n};\n\nvec3.init = function ( out ) {\n    return vec3.set( out, 0.0, 0.0, 0.0 );\n};\n\nvec3.transformMat4Rotate = function ( out, v, m ) {\n    var x = v[ 0 ],\n        y = v[ 1 ],\n        z = v[ 2 ];\n    out[ 0 ] = m[ 0 ] * x + m[ 1 ] * y + m[ 2 ] * z;\n    out[ 1 ] = m[ 4 ] * x + m[ 5 ] * y + m[ 6 ] * z;\n    out[ 2 ] = m[ 8 ] * x + m[ 9 ] * y + m[ 10 ] * z;\n    return out;\n};\n\nvec3.valid = function ( a ) {\n    if ( mth.isNaN( a[ 0 ] ) ) return false;\n    if ( mth.isNaN( a[ 1 ] ) ) return false;\n    if ( mth.isNaN( a[ 2 ] ) ) return false;\n    return true;\n};\nvec3.neg = vec3.negate;\nvec3.ZERO = vec3.create();\nvec3.ONE = vec3.fromValues( 1.0, 1.0, 1.0 );\nvec3.INFINITY = vec3.fromValues( Infinity, Infinity, Infinity );\nvec3.NEGATIVE_INFINITY = vec3.fromValues( -Infinity, -Infinity, -Infinity );\n\n// osg vec2 additions\n\nvec2.create32 = function () {\n    return new Float32Array( 2 );\n};\n\nvec2.create64 = function () {\n    return new Float64Array( 2 );\n};\n\nvec2.fromValues32 = function ( a, b ) {\n    var out = new Float32Array( 2 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    return out;\n};\n\nvec2.fromValues64 = function ( a, b ) {\n    var out = new Float64Array( 2 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    return out;\n};\n\nvec2.init = function ( out ) {\n    return vec2.set( out, 0.0, 0.0 );\n};\n\nvec2.valid = function ( a ) {\n    if ( mth.isNaN( a[ 0 ] ) ) return false;\n    if ( mth.isNaN( a[ 1 ] ) ) return false;\n    return true;\n};\n\nvec2.ZERO = vec2.create();\nvec2.ONE = vec2.fromValues( 1.0, 1.0 );\nvec2.INFINITY = vec2.fromValues( Infinity, Infinity );\nvec2.NEGATIVE_INFINITY = vec2.fromValues( -Infinity, -Infinity );\n\n// osg vec4 additions\n\nvec4.create32 = function () {\n    return new Float32Array( 4 );\n};\n\nvec4.create64 = function () {\n    return new Float64Array( 4 );\n};\n\nvec4.fromValues32 = function ( a, b, c, d ) {\n    var out = new Float32Array( 4 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    out[ 2 ] = c;\n    out[ 3 ] = d;\n    return out;\n};\n\nvec4.fromValues64 = function ( a, b, c, d ) {\n    var out = new Float64Array( 4 );\n    out[ 0 ] = a;\n    out[ 1 ] = b;\n    out[ 2 ] = c;\n    out[ 3 ] = d;\n    return out;\n};\n\nvec4.init = function ( out ) {\n    return vec4.set( out, 0.0, 0.0, 0.0, 0.0 );\n};\n\nvec4.valid = function ( a ) {\n    if ( mth.isNaN( a[ 0 ] ) ) return false;\n    if ( mth.isNaN( a[ 1 ] ) ) return false;\n    if ( mth.isNaN( a[ 2 ] ) ) return false;\n    if ( mth.isNaN( a[ 3 ] ) ) return false;\n    return true;\n};\nvec4.neg = vec4.negate;\nvec4.ZERO = vec4.create();\nvec4.ONE = vec4.fromValues( 1.0, 1.0, 1.0, 1.0 );\nvec4.INFINITY = vec4.fromValues( Infinity, Infinity, Infinity, Infinity );\nvec4.NEGATIVE_INFINITY = vec4.fromValues( -Infinity, -Infinity, -Infinity, -Infinity );\n\n\n// quat\n\nquat.IDENTITY = quat.create();\n\nquat.zeroRotation = function ( q ) {\n    return q[ 0 ] === 0.0 && q[ 1 ] === 0.0 && q[ 2 ] === 0.0 && q[ 3 ] === 1.0;\n};\n\nquat.create32 = function () {\n    var out = new Float32Array( 4 );\n    out[ 3 ] = 1.0;\n    return out;\n};\n\nquat.create64 = function () {\n    var out = new Float64Array( 4 );\n    out[ 3 ] = 1.0;\n    return out;\n};\n\nquat.fromValues32 = vec4.fromValues32;\nquat.fromValues64 = vec4.fromValues64;\nquat.init = quat.identity;\n\n// http://physicsforgames.blogspot.fr/2010/02/quaternions.html\n// called quatBlend\n//\n// NLERP is supposed to be\n// - Commutative,\n// - NOT Constant velocity\n// - Torque minimal\n//\n// a and be must be normalized\n// (otherwise they're not rotation...)\n// t must be between 0 and 1\nquat.nlerp = function ( out, a, b, t ) {\n    var ax = a[ 0 ],\n        ay = a[ 1 ],\n        az = a[ 2 ],\n        aw = a[ 3 ],\n        bx = b[ 0 ],\n        by = b[ 1 ],\n        bz = b[ 2 ],\n        bw = b[ 3 ];\n    var dot = ax * bx + ay * by + az * bz + aw * bw;\n    var at = 1.0 - t;\n    var outx, outy, outz, outw;\n    // shortest path\n    if ( dot < 0.0 ) {\n\n        // negates directly b in the 4 equation\n        // this.neg( b, r );\n        outx = ax * at - bx * t;\n        outy = ay * at - by * t;\n        outz = az * at - bz * t;\n        outw = aw * at - bw * t;\n\n    } else {\n        outx = ax * at + bx * t;\n        outy = ay * at + by * t;\n        outz = az * at + bz * t;\n        outw = aw * at + bw * t;\n    }\n\n    var invLen = 1.0 / Math.sqrt( outx * outx + outy * outy + outz * outz + outw * outw );\n    out[ 0 ] = outx * invLen;\n    out[ 1 ] = outy * invLen;\n    out[ 2 ] = outz * invLen;\n    out[ 3 ] = outw * invLen;\n    return out;\n};\n\n// MUST READ on SLERP, NLERP, LOG-LERP\n// http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/\n// with a slerp implementation (robust)\n//\n// MUST READ Howto enhance lerp, slerp and q normalize\n// http://number-none.com/product/Hacking%20Quaternions/\n//\n// MUST READ The book:\n// Essential Mathematics for Games and Interactive Applications page\n// ( from 10.6.1 Linear Interpolation to 10.6.3 Performance Improvements )\n//\n//  SLERP is:\n// - NOT commutative\n// - constant velocity\n// - torque minimal\n//\n// so not to be used when blending multiple non ordered rotations\n// (as in multiple animation)\n//\n// slerp see glMatrix implementation\n\n\n// mat3 additions\nmat3.IDENTITY = mat3.create();\nmat3.create32 = function () {\n    var out = new Float32Array( 9 );\n    out[ 0 ] = out[ 4 ] = out[ 8 ] = 1.0;\n    return out;\n};\n\nmat3.create64 = function () {\n    var out = new Float64Array( 9 );\n    out[ 0 ] = out[ 4 ] = out[ 8 ] = 1.0;\n    return out;\n};\n\n// mat4 additions\nmat4.IDENTITY = mat4.create();\n\nmat4.create32 = function () {\n    var out = new Float32Array( 16 );\n    out[ 0 ] = out[ 5 ] = out[ 10 ] = out[ 15 ] = 1.0;\n    return out;\n};\n\nmat4.create64 = function () {\n    var out = new Float64Array( 16 );\n    out[ 0 ] = out[ 5 ] = out[ 10 ] = out[ 15 ] = 1.0;\n    return out;\n};\n\nmat4.setTranslation = function ( out, a ) {\n    out[ 12 ] = a[ 0 ];\n    out[ 13 ] = a[ 1 ];\n    out[ 14 ] = a[ 2 ];\n    return out;\n};\n\nmat4.getFrustum = function ( out, matrix ) {\n    var right = 0.0;\n    var left = 0.0;\n    var top = 0.0;\n    var bottom = 0.0;\n    var zNear, zFar;\n\n    if ( matrix[ 0 * 4 + 3 ] !== 0.0 || matrix[ 1 * 4 + 3 ] !== 0.0 || matrix[ 2 * 4 + 3 ] !== -1.0 || matrix[ 3 * 4 + 3 ] !== 0.0 ) {\n        return false;\n    }\n\n    // note: near and far must be used inside this method instead of zNear and zFar\n    // because zNear and zFar are references and they may point to the same variable.\n    var tempNear = matrix[ 3 * 4 + 2 ] / ( matrix[ 2 * 4 + 2 ] - 1.0 );\n    var tempFar = matrix[ 3 * 4 + 2 ] / ( 1.0 + matrix[ 2 * 4 + 2 ] );\n\n    left = tempNear * ( matrix[ 2 * 4 ] - 1.0 ) / matrix[ 0 ];\n    right = tempNear * ( 1.0 + matrix[ 2 * 4 ] ) / matrix[ 0 ];\n\n    top = tempNear * ( 1.0 + matrix[ 2 * 4 + 1 ] ) / matrix[ 1 * 4 + 1 ];\n    bottom = tempNear * ( matrix[ 2 * 4 + 1 ] - 1.0 ) / matrix[ 1 * 4 + 1 ];\n\n    zNear = tempNear;\n    zFar = tempFar;\n\n    out.left = left;\n    out.right = right;\n    out.top = top;\n    out.bottom = bottom;\n    out.zNear = zNear;\n    out.zFar = zFar;\n\n    return true;\n};\n\nmat4.getPerspective = ( function () {\n    var c = {\n        right: 0,\n        left: 0,\n        top: 0,\n        bottom: 0,\n        zNear: 0,\n        zFar: 0\n    };\n    return function ( out, matrix ) {\n        // get frustum and compute results\n        var r = mat4.getFrustum( c, matrix );\n        if ( r ) {\n            out.fovy = 180 / Math.PI * ( Math.atan( c.top / c.zNear ) - Math.atan( c.bottom / c.zNear ) );\n            out.aspectRatio = ( c.right - c.left ) / ( c.top - c.bottom );\n        }\n        out.zNear = c.zNear;\n        out.zFar = c.zFar;\n        return out;\n    };\n} )();\n\nmat4.getLookAt = ( function () {\n    var inv = mat4.create();\n    var v1 = vec3.create();\n    var v2 = vec3.fromValues( 0.0, 1.0, 0.0 );\n    var v3 = vec3.fromValues( 0.0, 0.0, -1.0 );\n\n    return function ( eye, center, up, matrix, distance ) {\n\n        var d = distance !== undefined ? distance : 1.0;\n        mat4.invert( inv, matrix );\n        mat4.getTranslation( eye, inv );\n        vec3.transformMat4Rotate( up, v2, matrix );\n        vec3.transformMat4Rotate( center, v3, matrix );\n        vec3.normalize( center, center );\n        vec3.add( center, vec3.scale( v1, center, d ), eye );\n    };\n} )();\n\nmat4.getFrustumPlanes = ( function () {\n\n    var mvp = mat4.create();\n\n    return function ( out, projection, view, withNearFar ) {\n        mat4.mul( mvp, projection, view );\n\n        var computeNearFar = !!withNearFar;\n\n        // Right clipping plane.\n        var right = out[ 0 ];\n        right[ 0 ] = mvp[ 3 ] - mvp[ 0 ];\n        right[ 1 ] = mvp[ 7 ] - mvp[ 4 ];\n        right[ 2 ] = mvp[ 11 ] - mvp[ 8 ];\n        right[ 3 ] = mvp[ 15 ] - mvp[ 12 ];\n\n        // Left clipping plane.\n        var left = out[ 1 ];\n        left[ 0 ] = mvp[ 3 ] + mvp[ 0 ];\n        left[ 1 ] = mvp[ 7 ] + mvp[ 4 ];\n        left[ 2 ] = mvp[ 11 ] + mvp[ 8 ];\n        left[ 3 ] = mvp[ 15 ] + mvp[ 12 ];\n\n        // Bottom clipping plane.\n        var bottom = out[ 2 ];\n        bottom[ 0 ] = mvp[ 3 ] + mvp[ 1 ];\n        bottom[ 1 ] = mvp[ 7 ] + mvp[ 5 ];\n        bottom[ 2 ] = mvp[ 11 ] + mvp[ 9 ];\n        bottom[ 3 ] = mvp[ 15 ] + mvp[ 13 ];\n\n        // Top clipping plane.\n        var top = out[ 3 ];\n        top[ 0 ] = mvp[ 3 ] - mvp[ 1 ];\n        top[ 1 ] = mvp[ 7 ] - mvp[ 5 ];\n        top[ 2 ] = mvp[ 11 ] - mvp[ 9 ];\n        top[ 3 ] = mvp[ 15 ] - mvp[ 13 ];\n\n        var nbPlanes = 4;\n        if ( computeNearFar ) {\n            nbPlanes = 6;\n            // Far clipping plane.\n            var far = out[ 4 ];\n            far[ 0 ] = mvp[ 3 ] - mvp[ 2 ];\n            far[ 1 ] = mvp[ 7 ] - mvp[ 6 ];\n            far[ 2 ] = mvp[ 11 ] - mvp[ 10 ];\n            far[ 3 ] = mvp[ 15 ] - mvp[ 14 ];\n\n            // Near clipping plane.\n            var near = out[ 5 ];\n            near[ 0 ] = mvp[ 3 ] + mvp[ 2 ];\n            near[ 1 ] = mvp[ 7 ] + mvp[ 6 ];\n            near[ 2 ] = mvp[ 11 ] + mvp[ 10 ];\n            near[ 3 ] = mvp[ 15 ] + mvp[ 14 ];\n        }\n\n        //Normalize the planes, from osg code\n        for ( var i = 0; i < nbPlanes; i++ ) {\n            var p = out[ i ];\n            // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.\n            var inv = 1.0 / Math.sqrt( p[ 0 ] * p[ 0 ] + p[ 1 ] * p[ 1 ] + p[ 2 ] * p[ 2 ] );\n            p[ 0 ] *= inv;\n            p[ 1 ] *= inv;\n            p[ 2 ] *= inv;\n            p[ 3 ] *= inv;\n        }\n\n    };\n} )();\n\n// better precison\n// no far clipping artifacts.\n// no reason not to use.\n// Tightening the Precision of Perspective Rendering\n//http://www.geometry.caltech.edu/pubs/UD12.pdf\n// drop-in, just remove the one below, and rename this one\nmat4.infiniteFrustum = function ( out, left, right, bottom, top, znear ) {\n    var X = 2.0 * znear / ( right - left );\n    var Y = 2.0 * znear / ( top - bottom );\n    var A = ( right + left ) / ( right - left );\n    var B = ( top + bottom ) / ( top - bottom );\n    var C = -1.0;\n    out[ 0 ] = X;\n    out[ 1 ] = 0.0;\n    out[ 2 ] = 0.0;\n    out[ 3 ] = 0.0;\n\n    out[ 4 ] = 0.0;\n    out[ 5 ] = Y;\n    out[ 6 ] = 0.0;\n    out[ 7 ] = 0.0;\n\n    out[ 8 ] = A;\n    out[ 9 ] = B;\n    out[ 10 ] = C;\n    out[ 11 ] = -1.0;\n\n    out[ 12 ] = 0.0;\n    out[ 13 ] = 0.0;\n    out[ 14 ] = -2.0 * znear;\n    out[ 15 ] = 0.0;\n\n    return out;\n};\n\nmat4.lookAtDirection = ( function () {\n    var s = vec3.create();\n    var u = vec3.create();\n    var neg = vec3.create();\n\n    return function ( out, eye, eyeDir, up ) {\n        var f = eyeDir;\n        vec3.cross( s, f, up );\n        vec3.normalize( s, s );\n\n        vec3.cross( u, s, f );\n        vec3.normalize( u, u );\n\n        // s[0], u[0], -f[0], 0.0,\n        // s[1], u[1], -f[1], 0.0,\n        // s[2], u[2], -f[2], 0.0,\n        // 0,    0,    0,     1.0\n\n        out[ 0 ] = s[ 0 ];\n        out[ 1 ] = u[ 0 ];\n        out[ 2 ] = -f[ 0 ];\n        out[ 3 ] = 0.0;\n        out[ 4 ] = s[ 1 ];\n        out[ 5 ] = u[ 1 ];\n        out[ 6 ] = -f[ 1 ];\n        out[ 7 ] = 0.0;\n        out[ 8 ] = s[ 2 ];\n        out[ 9 ] = u[ 2 ];\n        out[ 10 ] = -f[ 2 ];\n        out[ 11 ] = 0.0;\n        out[ 12 ] = 0;\n        out[ 13 ] = 0;\n        out[ 14 ] = 0;\n        out[ 15 ] = 1.0;\n\n        return mat4.translate( out, out, vec3.neg( neg, eye ) );\n    };\n} )();\n\nmat4.getScale = ( function () {\n    var sx = vec3.create();\n    var sy = vec3.create();\n    var sz = vec3.create();\n    return function ( out, matrix ) {\n        sx[ 0 ] = matrix[ 0 ];\n        sx[ 1 ] = matrix[ 4 ];\n        sx[ 2 ] = matrix[ 8 ];\n        sy[ 0 ] = matrix[ 1 ];\n        sy[ 1 ] = matrix[ 5 ];\n        sy[ 2 ] = matrix[ 9 ];\n        sz[ 0 ] = matrix[ 2 ];\n        sz[ 1 ] = matrix[ 6 ];\n        sz[ 2 ] = matrix[ 10 ];\n\n        out[ 0 ] = vec3.length( sx );\n        out[ 1 ] = vec3.length( sy );\n        out[ 2 ] = vec3.length( sz );\n        return out;\n    };\n} )();\n\nmat4.getSqrScale = ( function () {\n    var sx = vec3.create();\n    var sy = vec3.create();\n    var sz = vec3.create();\n    return function ( out, matrix ) {\n        sx[ 0 ] = matrix[ 0 ];\n        sx[ 1 ] = matrix[ 4 ];\n        sx[ 2 ] = matrix[ 8 ];\n        sy[ 0 ] = matrix[ 1 ];\n        sy[ 1 ] = matrix[ 5 ];\n        sy[ 2 ] = matrix[ 9 ];\n        sz[ 0 ] = matrix[ 2 ];\n        sz[ 1 ] = matrix[ 6 ];\n        sz[ 2 ] = matrix[ 10 ];\n\n        out[ 0 ] = vec3.sqrLen( sx );\n        out[ 1 ] = vec3.sqrLen( sy );\n        out[ 2 ] = vec3.sqrLen( sz );\n        return out;\n    };\n} )();\n\nvar glmRotate = mat4.rotate;\nmat4.rotate = function ( out, a, rad, axis ) {\n    return glmRotate( out, a, rad, axis ) || mat4.identity( out );\n};\n\nvar glmFromRotate = mat4.fromRotation;\nmat4.fromRotation = function ( out, rad, axis ) {\n    return glmFromRotate( out, rad, axis ) || mat4.identity( out );\n};\n\nmodule.exports = glm;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/glMatrix.js\n// module id = 15\n// module chunks = 0 1 2","'use strict';\n\nvar clamp = function ( x, min, max ) {\n    // http://jsperf.com/math-clamp\n    // http://jsperf.com/clamping-methods/2\n    return Math.min( max, Math.max( min, x ) );\n};\n\nvar smoothStep = function ( edge0, edge1, x ) {\n    if ( x <= edge0 ) return 0.0;\n    if ( x >= edge1 ) return 1.0;\n    var y = ( x - edge0 ) / ( edge1 - edge0 );\n    return y * y * ( 3.0 - 2.0 * y );\n};\n\n// native isNaN is slow (e.g: https://jsperf.com/isnan-performance/2)\n// note : native isNaN will return true for undefined but\n// this function assume that x is a number\nvar fastIsNaN = function ( x ) {\n    return x !== x;\n};\n\nmodule.exports = {\n    clamp: clamp,\n    smoothStep: smoothStep,\n    isNaN: fastIsNaN\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/math.js\n// module id = 16\n// module chunks = 0 1 2","/**\n * @fileoverview gl-matrix - High performance matrix and vector operations\n * @author Brandon Jones\n * @author Colin MacKenzie IV\n * @version 2.3.2\n */\n\n/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n// END HEADER\n\nexports.glMatrix = require(\"./gl-matrix/common.js\");\nexports.mat2 = require(\"./gl-matrix/mat2.js\");\nexports.mat2d = require(\"./gl-matrix/mat2d.js\");\nexports.mat3 = require(\"./gl-matrix/mat3.js\");\nexports.mat4 = require(\"./gl-matrix/mat4.js\");\nexports.quat = require(\"./gl-matrix/quat.js\");\nexports.vec2 = require(\"./gl-matrix/vec2.js\");\nexports.vec3 = require(\"./gl-matrix/vec3.js\");\nexports.vec4 = require(\"./gl-matrix/vec4.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix.js\n// module id = 17\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\n/**\n * @class Common utilities\n * @name glMatrix\n */\nvar glMatrix = {};\n\n// Configuration Constants\nglMatrix.EPSILON = 0.000001;\nglMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\nglMatrix.RANDOM = Math.random;\nglMatrix.ENABLE_SIMD = false;\n\n// Capability detection\nglMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);\nglMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nglMatrix.setMatrixArrayType = function(type) {\n    glMatrix.ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n\n/**\n* Convert Degree To Radian\n*\n* @param {Number} Angle in Degrees\n*/\nglMatrix.toRadian = function(a){\n     return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less \n * than or equal to 1.0, and a relative tolerance is used for larger values)\n * \n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nglMatrix.equals = function(a, b) {\n\treturn Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nmodule.exports = glMatrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/common.js\n// module id = 18\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 2x2 Matrix\n * @name mat2\n */\nvar mat2 = {};\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nmat2.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nmat2.fromValues = function(m00, m01, m10, m11) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nmat2.set = function(out, m00, m01, m10, m11) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a1 = a[1];\n        out[1] = a[2];\n        out[2] = a1;\n    } else {\n        out[0] = a[0];\n        out[1] = a[2];\n        out[2] = a[1];\n        out[3] = a[3];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n\n        // Calculate the determinant\n        det = a0 * a3 - a2 * a1;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    \n    out[0] =  a3 * det;\n    out[1] = -a1 * det;\n    out[2] = -a2 * det;\n    out[3] =  a0 * det;\n\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.adjoint = function(out, a) {\n    // Caching this value is nessecary if out == a\n    var a0 = a[0];\n    out[0] =  a[3];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] =  a0;\n\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2.determinant = function (a) {\n    return a[0] * a[3] - a[2] * a[1];\n};\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    return out;\n};\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nmat2.mul = mat2.multiply;\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    return out;\n};\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nmat2.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.fromRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nmat2.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2.str = function (a) {\n    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))\n};\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix \n * @param {mat2} D the diagonal matrix \n * @param {mat2} U the upper triangular matrix \n * @param {mat2} a the input matrix to factorize\n */\n\nmat2.LDU = function (L, D, U, a) { \n    L[2] = a[2]/a[0]; \n    U[0] = a[0]; \n    U[1] = a[1]; \n    U[3] = a[3] - L[2] * U[1]; \n    return [L, D, U];       \n}; \n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nmat2.sub = mat2.subtract;\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nmat2.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nmat2.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\nmodule.exports = mat2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/mat2.js\n// module id = 19\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 2x3 Matrix\n * @name mat2d\n * \n * @description \n * A mat2d contains six elements defined as:\n * <pre>\n * [a, c, tx,\n *  b, d, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, c, tx,\n *  b, d, ty,\n *  0, 0, 1]\n * </pre>\n * The last row is ignored so the array is shorter and operations are faster.\n */\nvar mat2d = {};\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nmat2d.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nmat2d.fromValues = function(a, b, c, d, tx, ty) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nmat2d.set = function(out, a, b, c, d, tx, ty) {\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.invert = function(out, a) {\n    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],\n        atx = a[4], aty = a[5];\n\n    var det = aa * ad - ab * ac;\n    if(!det){\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = ad * det;\n    out[1] = -ab * det;\n    out[2] = -ac * det;\n    out[3] = aa * det;\n    out[4] = (ac * aty - ad * atx) * det;\n    out[5] = (ab * atx - aa * aty) * det;\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2d.determinant = function (a) {\n    return a[0] * a[3] - a[1] * a[2];\n};\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    out[4] = a0 * b4 + a2 * b5 + a4;\n    out[5] = a1 * b4 + a3 * b5 + a5;\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nmat2d.mul = mat2d.multiply;\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nmat2d.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nmat2d.translate = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = a0 * v0 + a2 * v1 + a4;\n    out[5] = a1 * v0 + a3 * v1 + a5;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nmat2d.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nmat2d.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = v[0];\n    out[5] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2d.str = function (a) {\n    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2d.frob = function (a) { \n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))\n}; \n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nmat2d.sub = mat2d.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nmat2d.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    return out;\n};\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nmat2d.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));\n};\n\nmodule.exports = mat2d;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/mat2d.js\n// module id = 20\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 3x3 Matrix\n * @name mat3\n */\nvar mat3 = {};\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nmat3.fromMat4 = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n};\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nmat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nmat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nmat3.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b01 = a22 * a11 - a12 * a21,\n        b11 = -a22 * a10 + a12 * a20,\n        b21 = a21 * a10 - a11 * a20,\n\n        // Calculate the determinant\n        det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    out[0] = (a11 * a22 - a12 * a21);\n    out[1] = (a02 * a21 - a01 * a22);\n    out[2] = (a01 * a12 - a02 * a11);\n    out[3] = (a12 * a20 - a10 * a22);\n    out[4] = (a00 * a22 - a02 * a20);\n    out[5] = (a02 * a10 - a00 * a12);\n    out[6] = (a10 * a21 - a11 * a20);\n    out[7] = (a01 * a20 - a00 * a21);\n    out[8] = (a00 * a11 - a01 * a10);\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nmat3.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n};\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b00 = b[0], b01 = b[1], b02 = b[2],\n        b10 = b[3], b11 = b[4], b12 = b[5],\n        b20 = b[6], b21 = b[7], b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n};\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nmat3.mul = mat3.multiply;\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nmat3.translate = function(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n        x = v[0], y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n};\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.rotate = function (out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nmat3.scale = function(out, a, v) {\n    var x = v[0], y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nmat3.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = v[0];\n    out[7] = v[1];\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n\n    out[0] = c;\n    out[1] = s;\n    out[2] = 0;\n\n    out[3] = -s;\n    out[4] = c;\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nmat3.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n\n    out[3] = 0;\n    out[4] = v[1];\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nmat3.fromMat2d = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = 0;\n\n    out[3] = a[2];\n    out[4] = a[3];\n    out[5] = 0;\n\n    out[6] = a[4];\n    out[7] = a[5];\n    out[8] = 1;\n    return out;\n};\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nmat3.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n};\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nmat3.normalFromMat4 = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat3.str = function (a) {\n    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + \n                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat3.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))\n};\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n};\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nmat3.sub = mat3.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nmat3.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n};\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nmat3.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    return out;\n};\n\n/*\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && \n           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&\n           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));\n};\n\n\nmodule.exports = mat3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/mat3.js\n// module id = 21\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 4x4 Matrix\n * @name mat4\n */\nvar mat4 = {\n  scalar: {},\n  SIMD: {},\n};\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nmat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nmat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nmat4.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a03 = a[3],\n            a12 = a[6], a13 = a[7],\n            a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.transpose = function(out, a) {\n    var a0, a1, a2, a3,\n        tmp01, tmp23,\n        out0, out1, out2, out3;\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    a1 = SIMD.Float32x4.load(a, 4);\n    a2 = SIMD.Float32x4.load(a, 8);\n    a3 = SIMD.Float32x4.load(a, 12);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 0,  out0);\n    SIMD.Float32x4.store(out, 4,  out1);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 8,  out2);\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Transpse a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;\n\n/**\n * Inverts a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n};\n\n/**\n * Inverts a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.invert = function(out, a) {\n  var row0, row1, row2, row3,\n      tmp1,\n      minor0, minor1, minor2, minor3,\n      det,\n      a0 = SIMD.Float32x4.load(a, 0),\n      a1 = SIMD.Float32x4.load(a, 4),\n      a2 = SIMD.Float32x4.load(a, 8),\n      a3 = SIMD.Float32x4.load(a, 12);\n\n  // Compute matrix adjugate\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  // Compute matrix determinant\n  det   = SIMD.Float32x4.mul(row0, minor0);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);\n  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);\n  det   = SIMD.Float32x4.sub(\n               SIMD.Float32x4.add(tmp1, tmp1),\n               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));\n  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);\n  if (!det) {\n      return null;\n  }\n\n  // Compute matrix inverse\n  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));\n  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));\n  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));\n  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));\n  return out;\n}\n\n/**\n * Inverts a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;\n\n/**\n * Calculates the adjugate of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.adjoint = function(out, a) {\n  var a0, a1, a2, a3;\n  var row0, row1, row2, row3;\n  var tmp1;\n  var minor0, minor1, minor2, minor3;\n\n  var a0 = SIMD.Float32x4.load(a, 0);\n  var a1 = SIMD.Float32x4.load(a, 4);\n  var a2 = SIMD.Float32x4.load(a, 8);\n  var a3 = SIMD.Float32x4.load(a, 12);\n\n  // Transpose the source matrix.  Sort of.  Not a true transpose operation\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  SIMD.Float32x4.store(out, 0,  minor0);\n  SIMD.Float32x4.store(out, 4,  minor1);\n  SIMD.Float32x4.store(out, 8,  minor2);\n  SIMD.Float32x4.store(out, 12, minor3);\n  return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nmat4.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n};\n\n/**\n * Multiplies two mat4's explicitly using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand, must be a Float32Array\n * @param {mat4} b the second operand, must be a Float32Array\n * @returns {mat4} out\n */\nmat4.SIMD.multiply = function (out, a, b) {\n    var a0 = SIMD.Float32x4.load(a, 0);\n    var a1 = SIMD.Float32x4.load(a, 4);\n    var a2 = SIMD.Float32x4.load(a, 8);\n    var a3 = SIMD.Float32x4.load(a, 12);\n\n    var b0 = SIMD.Float32x4.load(b, 0);\n    var out0 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 0, out0);\n\n    var b1 = SIMD.Float32x4.load(b, 4);\n    var out1 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 4, out1);\n\n    var b2 = SIMD.Float32x4.load(b, 8);\n    var out2 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 8, out2);\n\n    var b3 = SIMD.Float32x4.load(b, 12);\n    var out3 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),\n                        SIMD.Float32x4.add(\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Multiplies two mat4's explicitly not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.scalar.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];\n    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];\n    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];\n    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n    return out;\n};\n\n/**\n * Multiplies two mat4's using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nmat4.mul = mat4.multiply;\n\n/**\n * Translate a mat4 by the given vector not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.scalar.translate = function (out, a, v) {\n    var x = v[0], y = v[1], z = v[2],\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.SIMD.translate = function (out, a, v) {\n    var a0 = SIMD.Float32x4.load(a, 0),\n        a1 = SIMD.Float32x4.load(a, 4),\n        a2 = SIMD.Float32x4.load(a, 8),\n        a3 = SIMD.Float32x4.load(a, 12),\n        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);\n\n    if (a !== out) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];\n        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];\n    }\n\n    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));\n    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));\n    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));\n\n    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));\n    SIMD.Float32x4.store(out, 12, t0);\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.scalar.scale = function(out, a, v) {\n    var x = v[0], y = v[1], z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.SIMD.scale = function(out, a, v) {\n    var a0, a1, a2;\n    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    SIMD.Float32x4.store(\n        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));\n\n    a1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(\n        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));\n\n    a2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(\n        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));\n\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n */\nmat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.rotate = function (out, a, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t,\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23,\n        b00, b01, b02,\n        b10, b11, b12,\n        b20, b21, b22;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateX = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[0]  = a[0];\n        out[1]  = a[1];\n        out[2]  = a[2];\n        out[3]  = a[3];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[4] = a10 * c + a20 * s;\n    out[5] = a11 * c + a21 * s;\n    out[6] = a12 * c + a22 * s;\n    out[7] = a13 * c + a23 * s;\n    out[8] = a20 * c - a10 * s;\n    out[9] = a21 * c - a11 * s;\n    out[10] = a22 * c - a12 * s;\n    out[11] = a23 * c - a13 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateX = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n      out[0]  = a[0];\n      out[1]  = a[1];\n      out[2]  = a[2];\n      out[3]  = a[3];\n      out[12] = a[12];\n      out[13] = a[13];\n      out[14] = a[14];\n      out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;\n\n/**\n * Rotates a matrix by the given angle around the Y axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateY = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c - a20 * s;\n    out[1] = a01 * c - a21 * s;\n    out[2] = a02 * c - a22 * s;\n    out[3] = a03 * c - a23 * s;\n    out[8] = a00 * s + a20 * c;\n    out[9] = a01 * s + a21 * c;\n    out[10] = a02 * s + a22 * c;\n    out[11] = a03 * s + a23 * c;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateY = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;\n\n/**\n * Rotates a matrix by the given angle around the Z axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateZ = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c + a10 * s;\n    out[1] = a01 * c + a11 * s;\n    out[2] = a02 * c + a12 * s;\n    out[3] = a03 * c + a13 * s;\n    out[4] = a10 * c - a00 * s;\n    out[5] = a11 * c - a01 * s;\n    out[6] = a12 * c - a02 * s;\n    out[7] = a13 * c - a03 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateZ = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nmat4.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = v[1];\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = v[2];\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.fromRotation = function(out, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = x * x * t + c;\n    out[1] = y * x * t + z * s;\n    out[2] = z * x * t - y * s;\n    out[3] = 0;\n    out[4] = x * y * t - z * s;\n    out[5] = y * y * t + c;\n    out[6] = z * y * t + x * s;\n    out[7] = 0;\n    out[8] = x * z * t + y * s;\n    out[9] = y * z * t - x * s;\n    out[10] = z * z * t + c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromXRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = 1;\n    out[1]  = 0;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = c;\n    out[6] = s;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = -s;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromYRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = 0;\n    out[2]  = -s;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = s;\n    out[9] = 0;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromZRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = s;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = -s;\n    out[5] = c;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslation = function (out, q, v) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nmat4.getTranslation = function (out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n};\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nmat4.getRotation = function (out, mat) {\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n  var trace = mat[0] + mat[5] + mat[10];\n  var S = 0;\n\n  if (trace > 0) { \n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (mat[6] - mat[9]) / S;\n    out[1] = (mat[8] - mat[2]) / S; \n    out[2] = (mat[1] - mat[4]) / S; \n  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { \n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\n    out[3] = (mat[6] - mat[9]) / S;\n    out[0] = 0.25 * S;\n    out[1] = (mat[1] + mat[4]) / S; \n    out[2] = (mat[8] + mat[2]) / S; \n  } else if (mat[5] > mat[10]) { \n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\n    out[3] = (mat[8] - mat[2]) / S;\n    out[0] = (mat[1] + mat[4]) / S; \n    out[1] = 0.25 * S;\n    out[2] = (mat[6] + mat[9]) / S; \n  } else { \n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\n    out[3] = (mat[1] - mat[4]) / S;\n    out[0] = (mat[8] + mat[2]) / S;\n    out[1] = (mat[6] + mat[9]) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScale = function (out, q, v, s) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2,\n        sx = s[0],\n        sy = s[1],\n        sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0], y = q[1], z = q[2], w = q[3],\n      x2 = x + x,\n      y2 = y + y,\n      z2 = z + z,\n\n      xx = x * x2,\n      xy = x * y2,\n      xz = x * z2,\n      yy = y * y2,\n      yz = y * z2,\n      zz = z * z2,\n      wx = w * x2,\n      wy = w * y2,\n      wz = w * z2,\n\n      sx = s[0],\n      sy = s[1],\n      sz = s[2],\n\n      ox = o[0],\n      oy = o[1],\n      oz = o[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);\n  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);\n  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);\n  out[15] = 1;\n\n  return out;\n};\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nmat4.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.frustum = function (out, left, right, bottom, top, near, far) {\n    var rl = 1 / (right - left),\n        tb = 1 / (top - bottom),\n        nf = 1 / (near - far);\n    out[0] = (near * 2) * rl;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = (near * 2) * tb;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = (right + left) * rl;\n    out[9] = (top + bottom) * tb;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (far * near * 2) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspective = function (out, fovy, aspect, near, far) {\n    var f = 1.0 / Math.tan(fovy / 2),\n        nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (2 * far * near) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspectiveFromFieldOfView = function (out, fov, near, far) {\n    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),\n        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),\n        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),\n        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),\n        xScale = 2.0 / (leftTan + rightTan),\n        yScale = 2.0 / (upTan + downTan);\n\n    out[0] = xScale;\n    out[1] = 0.0;\n    out[2] = 0.0;\n    out[3] = 0.0;\n    out[4] = 0.0;\n    out[5] = yScale;\n    out[6] = 0.0;\n    out[7] = 0.0;\n    out[8] = -((leftTan - rightTan) * xScale * 0.5);\n    out[9] = ((upTan - downTan) * yScale * 0.5);\n    out[10] = far / (near - far);\n    out[11] = -1.0;\n    out[12] = 0.0;\n    out[13] = 0.0;\n    out[14] = (far * near) / (near - far);\n    out[15] = 0.0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.ortho = function (out, left, right, bottom, top, near, far) {\n    var lr = 1 / (left - right),\n        bt = 1 / (bottom - top),\n        nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nmat4.lookAt = function (out, eye, center, up) {\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,\n        eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2],\n        centerx = center[0],\n        centery = center[1],\n        centerz = center[2];\n\n    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&\n        Math.abs(eyey - centery) < glMatrix.EPSILON &&\n        Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n        return mat4.identity(out);\n    }\n\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n\n    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    } else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    } else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat4.str = function (a) {\n    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat4.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))\n};\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n};\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nmat4.sub = mat4.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nmat4.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n};\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nmat4.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    out[9] = a[9] + (b[9] * scale);\n    out[10] = a[10] + (b[10] * scale);\n    out[11] = a[11] + (b[11] * scale);\n    out[12] = a[12] + (b[12] * scale);\n    out[13] = a[13] + (b[13] * scale);\n    out[14] = a[14] + (b[14] * scale);\n    out[15] = a[15] + (b[15] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && \n           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && \n           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&\n           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.equals = function (a, b) {\n    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],\n        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], \n        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], \n        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];\n\n    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],\n        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], \n        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], \n        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));\n};\n\n\n\nmodule.exports = mat4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/mat4.js\n// module id = 22\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\nvar mat3 = require(\"./mat3.js\");\nvar vec3 = require(\"./vec3.js\");\nvar vec4 = require(\"./vec4.js\");\n\n/**\n * @class Quaternion\n * @name quat\n */\nvar quat = {};\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nquat.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nquat.rotationTo = (function() {\n    var tmpvec3 = vec3.create();\n    var xUnitVec3 = vec3.fromValues(1,0,0);\n    var yUnitVec3 = vec3.fromValues(0,1,0);\n\n    return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n            return out;\n        } else if (dot > 0.999999) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out[0] = tmpvec3[0];\n            out[1] = tmpvec3[1];\n            out[2] = tmpvec3[2];\n            out[3] = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n})();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nquat.setAxes = (function() {\n    var matr = mat3.create();\n\n    return function(out, view, right, up) {\n        matr[0] = right[0];\n        matr[3] = right[1];\n        matr[6] = right[2];\n\n        matr[1] = up[0];\n        matr[4] = up[1];\n        matr[7] = up[2];\n\n        matr[2] = -view[0];\n        matr[5] = -view[1];\n        matr[8] = -view[2];\n\n        return quat.normalize(out, quat.fromMat3(out, matr));\n    };\n})();\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nquat.clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nquat.fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nquat.copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nquat.set = vec4.set;\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nquat.identity = function(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nquat.setAxisAngle = function(out, axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n};\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nquat.getAxisAngle = function(out_axis, q) {\n    var rad = Math.acos(q[3]) * 2.0;\n    var s = Math.sin(rad / 2.0);\n    if (s != 0.0) {\n        out_axis[0] = q[0] / s;\n        out_axis[1] = q[1] / s;\n        out_axis[2] = q[2] / s;\n    } else {\n        // If s is zero, return any axis (no rotation - axis does not matter)\n        out_axis[0] = 1;\n        out_axis[1] = 0;\n        out_axis[2] = 0;\n    }\n    return rad;\n};\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nquat.add = vec4.add;\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nquat.multiply = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n};\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nquat.mul = quat.multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nquat.scale = vec4.scale;\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateX = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateY = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        by = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateZ = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bz = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n};\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nquat.calculateW = function (out, a) {\n    var x = a[0], y = a[1], z = a[2];\n\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n    return out;\n};\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nquat.dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nquat.lerp = vec4.lerp;\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nquat.slerp = function (out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    var        omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if ( cosom < 0.0 ) {\n        cosom = -cosom;\n        bx = - bx;\n        by = - by;\n        bz = - bz;\n        bw = - bw;\n    }\n    // calculate coefficients\n    if ( (1.0 - cosom) > 0.000001 ) {\n        // standard case (slerp)\n        omega  = Math.acos(cosom);\n        sinom  = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {        \n        // \"from\" and \"to\" quaternions are very close \n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    \n    return out;\n};\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount\n * @returns {quat} out\n */\nquat.sqlerp = (function () {\n  var temp1 = quat.create();\n  var temp2 = quat.create();\n  \n  return function (out, a, b, c, d, t) {\n    quat.slerp(temp1, a, d, t);\n    quat.slerp(temp2, b, c, t);\n    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));\n    \n    return out;\n  };\n}());\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nquat.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,\n        invDot = dot ? 1.0/dot : 0;\n    \n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0*invDot;\n    out[1] = -a1*invDot;\n    out[2] = -a2*invDot;\n    out[3] = a3*invDot;\n    return out;\n};\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nquat.conjugate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n * @function\n */\nquat.length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nquat.len = quat.length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nquat.squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nquat.sqrLen = quat.squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nquat.normalize = vec4.normalize;\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nquat.fromMat3 = function(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if ( fTrace > 0.0 ) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5/fRoot;  // 1/(4w)\n        out[0] = (m[5]-m[7])*fRoot;\n        out[1] = (m[6]-m[2])*fRoot;\n        out[2] = (m[1]-m[3])*fRoot;\n    } else {\n        // |w| <= 1/2\n        var i = 0;\n        if ( m[4] > m[0] )\n          i = 1;\n        if ( m[8] > m[i*3+i] )\n          i = 2;\n        var j = (i+1)%3;\n        var k = (i+2)%3;\n        \n        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;\n        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;\n        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;\n    }\n    \n    return out;\n};\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nquat.str = function (a) {\n    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.equals = vec4.equals;\n\nmodule.exports = quat;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/quat.js\n// module id = 23\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 3 Dimensional Vector\n * @name vec3\n */\nvar vec3 = {};\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nvec3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nvec3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nvec3.fromValues = function(x, y, z) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nvec3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nvec3.set = function(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nvec3.sub = vec3.subtract;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nvec3.mul = vec3.multiply;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nvec3.div = vec3.divide;\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nvec3.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nvec3.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nvec3.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    return out;\n};\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nvec3.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n};\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nvec3.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nvec3.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nvec3.dist = vec3.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec3.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nvec3.sqrDist = vec3.squaredDistance;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec3.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nvec3.len = vec3.length;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec3.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nvec3.sqrLen = vec3.squaredLength;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nvec3.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nvec3.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n};\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nvec3.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    var len = x*x + y*y + z*z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.cross = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n};\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.hermite = function (out, a, b, c, d, t) {\n  var factorTimes2 = t * t,\n      factor1 = factorTimes2 * (2 * t - 3) + 1,\n      factor2 = factorTimes2 * (t - 2) + t,\n      factor3 = factorTimes2 * (t - 1),\n      factor4 = factorTimes2 * (3 - 2 * t);\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.bezier = function (out, a, b, c, d, t) {\n  var inverseFactor = 1 - t,\n      inverseFactorTimesTwo = inverseFactor * inverseFactor,\n      factorTimes2 = t * t,\n      factor1 = inverseFactorTimesTwo * inverseFactor,\n      factor2 = 3 * t * inverseFactorTimesTwo,\n      factor3 = 3 * factorTimes2 * inverseFactor,\n      factor4 = factorTimes2 * t;\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nvec3.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    var z = (glMatrix.RANDOM() * 2.0) - 1.0;\n    var zScale = Math.sqrt(1.0-z*z) * scale;\n\n    out[0] = Math.cos(r) * zScale;\n    out[1] = Math.sin(r) * zScale;\n    out[2] = z * scale;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat3 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n};\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nvec3.transformQuat = function(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n};\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateX = function(out, a, b, c){\n   var p = [], r=[];\n\t  //Translate point to the origin\n\t  p[0] = a[0] - b[0];\n\t  p[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n\n\t  //perform rotation\n\t  r[0] = p[0];\n\t  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);\n\t  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);\n\n\t  //translate to correct position\n\t  out[0] = r[0] + b[0];\n\t  out[1] = r[1] + b[1];\n\t  out[2] = r[2] + b[2];\n\n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateY = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);\n  \tr[1] = p[1];\n  \tr[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateZ = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);\n  \tr[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);\n  \tr[2] = p[2];\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec3.forEach = (function() {\n    var vec = vec3.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 3;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nvec3.angle = function(a, b) {\n   \n    var tempA = vec3.fromValues(a[0], a[1], a[2]);\n    var tempB = vec3.fromValues(b[0], b[1], b[2]);\n \n    vec3.normalize(tempA, tempA);\n    vec3.normalize(tempB, tempB);\n \n    var cosine = vec3.dot(tempA, tempB);\n\n    if(cosine > 1.0){\n        return 0;\n    } else {\n        return Math.acos(cosine);\n    }     \n};\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec3.str = function (a) {\n    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2];\n    var b0 = b[0], b1 = b[1], b2 = b[2];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));\n};\n\nmodule.exports = vec3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/vec3.js\n// module id = 24\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 4 Dimensional Vector\n * @name vec4\n */\nvar vec4 = {};\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nvec4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nvec4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nvec4.fromValues = function(x, y, z, w) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nvec4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nvec4.set = function(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nvec4.sub = vec4.subtract;\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    out[3] = a[3] * b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nvec4.mul = vec4.multiply;\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    out[3] = a[3] / b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nvec4.div = vec4.divide;\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nvec4.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    out[3] = Math.ceil(a[3]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nvec4.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    out[3] = Math.floor(a[3]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    out[3] = Math.min(a[3], b[3]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    out[3] = Math.max(a[3], b[3]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nvec4.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    out[3] = Math.round(a[3]);\n    return out;\n};\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nvec4.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nvec4.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nvec4.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nvec4.dist = vec4.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec4.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nvec4.sqrDist = vec4.squaredDistance;\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec4.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nvec4.len = vec4.length;\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec4.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nvec4.sqrLen = vec4.squaredLength;\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nvec4.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = -a[3];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nvec4.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n};\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nvec4.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    var len = x*x + y*y + z*z + w*w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n        out[0] = x * len;\n        out[1] = y * len;\n        out[2] = z * len;\n        out[3] = w * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nvec4.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nvec4.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    //TODO: This is a pretty awful way of doing this. Find something better.\n    out[0] = glMatrix.RANDOM();\n    out[1] = glMatrix.RANDOM();\n    out[2] = glMatrix.RANDOM();\n    out[3] = glMatrix.RANDOM();\n    vec4.normalize(out, out);\n    vec4.scale(out, out, scale);\n    return out;\n};\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nvec4.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2], w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return out;\n};\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nvec4.transformQuat = function(out, a, q) {\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec4.forEach = (function() {\n    var vec = vec4.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 4;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec4.str = function (a) {\n    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\nmodule.exports = vec4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/vec4.js\n// module id = 25\n// module chunks = 0 1 2","/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = require(\"./common.js\");\n\n/**\n * @class 2 Dimensional Vector\n * @name vec2\n */\nvar vec2 = {};\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nvec2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvec2.div = vec2.divide;\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nvec2.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nvec2.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nvec2.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    return out;\n};\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nvec2.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nvec2.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n};\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nvec2.cross = function(out, a, b) {\n    var z = a[0] * b[1] - a[1] * b[0];\n    out[0] = out[1] = 0;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nvec2.random = function (out, scale) {\n    scale = scale || 1.0;\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    out[0] = Math.cos(r) * scale;\n    out[1] = Math.sin(r) * scale;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2d = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat3 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat4 = function(out, a, m) {\n    var x = a[0], \n        y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec2.forEach = (function() {\n    var vec = vec2.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 2;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1];\n    var b0 = b[0], b1 = b[1];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));\n};\n\nmodule.exports = vec2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gl-matrix/src/gl-matrix/vec2.js\n// module id = 26\n// module chunks = 0 1 2","'use strict';\n\nmodule.exports = {\n    ArrayType: Float64Array\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/config.js\n// module id = 27\n// module chunks = 0 1 2","'use strict';\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\n\nvar BoundingSphere = function () {\n    this._center = vec3.create();\n    this._radius = -1.0;\n};\n\nBoundingSphere.prototype = {\n    init: function () {\n        vec3.init( this._center );\n        this._radius = -1.0;\n    },\n    valid: function () {\n        return this._radius >= 0.0;\n    },\n    set: function ( center, radius ) {\n        this._center = center;\n        this._radius = radius;\n    },\n    center: function () {\n        return this._center;\n    },\n    radius: function () {\n        return this._radius;\n    },\n    radius2: function () {\n        return this._radius * this._radius;\n    },\n\n    expandByBoundingBox: ( function () {\n        var v = vec3.create();\n        var newbb = new BoundingBox();\n\n        return function ( bb ) {\n            if ( !bb.valid() )\n                return;\n\n            if ( this.valid() ) {\n                vec3.copy( newbb._min, bb._min );\n                vec3.copy( newbb._max, bb._max );\n\n                for ( var i = 0; i < 8; i++ ) {\n                    vec3.sub( v, bb.corner( i, v ), this._center ); // get the direction vector from corner\n                    vec3.normalize( v, v ); // normalise it.\n                    vec3.scaleAndAdd( v, this._center, v, -this._radius ); // move the vector in the opposite direction distance radius.\n                    newbb.expandByvec3( v ); // add it into the new bounding box.\n                }\n\n                newbb.center( this._center );\n                this._radius = newbb.radius();\n            } else {\n                bb.center( this._center );\n                this._radius = bb.radius();\n            }\n        };\n    } )(),\n\n    expandByvec3: ( function () {\n        var dv = vec3.create();\n        return function ( v ) {\n            if ( this.valid() ) {\n                vec3.sub( dv, v, this.center( dv ) );\n                var r = vec3.length( dv );\n                if ( r > this.radius() ) {\n                    var dr = ( r - this.radius() ) * 0.5;\n                    this._center[ 0 ] += dv[ 0 ] * ( dr / r );\n                    this._center[ 1 ] += dv[ 1 ] * ( dr / r );\n                    this._center[ 2 ] += dv[ 2 ] * ( dr / r );\n                    this._radius += dr;\n                }\n            } else {\n                this._center[ 0 ] = v[ 0 ];\n                this._center[ 1 ] = v[ 1 ];\n                this._center[ 2 ] = v[ 2 ];\n                this._radius = 0.0;\n            }\n        };\n    } )(),\n\n    expandRadiusBySphere: function ( sh ) {\n        if ( sh.valid() ) {\n            if ( this.valid() ) {\n                var r = vec3.distance( this._center, sh._center ) + sh._radius;\n                if ( r > this._radius ) {\n                    this._radius = r;\n                }\n                // else do nothing as vertex is within sphere.\n            } else {\n                vec3.copy( this._center, sh._center );\n                this._radius = sh._radius;\n            }\n        }\n    },\n\n    expandByBoundingSphere: function ( sh ) {\n        // ignore operation if incomming BoundingSphere is invalid.\n        if ( !sh.valid() ) {\n            return;\n        }\n\n        // This sphere is not set so use the inbound sphere\n        if ( !this.valid() ) {\n            this._center[ 0 ] = sh._center[ 0 ];\n            this._center[ 1 ] = sh._center[ 1 ];\n            this._center[ 2 ] = sh._center[ 2 ];\n            this._radius = sh.radius();\n\n            return;\n        }\n\n        // Calculate d == The distance between the sphere centers\n        var d = vec3.distance( sh.center(), this.center() );\n\n        // New sphere is already inside this one\n        if ( d + sh.radius() <= this.radius() ) {\n            return;\n        }\n\n        //  New sphere completely contains this one\n        if ( d + this.radius() <= sh.radius() ) {\n            this._center[ 0 ] = sh._center[ 0 ];\n            this._center[ 1 ] = sh._center[ 1 ];\n            this._center[ 2 ] = sh._center[ 2 ];\n            this._radius = sh._radius;\n            return;\n        }\n\n\n        // Build a new sphere that completely contains the other two:\n        //\n        // The center point lies halfway along the line between the furthest\n        // points on the edges of the two spheres.\n        //\n        // Computing those two points is ugly - so we'll use similar triangles\n        var newRadius = ( this.radius() + d + sh.radius() ) * 0.5;\n        var ratio = ( newRadius - this.radius() ) / d;\n\n        this._center[ 0 ] += ( sh._center[ 0 ] - this._center[ 0 ] ) * ratio;\n        this._center[ 1 ] += ( sh._center[ 1 ] - this._center[ 1 ] ) * ratio;\n        this._center[ 2 ] += ( sh._center[ 2 ] - this._center[ 2 ] ) * ratio;\n\n        this._radius = newRadius;\n    },\n    contains: function ( v ) {\n        if ( !this.valid() )\n            return false;\n        return vec3.sqrDist( this.center(), v ) <= this.radius2();\n    },\n    intersects: function ( bs ) {\n        if ( !this.valid() || !bs.valid() )\n            return false;\n        var r = this.radius() + bs.radius();\n        return vec3.sqrDist( bs.center(), this.center() ) <= r * r;\n    },\n\n    transformMat4: ( function () {\n        var scaleVec = vec3.create();\n        return function ( out, matrix ) {\n            if ( !this.valid() ) return out;\n\n            if ( out._center !== this._center ) {\n                vec3.copy( out._center, this._center );\n                out._radius = this._radius;\n            }\n            var sphCenter = out._center;\n            var sphRadius = out._radius;\n\n            mat4.getSqrScale( scaleVec, matrix );\n            var scale = Math.sqrt( Math.max( Math.max( scaleVec[ 0 ], scaleVec[ 1 ] ), scaleVec[ 2 ] ) );\n            sphRadius = sphRadius * scale;\n            out._radius = sphRadius;\n            vec3.transformMat4( sphCenter, sphCenter, matrix );\n\n            return out;\n        };\n    } )()\n\n};\n\nmodule.exports = BoundingSphere;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BoundingSphere.js\n// module id = 28\n// module chunks = 0 1 2","'use strict';\nvar Object = require( 'osg/Object' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n\n/** Stores a set of modes and attributes which represent a set of OpenGL state.\n *  Notice that a \\c StateSet contains just a subset of the whole OpenGL state.\n * <p>In OSG, each \\c Drawable and each \\c Node has a reference to a\n * \\c StateSet. These <tt>StateSet</tt>s can be shared between\n * different <tt>Drawable</tt>s and <tt>Node</tt>s (that is, several\n * <tt>Drawable</tt>s and <tt>Node</tt>s can reference the same \\c StateSet).\n * Indeed, this practice is recommended whenever possible,\n * as this minimizes expensive state changes in the graphics pipeline.\n */\nvar StateSet = function () {\n    Object.call( this );\n\n    this._parents = [];\n    this.attributeMap = {};\n\n    this.textureAttributeMapList = [];\n\n    this._binName = undefined;\n    this._binNumber = 0;\n\n    // put the shader generator name in an AttributePair\n    // so that we can use the mask value\n    this._shaderGeneratorPair = null;\n\n    this._updateCallbackList = [];\n\n    this.uniforms = {};\n\n    this._drawID = -1; // used by the RenderLeaf to decide if it should apply the stateSet\n};\n\nStateSet.AttributePair = function ( attr, value ) {\n    this._object = attr;\n    this._value = value;\n};\n\nStateSet.AttributePair.prototype = {\n    getShaderGeneratorName: function () {\n        return this._object;\n    },\n    getAttribute: function () {\n        return this._object;\n    },\n    getUniform: function () {\n        return this._object;\n    },\n    getValue: function () {\n        return this._value;\n    }\n};\n\n\nStateSet.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    setDrawID: function ( id ) {\n        this._drawID = id;\n    },\n\n    getDrawID: function () {\n        return this._drawID;\n    },\n\n    getAttributePair: function ( attribute, value ) {\n        return new StateSet.AttributePair( attribute, value );\n    },\n\n    addUniform: function ( uniform, originalMode ) {\n        var mode = originalMode !== undefined ? originalMode : StateAttribute.ON;\n        var name = uniform.getName();\n        this.uniforms[ name ] = this.getAttributePair( uniform, mode );\n    },\n\n    addParent: function ( node ) {\n        this._parents.push( node );\n    },\n\n    removeParent: function ( node ) {\n        var idx = this._parents.indexOf( node );\n        if ( idx === -1 ) return;\n        this._parents.splice( idx, 1 );\n    },\n\n    removeUniform: function ( uniform ) {\n        delete this.uniforms[ uniform.getName() ];\n    },\n\n    removeUniformByName: function ( uniformName ) {\n        delete this.uniforms[ uniformName ];\n    },\n\n    getUniform: function ( uniform ) {\n        var uniformMap = this.uniforms;\n        if ( uniformMap[ uniform ] ) return uniformMap[ uniform ].getAttribute();\n        return undefined;\n    },\n\n    getUniformList: function () {\n        return this.uniforms;\n    },\n\n    setTextureAttributeAndModes: function ( unit, attribute, originalMode ) {\n        var mode = originalMode !== undefined ? originalMode : StateAttribute.ON;\n        this._setTextureAttribute( unit, this.getAttributePair( attribute, mode ) );\n    },\n\n    getNumTextureAttributeLists: function () {\n        return this.textureAttributeMapList.length;\n    },\n\n    getTextureAttribute: function ( unit, attribute ) {\n        if ( this.textureAttributeMapList[ unit ] === undefined ) return undefined;\n\n        var textureMap = this.textureAttributeMapList[ unit ];\n        if ( textureMap[ attribute ] === undefined ) return undefined;\n\n        return textureMap[ attribute ].getAttribute();\n    },\n\n    removeTextureAttribute: function ( unit, attributeName ) {\n        if ( this.textureAttributeMapList[ unit ] === undefined ) return;\n\n        var textureAttributeMap = this.textureAttributeMapList[ unit ];\n        if ( textureAttributeMap[ attributeName ] === undefined ) return;\n\n\n        delete textureAttributeMap[ attributeName ];\n    },\n\n    getAttribute: function ( attributeType ) {\n        if ( this.attributeMap[ attributeType ] === undefined ) {\n            return undefined;\n        }\n        return this.attributeMap[ attributeType ].getAttribute();\n    },\n\n    setAttributeAndModes: function ( attribute, originalMode ) {\n        var mode = originalMode !== undefined ? originalMode : StateAttribute.ON;\n        this._setAttribute( this.getAttributePair( attribute, mode ) );\n    },\n\n    setAttribute: function ( attribute, originalMode ) {\n        var mode = originalMode !== undefined ? originalMode : StateAttribute.ON;\n        this._setAttribute( this.getAttributePair( attribute, mode ) );\n    },\n\n    // TODO: check if it's an attribute type or a attribute to remove it\n    removeAttribute: function ( attributeName ) {\n\n        if ( this.attributeMap[ attributeName ] !== undefined ) {\n            delete this.attributeMap[ attributeName ];\n        }\n    },\n\n    setRenderingHint: function ( hint ) {\n        if ( hint === 'OPAQUE_BIN' ) {\n            this.setRenderBinDetails( 0, 'RenderBin' );\n        } else if ( hint === 'TRANSPARENT_BIN' ) {\n            this.setRenderBinDetails( 10, 'DepthSortedBin' );\n        } else {\n            this.setRenderBinDetails( 0, '' );\n        }\n    },\n\n    getUpdateCallbackList: function () {\n        return this._updateCallbackList;\n    },\n\n    removeUpdateCallback: function ( cb ) {\n        var idx = this._updateCallbackList.indexOf( cb );\n        if ( idx === -1 ) return;\n        this._updateCallbackList.splice( idx, 1 );\n\n        if ( this._updateCallbackList.length === 0 ) {\n            var parents = this._parents;\n            for ( var i = 0, l = parents.length; i < l; i++ ) {\n                var parent = parents[ i ];\n                parent.setNumChildrenRequiringUpdateTraversal( parent.getNumChildrenRequiringUpdateTraversal() - 1 );\n            }\n        }\n    },\n\n    requiresUpdateTraversal: function () {\n        return !!this._updateCallbackList.length;\n    },\n\n    addUpdateCallback: function ( cb ) {\n\n        var dontNoticeParents = Boolean( this._updateCallbackList.length );\n        this._updateCallbackList.push( cb );\n\n        // parent alreay know we have update callback\n        if ( dontNoticeParents ) return;\n\n        var parents = this._parents;\n        for ( var i = 0, l = parents.length; i < l; i++ ) {\n            var parent = parents[ i ];\n            parent.setNumChildrenRequiringUpdateTraversal( parent.getNumChildrenRequiringUpdateTraversal() + 1 );\n        }\n    },\n\n    hasUpdateCallback: function ( cb ) {\n        return this._updateCallbackList.indexOf( cb ) !== -1;\n    },\n\n    setRenderBinDetails: function ( num, binName ) {\n        this._binNumber = num;\n        this._binName = binName;\n    },\n    getAttributeMap: function () {\n        return this.attributeMap;\n    },\n    getBinNumber: function () {\n        return this._binNumber;\n    },\n    getBinName: function () {\n        return this._binName;\n    },\n    setBinNumber: function ( binNum ) {\n        this._binNumber = binNum;\n    },\n    setBinName: function ( binName ) {\n        this._binName = binName;\n    },\n    getAttributeList: function () {\n        var list = [];\n        for ( var keyAttribute in this.attributeMap ) {\n            list.push( this.attributeMap[ keyAttribute ] );\n        }\n        return list;\n    },\n    setShaderGeneratorName: function ( generatorName, mask ) {\n        this._shaderGeneratorPair = this.getAttributePair( generatorName, mask );\n    },\n    getShaderGeneratorPair: function () {\n        return this._shaderGeneratorPair;\n    },\n    getShaderGeneratorName: function () {\n        return this._shaderGeneratorPair ? this._shaderGeneratorPair.getShaderGeneratorName() : undefined;\n    },\n    releaseGLObjects: function () {\n        for ( var i = 0, j = this.textureAttributeMapList.length; i < j; i++ ) {\n            this.getTextureAttribute( i, 'Texture' ).releaseGLObjects();\n        }\n        var list = this.getAttributeList();\n        for ( i = 0, j = list.length; i < j; i++ ) {\n            // Remove only if we have releaseGLObject method.\n            if ( list[ i ]._object.releaseGLObjects ) {\n                list[ i ]._object.releaseGLObjects();\n            }\n        }\n    },\n    _getUniformMap: function () {\n        return this.uniforms;\n    },\n\n    // for internal use, you should not call it directly\n    _setTextureAttribute: function ( unit, attributePair ) {\n\n        if ( this.textureAttributeMapList[ unit ] === undefined ) {\n            this.textureAttributeMapList[ unit ] = {};\n        }\n\n        var name = attributePair.getAttribute().getTypeMember();\n        var textureUnitAttributeMap = this.textureAttributeMapList[ unit ];\n\n        textureUnitAttributeMap[ name ] = attributePair;\n\n    },\n\n    // for internal use, you should not call it directly\n    _setAttribute: function ( attributePair ) {\n\n        var name = attributePair.getAttribute().getTypeMember();\n        this.attributeMap[ name ] = attributePair;\n\n    }\n\n} ), 'osg', 'StateSet' );\n\nmodule.exports = StateSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/StateSet.js\n// module id = 29\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\n\n\nvar StateAttribute = function () {\n    Object.call( this );\n};\n\nStateAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    getType: function () {\n        return this.attributeType;\n    },\n\n    // basically, if you want two StateAttribute with the same attributeType in a stateSet/State\n    // their typeMember should be different\n    getTypeMember: function () {\n        return this.attributeType;\n    },\n\n    apply: function () {},\n\n    // getHash is used by the compiler to know if a change in a StateAttribute\n    // must trigger a shader build\n    // If you create your own attribute you will have to customize this function\n    // a good rule is to that if you change uniform it should not rebuild a shader\n    // but if you change a type or representation of your StateAttribute, then it should\n    // if it impact the rendering.\n    // check other attributes for examples\n    getHash: function () {\n        return this.getTypeMember();\n    }\n\n} ), 'osg', 'StateAttribute' );\n\nStateAttribute.OFF = 0;\nStateAttribute.ON = 1;\nStateAttribute.OVERRIDE = 2;\nStateAttribute.PROTECTED = 4;\nStateAttribute.INHERIT = 8;\n\nmodule.exports = StateAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/StateAttribute.js\n// module id = 30\n// module chunks = 0 1 2","'use strict';\n\nvar NodeVisitor = function ( traversalMode ) {\n    /*jshint bitwise: false */\n    this.traversalMask = ~0x0;\n    /*jshint bitwise: true */\n    this.nodeMaskOverride = 0;\n    this.traversalMode = traversalMode;\n    if ( traversalMode === undefined ) {\n        this.traversalMode = NodeVisitor.TRAVERSE_ALL_CHILDREN;\n    }\n    this.nodePath = [];\n    this.visitorType = NodeVisitor.NODE_VISITOR;\n    this._databaseRequestHandler = undefined;\n    this._frameStamp = undefined;\n\n    this.traverse = NodeVisitor._traversalFunctions[ this.traversalMode ];\n    this.pushOntoNodePath = NodeVisitor._pushOntoNodePath[ this.traversalMode ];\n    this.popFromNodePath = NodeVisitor._popFromNodePath[ this.traversalMode ];\n};\n\n//NodeVisitor.TRAVERSE_NONE = 0;\nNodeVisitor.TRAVERSE_PARENTS = 1;\nNodeVisitor.TRAVERSE_ALL_CHILDREN = 2;\nNodeVisitor.TRAVERSE_ACTIVE_CHILDREN = 3;\n\nNodeVisitor.NODE_VISITOR = 0;\nNodeVisitor.UPDATE_VISITOR = 1;\nNodeVisitor.CULL_VISITOR = 2;\n\n// =================== Traversal functions ===============\nvar traverseParents = function traverseParents( node ) {\n    node.ascend( this );\n};\n\nvar traverseChildren = function traverseAllChildren( node ) {\n    node.traverse( this );\n};\n\n// must be sync with TRAVERSE_ENUMS\nNodeVisitor._traversalFunctions = [\n    undefined,\n    traverseParents,\n    traverseChildren,\n    traverseChildren\n];\n\n// =================== PushOntoNodePath functions ===============\nvar pushOntoNodePathParents = function ( node ) {\n    this.nodePath.unshift( node );\n};\n\nvar pushOntoNodePathChildren = function ( node ) {\n    this.nodePath.push( node );\n};\n\nNodeVisitor._pushOntoNodePath = [\n    undefined,\n    pushOntoNodePathParents,\n    pushOntoNodePathChildren,\n    pushOntoNodePathChildren\n];\n\n// =================== PopOntoNodePath functions ===============\nvar popFromNodePathParents = function () {\n    return this.nodePath.shift();\n};\n\nvar popFromNodePathChildren = function () {\n    this.nodePath.pop();\n};\n\nNodeVisitor._popFromNodePath = [\n    undefined,\n    popFromNodePathParents,\n    popFromNodePathChildren,\n    popFromNodePathChildren\n];\n\n\nNodeVisitor.prototype = {\n\n    reset: function () {\n        // to be used when you want to re-use a nv\n        this.nodePath.length = 0;\n    },\n\n    setFrameStamp: function ( frameStamp ) {\n        this._frameStamp = frameStamp;\n    },\n\n    getFrameStamp: function () {\n        return this._frameStamp;\n    },\n\n\n    setNodeMaskOverride: function ( m ) {\n        this.nodeMaskOverride = m;\n    },\n    getNodeMaskOverride: function () {\n        return this.nodeMaskOverride;\n    },\n\n    setTraversalMask: function ( m ) {\n        this.traversalMask = m;\n    },\n    getTraversalMask: function () {\n        return this.traversalMask;\n    },\n\n    getNodePath: function () {\n        return this.nodePath;\n    },\n\n    pushOntoNodePath: function ( node ) {\n        NodeVisitor._pushOntoNodePath[ this.traversalMode ].call( this, node );\n    },\n    popFromNodePath: function () {\n        NodeVisitor._popFromNodePath[ this.traversalMode ].call( this );\n    },\n    validNodeMask: function ( node ) {\n        var nm = node.getNodeMask();\n        /*jshint bitwise: false */\n        return ( ( this.traversalMask & ( this.nodeMaskOverride | nm ) ) !== 0 );\n        /*jshint bitwise: true */\n    },\n    apply: function ( node ) {\n        this.traverse( node );\n    },\n    traverse: function ( node ) {\n        NodeVisitor._traversalFunctions[ this.traversalMode ].call( this, node );\n    },\n    getVisitorType: function () {\n        return this.visitorType;\n    },\n    setDatabaseRequestHandler: function ( dbpager ) {\n        this._databaseRequestHandler = dbpager;\n    },\n    getDatabaseRequestHandler: function () {\n        return this._databaseRequestHandler;\n    }\n};\n\nmodule.exports = NodeVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/NodeVisitor.js\n// module id = 31\n// module chunks = 0 1 2","'use strict';\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\n\n/**\n *  Prevents Memory fragmentation, GC heavy usage\n *    using pre-allocated memory segment\n *    allowing reuse of memory\n *  @class MatrixMemoryPool\n */\nvar MatrixMemoryPool = function () {\n\n    this._stack = [ mat4.create() ];\n    this._current = 0;\n\n};\n\n\n/** @lends MatrixMemoryPool.prototype */\nMatrixMemoryPool.prototype = {\n\n    // start reuse the stack\n    reset: function () {\n\n        this._current = 0;\n\n    },\n\n    get: function () {\n\n        var m = this._stack[ this._current++ ];\n\n        if ( this._current === this._stack.length ) {\n\n            this._stack.push( mat4.create() );\n\n        }\n\n        return m;\n\n    }\n\n};\n\nmodule.exports = MatrixMemoryPool;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/MatrixMemoryPool.js\n// module id = 32\n// module chunks = 0 1 2","'use strict';\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar TransformEnums = require( 'osg/transformEnums' );\n\n\nvar computeLocalToWorld = function ( nodePath, ignoreCameras, userMatrix ) {\n\n    var ignoreCamera = ignoreCameras;\n\n    if ( ignoreCamera === undefined ) ignoreCamera = true;\n\n    var matrix = userMatrix || mat4.create();\n\n    var j = 0;\n\n    if ( ignoreCamera ) {\n\n        for ( j = nodePath.length - 1; j >= 0; j-- ) {\n\n            var camera = nodePath[ j ];\n\n            if ( camera.className() === 'Camera' &&\n                ( camera.getReferenceFrame() !== TransformEnums.RELATIVE_RF || camera.getParents().length === 0 ) ) {\n                break;\n            }\n\n        }\n\n        // because when we break it's to an index - 1\n        // it works because if nothing camera found j == -1 at the end of the loop\n        // and if we found a camera we want to start at the camera index + 1\n        j += 1;\n\n    }\n\n    for ( var i = j, l = nodePath.length; i < l; i++ ) {\n\n        var node = nodePath[ i ];\n\n        if ( node.computeLocalToWorldMatrix ) {\n            node.computeLocalToWorldMatrix( matrix );\n        }\n\n    }\n\n    return matrix;\n\n};\n\nmodule.exports = {\n    computeLocalToWorld: computeLocalToWorld\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/computeMatrixFromNodePath.js\n// module id = 33\n// module chunks = 0 1 2","'use strict';\nmodule.exports = {\n    RELATIVE_RF: 0,\n    ABSOLUTE_RF: 1\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/transformEnums.js\n// module id = 34\n// module chunks = 0 1 2","'use strict';\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar Geometry = require( 'osg/Geometry' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar Transform = require( 'osg/Transform' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n\nvar ComputeBoundsVisitor = function ( traversalMode ) {\n    NodeVisitor.call( this, traversalMode );\n\n    // keep a matrix in memory to avoid to create matrix\n    this._reservedMatrixStack = new MatrixMemoryPool();\n\n    // Matrix stack along path traversal\n    this._matrixStack = [];\n    this._bb = new BoundingBox();\n};\n\nComputeBoundsVisitor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    reset: function () {\n        this._reservedMatrixStack.reset();\n        this._matrixStack.length = 0;\n        this._bb.init();\n    },\n\n    getBoundingBox: function () {\n        return this._bb;\n    },\n\n    // not implemented\n    //void getPolytope(osg::Polytope& polytope, float margin=0.1) const;\n    //void getBase(osg::Polytope& polytope, float margin=0.1) const;\n\n    //applyDrawable: function ( drawable ) {},\n\n    applyTransform: function ( transform ) {\n\n        var matrix = this._reservedMatrixStack.get();\n        var stackLength = this._matrixStack.length;\n\n        if ( stackLength )\n            mat4.copy( matrix, this._matrixStack[ stackLength - 1 ] );\n        else\n            mat4.identity( matrix );\n\n        transform.computeLocalToWorldMatrix( matrix, this );\n\n        this.pushMatrix( matrix );\n\n        this.traverse( transform );\n\n        this.popMatrix();\n    },\n\n    apply: function ( node ) {\n\n        if ( node instanceof Transform ) {\n            this.applyTransform( node );\n            return;\n\n        } else if ( node instanceof Geometry ) {\n            this.applyBoundingBox( node.getBoundingBox() );\n            return;\n        }\n\n        this.traverse( node );\n\n    },\n\n    pushMatrix: function ( matrix ) {\n        this._matrixStack.push( matrix );\n    },\n\n    popMatrix: function () {\n        this._matrixStack.pop();\n    },\n\n\n    applyBoundingBox: ( function () {\n        var bbOut = new BoundingBox();\n\n        return function ( bbox ) {\n\n            var stackLength = this._matrixStack.length;\n\n            if ( !stackLength )\n                this._bb.expandByBoundingBox( bbox );\n            else if ( bbox.valid() ) {\n                var matrix = this._matrixStack[ stackLength - 1 ];\n                //Matrix.transformBoundingBox( matrix, bbox, bbOut );\n                bbox.transformMat4( bbOut, matrix );\n                this._bb.expandByBoundingBox( bbOut );\n            }\n\n        };\n    } )(),\n\n    getMatrixStack: function () {\n        return this._matrixStack;\n    }\n\n\n} ), 'osg', 'ComputeBoundsVisitor' );\n\nmodule.exports = ComputeBoundsVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/ComputeBoundsVisitor.js\n// module id = 35\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar BufferArrayProxy = require( 'osg/BufferArrayProxy' );\n\n/**\n * Geometry manage array and primitives to draw a geometry.\n * @class Geometry\n */\n\nvar Geometry = function () {\n\n    Node.call( this );\n\n    this._attributes = {};\n    this._primitives = [];\n\n    // function is generated for each Shader Program ID\n    // which generates a a special \"draw\"\n    // TODO: could be upon hash of combination of attributes\n    // (as multiple shader Programs can use same combination of attributes)\n    this._cacheDrawCall = {};\n\n    // VAO cached data, per combination of vertex buffer\n    // program id also the cache key\n    this._useVAO = undefined;\n    this._vao = {};\n    this._cacheVertexAttributeBufferList = {};\n\n    // null means the kdTree builder will skip the kdTree creation\n    this._shape = undefined;\n\n};\n\nGeometry.enableVAO = true;\n\n/** @lends Geometry.prototype */\nGeometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {\n\n    releaseGLObjects: function () {\n\n        if ( this.stateset !== undefined ) this.stateset.releaseGLObjects();\n\n        for ( var keyAttribute in this._attributes ) {\n            var value = this._attributes[ keyAttribute ];\n            value.releaseGLObjects();\n        }\n\n        for ( var i = 0, h = this._primitives.length; i < h; i++ ) {\n            var prim = this._primitives[ i ];\n            if ( prim.getIndices !== undefined ) {\n                if ( prim.getIndices() !== undefined && prim.getIndices() !== null ) {\n                    prim.indices.releaseGLObjects();\n                }\n            }\n        }\n\n        this.releaseVAO();\n\n    },\n\n    releaseVAO: function () {\n\n        if ( !this._useVAO || !this._glContext ) return;\n\n        for ( var prgID in this._vao ) {\n            if ( this._vao[ prgID ] ) {\n                this._glContext.deleteVertexArray( this._vao[ prgID ] );\n                this._vao[ prgID ] = undefined;\n            }\n        }\n    },\n\n    dirty: function () {\n        this._cacheDrawCall = {};\n        this.releaseVAO();\n    },\n\n    getPrimitives: function () {\n        // Notify.warn( 'deprecated use instead getPrimitiveSetList' );\n        return this.getPrimitiveSetList();\n    },\n\n    getAttributes: function () {\n        // Notify.warn( 'deprecated use instead getVertexAttributeList' );\n        return this.getVertexAttributeList();\n    },\n\n    getShape: function () {\n        return this._shape;\n    },\n\n    setShape: function ( shape ) {\n        this._shape = shape;\n    },\n\n    getVertexAttributeList: function () {\n        return this._attributes;\n    },\n\n    /**\n     * Return the primitiveset list\n     * If you modify something inside this array\n     * you must call dirty() on the Geometry\n     */\n    getPrimitiveSetList: function () {\n        return this._primitives;\n    },\n\n    /**\n     * Set the buffer array on the attribute name key\n     * key is often something like Vertex, Normal, Color, ...\n     * for classic geometry\n     *\n     * if you change a buffer a dirty will be automatically\n     * called to rebuild the VAO if needed.\n     */\n    setVertexAttribArray: function ( key, array ) {\n        if ( this._attributes[ key ] !== array ) {\n            this._attributes[ key ] = array;\n            this.dirty();\n        }\n    },\n\n    _generateVertexSetup: function ( validAttributeKeyList, validAttributeIndexList, includeFirstIndexBuffer ) {\n\n        // generate setup for vertex attribute\n        // will be used as setup for vao or as is without vao\n        var vertexAttributeSetup = [ '//generated by Geometry::implementation',\n            'state.lazyDisablingOfVertexAttributes();',\n            'var attr;'\n        ];\n\n        for ( var i = 0, l = validAttributeKeyList.length; i < l; i++ ) {\n\n            vertexAttributeSetup.push( 'attr = this._attributes[\\'' + validAttributeKeyList[ i ] + '\\'];' );\n            vertexAttributeSetup.push( 'if ( attr.BufferArrayProxy ) attr = attr.getBufferArray();' );\n            vertexAttributeSetup.push( 'if ( !attr.isValid() ) return;' );\n            vertexAttributeSetup.push( 'state.setVertexAttribArray(' + validAttributeIndexList[ i ] + ', attr, attr.getNormalize() );' );\n\n        }\n\n        vertexAttributeSetup.push( 'state.applyDisablingOfVertexAttributes();' );\n\n        if ( includeFirstIndexBuffer )\n            vertexAttributeSetup.push( 'state.setIndexArray( this._primitives[ 0 ].getIndices() );' );\n\n        return vertexAttributeSetup;\n    },\n\n    _generatePrimitive: function ( primitives, hasVertexColor, optimizeVAO ) {\n\n        var primitiveSetup = [\n            hasVertexColor ? 'state.enableVertexColor();' : 'state.disableVertexColor();'\n        ];\n\n        if ( optimizeVAO ) {\n            return primitiveSetup.concat( [\n                'var primitive = this._primitives[ 0 ];',\n                'var indexes = primitive.getIndices();',\n                'if ( indexes.isDirty() ) {;',\n                '  indexes.bind( gl );',\n                '  indexes.compile( gl );',\n                '};',\n                'primitive.drawElements( state );'\n            ] );\n        }\n\n\n        primitiveSetup.push( 'var primitives = this._primitives;' );\n        for ( var j = 0, m = primitives.length; j < m; j++ )\n            primitiveSetup.push( 'primitives[' + j + '].draw(state);' );\n\n        return primitiveSetup;\n    },\n\n    /**\n     *  Generate a function specific to the Geometry/Program\n     *  two version one using VAO and a regular one\n     */\n    generateDrawCommand: ( function () {\n\n        var validAttributeList = [];\n        var validAttributeKeyList = [];\n\n        return function ( state, program, prgID ) {\n\n            var attributesCacheMap = program._attributesCache;\n            var geometryVertexAttributes = this.getVertexAttributeList();\n\n            validAttributeKeyList.length = 0;\n            validAttributeList.length = 0;\n\n            // 1 - register valid vertex attributes and color flag\n\n            var attribute, j, m, attr;\n\n            var useVAO = this._useVAO;\n            var listVABuff = useVAO ? [] : undefined;\n\n            var hasVertexColor = false;\n\n            for ( var key in attributesCacheMap ) {\n                attribute = attributesCacheMap[ key ];\n                attr = geometryVertexAttributes[ key ];\n\n                if ( attr === undefined ) continue;\n\n                var attributeBuffer = this._attributes[ key ];\n\n                // dont use VAO if we have BufferArrayProxy\n                // typically used for morphing\n                if ( attributeBuffer instanceof BufferArrayProxy ) {\n                    attributeBuffer = attributeBuffer.getBufferArray();\n                    useVAO = false;\n                }\n\n                if ( !attributeBuffer.isValid() ) return undefined;\n\n                // store for later usage at draw time/update\n                if ( useVAO ) listVABuff.push( attributeBuffer );\n\n                if ( !hasVertexColor && key === 'Color' )\n                    hasVertexColor = true;\n\n                validAttributeKeyList.push( key );\n                validAttributeList.push( attribute );\n            }\n\n\n            var autogeneratedFunction;\n            var functionName;\n\n            // generate specific function using VAO or standard\n            if ( useVAO ) {\n\n                this._cacheVertexAttributeBufferList[ prgID ] = listVABuff;\n\n                // if there is only one drawElement we can put the index buffer\n                // in the vao\n                var optimizeIndexBufferVAO = ( this._primitives.length === 1 && this._primitives[ 0 ] instanceof DrawElements );\n\n                var vertexAttributeSetup = this._generateVertexSetup( validAttributeKeyList, validAttributeList, optimizeIndexBufferVAO );\n\n                state.clearVertexAttribCache();\n\n                var gl = state.getGraphicContext();\n                var vao = gl.createVertexArray();\n                state.setVertexArrayObject( vao );\n                this._vao[ prgID ] = vao;\n\n                // evaluate the vertexAttribute setup to register into the vao\n                /*jshint evil: true */\n                var vertexSetupCommand = new Function( 'state', vertexAttributeSetup.join( '\\n' ) );\n                /*jshint evil: false */\n                vertexSetupCommand.call( this, state );\n\n                // setup the program\n                var vaoSetup = [\n                    'var gl = state.getGraphicContext();',\n                    'var vao = this._vao[ ' + prgID + ' ] ',\n                    'var hasChanged = state.setVertexArrayObject( vao );',\n                    'if ( hasChanged ) {',\n                    '  var vaList = this._cacheVertexAttributeBufferList[ ' + prgID + ' ];',\n                    '  var va;'\n                ];\n                for ( j = 0, m = listVABuff.length; j < m; j++ ) {\n                    vaoSetup.push( '  va = vaList[ ' + j + '];' );\n                    vaoSetup.push( '  if ( va.isDirty() ) {;' );\n                    vaoSetup.push( '    va.bind( gl );' );\n                    vaoSetup.push( '    va.compile( gl );' );\n                    vaoSetup.push( '  };' );\n                }\n                vaoSetup.push( '}' );\n\n                autogeneratedFunction = vaoSetup.concat( this._generatePrimitive( this._primitives, hasVertexColor, optimizeIndexBufferVAO ) ).join( '\\n' );\n                functionName = 'GeometryDrawImplementationCacheVAO';\n\n            } else {\n\n                autogeneratedFunction = this._generateVertexSetup( validAttributeKeyList, validAttributeList, false ).concat( this._generatePrimitive( this._primitives, hasVertexColor, false ) ).join( '\\n' );\n                functionName = 'GeometryDrawImplementationCache';\n\n            }\n\n            /*jshint evil: true */\n            // name the function\n            // http://stackoverflow.com/questions/5905492/dynamic-function-name-in-javascript\n            var drawCommand = ( new Function( 'state', 'return function ' + functionName + '( state ) { ' + autogeneratedFunction + '}' ) )();\n            /*jshint evil: false */\n\n            this._cacheDrawCall[ prgID ] = drawCommand;\n            return drawCommand;\n        };\n\n    } )(),\n\n    drawImplementation: function ( state ) {\n\n        var program = state.getLastProgramApplied();\n        var prgID = program.getInstanceID();\n\n        var cachedDraw = this._cacheDrawCall[ prgID ];\n\n        if ( this._useVAO && !this._vao[ prgID ] ) state.setVertexArrayObject( null );\n\n        if ( cachedDraw ) {\n            cachedDraw.call( this, state );\n            return;\n        }\n\n        // generate cachedDraw\n\n        if ( !this._primitives.length ) return;\n\n        if ( this._useVAO === undefined && Geometry.enableVAO ) { // will be null if not supported\n            this._useVAO = WebGLCaps.instance().hasVAO();\n            this._glContext = state.getGraphicContext();\n        }\n\n        cachedDraw = this.generateDrawCommand( state, program, prgID );\n        cachedDraw.call( this, state );\n        state.setVertexArrayObject( null );\n\n    },\n\n    setBound: function ( bb ) {\n        this._boundingBox = bb;\n        this._boundingBoxComputed = true;\n    },\n\n    computeBoundingBox: function ( boundingBox ) {\n\n        boundingBox.init();\n\n        var vertexArray = this.getVertexAttributeList().Vertex;\n        if ( vertexArray && vertexArray.getElements() && vertexArray.getItemSize() > 2 ) {\n            var vertexes = vertexArray.getElements();\n            var itemSize = vertexArray.getItemSize();\n\n            var min = boundingBox.getMin();\n            var max = boundingBox.getMax();\n\n            var minx = min[ 0 ];\n            var miny = min[ 1 ];\n            var minz = min[ 2 ];\n            var maxx = max[ 0 ];\n            var maxy = max[ 1 ];\n            var maxz = max[ 2 ];\n\n            // if the box is un-initialized min=Inf and max=-Inf\n            // we can't simply write if(x > min) [...] else (x < max) [...]\n            // most of the time the else condition is run so it's a kinda useless\n            // optimization anyway\n            for ( var idx = 0, l = vertexes.length; idx < l; idx += itemSize ) {\n                var v1 = vertexes[ idx ];\n                var v2 = vertexes[ idx + 1 ];\n                var v3 = vertexes[ idx + 2 ];\n                if ( v1 < minx ) minx = v1;\n                if ( v1 > maxx ) maxx = v1;\n                if ( v2 < miny ) miny = v2;\n                if ( v2 > maxy ) maxy = v2;\n                if ( v3 < minz ) minz = v3;\n                if ( v3 > maxz ) maxz = v3;\n            }\n\n            min[ 0 ] = minx;\n            min[ 1 ] = miny;\n            min[ 2 ] = minz;\n            max[ 0 ] = maxx;\n            max[ 1 ] = maxy;\n            max[ 2 ] = maxz;\n        }\n\n        return boundingBox;\n    },\n\n    computeBoundingSphere: function ( boundingSphere ) {\n        boundingSphere.init();\n        var bb = this.getBoundingBox();\n        boundingSphere.expandByBoundingBox( bb );\n        return boundingSphere;\n    }\n\n\n} ), 'osg', 'Geometry' );\n\nGeometry.appendVertexAttributeToList = function ( from, to, postfix ) {\n\n    for ( var key in from ) {\n        var keyPostFix = key;\n        if ( postfix !== undefined )\n            keyPostFix += '_' + postfix;\n\n        to[ keyPostFix ] = from[ key ];\n    }\n\n};\n\n\nMACROUTILS.setTypeID( Geometry );\n\nmodule.exports = Geometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Geometry.js\n// module id = 36\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar WebGLUtils = require( 'osgViewer/webgl-utils' );\nvar Options = require( 'osg/Options' );\nvar Texture;\n\nvar WebGLCaps = function () {\n\n    // circular deps with texture\n    if ( !Texture ) Texture = require( 'osg/Texture' );\n\n    this._checkRTT = {};\n    this._webGLExtensions = {};\n    this._webGLParameters = {};\n    this._webGLShaderMaxInt = 'NONE';\n    this._webGLShaderMaxFloat = 'NONE';\n\n    this._bugsDB = {};\n    this._webGLPlatforms = {};\n\n    // webgl minimum requirements as per webgl specs\n    // useful for nodejs env\n    this._webGLParameters[ 'MAX_COMBINED_TEXTURE_IMAGE_UNITS' ] = 8;\n    this._webGLParameters[ 'MAX_CUBE_MAP_TEXTURE_SIZE' ] = 16;\n    this._webGLParameters[ 'MAX_FRAGMENT_UNIFORM_VECTORS' ] = 16;\n    this._webGLParameters[ 'MAX_RENDERBUFFER_SIZE' ] = 1;\n    this._webGLParameters[ 'MAX_TEXTURE_IMAGE_UNITS' ] = 8;\n    this._webGLParameters[ 'MAX_TEXTURE_SIZE' ] = 64;\n    this._webGLParameters[ 'MAX_VARYING_VECTORS' ] = 8;\n    this._webGLParameters[ 'MAX_VERTEX_ATTRIBS' ] = 8;\n    this._webGLParameters[ 'MAX_VERTEX_TEXTURE_IMAGE_UNITS' ] = 0;\n    this._webGLParameters[ 'MAX_VERTEX_UNIFORM_VECTORS' ] = 128;\n    this._webGLParameters[ 'MAX_VIEWPORT_DIMS' ] = [ 1, 1 ];\n    this._webGLParameters[ 'NUM_COMPRESSED_TEXTURE_FORMATS' ] = 0;\n    this._webGLParameters[ 'MAX_SHADER_PRECISION_FLOAT' ] = 'none';\n    this._webGLParameters[ 'MAX_SHADER_PRECISION_INT' ] = 'none';\n\n    // for multiple context\n    // allow checking we're on the good one\n    this._gl = undefined;\n\n};\n\nWebGLCaps.instance = function ( glParam ) {\n\n\n    if ( !WebGLCaps._instance ) {\n\n        var oldWebGLInspector;\n        var gl = glParam;\n\n        if ( !gl ) {\n\n            // make sure we don't break webglinspector\n            // with our webglcaps canvas\n            var webglInspector = typeof window !== 'undefined' && window.gli;\n\n            if ( webglInspector ) {\n\n                oldWebGLInspector = window.gli.host.inspectContext;\n                window.gli.host.inspectContext = false;\n\n            }\n\n            var c = document.createElement( 'canvas' );\n            c.width = 32;\n            c.height = 32;\n\n            var options = new Options();\n            // not necessary, but for some reasons it crashed on chromium vr build\n            options.extend( {\n                antialias: false\n            } );\n            // in case of webgl2\n            options.extendWithOptionsURL();\n\n            gl = WebGLUtils.setupWebGL( c, options, function () {} );\n\n        }\n\n        WebGLCaps._instance = new WebGLCaps();\n        if ( gl ) {\n\n            WebGLCaps._instance.init( gl );\n\n        } else {\n\n            // gracefully handle non webgl\n            // like nodejs, phantomjs\n            // warns but no error so that nodejs/phantomjs\n            // can still has some webglcaps object\n            Notify.warn( 'no support for webgl context detected.' );\n\n        }\n\n        if ( oldWebGLInspector ) {\n\n            window.gli.host.inspectContext = oldWebGLInspector;\n\n        }\n\n        //delete c;\n    }\n\n    if ( glParam && glParam !== WebGLCaps._instance.getContext() ) {\n\n        // webgl caps called with a different context\n        // than the one we draw in, will result on hard crash\n        // when using extension from another context\n        WebGLCaps._instance.initContextDependant( glParam );\n\n    }\n\n    return WebGLCaps._instance;\n};\n\nWebGLCaps.prototype = {\n\n    getContext: function () {\n        return this._gl;\n    },\n\n    initContextDependant: function ( gl ) {\n\n        // store context in case of multiple context\n        this._gl = gl;\n        // We need to check if this is a webGL2 context to get the extensions work.\n        this._isGL2 = typeof window.WebGL2RenderingContext !== 'undefined' && gl instanceof window.WebGL2RenderingContext;\n        // Takes care of circular dependencies on Texture\n        // Texture should be resolved at this point\n        // Texture = require( 'osg/Texture' );\n\n        // get extensions\n        this.initWebGLExtensions( gl );\n\n        // get float support\n        this.hasLinearHalfFloatRTT( gl );\n        this.hasLinearFloatRTT( gl );\n        this.hasHalfFloatRTT( gl );\n        this.hasFloatRTT( gl );\n\n    },\n\n    init: function ( gl ) {\n\n        // get capabilites\n        this.initWebGLParameters( gl );\n\n        // order is important\n        // to allow webgl extensions filtering\n        this.initPlatformSupport();\n        this.initBugDB();\n\n        this.initContextDependant( gl );\n\n        if ( this._isGL2 ) {\n\n            var nativeExtension = [\n                'OES_element_index_uint',\n                'EXT_sRGB',\n                'EXT_blend_minmax',\n                'EXT_frag_depth',\n                'WEBGL_depth_texture',\n                'EXT_shader_texture_lod',\n                'OES_standard_derivatives',\n                'OES_texture_float',\n                'OES_texture_half_float',\n                'OES_texture_half_float_linear',\n                'OES_texture_float_linear',\n                'OES_vertex_array_object',\n                'WEBGL_draw_buffers',\n                'OES_fbo_render_mipmap',\n                'ANGLE_instanced_arrays'\n            ];\n\n            var ext = WebGLCaps._instance.getWebGLExtensions();\n            var dummyFunc = function () {};\n            for ( var i = 0, l = nativeExtension.length; i < l; i++ ) {\n                ext[ nativeExtension[ i ] ] = dummyFunc;\n            }\n        }\n\n    },\n\n    isWebGL2: function () {\n        return this._isGL2;\n    },\n\n    // inevitable bugs per platform (browser/OS/GPU)\n    initBugDB: function () {\n\n        var p = this._webGLPlatforms;\n        var ext = this._webGLParameters;\n\n        // derivatives gives strange results on Shadow Shaders\n        if ( p.Apple ) {\n\n            if ( !ext.UNMASKED_VENDOR_WEBGL || ext.UNMASKED_VENDOR_WEBGL.indexOf( 'Intel' ) !== -1 ) {\n\n                // bug is on INTEL GPU on APPLE\n                // we disable the ext on Apple if we cannot get GPU info\n                this._bugsDB[ 'OES_standard_derivatives' ] = true;\n\n            }\n\n        }\n    },\n\n    initPlatformSupport: function () {\n\n        var p = this._webGLPlatforms;\n\n        p.Apple = navigator.vendor.indexOf( 'Apple' ) !== -1 || navigator.vendor.indexOf( 'OS X' ) !== -1;\n\n        // degrades complexity on handhelds.\n        p.Mobile = /Mobi/.test( navigator.userAgent ) || /ablet/.test( navigator.userAgent );\n\n    },\n\n    getWebGLPlatform: function ( str ) {\n        return this._webGLPlatforms[ str ];\n    },\n\n    getWebGLPlatforms: function () {\n        return this._webGLPlatforms;\n    },\n\n    getWebGLParameter: function ( str ) {\n        return this._webGLParameters[ str ];\n    },\n\n    getWebGLParameters: function () {\n        return this._webGLParameters;\n    },\n\n    getShaderMaxPrecisionFloat: function () {\n        return this._webGLParameters.MAX_SHADER_PRECISION_FLOAT;\n    },\n\n    getShaderMaxPrecisionInt: function () {\n        return this._webGLParameters.MAX_SHADER_PRECISION_INT;\n    },\n\n    checkSupportRTT: function ( gl, typeFloat, typeTexture ) {\n\n        var key = typeFloat + ',' + typeTexture;\n\n        if ( this._isGL2 ) {\n            return !!this._webGLExtensions[ 'EXT_color_buffer_float' ];\n        }\n\n        // check once only\n        if ( this._checkRTT[ key ] !== undefined )\n            return this._checkRTT[ key ];\n\n        // no cached results, need gl context\n        if ( !gl ) return false;\n\n        // from http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#how-can-i-detect-if-i-can-render-to-floating-point-textures\n\n        // setup the texture\n        var texture = gl.createTexture();\n        gl.bindTexture( gl.TEXTURE_2D, texture );\n        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, typeFloat, null );\n        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, typeTexture );\n        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, typeTexture );\n\n        // setup the framebuffer\n        var framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n        gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0 );\n\n        // check the framebuffer\n        var status = this._checkRTT[ key ] = gl.checkFramebufferStatus( gl.FRAMEBUFFER ) === gl.FRAMEBUFFER_COMPLETE;\n\n        // cleanup\n        gl.deleteTexture( texture );\n        gl.deleteFramebuffer( framebuffer );\n        gl.bindTexture( gl.TEXTURE_2D, null );\n        gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\n        return status;\n    },\n\n    hasLinearHalfFloatRTT: function ( gl ) {\n        return this._webGLExtensions[ 'OES_texture_half_float_linear' ] && this.checkSupportRTT( gl, Texture.HALF_FLOAT_OES, Texture.LINEAR );\n    },\n\n    hasLinearFloatRTT: function ( gl ) {\n        return this._webGLExtensions[ 'OES_texture_float_linear' ] && this.checkSupportRTT( gl, Texture.FLOAT, Texture.LINEAR );\n    },\n\n    hasHalfFloatRTT: function ( gl ) {\n        return this._webGLExtensions[ 'OES_texture_half_float' ] && this.checkSupportRTT( gl, Texture.HALF_FLOAT_OES, Texture.NEAREST );\n    },\n\n    hasFloatRTT: function ( gl ) {\n        return this._webGLExtensions[ 'OES_texture_float' ] && this.checkSupportRTT( gl, Texture.FLOAT, Texture.NEAREST );\n    },\n\n    queryPrecision: function ( gl, shaderType, precision ) {\n        var answer = gl.getShaderPrecisionFormat( shaderType, precision );\n        if ( !answer ) return false;\n        return answer.precision !== 0;\n    },\n\n    hasVAO: function () {\n        return !!this._webGLExtensions[ 'OES_vertex_array_object' ];\n    },\n\n    getDisjointTimerQuery: function () {\n        return this._webGLExtensions[ 'EXT_disjoint_timer_query_webgl2' ] || this._webGLExtensions[ 'EXT_disjoint_timer_query' ];\n    },\n\n    initWebGLParameters: function ( gl ) {\n        if ( !gl ) return;\n        var limits = [\n            'MAX_COMBINED_TEXTURE_IMAGE_UNITS',\n            'MAX_CUBE_MAP_TEXTURE_SIZE',\n            'MAX_FRAGMENT_UNIFORM_VECTORS',\n            'MAX_RENDERBUFFER_SIZE',\n            'MAX_TEXTURE_IMAGE_UNITS',\n            'MAX_TEXTURE_SIZE',\n            'MAX_VARYING_VECTORS',\n            'MAX_VERTEX_ATTRIBS',\n            'MAX_VERTEX_TEXTURE_IMAGE_UNITS',\n            'MAX_VERTEX_UNIFORM_VECTORS',\n            'MAX_VIEWPORT_DIMS',\n            'SHADING_LANGUAGE_VERSION',\n            'VERSION',\n            'VENDOR',\n            'RENDERER',\n            'ALIASED_LINE_WIDTH_RANGE',\n            'ALIASED_POINT_SIZE_RANGE',\n            'RED_BITS',\n            'GREEN_BITS',\n            'BLUE_BITS',\n            'ALPHA_BITS',\n            'DEPTH_BITS',\n            'STENCIL_BITS'\n        ];\n        var params = this._webGLParameters;\n        for ( var i = 0, len = limits.length; i < len; ++i ) {\n            var par = limits[ i ];\n            params[ par ] = gl.getParameter( gl[ par ] );\n        }\n\n        //shader precisions for float\n        if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ) ) {\n            params.MAX_SHADER_PRECISION_FLOAT = 'high';\n        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ) ) {\n            params.MAX_SHADER_PRECISION_FLOAT = 'medium';\n        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.LOW_FLOAT ) ) {\n            params.MAX_SHADER_PRECISION_FLOAT = 'low';\n        }\n\n        //shader precisions for float\n        if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.HIGH_INT ) ) {\n            params.MAX_SHADER_PRECISION_INT = 'high';\n        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.MEDIUM_INT ) ) {\n            params.MAX_SHADER_PRECISION_INT = 'medium';\n        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.LOW_INT ) ) {\n            params.MAX_SHADER_PRECISION_INT = 'low';\n        }\n\n        // get GPU, Angle or not, Opengl/directx, etc.\n        //  ffx && chrome only\n        var debugInfo = gl.getExtension( 'WEBGL_debug_renderer_info' );\n        if ( debugInfo ) {\n            params.UNMASKED_RENDERER_WEBGL = gl.getParameter( debugInfo.UNMASKED_VENDOR_WEBGL );\n            params.UNMASKED_VENDOR_WEBGL = gl.getParameter( debugInfo.UNMASKED_RENDERER_WEBGL );\n\n        }\n        // TODO ?\n        // try to compile a small shader to test the spec is respected\n    },\n\n    applyExtension: function ( gl, name ) {\n        // Borrowed from https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html\n        var ext = gl.getExtension( name );\n        var suffix = name.split( '_' )[ 0 ];\n        var prefix = '_' + suffix;\n        var suffixRE = new RegExp( suffix + '$' );\n        var prefixRE = new RegExp( prefix );\n        for ( var key in ext ) {\n            var val = ext[ key ];\n            if ( typeof ( val ) === 'function' ) {\n                // remove suffix (eg: bindVertexArrayOES -> bindVertexArray)\n                var unsuffixedKey = key.replace( suffixRE, '' );\n                if ( key.substring )\n                    gl[ unsuffixedKey ] = ext[ key ].bind( ext );\n            } else {\n                var unprefixedKey = key.replace( prefixRE, '' );\n                if ( gl[ unprefixedKey ] === undefined )\n                    gl[ unprefixedKey ] = ext[ key ];\n            }\n        }\n    },\n\n    getWebGLExtension: function ( str ) {\n        return this._webGLExtensions[ str ];\n    },\n\n    getWebGLExtensions: function () {\n        return this._webGLExtensions;\n    },\n\n    initWebGLExtensions: function ( gl, filterBugs ) {\n\n        // nodejs, phantomjs\n        if ( !gl ) return;\n\n        var doFilter = filterBugs;\n        if ( doFilter === undefined )\n            doFilter = true;\n\n        var supported = gl.getSupportedExtensions();\n        var ext = this._webGLExtensions;\n        // we load all the extensions\n        for ( var i = 0, len = supported.length; i < len; ++i ) {\n            var sup = supported[ i ];\n\n            if ( doFilter && this._bugsDB[ sup ] ) {\n                // bugs on that configuration, do not enable\n                continue;\n            }\n\n            ext[ sup ] = gl.getExtension( sup );\n            if ( !this._isGL2 )\n                this.applyExtension( gl, sup );\n        }\n\n        var anisoExt = this.getWebGLExtension( 'EXT_texture_filter_anisotropic' );\n        if ( anisoExt ) {\n            Texture.ANISOTROPIC_SUPPORT_EXT = true;\n            Texture.ANISOTROPIC_SUPPORT_MAX = gl.getParameter( anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n        }\n\n    }\n};\n\nmodule.exports = WebGLCaps;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/WebGLCaps.js\n// module id = 37\n// module chunks = 0 1 2","// jshint ignore: start\n\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\n\n'use strict';\nvar WebGLUtils = function () {\n\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function ( msg ) {\n        return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n        // return '' +\n        //   '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n        //   '<td align=\"center\">' +\n        //   '<div style=\"display: table-cell; vertical-align: middle;\">' +\n        //   '<div style=\"\">' + msg + '</div>' +\n        //   '</div>' +\n        //   '</td></tr></table>';\n    };\n\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function (\n        /** Element */\n        canvas,\n        /** WebGLContextCreationAttirbutes */\n        opt_attribs,\n        /** function:(msg) */\n        opt_onError ) {\n        function handleCreationError( msg ) {\n            if ( msg.indexOf( 'WebGL2' ) !== -1 ) return;\n            var container = document.getElementsByTagName( \"body\" )[ 0 ];\n            //var container = canvas.parentNode;\n            if ( container ) {\n                var str = window.WebGLRenderingContext ?\n                    OTHER_PROBLEM :\n                    GET_A_WEBGL_BROWSER;\n                if ( msg ) {\n                    str += \"<br/><br/>Status: \" + msg;\n                }\n                container.innerHTML = makeFailHTML( str );\n            }\n        }\n\n        opt_onError = opt_onError || handleCreationError;\n\n        if ( canvas.addEventListener ) {\n            canvas.addEventListener( \"webglcontextcreationerror\", function ( event ) {\n                opt_onError( event.statusMessage );\n            }, false );\n        }\n        var context = create3DContext( canvas, opt_attribs );\n        if ( !context ) {\n            //if ( !window.WebGLRenderingContext )\n            opt_onError( \"\" );\n        }\n\n        return context;\n    };\n\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function ( canvas, opt_attribs ) {\n\n        // only try to enable if URl options ?webgl2=1\n        var names = [];\n        if ( opt_attribs && opt_attribs.webgl2 ) {\n            names = names.concat( [ \"webgl2\", \"experimental-webgl2\" ] );\n        }\n        names = names.concat( [ \"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\" ] );\n\n        var context = null;\n        for ( var ii = 0; ii < names.length; ++ii ) {\n            try {\n                context = canvas.getContext( names[ ii ], opt_attribs );\n            } catch ( e ) {}\n            if ( context ) {\n                break;\n            }\n        }\n        return context;\n    };\n\n    return {\n        create3DContext: create3DContext,\n        setupWebGL: setupWebGL\n    };\n}();\n\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif ( !window.requestAnimationFrame ) {\n    window.requestAnimationFrame = ( function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n\n            function ( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {\n                window.setTimeout( callback, 1000 / 60 );\n            };\n    } )();\n}\n\nif ( !window.cancelRequestAnimFrame ) {\n    window.cancelRequestAnimFrame = ( function () {\n        return window.cancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.mozCancelRequestAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            clearTimeout;\n    } )();\n}\n\nif ( !Date.now ) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\n\nmodule.exports = WebGLUtils;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/webgl-utils.js\n// module id = 38\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\n\nvar OptionsDefault = {\n    'antialias': true, // activate MSAA\n    //'overrideDevicePixelRatio': 1, // if specified override the device pixel ratio\n    'fullscreen': true,\n    'enableFrustumCulling': false,\n    'stats': false, // display canvas with stats for the viewer\n    'scrollwheel': true,\n    'webgl2': false\n};\n\nvar Options = function () {\n    for ( var keyOption in OptionsDefault ) {\n        this[ keyOption ] = OptionsDefault[ keyOption ];\n    }\n};\n\nvar urlOptions;\nOptions.getOptionsURL = function () {\n    if ( urlOptions ) return urlOptions;\n\n    urlOptions = {};\n\n    if ( !window.location.search ) return urlOptions;\n\n    var vars = [];\n    var hash;\n    // slice(1) to remove leading '?'\n    var hashes = window.location.search.slice( 1 ).split( '&' );\n    for ( var i = 0; i < hashes.length; i++ ) {\n        hash = hashes[ i ].split( '=' );\n        var element = hash[ 0 ];\n        vars.push( element );\n        var result = hash[ 1 ];\n\n        // ideally we should have typed option\n        if ( result === '0' || result === 'false' ) continue;\n        if ( result === undefined ) result = '1';\n\n        urlOptions[ element ] = result;\n    }\n\n    if ( urlOptions.log !== undefined ) {\n        var level = urlOptions.log.toLowerCase();\n\n        switch ( level ) {\n        case 'debug':\n            Notify.setNotifyLevel( Notify.DEBUG );\n            break;\n        case 'info':\n            Notify.setNotifyLevel( Notify.INFO );\n            break;\n        case 'notice':\n            Notify.setNotifyLevel( Notify.NOTICE );\n            break;\n        case 'warn':\n            Notify.setNotifyLevel( Notify.WARN );\n            break;\n        case 'error':\n            Notify.setNotifyLevel( Notify.ERROR );\n            break;\n        case 'html':\n            var logContent = [];\n            var divLogger = document.createElement( 'div' );\n            var codeElement = document.createElement( 'pre' );\n            document.addEventListener( 'DOMContentLoaded', function () {\n                document.body.appendChild( divLogger );\n                divLogger.appendChild( codeElement );\n            } );\n            var logFunc = function ( str ) {\n                logContent.unshift( str );\n                codeElement.innerHTML = logContent.join( '\\n' );\n            };\n            divLogger.style.overflow = 'hidden';\n            divLogger.style.position = 'absolute';\n            divLogger.style.zIndex = '10000';\n            divLogger.style.height = '100%';\n            divLogger.style.maxWidth = '600px';\n            codeElement.style.overflow = 'scroll';\n            codeElement.style.width = '105%';\n            codeElement.style.height = '100%';\n            codeElement.style.fontSize = '10px';\n\n            [ 'log', 'error', 'warn', 'info', 'debug' ].forEach( function ( value ) {\n                window.console[ value ] = logFunc;\n            } );\n            break;\n        }\n    }\n\n    return urlOptions;\n\n};\n\nOptions.prototype = {\n\n    extend: function ( options ) {\n        MACROUTILS.objectMix( this, options );\n        return this;\n    },\n\n    get: function ( key ) {\n        return this[ key ];\n    },\n\n    getBoolean: function ( key ) {\n        var val = this.getString( key );\n        if ( val ) return ( val !== 'false' && val !== '0' );\n        return undefined;\n    },\n\n    getNumber: function ( key ) {\n        var val = this[ key ];\n        if ( val ) return Number( val );\n        return undefined;\n    },\n\n    getString: function ( key ) {\n        var val = this[ key ];\n        if ( val !== undefined ) return this[ key ].toString();\n        return undefined;\n    },\n\n    extendWithOptionsURL: function () {\n        this.extend( Options.getOptionsURL() );\n    }\n\n};\n\nmodule.exports = Options;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Options.js\n// module id = 39\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\nvar Image = require( 'osg/Image' );\nvar GLObject = require( 'osg/GLObject' );\n\nvar TextureManager = require( 'osg/TextureManager' );\nvar WebglCaps = require( 'osg/WebGLCaps' );\n\nvar ImageBitmap = window.ImageBitmap || function () {};\n\n// helper\nvar isPowerOf2 = function ( x ) {\n    /*jshint bitwise: false */\n    return ( ( x !== 0 ) && ( ( x & ( ~x + 1 ) ) === x ) );\n    /*jshint bitwise: true */\n};\n\n/**\n * Texture encapsulate webgl texture object\n * @class Texture\n * Not that dirty here is mainly for texture binding\n * any dirty will cause re-bind\n * hint: don't dirty a texture attached to a camera/framebuffer\n * it will end blank\n * @inherits StateAttribute\n */\nvar Texture = function () {\n\n    StateAttribute.call( this );\n    GLObject.call( this );\n    this.setDefaultParameters();\n    this._dirty = true;\n    this._dirtyMipmap = true;\n    this._applyTexImage2DCallbacks = [];\n    this._textureObject = undefined;\n\n    this._textureNull = true;\n};\n\nvar checkAndFixEnum = function ( mode, fallback ) {\n\n    var value = Texture[ mode ];\n\n    if ( value === undefined ) {\n        Notify.warn( 'bad Texture enum argument ' + mode + '\\n' + 'fallback to ' + fallback );\n        return fallback;\n    }\n\n    return value;\n};\n\nTexture.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\nTexture.UNPACK_FLIP_Y_WEBGL = 0x9240;\nTexture.BROWSER_DEFAULT_WEBGL = 0x9244;\nTexture.NONE = 0x0;\n\nTexture.DEPTH_COMPONENT = 0x1902;\nTexture.DEPTH_COMPONENT16 = 0x81A5;\nTexture.DEPTH_STENCIL = 0x84F9;\n// gl2\nTexture.DEPTH24_STENCIL8 = 0x88F0;\nTexture.DEPTH_COMPONENT24 = 0x81A6;\nTexture.DEPTH_COMPONENT32F = 0x8CAC;\n\n// DXT formats, from:\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\nTexture.COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\nTexture.COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\nTexture.COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\nTexture.COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n\n// ATC formats, from:\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\nTexture.COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\nTexture.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\nTexture.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n\n// PVR formats, from:\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nTexture.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\nTexture.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\nTexture.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\nTexture.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n\n// ETC1 format, from:\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\nTexture.COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\n\n// filter mode\nTexture.LINEAR = 0x2601;\nTexture.NEAREST = 0x2600;\nTexture.NEAREST_MIPMAP_NEAREST = 0x2700;\nTexture.LINEAR_MIPMAP_NEAREST = 0x2701;\nTexture.NEAREST_MIPMAP_LINEAR = 0x2702;\nTexture.LINEAR_MIPMAP_LINEAR = 0x2703;\n// filter anisotropy\nTexture.TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\nTexture.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n\n// wrap mode\nTexture.CLAMP_TO_EDGE = 0x812F;\nTexture.REPEAT = 0x2901;\nTexture.MIRRORED_REPEAT = 0x8370;\n\n// target\nTexture.TEXTURE_2D = 0x0DE1;\nTexture.TEXTURE_CUBE_MAP = 0x8513;\nTexture.TEXTURE_BINDING_CUBE_MAP = 0x8514;\nTexture.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nTexture.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nTexture.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nTexture.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nTexture.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nTexture.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;\nTexture.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\n\n// https: //www.khronos.org/registry/webgl/specs/latest/2.0/#3.7.6\n///////////\n// TYPE GL1\n///////////\nTexture.UNSIGNED_BYTE = 0x1401;\nTexture.UNSIGNED_SHORT = 0x1403;\nTexture.UNSIGNED_SHORT_4_4_4_4 = 0x8033;\nTexture.UNSIGNED_SHORT_5_5_5_1 = 0x8034;\nTexture.UNSIGNED_SHORT_5_6_5 = 0x8363;\nTexture.FLOAT = 0x1406;\nTexture.HALF_FLOAT_OES = 0x8D61;\n// TYPE GL2\nTexture.HALF_FLOAT = 0x140B;\nTexture.UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\nTexture.UNSIGNED_INT_24_8 = 0x84FA;\n\n/////////////\n// FORMAT GL1\n/////////////\nTexture.ALPHA = 0x1906;\nTexture.RGB = 0x1907;\nTexture.RGBA = 0x1908;\nTexture.LUMINANCE = 0x1909;\nTexture.LUMINANCE_ALPHA = 0x190A;\n// format gl2\nTexture.RED_INTEGER = 0x8D94;\nTexture.RGB_INTEGER = 0x8D98;\nTexture.RGBA_INTEGER = 0x8D99;\nTexture.RG_INTEGER = 0x8228;\nTexture.RED = 0x1903;\n\n//////////////////////\n// INTERNAL FORMAT GL2\n//////////////////////\nTexture.R8 = 0x8229;\nTexture.R8UI = 0x8232;\nTexture.RG8 = 0x822B;\nTexture.RG8UI = 0x8238;\nTexture.RGB8 = 0x8F96;\nTexture.RGB565 = 0x8D62;\nTexture.RGB9_E5 = 0x8C3D;\nTexture.RGB8UI = 0x8D7D;\nTexture.RGBA8 = 0x8058;\nTexture.RGB5_A1 = 0x8057;\nTexture.RGBA4 = 0x8056;\nTexture.RGBA8UI = 0x8D7C;\nTexture.SRGB8_ALPHA8 = 0x8C43;\nTexture.SRGB8 = 0x8C41;\n\n// HALF FLOAT - FLOAT\nTexture.R16F = 0x822D;\nTexture.RG16F = 0x822F;\nTexture.RGB16F = 0x881B;\nTexture.RGBA16F = 0x881A;\nTexture.R11F_G11F_B10F = 0x8C3A; // and UNSIGNED_INT_10F_11F_11F_REV\n// FLOAT\nTexture.R32F = 0x822E;\nTexture.RG32F = 0x8230;\nTexture.RGB32F = 0x8815;\nTexture.RGBA32F = 0x8814;\n\nvar createMapGl2ToGl1 = function () {\n    var map = {};\n\n    map[ Texture.R8 ] = Texture.LUMINANCE;\n    map[ Texture.R8UI ] = Texture.LUMINANCE;\n    map[ Texture.R16F ] = Texture.LUMINANCE;\n    map[ Texture.R32F ] = Texture.LUMINANCE;\n    map[ Texture.SRGB8 ] = Texture.LUMINANCE;\n    map[ Texture.RG8 ] = Texture.RGB;\n    map[ Texture.RG8UI ] = Texture.RGB;\n    map[ Texture.RG16F ] = Texture.RGB;\n    map[ Texture.RG32F ] = Texture.RGB;\n    map[ Texture.RGB8 ] = Texture.RGB;\n    map[ Texture.RGB565 ] = Texture.RGB;\n    map[ Texture.RGB9_E5 ] = Texture.RGB;\n    map[ Texture.RGB8UI ] = Texture.RGB;\n    map[ Texture.RGB5_A1 ] = Texture.RGB;\n    map[ Texture.RGB16F ] = Texture.RGB;\n    map[ Texture.RGB32F ] = Texture.RGB;\n    map[ Texture.RGBA8 ] = Texture.RGBA;\n    map[ Texture.R11F_G11F_B10F ] = Texture.RGBA;\n    map[ Texture.RGBA16F ] = Texture.RGBA;\n    map[ Texture.RGBA32F ] = Texture.RGBA;\n    map[ Texture.SRGB8_ALPHA8 ] = Texture.RGBA;\n\n    return map;\n};\n\nvar createMapGl1ToGl2 = function () {\n    var map = {};\n\n    var float = {};\n    var halfFloat = {};\n    var ushort = {};\n    var uint = {};\n    var uin24 = {};\n\n    map[ Texture.FLOAT ] = float;\n    map[ Texture.HALF_FLOAT ] = map[ Texture.HALF_FLOAT_OES ] = halfFloat;\n    map[ Texture.UNSIGNED_SHORT ] = ushort;\n    map[ Texture.UNSIGNED_INT ] = uint;\n    map[ Texture.UNSIGNED_INT_24_8 ] = uin24;\n\n    halfFloat[ Texture.LUMINANCE ] = Texture.R16F;\n    halfFloat[ Texture.RGB ] = Texture.RGB16F;\n    halfFloat[ Texture.RGBA ] = Texture.RGBA16F;\n\n    float[ Texture.LUMINANCE ] = Texture.R32F;\n    float[ Texture.RGB ] = Texture.RGB32F;\n    float[ Texture.RGBA ] = Texture.RGBA32F;\n\n    ushort[ Texture.DEPTH_COMPONENT ] = Texture.DEPTH_COMPONENT16;\n    uint[ Texture.DEPTH_COMPONENT ] = Texture.DEPTH_COMPONENT32F;\n    uin24[ Texture.DEPTH_STENCIL ] = Texture.DEPTH24_STENCIL8;\n\n    return map;\n};\n\nvar internalFormatGl2ToGl1 = createMapGl2ToGl1();\nvar internalFormatGl1ToGl2 = createMapGl1ToGl2();\n\nTexture._sTextureManager = new window.Map();\n\n// Getter for textureManager\nTexture.getTextureManager = function ( gl ) {\n\n    if ( !Texture._sTextureManager.has( gl ) )\n        Texture._sTextureManager.set( gl, new TextureManager() );\n\n    return Texture._sTextureManager.get( gl );\n};\n\nTexture.getEnumFromString = function ( v ) {\n\n    var value = v;\n\n    if ( typeof ( value ) === 'string' )\n        value = checkAndFixEnum( value, v );\n\n    return value;\n};\n\nTexture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Texture',\n\n    cloneType: function () {\n        return new Texture();\n    },\n\n    dirty: function () {\n        this._dirty = true;\n    },\n\n    isDirty: function () {\n        return this._dirty;\n    },\n\n    isTextureNull: function () {\n        return this._textureNull;\n    },\n\n    getOrCreateUniforms: function ( unit ) {\n\n        if ( Texture.uniforms === undefined ) {\n            Texture.uniforms = [];\n        }\n        if ( Texture.uniforms[ unit ] === undefined ) {\n            var name = this.getType() + unit;\n            Texture.uniforms[ unit ] = {\n                texture: Uniform.createInt1( unit, name )\n            };\n        }\n\n        // uniform for an texture attribute should directly in Texture.uniforms[unit]\n        // and not in Texture.uniforms[unit][Texture0]\n\n        // Why it's in Texture.uniforms[unit]['texture'] :\n        // a 'texture' is a texture attribute but you also have old texenv\n        //  that are texture attribute because  they are applied on a texture unit.\n        // I admit that currently we dont have this or we used to but we dont have it anymore.\n        // It's the same design than osg.\n        // We could imagine for example a TextureGreyScale texture attributes,\n        // that would transform the input texture\n        // on unit X into greyscale used in the shader.\n\n        return Texture.uniforms[ unit ];\n    },\n\n    setDefaultParameters: function () {\n        this._image = undefined;\n        this._magFilter = Texture.LINEAR;\n        this._minFilter = Texture.LINEAR;\n        this._maxAnisotropy = 1.0;\n        this._wrapS = Texture.CLAMP_TO_EDGE;\n        this._wrapT = Texture.CLAMP_TO_EDGE;\n        this._textureWidth = 0;\n        this._textureHeight = 0;\n        this._unrefImageDataAfterApply = false;\n        this._internalFormat = undefined;\n        this._dirtyMipmap = true;\n        this._textureTarget = Texture.TEXTURE_2D;\n        this._type = Texture.UNSIGNED_BYTE;\n        this._isCompressed = false;\n\n        this._flipY = true;\n        this._colorSpaceConversion = Texture.NONE; //Texture.BROWSER_DEFAULT_WEBGL;\n    },\n\n    // check https://www.khronos.org/registry/webgl/specs/latest/1.0/#PIXEL_STORAGE_PARAMETERS\n    setColorSpaceConversion: function ( enumValue ) {\n        this._colorSpaceConversion = enumValue;\n    },\n\n    setFlipY: function ( bool ) {\n        this._flipY = bool;\n    },\n\n\n    getTextureTarget: function () {\n        return this._textureTarget;\n    },\n\n    getTextureObject: function () {\n        return this._textureObject;\n    },\n\n    setTextureSize: function ( w, h ) {\n\n        var maxSize = WebglCaps.instance().getWebGLParameter( 'MAX_TEXTURE_SIZE' );\n\n        if ( w !== this._textureWidth || h !== this._textureHeight )\n            this.dirty();\n\n        if ( w !== undefined ) {\n            if ( w > maxSize ) {\n                Notify.error( 'width (' + w + ') too big for GPU. Max Texture Size is \"' + maxSize + '\"' );\n                this._textureWidth = maxSize;\n            } else {\n                this._textureWidth = w;\n            }\n        }\n\n        if ( h !== undefined ) {\n            if ( h > maxSize ) {\n                Notify.error( 'height (' + h + ') too big for GPU. Max Texture Size is \"' + maxSize + '\"' );\n                this._textureHeight = maxSize;\n            } else {\n                this._textureHeight = h;\n            }\n        }\n\n        this._textureNull = false;\n    },\n\n    init: function ( state ) {\n\n        if ( !this._gl ) this.setGraphicContext( state.getGraphicContext() );\n\n        if ( !this._textureObject ) {\n            this._textureObject = Texture.getTextureManager( this._gl ).generateTextureObject( this._gl,\n                this,\n                this._textureTarget,\n                this._internalFormat,\n                this._textureWidth,\n                this._textureHeight );\n\n            this.dirty();\n            this._dirtyTextureObject = false;\n            this._textureNull = false;\n        }\n    },\n\n    addApplyTexImage2DCallback: function ( callback ) {\n\n        var index = this._applyTexImage2DCallbacks.indexOf( callback );\n        if ( index < 0 ) {\n            this._applyTexImage2DCallbacks.push( callback );\n        }\n    },\n\n    removeApplyTexImage2DCallback: function ( callback ) {\n\n        var index = this._applyTexImage2DCallbacks.indexOf( callback );\n        if ( index >= 0 ) {\n            this._applyTexImage2DCallbacks.splice( index, 1 );\n        }\n    },\n\n    getWidth: function () {\n        return this._textureWidth;\n    },\n\n    getHeight: function () {\n        return this._textureHeight;\n    },\n\n    releaseGLObjects: function () {\n\n        if ( this._textureObject !== undefined && this._textureObject !== null && this._gl !== undefined ) {\n            Texture.getTextureManager( this._gl ).releaseTextureObject( this._textureObject );\n        }\n        this._textureObject = undefined;\n    },\n\n    getWrapT: function () {\n        return this._wrapT;\n    },\n\n    getWrapS: function () {\n        return this._wrapS;\n    },\n\n    setWrapS: function ( value ) {\n\n        if ( typeof value === 'string' ) {\n            this._wrapS = checkAndFixEnum( value, Texture.CLAMP_TO_EDGE );\n        } else {\n            this._wrapS = value;\n        }\n\n        this.dirtyTextureParameters();\n\n    },\n\n    setWrapT: function ( value ) {\n\n        if ( typeof value === 'string' ) {\n            this._wrapT = checkAndFixEnum( value, Texture.CLAMP_TO_EDGE );\n        } else {\n            this._wrapT = value;\n        }\n\n        this.dirtyTextureParameters();\n    },\n\n    // TODO CP:\n    // we should split dirty texture object of parameters\n    // dirty parameters only regenarate parameter\n    // dirty texture object needs to release a texture and\n    // re allocate one\n    dirtyTextureParameters: function () {\n        this.dirty(); // make everything dirty for now\n        this.dirtyMipmap();\n        this.dirtyTextureObject();\n    },\n\n    dirtyTextureObject: function () {\n        this._dirtyTextureObject = true;\n        this.dirtyMipmap();\n        this.dirty(); // make everything dirty for now\n    },\n\n\n    getMinFilter: function () {\n        return this._minFilter;\n    },\n\n    getMagFilter: function () {\n        return this._magFilter;\n    },\n\n    // https://www.opengl.org/registry/specs/EXT/texture_filter_anisotropic.txt\n    setMaxAnisotropy: function ( multiplier ) {\n        this._maxAnisotropy = multiplier;\n        this.dirtyTextureParameters();\n    },\n\n    getMaxAnisotropy: function () {\n        return this._maxAnisotropy;\n    },\n\n    // some value enable mipmapping\n    setMinFilter: function ( value ) {\n\n        if ( typeof ( value ) === 'string' ) {\n            this._minFilter = checkAndFixEnum( value, Texture.LINEAR );\n        } else {\n            this._minFilter = value;\n        }\n\n        this.dirtyTextureParameters();\n    },\n\n    // Either Linear or nearest.\n    setMagFilter: function ( value ) {\n\n        if ( typeof ( value ) === 'string' ) {\n            this._magFilter = checkAndFixEnum( value, Texture.LINEAR );\n        } else {\n            this._magFilter = value;\n        }\n\n        this.dirtyTextureParameters();\n    },\n\n    setImage: function ( img, imageFormat ) {\n\n        var image = img;\n        if ( img instanceof window.Image ||\n            img instanceof HTMLCanvasElement ||\n            img instanceof ImageBitmap ||\n            img instanceof Uint8Array ) {\n            image = new Image( img );\n        }\n\n        this._image = image;\n        this.setImageFormat( imageFormat );\n        if ( image ) {\n            if ( image.getWidth && image.getHeight ) {\n                this.setTextureSize( image.getWidth(), image.getHeight() );\n            } else if ( image.width && image.height ) {\n                this.setTextureSize( image.width, image.height );\n            }\n        }\n        this._textureNull = false;\n        this.dirty();\n    },\n\n    getImage: function () {\n        return this._image;\n    },\n\n    setImageFormat: function ( format ) {\n\n        var imageFormat = format;\n        if ( imageFormat ) {\n\n            if ( typeof imageFormat === 'string' )\n                imageFormat = Texture[ imageFormat ];\n\n            this._imageFormat = imageFormat;\n        } else {\n            this._imageFormat = Texture.RGBA;\n        }\n    },\n\n    setInternalFormatType: function ( value ) {\n        // UNSIGNED_BYTE, HALF_FLOAT, FLOAT\n\n        if ( typeof value === 'string' ) {\n            this._type = Texture[ value ];\n        } else {\n            this._type = value;\n        }\n    },\n\n    getInternalFormatType: function () {\n        return this._type;\n    },\n\n    setUnrefImageDataAfterApply: function ( bool ) {\n        this._unrefImageDataAfterApply = bool;\n    },\n\n    checkIsCompressed: function ( format ) {\n\n        var fo = format || this._internalFormat;\n        switch ( fo ) {\n        case Texture.COMPRESSED_RGB_S3TC_DXT1_EXT:\n        case Texture.COMPRESSED_RGBA_S3TC_DXT1_EXT:\n        case Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT:\n        case Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT:\n        case Texture.COMPRESSED_RGB_ATC_WEBGL:\n        case Texture.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\n        case Texture.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\n        case Texture.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\n        case Texture.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\n        case Texture.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\n        case Texture.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\n        case Texture.COMPRESSED_RGB_ETC1_WEBGL:\n            return true;\n        default:\n            return false;\n        }\n    },\n\n    setInternalFormat: function ( formatSource ) {\n        // RGB, RGBA, ALPHA, LUMINANCE, LUMINANCE_ALPHA\n        // RGB16F, RGB32F, etc...\n        // DEPTH_COMPONENT, DEPTH_STENCIL\n\n        var format = formatSource;\n        if ( format ) {\n\n            if ( typeof format === 'string' )\n                format = Texture[ format ];\n\n            this._isCompressed = this.checkIsCompressed( format );\n\n        } else {\n            this._isCompressed = false;\n            format = Texture.RGBA;\n        }\n\n        this._internalFormat = format;\n    },\n\n    getInternalFormat: function () {\n        return this._internalFormat;\n    },\n\n    isDirtyMipmap: function () {\n        return this._dirtyMipmap;\n    },\n\n    // Will cause the mipmaps to be regenerated on the next bind of the texture\n    // Nothing will be done if the minFilter is not of the form XXX_MIPMAP_XXX\n    // TODO : not to be used if the texture is compressed !\n    dirtyMipmap: function () {\n        this._dirtyMipmap = true;\n    },\n\n    applyFilterParameter: function ( gl, target ) {\n\n        var powerOfTwo = isPowerOf2( this._textureWidth ) && isPowerOf2( this._textureHeight );\n        if ( !powerOfTwo ) {\n            // NPOT non support in webGL explained here\n            // https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\n            // so disabling mipmap...\n            this._wrapT = Texture.CLAMP_TO_EDGE;\n            this._wrapS = Texture.CLAMP_TO_EDGE;\n\n            if ( this._minFilter === Texture.LINEAR_MIPMAP_LINEAR ||\n                this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ) {\n                this._minFilter = Texture.LINEAR;\n            }\n        }\n        gl.texParameteri( target, gl.TEXTURE_MAG_FILTER, this._magFilter );\n        gl.texParameteri( target, gl.TEXTURE_MIN_FILTER, this._minFilter );\n\n\n        // handle extension EXT_texture_filter_anisotropic\n        if ( this._maxAnisotropy > 1.0 && Texture.ANISOTROPIC_SUPPORT_EXT ) {\n            var multiplier = this._maxAnisotropy < Texture.ANISOTROPIC_SUPPORT_MAX ? this._maxAnisotropy : Texture.ANISOTROPIC_SUPPORT_MAX;\n            gl.texParameterf( target, Texture.TEXTURE_MAX_ANISOTROPY_EXT, multiplier );\n        }\n\n        gl.texParameteri( target, gl.TEXTURE_WRAP_S, this._wrapS );\n        gl.texParameteri( target, gl.TEXTURE_WRAP_T, this._wrapT );\n\n    },\n\n    generateMipmap: function ( gl, target ) {\n\n        this._dirtyMipmap = false;\n        if ( !this.hasMipmapFilter() ) return;\n\n        // manual mipmap provided\n        var img = this._image;\n        if ( img && img.hasMipmap() ) {\n\n            var internalFormat = this._getInternalFormatGL();\n            var mips = img.getMipmap();\n            for ( var level = 1, nbLevel = mips.length; level < nbLevel; level++ ) {\n                var imi = mips[ level ];\n                if ( this._isCompressed )\n                    this.applyTexImage2D( gl, this._textureTarget, level, internalFormat, imi.getWidth(), imi.getHeight(), 0, imi.getImage() );\n                else\n                    this.applyTexImage2D( gl, this._textureTarget, level, internalFormat, imi.getWidth(), imi.getHeight(), 0, this._internalFormat, this._type, imi.getImage() );\n            }\n\n        } else {\n            // automatic mipmap\n            gl.generateMipmap( target );\n        }\n    },\n\n    // return true if contains a mipmap filter\n    hasMipmapFilter: function () {\n\n        return this._minFilter === Texture.NEAREST_MIPMAP_NEAREST ||\n            this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ||\n            this._minFilter === Texture.NEAREST_MIPMAP_LINEAR ||\n            this._minFilter === Texture.LINEAR_MIPMAP_LINEAR;\n    },\n\n    applyTexImage2D: function ( gl ) {\n\n        var args = Array.prototype.slice.call( arguments, 1 );\n        MACROUTILS.timeStamp( 'osgjs.metrics:Texture.texImage2d' );\n\n        // use parameters of pixel store\n        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, this._flipY );\n        gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._colorSpaceConversion );\n\n        if ( this._isCompressed ) gl.compressedTexImage2D.apply( gl, args );\n        else gl.texImage2D.apply( gl, args );\n\n        // call a callback when upload is done if there is one\n        var numCallback = this._applyTexImage2DCallbacks.length;\n        if ( numCallback > 0 ) {\n            for ( var i = 0, l = numCallback; i < l; i++ ) {\n                this._applyTexImage2DCallbacks[ i ].call( this );\n            }\n        }\n    },\n\n    computeTextureFormat: function () {\n\n        if ( !this._internalFormat ) {\n            this._internalFormat = this._imageFormat || Texture.RGBA;\n            this._imageFormat = this._internalFormat;\n        } else {\n            this._imageFormat = this._internalFormat;\n        }\n\n    },\n\n    applyImage: function ( gl ) {\n\n        var internalFormat = this._getInternalFormatGL();\n        var image = this._image || null;\n        var data = image && this._image.getImage();\n\n        var type = this._getTypeGL();\n\n        if ( this._isCompressed ) {\n            this.applyTexImage2D( gl, this._textureTarget, 0, internalFormat, this._textureWidth, this._textureHeight, 0, data );\n        } else if ( !data || image.isTypedArray() ) {\n            this.applyTexImage2D( gl, this._textureTarget, 0, internalFormat, this._textureWidth, this._textureHeight, 0, this._internalFormat, type, data );\n        } else {\n            this.applyTexImage2D( gl, this._textureTarget, 0, internalFormat, this._internalFormat, type, data );\n        }\n\n        if ( image ) image.setDirty( false );\n\n    },\n\n    apply: function ( state ) {\n\n        var gl = state.getGraphicContext();\n        // if need to release the texture\n        if ( this._dirtyTextureObject ) {\n            this.releaseGLObjects();\n            this._dirtyTextureObject = false;\n        }\n\n        if ( this._textureObject !== undefined && !this.isDirty() ) {\n            this._textureObject.bind( gl );\n            // If we have modified the texture via Rtt or texSubImage2D and _need_ updated mipmaps,\n            // then we must regenerate the mipmaps explicitely.\n            // In all other cases, don't set this flag because it can be costly\n            if ( this.isDirtyMipmap() ) {\n                this.generateMipmap( gl, this._textureTarget );\n            }\n\n            // image update like video\n            if ( this._image !== undefined && this._image.isDirty() ) {\n                this.applyImage( gl );\n            }\n\n        } else if ( this._textureNull ) {\n\n            gl.bindTexture( this._textureTarget, null );\n\n        } else {\n\n            var image = this._image;\n            if ( image !== undefined ) {\n\n                // when data is ready we will upload it to the gpu\n                if ( image.isReady() ) {\n\n                    // must be called before init\n                    this.computeTextureFormat();\n\n                    var imgWidth = image.getWidth() || this._textureWidth;\n                    var imgHeight = image.getHeight() || this._textureHeight;\n\n                    this.setTextureSize( imgWidth, imgHeight );\n\n                    if ( !this._textureObject ) {\n                        this.init( state );\n                    }\n\n                    this._textureObject.bind( gl );\n\n                    this.applyImage( gl );\n                    this.applyFilterParameter( gl, this._textureTarget );\n                    this.generateMipmap( gl, this._textureTarget );\n\n                    if ( this._unrefImageDataAfterApply ) {\n                        this._image = undefined;\n                    }\n\n                    this._dirty = false;\n\n                } else {\n                    gl.bindTexture( this._textureTarget, null );\n                }\n\n            } else if ( this._textureHeight !== 0 && this._textureWidth !== 0 ) {\n\n                // must be called before init\n                this.computeTextureFormat();\n\n                if ( !this._textureObject ) {\n                    this.init( state );\n                }\n                this._textureObject.bind( gl );\n\n                this.applyImage( gl );\n\n                this.applyFilterParameter( gl, this._textureTarget );\n                this.generateMipmap( gl, this._textureTarget );\n                this._dirty = false;\n            }\n        }\n    },\n\n    _getInternalFormatGL: function () {\n        var internalFormat = this._internalFormat;\n\n        // gl1\n        if ( !WebglCaps.instance().isWebGL2() ) {\n            return internalFormatGl2ToGl1[ internalFormat ] || internalFormat;\n        }\n\n        // gl2\n        var map = internalFormatGl1ToGl2[ this._type ];\n        return ( map && map[ internalFormat ] ) || internalFormat;\n    },\n\n    _getTypeGL: function () {\n        if ( this._type === Texture.HALF_FLOAT && !WebglCaps.instance().isWebGL2() )\n            return Texture.HALF_FLOAT_OES;\n        return this._type;\n    }\n\n\n} ) ), 'osg', 'Texture' );\n\nMACROUTILS.setTypeID( Texture );\n\nTexture.textureNull = new Texture();\n\nTexture.createFromImage = function ( image, format ) {\n    var a = new Texture();\n    a.setImage( image, format );\n    return a;\n};\n\nTexture.createFromCanvas = function ( canvas, format ) {\n    return Texture.createFromImage( canvas, format );\n};\n\nmodule.exports = Texture;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Texture.js\n// module id = 40\n// module chunks = 0 1 2","'use strict';\nvar notify = require( 'osg/notify' );\n\n/**\n * Uniform manage variable used in glsl shader.\n * @class Uniform\n */\nvar Uniform = function ( name ) {\n    this._data = undefined;\n    this._transpose = false;\n    this._glCall = '';\n    this._cache = undefined;\n    this._name = name;\n    this._type = undefined;\n    this._isMatrix = false;\n};\n\nUniform.isUniform = function ( obj ) {\n    if ( typeof obj === 'object' && window.Object.getPrototypeOf( obj ) === Uniform.prototype ) {\n        return true;\n    }\n    return false;\n};\n\n/** @lends Uniform.prototype */\nUniform.prototype = {\n\n    getName: function () {\n        return this._name;\n    },\n\n    getType: function () {\n        return this._type;\n    },\n\n    apply: function UniformApply( gl, location ) {\n\n        if ( !this._cache )\n            this._cache = gl[ this._glCall ];\n\n        if ( this._isMatrix )\n            this._cache.call( gl, location, this._transpose, this._data );\n        else\n            this._cache.call( gl, location, this._data );\n    },\n\n    // no type checking, so array should be valid\n    setInternalArray: function ( array ) {\n        notify.warn( 'setInternalArray deprecated, please use getInternalArray instead: ' + array.length );\n        this._data = array;\n    },\n\n    getInternalArray: function () {\n        return this._data;\n    },\n\n    setFloat: function ( f ) {\n        this._data[ 0 ] = f;\n    },\n\n    setFloat1: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n    },\n\n    setFloat2: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n        this._data[ 1 ] = f[ 1 ];\n    },\n\n    setFloat3: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n        this._data[ 1 ] = f[ 1 ];\n        this._data[ 2 ] = f[ 2 ];\n    },\n\n    setFloat4: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n        this._data[ 1 ] = f[ 1 ];\n        this._data[ 2 ] = f[ 2 ];\n        this._data[ 3 ] = f[ 3 ];\n    },\n\n    setFloat9: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n        this._data[ 1 ] = f[ 1 ];\n        this._data[ 2 ] = f[ 2 ];\n        this._data[ 3 ] = f[ 3 ];\n        this._data[ 4 ] = f[ 4 ];\n        this._data[ 5 ] = f[ 5 ];\n        this._data[ 6 ] = f[ 6 ];\n        this._data[ 7 ] = f[ 7 ];\n        this._data[ 8 ] = f[ 8 ];\n    },\n\n    setFloat16: function ( f ) {\n        this._data[ 0 ] = f[ 0 ];\n        this._data[ 1 ] = f[ 1 ];\n        this._data[ 2 ] = f[ 2 ];\n        this._data[ 3 ] = f[ 3 ];\n        this._data[ 4 ] = f[ 4 ];\n        this._data[ 5 ] = f[ 5 ];\n        this._data[ 6 ] = f[ 6 ];\n        this._data[ 7 ] = f[ 7 ];\n        this._data[ 8 ] = f[ 8 ];\n        this._data[ 9 ] = f[ 9 ];\n        this._data[ 10 ] = f[ 10 ];\n        this._data[ 11 ] = f[ 11 ];\n        this._data[ 12 ] = f[ 12 ];\n        this._data[ 13 ] = f[ 13 ];\n        this._data[ 14 ] = f[ 14 ];\n        this._data[ 15 ] = f[ 15 ];\n    }\n};\nUniform.prototype.setVec2 = Uniform.prototype.setFloat2;\nUniform.prototype.setVec3 = Uniform.prototype.setFloat3;\nUniform.prototype.setVec4 = Uniform.prototype.setFloat4;\nUniform.prototype.setMatrix4 = Uniform.prototype.setFloat16;\nUniform.prototype.setMatrix3 = Uniform.prototype.setFloat9;\nUniform.prototype.setInt = Uniform.prototype.setFloat;\nUniform.prototype.setInt1 = Uniform.prototype.setFloat1;\nUniform.prototype.setInt2 = Uniform.prototype.setFloat2;\nUniform.prototype.setInt3 = Uniform.prototype.setFloat3;\nUniform.prototype.setInt4 = Uniform.prototype.setFloat4;\n\nvar createUniformX = function ( dataOrName, nameOrNbItem, internalArray, glSignature, type, isMatrix ) {\n    var data = ( nameOrNbItem && nameOrNbItem.length ) ? dataOrName : undefined;\n    var uniform = new Uniform( data !== undefined ? nameOrNbItem : dataOrName );\n\n    uniform._data = internalArray;\n\n    if ( data !== undefined ) {\n        if ( data.length ) {\n            for ( var i = 0, nbElts = data.length; i < nbElts; ++i )\n                uniform._data[ i ] = data[ i ];\n        } else {\n            uniform._data[ 0 ] = data;\n        }\n    }\n\n    uniform._glCall = glSignature;\n    uniform._type = type;\n    uniform._isMatrix = !!isMatrix;\n    return uniform;\n};\n\nvar createMat2 = function ( nbItem ) {\n    var out = new Float32Array( nbItem * 4 );\n    for ( var i = 0; i < out.length; i += 4 ) out[ i ] = out[ i + 3 ] = 1.0;\n    return out;\n};\n\nvar createMat3 = function ( nbItem ) {\n    var out = new Float32Array( nbItem * 9 );\n    for ( var i = 0; i < out.length; i += 9 ) out[ i ] = out[ i + 4 ] = out[ i + 8 ] = 1.0;\n    return out;\n};\n\nvar createMat4 = function ( nbItem ) {\n    var out = new Float32Array( nbItem * 16 );\n    for ( var i = 0; i < out.length; i += 16 ) out[ i ] = out[ i + 5 ] = out[ i + 10 ] = out[ i + 15 ] = 1.0;\n    return out;\n};\n\n// possibles signatures\n// name\n// data, name\n// name, nbItem\nvar _getNbItem = function ( itemSize, dataOrName, nameOrNbItem ) {\n    if ( nameOrNbItem && !nameOrNbItem.length ) return nameOrNbItem; // name, nbItem\n    if ( typeof dataOrName !== 'string' ) return ( dataOrName.length || 1 ) / itemSize; // data, name\n    return 1; // name\n};\n\n// works also for float array but data must be given\nUniform.createFloat1 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Float32Array( 1 * _getNbItem( 1, dataOrName, nameOrNbItem ) ), 'uniform1fv', 'float' );\n};\nUniform.createFloat2 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Float32Array( 2 * _getNbItem( 2, dataOrName, nameOrNbItem ) ), 'uniform2fv', 'vec2' );\n};\nUniform.createFloat3 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Float32Array( 3 * _getNbItem( 3, dataOrName, nameOrNbItem ) ), 'uniform3fv', 'vec3' );\n};\nUniform.createFloat4 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Float32Array( 4 * _getNbItem( 4, dataOrName, nameOrNbItem ) ), 'uniform4fv', 'vec4' );\n};\n\nUniform.createInt1 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Int32Array( 1 * _getNbItem( 1, dataOrName, nameOrNbItem ) ), 'uniform1iv', 'int' );\n};\nUniform.createInt2 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Int32Array( 2 * _getNbItem( 2, dataOrName, nameOrNbItem ) ), 'uniform2iv', 'vec2i' );\n};\nUniform.createInt3 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Int32Array( 3 * _getNbItem( 3, dataOrName, nameOrNbItem ) ), 'uniform3iv', 'vec3i' );\n};\nUniform.createInt4 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, new Int32Array( 4 * _getNbItem( 4, dataOrName, nameOrNbItem ) ), 'uniform4iv', 'vec4i' );\n};\n\nUniform.createMatrix2 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, createMat2( _getNbItem( 4, dataOrName, nameOrNbItem ) ), 'uniformMatrix2fv', 'mat2', true );\n};\n\nUniform.createMatrix3 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, createMat3( _getNbItem( 9, dataOrName, nameOrNbItem ) ), 'uniformMatrix3fv', 'mat3', true );\n};\n\nUniform.createMatrix4 = function ( dataOrName, nameOrNbItem ) {\n    return createUniformX( dataOrName, nameOrNbItem, createMat4( _getNbItem( 16, dataOrName, nameOrNbItem ) ), 'uniformMatrix4fv', 'mat4', true );\n};\n\n// alias\nUniform.float = Uniform.createFloatArray = Uniform.createFloat = Uniform.createFloat1;\nUniform.vec2 = Uniform.createFloat2Array = Uniform.createFloat2;\nUniform.vec3 = Uniform.createFloat3Array = Uniform.createFloat3;\nUniform.vec4 = Uniform.createFloat4Array = Uniform.createFloat4;\n\nUniform.int = Uniform.createIntArray = Uniform.createInt = Uniform.createInt1;\nUniform.vec2i = Uniform.createInt2Array = Uniform.createInt2;\nUniform.vec3i = Uniform.createInt3Array = Uniform.createInt3;\nUniform.vec4i = Uniform.createInt4Array = Uniform.createInt4;\n\nUniform.mat2 = Uniform.createMat2Array = Uniform.createMat2 = Uniform.createMatrix2;\nUniform.mat3 = Uniform.createMat3Array = Uniform.createMat3 = Uniform.createMatrix3;\nUniform.mat4 = Uniform.createMat4Array = Uniform.createMat4 = Uniform.createMatrix4;\n\nmodule.exports = Uniform;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Uniform.js\n// module id = 41\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\n\nvar ImageBitmap = window.ImageBitmap || function () {};\n\nvar ImageObject = function ( image ) {\n    Object.call( this );\n\n    this._imageObject = undefined;\n    this._url = undefined;\n    this._width = undefined;\n    this._height = undefined;\n    this._dirty = true;\n    this._mipmap = [];\n\n    if ( image ) {\n        this.setImage( image );\n    }\n\n    this._isGreyscale = undefined;\n};\n\nImageObject.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    dirty: function () {\n        this._isGreyscale = undefined;\n        this._dirty = true;\n    },\n\n    isDirty: function () {\n        return this._dirty;\n    },\n\n    setDirty: function ( bool ) {\n        this._dirty = bool;\n    },\n\n    getImage: function () {\n        return ( this._imageObject instanceof ImageObject ) ? this._imageObject.getImage() : this._imageObject;\n    },\n\n    getURL: function () {\n        return this._url;\n    },\n\n    setURL: function ( url ) {\n        this._url = url;\n    },\n\n    useOrCreateImage: function ( img ) {\n        return ( img instanceof( ImageObject ) === false ) ? new ImageObject( img ) : img;\n    },\n\n    setImage: function ( img ) {\n        if ( !this._url && img && ( img.src || img.currentSrc ) ) {\n            // TODO what is currentSrc ?\n            this._url = img.src || img.currentSrc;\n        }\n\n        this._mipmap.length = 0;\n\n        // img can be an image or an array of image if specify the\n        // all mipmap levels\n        if ( Array.isArray( img ) ) {\n            for ( var i = 0, nbImg = img.length; i < nbImg; i++ ) {\n                this._mipmap.push( this.useOrCreateImage( img[ i ] ) );\n            }\n            this.setWidth( this._mipmap[ 0 ].getWidth() );\n            this.setHeight( this._mipmap[ 0 ].getHeight() );\n        } else {\n            this._mipmap.push( img );\n        }\n\n        this._imageObject = this._mipmap[ 0 ];\n        this.dirty();\n    },\n\n    isCanvas: function () {\n        return this.getImage() instanceof window.HTMLCanvasElement;\n    },\n\n    isBitmap: function () {\n        return this.getImage() instanceof ImageBitmap;\n    },\n\n    isVideo: function () {\n        return this.getImage() instanceof window.HTMLVideoElement;\n    },\n\n    isImage: function () {\n        return this.getImage() instanceof window.Image;\n    },\n\n    isTypedArray: function () {\n        var img = this.getImage();\n        return img instanceof Uint8Array || img instanceof Float32Array || img instanceof Uint16Array;\n    },\n\n    setWidth: function ( w ) {\n        this._width = w;\n    },\n\n    setHeight: function ( h ) {\n        this._height = h;\n    },\n\n    getWidth: function () {\n        var img = this.getImage();\n        if ( this.isImage() ) {\n            return img.naturalWidth;\n        } else if ( this.isVideo() ) {\n            return img.videoWidth;\n        } else if ( this.isCanvas() || this.isBitmap() ) {\n            return img.width;\n        }\n        return this._width;\n    },\n\n    getHeight: function () {\n        var img = this.getImage();\n        if ( this.isImage() ) {\n            return img.naturalHeight;\n        } else if ( this.isVideo() ) {\n            return img.videoHeight;\n        } else if ( this.isCanvas() || this.isBitmap() ) {\n            return img.height;\n        }\n        return this._height;\n    },\n\n    isGreyscale: function ( nbSamples ) {\n        if ( this._isGreyscale !== undefined )\n            return this._isGreyscale;\n\n        if ( this._imageObject !== undefined && this.isReady() && this._isGreyscale === undefined ) {\n\n            var canvas = this._imageObject;\n            if ( !this.isCanvas() ) {\n                canvas = document.createElement( 'canvas' );\n            }\n            var ctx = canvas.getContext( '2d' );\n            canvas.width = this._imageObject.width;\n            canvas.height = this._imageObject.height;\n            ctx.drawImage( this._imageObject, 0, 0 );\n\n            var sampleX, sampleY;\n            // cap sample if needed\n            if ( !nbSamples ) {\n                sampleX = canvas.width;\n                sampleY = canvas.height;\n            }\n            if ( nbSamples > 0 ) {\n                nbSamples = Math.min( Math.min( canvas.width, canvas.height ), nbSamples );\n                sampleX = sampleY = nbSamples;\n            }\n\n            var isGreyscale = true;\n            var xFactor = canvas.width / ( sampleX );\n            var yFactor = canvas.height / ( sampleY );\n            for ( var i = 0; i < sampleX; i++ ) {\n                for ( var j = 0; j < sampleY; j++ ) {\n                    var x = Math.floor( xFactor * ( i + 0.5 ) ),\n                        y = Math.floor( yFactor * ( j + 0.5 ) );\n                    var data = ctx.getImageData( x, y, 1, 1 ).data;\n                    if ( !( data[ 0 ] === data[ 1 ] && data[ 0 ] === data[ 2 ] ) ) {\n                        isGreyscale = false;\n                        break;\n                    }\n                }\n            }\n            this._isGreyscale = isGreyscale;\n        }\n\n        return this._isGreyscale;\n    },\n\n    isReady: function () {\n\n        // image is a osgImage\n        if ( this._imageObject && this._imageObject instanceof ImageObject ) {\n            return this._imageObject.isReady();\n        }\n\n\n        // image are ready for static data\n        if ( this.isCanvas() || this.isTypedArray() || this.isBitmap() ) {\n            return true;\n        }\n\n        if ( this.isImage() ) {\n            var image = this.getImage();\n            if ( image.complete ) {\n                if ( image.naturalWidth !== undefined && image.naturalWidth === 0 ) {\n                    return false;\n                }\n\n                return true;\n            }\n        }\n\n        if ( this.isVideo() ) {\n            if ( this.getWidth() !== 0 ) return true;\n        }\n\n        // here means we have something but we don't know what\n        // Check if the object is not a image\n        // by \"feature\" detect it\n        var imageTry = this.getImage();\n        if ( imageTry.complete ) {\n            if ( imageTry.naturalWidth !== undefined && imageTry.naturalWidth === 0 ) {\n                return false;\n            }\n            return true;\n        }\n\n        // It's not something we recognise\n        return false;\n    },\n\n    getMipmap: function () {\n        return this._mipmap;\n    },\n\n    hasMipmap: function () {\n        return this._mipmap.length > 1;\n    },\n\n    release: function () {\n        this._mipmap.length = 0;\n        this._imageObject = undefined;\n    }\n} ), 'osg', 'Image' );\n\nMACROUTILS.setTypeID( ImageObject );\n\nmodule.exports = ImageObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Image.js\n// module id = 42\n// module chunks = 0 1 2","'use strict';\n\n// Base class for GLResources: Textures, Buffers, Programs, Shaders, FrameBuffers and RenderBuffers\n// It holds a reference to the graphic context that is needed for resource deletion\n\nvar GLObject = function () {\n    this._gl = undefined;\n};\n\nGLObject.prototype = {\n    setGraphicContext: function ( gl ) {\n        this._gl = gl;\n    },\n    getGraphicContext: function () {\n        return this._gl;\n    }\n};\n\nmodule.exports = GLObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/GLObject.js\n// module id = 43\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar Timer = require( 'osg/Timer' );\n\n\nvar TextureProfile = function ( target, internalFormat, width, height ) {\n    this._target = target;\n    this._internalFormat = internalFormat;\n    this._width = width;\n    this._height = height;\n    this._size = 0;\n    this.computeSize();\n};\n\nTextureProfile.prototype = {\n    match: function ( textureProfile ) {\n        return textureProfile._target === this._target &&\n            textureProfile._internalFormat === this._internalFormat &&\n            textureProfile._width === this._width &&\n            textureProfile._height === this._height;\n    },\n    computeSize: function () {\n        var Texture = require( 'osg/Texture' );\n\n        var numBitsPerTexel = 0;\n        switch ( this._internalFormat ) {\n        case ( 1 ):\n            numBitsPerTexel = 8;\n            break;\n        case ( Texture.ALPHA ):\n            numBitsPerTexel = 8;\n            break;\n        case ( Texture.LUMINANCE ):\n            numBitsPerTexel = 8;\n            break;\n\n        case ( Texture.LUMINANCE_ALPHA ):\n            numBitsPerTexel = 16;\n            break;\n        case ( 2 ):\n            numBitsPerTexel = 16;\n            break;\n\n        case ( Texture.RGB ):\n            numBitsPerTexel = 24;\n            break;\n        case ( 3 ):\n            numBitsPerTexel = 24;\n            break;\n\n        case ( Texture.RGBA ):\n            numBitsPerTexel = 32;\n            break;\n        case ( 4 ):\n            numBitsPerTexel = 32;\n            break;\n\n        }\n        var size = ( Math.ceil( this._width * this._height * numBitsPerTexel ) / 8.0 );\n\n        if ( this._target === Texture.TEXTURE_CUBE_MAP )\n            size *= 6.0;\n\n        // add the mipmap overhead size even if not used\n        size += size / 3.0;\n\n        this._size = size;\n    },\n\n    getSize: function () {\n        return this._size;\n    }\n\n};\nTextureProfile.getHash = function () {\n    var array = Array.prototype.slice.call( arguments );\n    var hash = '';\n    array.forEach( function ( element ) {\n        hash += element;\n    } );\n    return hash;\n};\n\n\nvar TextureObject = function ( texture, id, textureSet ) {\n    this._texture = texture;\n    this._id = id;\n    this._textureSet = textureSet;\n};\n\nTextureObject.prototype = {\n    target: function () {\n        return this._textureSet._profile._target;\n    },\n    id: function () {\n        return this._id;\n    },\n    getTextureSet: function () {\n        return this._textureSet;\n    },\n    reset: function () {\n        this._textureObject = null;\n        this._texture = undefined;\n    },\n    bind: function ( gl ) {\n        gl.bindTexture( this.target(), this._id );\n    }\n};\n\nvar TextureObjectSet = function ( profile ) {\n    this._profile = profile;\n    this._usedTextureObjects = [];\n    this._orphanedTextureObjects = [];\n};\n\nTextureObjectSet.prototype = {\n    getProfile: function () {\n        return this._profile;\n    },\n    getUsedTextureObjects: function () {\n        return this._usedTextureObjects;\n    },\n    getOrphanedTextureObjects: function () {\n        return this._orphanedTextureObjects;\n    },\n\n    takeOrGenerate: function ( gl, texture ) {\n\n        var textureObject;\n        if ( this._orphanedTextureObjects.length > 0 ) {\n            textureObject = this.takeFromOrphans();\n            textureObject._texture = texture;\n            this._usedTextureObjects.push( textureObject );\n            return textureObject;\n        }\n\n        var textureID = gl.createTexture();\n        textureObject = new TextureObject( texture, textureID, this );\n        this._usedTextureObjects.push( textureObject );\n\n        return textureObject;\n    },\n\n    // get texture object from pool\n    takeFromOrphans: function () {\n\n        if ( this._orphanedTextureObjects.length )\n            return this._orphanedTextureObjects.pop();\n\n        return undefined;\n    },\n\n    // release texture object\n    orphan: function ( textureObject ) {\n        var index = this._usedTextureObjects.indexOf( textureObject );\n        if ( index !== -1 ) {\n            this._orphanedTextureObjects.push( this._usedTextureObjects[ index ] );\n            this._usedTextureObjects.splice( index, 1 );\n        }\n    },\n\n    flushDeletedTextureObjects: function ( gl, availableTime ) {\n        // if no time available don't try to flush objects.\n        if ( availableTime <= 0.0 ) return availableTime;\n        var nbTextures = this._orphanedTextureObjects.length;\n        // Should we use a maxSizeTexturePool value?\n        //var size = this.getProfile().getSize();\n        // We need to test if we have time to flush\n        var elapsedTime = 0.0;\n        var beginTime = Timer.instance().tick();\n        var i;\n        for ( i = 0; i < nbTextures && elapsedTime < availableTime; i++ ) {\n            gl.deleteTexture( this._orphanedTextureObjects[ i ].id() );\n            this._orphanedTextureObjects[ i ].reset();\n            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n        }\n        this._orphanedTextureObjects.splice( 0, i );\n        return availableTime - elapsedTime;\n    },\n\n    flushAllDeletedTextureObjects: function ( gl ) {\n        var nbTextures = this._orphanedTextureObjects.length;\n        var size = this.getProfile().getSize();\n        for ( var i = 0, j = nbTextures; i < j; ++i ) {\n            gl.deleteTexture( this._orphanedTextureObjects[ i ].id() );\n            this._orphanedTextureObjects[ i ].reset();\n        }\n        this._orphanedTextureObjects.length = 0;\n        Notify.info( 'TextureManager: released ' + nbTextures + ' with ' + ( nbTextures * size / ( 1024 * 1024 ) ) + ' MB' );\n    }\n};\n\n\nvar TextureManager = function () {\n    this._textureSetMap = {};\n};\n\nTextureManager.prototype = {\n\n    generateTextureObject: function ( gl,\n        texture,\n        target,\n        internalFormat,\n        width,\n        height ) {\n        var hash = TextureProfile.getHash( target, internalFormat, width, height );\n\n        if ( this._textureSetMap[ hash ] === undefined ) {\n            this._textureSetMap[ hash ] = new TextureObjectSet( new TextureProfile( target, internalFormat, width, height ) );\n        }\n\n        var textureSet = this._textureSetMap[ hash ];\n        var textureObject = textureSet.takeOrGenerate( gl, texture );\n        return textureObject;\n    },\n\n    updateStats: function ( frameNumber, rStats ) {\n        var totalUsed = 0;\n        var totalUnused = 0;\n        for ( var keyTexture in this._textureSetMap ) {\n            var profile = this._textureSetMap[ keyTexture ].getProfile();\n            var size = profile.getSize();\n            var nbUsed = this._textureSetMap[ keyTexture ].getUsedTextureObjects().length;\n            var nbUnused = this._textureSetMap[ keyTexture ].getOrphanedTextureObjects().length;\n            totalUsed += nbUsed * size;\n            totalUnused += nbUnused * size;\n        }\n\n        var MB = 1024 * 1024;\n        rStats( 'textureused' ).set( totalUsed / MB );\n        rStats( 'texturereserved' ).set( totalUnused / MB );\n        rStats( 'texturetotal' ).set( ( totalUsed + totalUnused ) / MB );\n    },\n\n    reportStats: function () {\n        var total = 0;\n        for ( var keyTexture in this._textureSetMap ) {\n            var profile = this._textureSetMap[ keyTexture ].getProfile();\n            var size = profile.getSize() / ( 1024 * 1024 );\n            var nb = this._textureSetMap[ keyTexture ].getUsedTextureObjects().length;\n            size *= nb;\n            total += size;\n            Notify.notice( String( size ) + ' MB with ' + nb + ' texture of ' + profile._width + 'x' + profile._height + ' ' + profile._internalFormat );\n        }\n\n        Notify.notice( String( total ) + ' MB in total' );\n    },\n\n    flushAllDeletedTextureObjects: function ( gl ) {\n        for ( var keyTexture in this._textureSetMap ) {\n            this._textureSetMap[ keyTexture ].flushAllDeletedTextureObjects( gl );\n        }\n    },\n\n    flushDeletedTextureObjects: function ( gl, availableTimeArg ) {\n        var availableTime = availableTimeArg;\n        for ( var keyTexture in this._textureSetMap ) {\n            availableTime = this._textureSetMap[ keyTexture ].flushDeletedTextureObjects( gl, availableTime );\n            if ( availableTime <= 0.0 ) break;\n        }\n        return availableTime;\n    },\n\n    releaseTextureObject: function ( textureObject ) {\n        if ( textureObject ) {\n            var ts = textureObject.getTextureSet();\n            ts.orphan( textureObject );\n        }\n    }\n\n};\n\nmodule.exports = TextureManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/TextureManager.js\n// module id = 44\n// module chunks = 0 1 2","'use strict';\nvar PrimitiveSet = require( 'osg/primitiveSet' );\n\n\n/**\n * DrawElements manage rendering of indexed primitives\n * @class DrawElements\n */\nvar DrawElements = function ( mode, indices ) {\n    this.mode = PrimitiveSet.POINTS;\n    if ( mode !== undefined ) {\n        if ( typeof ( mode ) === 'string' ) {\n            mode = PrimitiveSet[ mode ];\n        }\n        this.mode = mode;\n    }\n    this.count = 0;\n    this.offset = 0;\n    this.indices = indices;\n    this.uType = DrawElements.UNSIGNED_SHORT;\n    if ( indices !== undefined ) {\n        this.setIndices( indices );\n    }\n};\n\nDrawElements.UNSIGNED_BYTE = 0x1401;\nDrawElements.UNSIGNED_SHORT = 0x1403;\nDrawElements.UNSIGNED_INT = 0x1405;\n\n/** @lends DrawElements.prototype */\nDrawElements.prototype = {\n    getMode: function () {\n        return this.mode;\n    },\n    draw: function ( state ) {\n        if ( this.count === 0 )\n            return;\n        state.setIndexArray( this.indices );\n        this.drawElements( state );\n    },\n    drawElements: function ( state ) {\n        var gl = state.getGraphicContext();\n        gl.drawElements( this.mode, this.count, this.uType, this.offset );\n    },\n    setIndices: function ( indices ) {\n        this.indices = indices;\n        var elts = indices.getElements();\n        this.count = elts.length;\n\n        var nbBytes = elts.BYTES_PER_ELEMENT;\n        if ( nbBytes === 1 ) this.uType = DrawElements.UNSIGNED_BYTE;\n        else if ( nbBytes === 2 ) this.uType = DrawElements.UNSIGNED_SHORT;\n        else if ( nbBytes === 4 ) this.uType = DrawElements.UNSIGNED_INT;\n    },\n    getIndices: function () {\n        return this.indices;\n    },\n    setFirst: function ( val ) {\n        this.offset = val;\n    },\n    getFirst: function () {\n        return this.offset;\n    },\n    setCount: function ( val ) {\n        this.count = val;\n    },\n    getCount: function () {\n        return this.count;\n    },\n    getNumIndices: function () {\n        return this.indices.getElements().length;\n    },\n    index: function ( i ) {\n        return this.indices.getElements()[ i ];\n    }\n\n\n};\n\nmodule.exports = DrawElements;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/DrawElements.js\n// module id = 45\n// module chunks = 0 1 2","'use strict';\nvar PrimitiveSet = {};\nPrimitiveSet.POINTS = 0x0000;\nPrimitiveSet.LINES = 0x0001;\nPrimitiveSet.LINE_LOOP = 0x0002;\nPrimitiveSet.LINE_STRIP = 0x0003;\nPrimitiveSet.TRIANGLES = 0x0004;\nPrimitiveSet.TRIANGLE_STRIP = 0x0005;\nPrimitiveSet.TRIANGLE_FAN = 0x0006;\n\nmodule.exports = PrimitiveSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/primitiveSet.js\n// module id = 46\n// module chunks = 0 1 2","'use strict';\nvar BufferArray = require( 'osg/BufferArray' );\n\n\nvar BufferArrayProxy = function ( bufferArray ) {\n\n    this._initialBufferArray = undefined;\n    this._bufferArray = undefined;\n    if ( bufferArray ) {\n        this.setBufferArray( bufferArray );\n        this.setInitialBufferArray( bufferArray );\n    }\n\n};\n\nvar prototype = {\n    setInitialBufferArray: function ( bufferArray ) {\n        this._initialBufferArray = bufferArray;\n    },\n    getInitialBufferArray: function () {\n        return this._initialBufferArray;\n    },\n    setBufferArray: function ( bufferArray ) {\n        this._bufferArray = bufferArray.getBufferArray ? bufferArray.getBufferArray() : bufferArray;\n    },\n    getBufferArray: function () {\n        return this._bufferArray;\n    }\n};\n\n// adds original method of BufferArray prototype for the proxy for convenient usage\nvar makeFunc = function ( func ) {\n    return function () {\n        return func.apply( this._bufferArray, arguments );\n    };\n};\n\nfor ( var methodName in BufferArray.prototype ) {\n    prototype[ methodName ] = makeFunc( BufferArray.prototype[ methodName ] );\n}\n\nBufferArrayProxy.prototype = prototype;\nmodule.exports = BufferArrayProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BufferArrayProxy.js\n// module id = 47\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar GLObject = require( 'osg/GLObject' );\nvar Timer = require( 'osg/Timer' );\n\n\nvar getAttributeType = function ( array ) {\n    var type;\n\n    if ( array instanceof MACROUTILS.Float32Array ) type = 0x1406;\n    if ( array instanceof MACROUTILS.Uint32Array ) type = 0x1405;\n    if ( array instanceof MACROUTILS.Uint16Array ) type = 0x1403;\n    if ( array instanceof MACROUTILS.Uint8Array ) type = 0x1401;\n\n    return type;\n};\n\n/**\n * BufferArray manage vertex / normal / ... array used by webgl.\n * osgjs automatically converts array buffers to Float32Array and\n * element array buffers to Uint16Array if not said explicitly with\n * preserveArrayType variable in constructor.\n * @class BufferArray\n */\n\nvar BufferArray = function ( target, elements, itemSize, preserveArrayType ) {\n\n    GLObject.call( this );\n    // maybe could inherit from Object\n    this._instanceID = Object.getInstanceID();\n\n    this.dirty();\n\n    this._itemSize = itemSize;\n    this._target = typeof target === 'string' ? BufferArray[ target ] : target;\n\n    // initialized by setElements\n    this._type = undefined;\n    this._normalize = false;\n\n    if ( elements !== undefined ) {\n        var typedArray = elements;\n        if ( !preserveArrayType ) {\n            if ( this._target === BufferArray.ELEMENT_ARRAY_BUFFER ) {\n                typedArray = elements instanceof MACROUTILS.Uint16Array ? elements : new MACROUTILS.Uint16Array( elements );\n            } else {\n                typedArray = elements instanceof MACROUTILS.Float32Array ? elements : new MACROUTILS.Float32Array( elements );\n            }\n        }\n        this.setElements( typedArray );\n    }\n};\n\nBufferArray.ELEMENT_ARRAY_BUFFER = 0x8893;\nBufferArray.ARRAY_BUFFER = 0x8892;\n\n// static cache of glBuffers flagged for deletion, which will actually\n// be deleted in the correct GL context.\nBufferArray._sDeletedGLBufferArrayCache = new window.Map();\n\n// static method to delete Program\nBufferArray.deleteGLBufferArray = function ( gl, buffer ) {\n    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) )\n        BufferArray._sDeletedGLBufferArrayCache.set( gl, [] );\n    BufferArray._sDeletedGLBufferArrayCache.get( gl ).push( buffer );\n};\n\n// static method to flush all the cached glPrograms which need to be deleted in the GL context specified\nBufferArray.flushDeletedGLBufferArrays = function ( gl, availableTime ) {\n    // if no time available don't try to flush objects.\n    if ( availableTime <= 0.0 ) return availableTime;\n    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) ) return availableTime;\n    var elapsedTime = 0.0;\n    var beginTime = Timer.instance().tick();\n    var deleteList = BufferArray._sDeletedGLBufferArrayCache.get( gl );\n    var numBuffers = deleteList.length;\n    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {\n        gl.deleteBuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n    }\n    return availableTime - elapsedTime;\n};\n\nBufferArray.flushAllDeletedGLBufferArrays = function ( gl ) {\n    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) ) return;\n    var deleteList = BufferArray._sDeletedGLBufferArrayCache.get( gl );\n    var numBuffers = deleteList.length;\n    for ( var i = numBuffers - 1; i >= 0; i-- ) {\n        gl.deleteBuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n    }\n};\n\n/** @lends BufferArray.prototype */\nBufferArray.prototype = MACROUTILS.objectInherit( GLObject.prototype, {\n    getInstanceID: function () {\n        return this._instanceID;\n    },\n    setItemSize: function ( size ) {\n        this._itemSize = size;\n    },\n    isValid: function () {\n        if ( this._buffer !== undefined ||\n            this._elements !== undefined ) {\n            return true;\n        }\n        return false;\n    },\n\n    releaseGLObjects: function () {\n        if ( this._buffer !== undefined && this._buffer !== null && this._gl !== undefined ) {\n            BufferArray.deleteGLBufferArray( this._gl, this._buffer );\n        }\n        this._buffer = undefined;\n    },\n\n    setNormalize: function ( normalize ) {\n        this._normalize = normalize;\n    },\n\n    getNormalize: function () {\n        return this._normalize;\n    },\n\n    bind: function ( gl ) {\n        if ( !this._gl ) this.setGraphicContext( gl );\n        var target = this._target;\n        var buffer = this._buffer;\n\n        if ( buffer ) {\n            gl.bindBuffer( target, buffer );\n            return;\n        }\n\n        if ( !buffer && this._elements.length > 0 ) {\n            this._buffer = gl.createBuffer();\n            this._numItems = this._elements.length / this._itemSize;\n            gl.bindBuffer( target, this._buffer );\n        }\n    },\n    getItemSize: function () {\n        return this._itemSize;\n    },\n    dirty: function () {\n        this._dirty = true;\n    },\n    isDirty: function () {\n        return this._dirty;\n    },\n    compile: function ( gl ) {\n        if ( this._dirty ) {\n            MACROUTILS.timeStamp( 'osgjs.metrics:bufferData' );\n            gl.bufferData( this._target, this._elements, gl.STATIC_DRAW );\n            this._dirty = false;\n        }\n    },\n    getElements: function () {\n        return this._elements;\n    },\n    setElements: function ( elements ) {\n        this._elements = elements;\n        this._type = getAttributeType( elements );\n        this._dirty = true;\n    },\n    getType: function () {\n        return this._type;\n    }\n\n} );\n\nmodule.exports = BufferArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BufferArray.js\n// module id = 48\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\n\nvar BillboardAttribute = function () {\n    StateAttribute.call( this );\n    this._attributeEnable = false;\n};\n\nBillboardAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Billboard',\n\n    cloneType: function () {\n        return new BillboardAttribute();\n    },\n\n    setEnabled: function ( state ) {\n        this._attributeEnable = state;\n    },\n\n    isEnabled: function () {\n        return this._attributeEnable;\n    },\n\n    apply: function () {}\n\n} ), 'osg', 'Billboard' );\n\nmodule.exports = BillboardAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BillboardAttribute.js\n// module id = 49\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n/**\n *  Manage BlendColor attribute\n *  @class\n *  @memberOf osg\n *  @extends StateAttribute\n */\nvar BlendColor = function ( color ) {\n    StateAttribute.call( this );\n    this._constantColor = vec4.create();\n    vec4.set( this._constantColor, 1.0, 1.0, 1.0, 1.0 );\n    if ( color !== undefined ) {\n        this.setConstantColor( color );\n    }\n};\n\n/**\n * @lends BlendColor.prototype\n */\nBlendColor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n    attributeType: 'BlendColor',\n    cloneType: function () {\n        return new BlendColor();\n    },\n\n    /**\n     *\n     * @param {} color\n     */\n    setConstantColor: function ( color ) {\n        vec4.copy( this._constantColor, color );\n    },\n    getConstantColor: function () {\n        return this._constantColor;\n    },\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        gl.blendColor( this._constantColor[ 0 ],\n            this._constantColor[ 1 ],\n            this._constantColor[ 2 ],\n            this._constantColor[ 3 ] );\n    }\n} ), 'osg', 'BlendColor' );\n\nmodule.exports = BlendColor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BlendColor.js\n// module id = 50\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\n/**\n *  Manage Blending mode\n *  @class BlendFunc\n */\nvar BlendFunc = function ( sourceRGB, destinationRGB, sourceAlpha, destinationAlpha ) {\n    StateAttribute.call( this );\n    this._sourceFactor = BlendFunc.DISABLE;\n    this._destinationFactor = BlendFunc.DISABLE;\n    this._sourceFactorAlpha = this._sourceFactor;\n    this._destinationFactorAlpha = this._destinationFactor;\n    this._separate = false;\n    if ( sourceRGB !== undefined ) {\n        this.setSource( sourceRGB );\n    }\n    if ( destinationRGB !== undefined ) {\n        this.setDestination( destinationRGB );\n    }\n\n    if ( sourceAlpha !== undefined ) {\n        this.setSourceAlpha( sourceAlpha );\n    }\n    if ( destinationAlpha !== undefined ) {\n        this.setDestinationAlpha( destinationAlpha );\n    }\n};\n\nBlendFunc.DISABLE = -1;\nBlendFunc.ZERO = 0;\nBlendFunc.ONE = 1;\nBlendFunc.SRC_COLOR = 0x0300;\nBlendFunc.ONE_MINUS_SRC_COLOR = 0x0301;\nBlendFunc.SRC_ALPHA = 0x0302;\nBlendFunc.ONE_MINUS_SRC_ALPHA = 0x0303;\nBlendFunc.DST_ALPHA = 0x0304;\nBlendFunc.ONE_MINUS_DST_ALPHA = 0x0305;\nBlendFunc.DST_COLOR = 0x0306;\nBlendFunc.ONE_MINUS_DST_COLOR = 0x0307;\nBlendFunc.SRC_ALPHA_SATURATE = 0x0308;\n\n/* Separate Blend Functions */\nBlendFunc.BLEND_DST_RGB = 0x80C8;\nBlendFunc.BLEND_SRC_RGB = 0x80C9;\nBlendFunc.BLEND_DST_ALPHA = 0x80CA;\nBlendFunc.BLEND_SRC_ALPHA = 0x80CB;\nBlendFunc.CONSTANT_COLOR = 0x8001;\nBlendFunc.ONE_MINUS_CONSTANT_COLOR = 0x8002;\nBlendFunc.CONSTANT_ALPHA = 0x8003;\nBlendFunc.ONE_MINUS_CONSTANT_ALPHA = 0x8004;\nBlendFunc.BLEND_COLOR = 0x8005;\n\n\n/** @lends BlendFunc.prototype */\nBlendFunc.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n    /**\n  StateAttribute type of BlendFunc\n  @type String\n   */\n    attributeType: 'BlendFunc',\n    /**\n    Create an instance of this StateAttribute\n    */\n    cloneType: function () /**BlendFunc*/ {\n        return new BlendFunc();\n    },\n    setSource: function ( f ) {\n        this.setSourceRGB( f );\n        this.setSourceAlpha( f );\n    },\n    getSource: function () {\n        return this._sourceFactor;\n    },\n    setDestination: function ( f ) {\n        this.setDestinationRGB( f );\n        this.setDestinationAlpha( f );\n    },\n    getDestination: function () {\n        return this._destinationFactor;\n    },\n    getSeparate: function () {\n        return this._separate;\n    },\n    checkSeparate: function () {\n        return ( this._sourceFactor !== this._sourceFactorAlpha ||\n            this._destinationFactor !== this._destinationFactorAlpha );\n    },\n    setSourceRGB: function ( f ) {\n        if ( typeof f === 'string' ) {\n            this._sourceFactor = BlendFunc[ f ];\n        } else {\n            this._sourceFactor = f;\n        }\n        this._separate = this.checkSeparate();\n    },\n    getSourceRGB: function () {\n        return this._sourceFactor;\n    },\n    setSourceAlpha: function ( f ) {\n        if ( typeof f === 'string' ) {\n            this._sourceFactorAlpha = BlendFunc[ f ];\n        } else {\n            this._sourceFactorAlpha = f;\n        }\n        this._separate = this.checkSeparate();\n    },\n    getSourceAlpha: function () {\n        return this._sourceFactorAlpha;\n    },\n    setDestinationRGB: function ( f ) {\n        if ( typeof f === 'string' ) {\n            this._destinationFactor = BlendFunc[ f ];\n        } else {\n            this._destinationFactor = f;\n        }\n        this._separate = this.checkSeparate();\n    },\n    getDestinationRGB: function () {\n        return this._destinationFactor;\n    },\n    setDestinationAlpha: function ( f ) {\n        if ( typeof f === 'string' ) {\n            this._destinationFactorAlpha = BlendFunc[ f ];\n        } else {\n            this._destinationFactorAlpha = f;\n        }\n        this._separate = this.checkSeparate();\n    },\n    getDestinationAlpha: function () {\n        return this._destinationFactorAlpha;\n    },\n\n    /**\n      Apply the mode, must be called in the draw traversal\n      @param state\n  */\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        if ( this._sourceFactor === BlendFunc.DISABLE || this._destinationFactor === BlendFunc.DISABLE ) {\n            gl.disable( gl.BLEND );\n        } else {\n            gl.enable( gl.BLEND );\n            if ( this._separate ) {\n                gl.blendFuncSeparate( this._sourceFactor, this._destinationFactor,\n                    this._sourceFactorAlpha, this._destinationFactorAlpha );\n            } else {\n                gl.blendFunc( this._sourceFactor, this._destinationFactor );\n            }\n        }\n    }\n} ), 'osg', 'BlendFunc' );\n\nmodule.exports = BlendFunc;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/BlendFunc.js\n// module id = 51\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Transform = require( 'osg/Transform' );\nvar CullSettings = require( 'osg/CullSettings' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Texture = require( 'osg/Texture' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n\n/**\n * Camera - is a subclass of Transform which represents encapsulates the settings of a Camera.\n * @class Camera\n * @inherits Transform CullSettings\n */\nvar Camera = function () {\n    Transform.call( this );\n    CullSettings.call( this );\n\n    this.viewport = undefined;\n    this._graphicContext = undefined;\n    this.setClearColor( vec4.fromValues( 0, 0, 0, 1.0 ) );\n    this.setClearDepth( 1.0 );\n\n    /*jshint bitwise: false */\n    this.setClearMask( Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT );\n    /*jshint bitwise: true */\n\n    this.setViewMatrix( mat4.create() );\n    this.setProjectionMatrix( mat4.create() );\n    this.renderOrder = Camera.NESTED_RENDER;\n    this.renderOrderNum = 0;\n\n    this._view = undefined;\n    this._renderer = undefined;\n    this._attachments = {};\n};\n\nCamera.PRE_RENDER = 0;\nCamera.NESTED_RENDER = 1;\nCamera.POST_RENDER = 2;\n\nCamera.COLOR_BUFFER_BIT = 0x00004000;\nCamera.DEPTH_BUFFER_BIT = 0x00000100;\nCamera.STENCIL_BUFFER_BIT = 0x00000400;\n\n/** @lends Camera.prototype */\nCamera.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit(\n    CullSettings.prototype,\n    MACROUTILS.objectInherit( Transform.prototype, {\n        // at which view this camera is attached\n        getView: function () {\n            return this._view;\n        },\n\n        setView: function ( view ) {\n            this._view = view;\n        },\n\n        getRenderer: function () {\n            return this._renderer;\n        },\n\n        setRenderer: function ( renderer ) {\n            this._renderer = renderer;\n        },\n\n        // Set the final draw callback for custom operations\n        // to be done after the drawing of\n        // the camera's subgraph and pre render stages.\n        setFinalDrawCallback: function ( cb ) {\n\n            this._finalDrawCallback = cb;\n\n        },\n\n        getFinalDrawCallback: function () {\n\n            return this._finalDrawCallback;\n\n        },\n\n        // Set the initial draw callback for custom operations\n        // to be done before the drawing of\n        // the camera's subgraph and pre render stages.\n        setInitialDrawCallback: function ( cb ) {\n\n            this._initialDrawCallback = cb;\n\n        },\n\n        getInitialDrawCallback: function () {\n\n            return this._initialDrawCallback;\n\n        },\n\n\n        getAttachments: function () {\n            return this._attachments;\n        },\n\n        setGraphicContext: function ( gc ) {\n            this._graphicContext = gc;\n        },\n        getGraphicContext: function () {\n            return this._graphicContext;\n        },\n        setClearDepth: function ( depth ) {\n            this.clearDepth = depth;\n        },\n        getClearDepth: function () {\n            return this.clearDepth;\n        },\n\n        setClearMask: function ( mask ) {\n            this.clearMask = mask;\n        },\n        getClearMask: function () {\n            return this.clearMask;\n        },\n\n        setClearColor: function ( color ) {\n            this.clearColor = color;\n        },\n        getClearColor: function () {\n            return this.clearColor;\n        },\n\n        setViewport: function ( vp ) {\n            this.viewport = vp;\n            this.getOrCreateStateSet().setAttributeAndModes( vp );\n        },\n        getViewport: function () {\n            return this.viewport;\n        },\n\n\n        setViewMatrix: function ( matrix ) {\n            this.modelviewMatrix = matrix;\n        },\n        setViewMatrixAsLookAt: function ( eye, center, up ) {\n            mat4.lookAt( this.getViewMatrix(), eye, center, up );\n        },\n        setProjectionMatrix: function ( matrix ) {\n            this.projectionMatrix = matrix;\n        },\n\n        /** Set to an orthographic projection. See OpenGL glOrtho for documentation further details.*/\n        setProjectionMatrixAsOrtho: function ( left, right,\n            bottom, top,\n            zNear, zFar ) {\n            mat4.ortho( this.getProjectionMatrix(), left, right, bottom, top, zNear, zFar );\n        },\n        isRenderToTextureCamera: function () {\n            return window.Object.keys( this._attachments ).length > 0;\n        },\n\n        getViewMatrix: function () {\n            return this.modelviewMatrix;\n        },\n        getProjectionMatrix: function () {\n            return this.projectionMatrix;\n        },\n        getRenderOrder: function () {\n            return this.renderOrder;\n        },\n        setRenderOrder: function ( order, orderNum ) {\n            this.renderOrder = order;\n            this.renderOrderNum = orderNum;\n        },\n\n        detachAll: function () {\n            this._attachments = {};\n\n            if ( this.frameBufferObject ) {\n                this.frameBufferObject.dirty();\n            }\n        },\n\n        // TODO: fix in case of shared fbo\n        // TODO: fix adding a resize case\n        resetAttachments: function () {\n\n\n            if ( this.frameBufferObject ) {\n\n                this.frameBufferObject.reset();\n                // remove framebuffer\n                this.frameBufferObject = 0;\n            }\n\n            // removes camera attachement\n            this._attachments = {};\n\n        },\n\n        attachTexture: function ( bufferComponent, texture, textureTarget ) {\n            if ( this.frameBufferObject ) {\n                this.frameBufferObject.dirty();\n            }\n\n            // because before the argument was level and the spec says\n            // it must always be 0 ! is valid for 0 or undefined\n            if ( !textureTarget ) {\n                textureTarget = Texture.TEXTURE_2D;\n            }\n\n            this._attachments[ bufferComponent ] = {\n                'attachment': bufferComponent,\n                'texture': texture,\n                'textureTarget': textureTarget\n            };\n        },\n\n        attachRenderBuffer: function ( bufferComponent, internalFormat ) {\n            if ( this.frameBufferObject ) {\n                this.frameBufferObject.dirty();\n            }\n            this._attachments[ bufferComponent ] = {\n                'format': internalFormat,\n                'attachment': bufferComponent\n            };\n        },\n\n        computeLocalToWorldMatrix: function ( matrix /*,nodeVisitor*/ ) {\n            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n                mat4.mul( matrix, matrix, this.modelviewMatrix );\n            } else { // absolute\n                mat4.copy( matrix, this.modelviewMatrix );\n            }\n            return true;\n        },\n\n        computeWorldToLocalMatrix: ( function () {\n            var minverse = mat4.create();\n            return function ( matrix /*, nodeVisitor */ ) {\n                mat4.invert( minverse, this.modelviewMatrix );\n                if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n                    mat4.mul( matrix, minverse, matrix );\n                } else {\n                    mat4.copy( matrix, minverse );\n                }\n                return true;\n            };\n        } )()\n\n    } ) ), 'osg', 'Camera' );\n\nMACROUTILS.setTypeID( Camera );\n\nmodule.exports = Camera;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Camera.js\n// module id = 52\n// module chunks = 0 1 2","'use strict';\n\n\nvar CullSettings = function () {\n\n    // Not doing a this.reset()\n    // because of multiple inheritance\n    // it will call the wrong reset\n    // cullstack reset for isntance()\n    CullSettings.prototype.reset.call( this );\n\n};\n\nCullSettings.prototype = {\n    reset: function () {\n\n        this._computeNearFar = true;\n        this._nearFarRatio = 0.005;\n\n        // Magic numbers 3 & 4\n        this.bbCornerFar = 3;\n        this.bbCornerNear = 4;\n        // see code below for for the\n        // Code simplification origin\n        // var vec3 = require( 'osg/glMatrix' ).vec3;\n        // var lookVector = vec3.fromValues( 0.0, 0.0, -1.0 );\n        // /*jshint bitwise: false */\n        // this.bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\n        // this.bbCornerNear = ( ~this.bbCornerFar ) & 7;\n        // /*jshint bitwise: true */\n        // is equivalent to\n\n        this._enableFrustumCulling = false;\n\n        // who sets the parameter\n        // if it's cullvisitor\n        // it's an OVERRIDER for enableFrustumCulling\n        // allowing for global EnableFrustimCulling\n        this._settingsSourceOverrider = this;\n        //LOD bias for the CullVisitor to use\n        this._LODScale = 1.0;\n        // Custom clampProjectionMatrix\n        this._clampProjectionMatrixCallback = undefined;\n    },\n\n    setCullSettings: function ( settings ) {\n        this._computeNearFar = settings._computeNearFar;\n        this._nearFarRatio = settings._nearFarRatio;\n        this._enableFrustumCulling = settings._enableFrustumCulling;\n        this._settingsSourceOverrider = settings._settingsSourceOverrider;\n        this._clampProjectionMatrixCallback = settings._clampProjectionMatrixCallback;\n    },\n\n    setNearFarRatio: function ( ratio ) {\n        this._nearFarRatio = ratio;\n    },\n    getNearFarRatio: function () {\n        return this._nearFarRatio;\n    },\n    setComputeNearFar: function ( value ) {\n        this._computeNearFar = value;\n    },\n    getComputeNearFar: function () {\n        return this._computeNearFar;\n    },\n\n    setEnableFrustumCulling: function ( value ) {\n        this._enableFrustumCulling = value;\n    },\n    getEnableFrustumCulling: function () {\n        return this._enableFrustumCulling;\n    },\n\n    getSettingSourceOverrider: function () {\n        return this._settingsSourceOverrider;\n    },\n\n    setClampProjectionMatrixCallback: function ( callback ) {\n        this._clampProjectionMatrixCallback = callback;\n    },\n\n    getClampProjectionMatrixCallback: function () {\n        return this._clampProjectionMatrixCallback;\n    },\n\n    setLODScale: function ( scale ) {\n        this._LODScale = scale;\n    },\n    getLODScale: function () {\n        return this._LODScale;\n    }\n\n};\n\nmodule.exports = CullSettings;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/CullSettings.js\n// module id = 53\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\n\nvar ColorMask = function ( red, green, blue, alpha ) {\n\n    StateAttribute.call( this );\n\n    this._colorMask = [ true, true, true, true ];\n    this.setMask( red, green, blue, alpha );\n};\n\nColorMask.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'ColorMask',\n\n    cloneType: function () {\n        return new ColorMask();\n    },\n\n    setMask: function ( red, green, blue, alpha ) {\n\n        if ( red !== undefined &&\n            green !== undefined &&\n            blue !== undefined &&\n            alpha !== undefined ) {\n\n            this._colorMask[ 0 ] = red;\n            this._colorMask[ 1 ] = green;\n            this._colorMask[ 2 ] = blue;\n            this._colorMask[ 3 ] = alpha;\n        }\n    },\n\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        var colorMask = this._colorMask;\n        gl.colorMask( colorMask[ 0 ], colorMask[ 1 ], colorMask[ 2 ], colorMask[ 3 ] );\n    }\n\n} ), 'osg', 'ColorMask' );\n\nmodule.exports = ColorMask;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/ColorMask.js\n// module id = 54\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\n\n/**\n *  Manage CullFace attribute\n *  @class CullFace\n */\nvar CullFace = function ( mode ) {\n    StateAttribute.call( this );\n    this.setMode( mode !== undefined ? mode : CullFace.BACK );\n};\n\nCullFace.DISABLE = 0x0;\nCullFace.FRONT = 0x0404;\nCullFace.BACK = 0x0405;\nCullFace.FRONT_AND_BACK = 0x0408;\n\n/** @lends CullFace.prototype */\nCullFace.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'CullFace',\n\n    cloneType: function () {\n        return new CullFace();\n    },\n\n    setMode: function ( mode ) {\n        var value = mode;\n        if ( typeof value === 'string' ) value = CullFace[ value ];\n        this._mode = value;\n    },\n\n    getMode: function () {\n        return this._mode;\n    },\n\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        if ( this._mode === CullFace.DISABLE ) {\n            gl.disable( gl.CULL_FACE );\n        } else {\n            gl.enable( gl.CULL_FACE );\n            gl.cullFace( this._mode );\n        }\n\n    }\n} ), 'osg', 'CullFace' );\n\nmodule.exports = CullFace;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/CullFace.js\n// module id = 55\n// module chunks = 0 1 2","'use strict';\nvar Polytope = require( 'osg/Polytope' );\n\nvar CullingSet = function () {\n\n    this._mask = CullingSet.DEFAULT_CULLING;\n    this._frustum = new Polytope();\n\n};\n\nCullingSet.prototype = {\n\n    reset: function () {\n        this._mask = CullingSet.DEFAULT_CULLING;\n        this._frustum.clear();\n    },\n    setCullingMask: function ( mask ) {\n        this._mask = mask;\n    },\n    getCullingMask: function () {\n        return this._mask;\n    },\n    setFrustum: function ( frustum ) {\n        this._frustum = frustum;\n    },\n    getFrustum: function () {\n        return this._frustum;\n    },\n    getCurrentResultMask: function () {\n        return this._frustum.getCurrentMask();\n    },\n    pushCurrentMask: function () {\n        this._frustum.pushCurrentMask();\n    },\n    popCurrentMask: function () {\n        this._frustum.popCurrentMask();\n    },\n    resetCullingMask: function () {\n        this._frustum.setResultMask( this._frustum.getCurrentMask() );\n    },\n    isBoundingBoxCulled: function ( bbox ) {\n        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {\n            // is it outside the view frustum...\n            if ( !this._frustum.containsBoundingBox( bbox ) ) return true;\n        }\n        return false;\n    },\n    isBoundingSphereCulled: function ( bs ) {\n        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {\n            // is it outside the view frustum...\n            if ( !this._frustum.containsBoundingSphere( bs ) ) return true;\n        }\n        return false;\n    },\n    isVerticesCulled: function ( vertices ) {\n        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {\n            // is it outside the view frustum...\n            if ( !this._frustum.containsVertices( vertices ) ) return true;\n        }\n        return false;\n    }\n};\n\nCullingSet.NO_CULLING = 0x0;\n\nCullingSet.VIEW_FRUSTUM_LEFT_CULLING = 0x1;\nCullingSet.VIEW_FRUSTUM_RIGHT_CULLING = 0x2;\nCullingSet.VIEW_FRUSTUM_TOP_CULLING = 0x3;\nCullingSet.VIEW_FRUSTUM_BOTTOM_CULLING = 0x4;\nCullingSet.NEAR_PLANE_CULLING = 0x5;\nCullingSet.FAR_PLANE_CULLING = 0x6;\n\nCullingSet.VIEW_FRUSTUM_SIDES_CULLING = CullingSet.VIEW_FRUSTUM_LEFT_CULLING | CullingSet.VIEW_FRUSTUM_RIGHT_CULLING | CullingSet.VIEW_FRUSTUM_BOTTOM_CULLING | CullingSet.VIEW_FRUSTUM_TOP_CULLING;\n\nCullingSet.VIEW_FRUSTUM_CULLING = CullingSet.VIEW_FRUSTUM_SIDES_CULLING | CullingSet.NEAR_PLANE_CULLING | CullingSet.FAR_PLANE_CULLING;\n\nCullingSet.DEFAULT_CULLING = CullingSet.VIEW_FRUSTUM_SIDES_CULLING;\n\nCullingSet.ENABLE_ALL_CULLING = CullingSet.VIEW_FRUSTUM_CULLING;\n\nmodule.exports = CullingSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/CullingSet.js\n// module id = 56\n// module chunks = 0 1 2","'use strict';\nvar Object = require( 'osg/Object' );\nvar Plane = require( 'osg/Plane' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n/*jshint bitwise: false */\n/**\n * Polytope class for representing convex clipping volumes made up of a set of planes.\n * When adding planes, their normals should point inwards (into the volume)\n * @class Polytope\n */\nvar Polytope = function () {\n\n    this._clippingMask = 0x0;\n\n    this._planeList = [ Plane.create(), Plane.create(), Plane.create(), Plane.create(), Plane.create(), Plane.create() ];\n    this._vertexList = [];\n\n    // stack of clipping masks\n    this._maskStack = [];\n\n    // init with a clear mask\n    this._resultMask = 0;\n    this._maskStack.push( this._resultMask );\n};\n\nPolytope.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n\n    getPlanes: function () {\n        return this._planeList;\n    },\n\n    setPlanes: function ( pl ) {\n        this._planeList = pl;\n        this.setupMask();\n    },\n\n    clear: function () {\n\n        this._clippingMask = 0x0;\n        if ( this._planeList ) {\n            for ( var i = 0, l = this._planeList.length; i < l; ++i ) {\n                Plane.init( this._planeList[ i ] );\n            }\n        }\n        this._vertexList = [];\n        this.setupMask();\n\n    },\n\n    /** Create a Polytope which is a cube, centered at 0,0,0, with sides of 2 units.*/\n    setToUnitFrustum: function ( withNear, withFar ) {\n        if ( withNear === undefined ) withNear = true;\n\n        if ( withFar === undefined ) withFar = true;\n\n        this._planeList.length = 0;\n        this._planeList.push( vec4.set( Plane.create(), 1.0, 0.0, 0.0, 1.0 ) ); // left plane.\n        this._planeList.push( vec4.set( Plane.create(), -1.0, 0.0, 0.0, 1.0 ) ); // right plane.\n        this._planeList.push( vec4.set( Plane.create(), 0.0, 1.0, 0.0, 1.0 ) ); // bottom plane.\n        this._planeList.push( vec4.set( Plane.create(), 0.0, -1.0, 0.0, 1.0 ) ); // top plane.\n        if ( withNear ) this._planeList.push( vec4.set( Plane.create(), 0.0, 0.0, 1.0, 1.0 ) ); // near plane\n        if ( withFar ) this._planeList.push( vec4.set( Plane.create(), 0.0, 0.0, -1.0, 1.0 ) ); // far plane\n        this.setupMask();\n    },\n\n\n    /** Create a Polytope which is a equivalent to BoundingBox.*/\n    setToBoundingBox: function ( bb ) {\n        this._planeList.length = 0;\n        this._planeList.push( vec4.set( Plane.create(), 1.0, 0.0, 0.0, -bb.getMin()[ 0 ] ) ); // left plane.\n        this._planeList.push( vec4.set( Plane.create(), -1.0, 0.0, 0.0, bb.getMax()[ 0 ] ) ); // right plane.\n        this._planeList.push( vec4.set( Plane.create(), 0.0, 1.0, 0.0, -bb.getMin()[ 1 ] ) ); // bottom plane.\n        this._planeList.push( vec4.set( Plane.create(), 0.0, -1.0, 0.0, bb.getMax()[ 1 ] ) ); // top plane.\n        this._planeList.push( vec4.set( Plane.create(), 0.0, 0.0, 1.0, -bb.getMin()[ 2 ] ) ); // near plane\n        this._planeList.push( vec4.set( Plane.create(), 0.0, 0.0, -1.0, bb.getMax()[ 2 ] ) ); // far plane\n        this.setupMask();\n    },\n\n    setAndTransformProvidingInverse: function ( pt, matrix ) {\n        this._referenceVertexList = pt._referenceVertexList;\n        var resultMask = pt._maskStack[ this._maskStack.length - 1 ];\n        if ( resultMask === 0 ) {\n            this._maskStack[ this._maskStack.length - 1 ] = 0;\n            this._resultMask = 0;\n            this._planeList.length = 0;\n            return;\n        }\n        var selectorMask = 0x1;\n\n        var numActivePlanes = 0;\n        // count number of active planes.\n        var i;\n        for ( i = 0; i !== pt._planeList.length; ++i ) {\n            if ( resultMask & selectorMask ) ++numActivePlanes;\n            selectorMask <<= 1;\n        }\n\n        this._planeList.length = numActivePlanes;\n        this._resultMask = 0;\n        selectorMask = 0x1;\n        var index = 0;\n        for ( i = 0; i !== pt._planeList.length; ++i ) {\n            if ( resultMask & selectorMask ) {\n                this._planeList[ index ] = pt._planeList[ i ];\n                Plane.transformProvidingInverse( this._planeList[ index++ ], matrix );\n                this._resultMask = ( this._resultMask << 1 ) | 1;\n            }\n            selectorMask <<= 1;\n        }\n\n        this._maskStack[ this._maskStack.length - 1 ] = this._resultMask;\n    },\n\n    voidset: function ( pl ) {\n        this._planeList = pl;\n        this.setupMask();\n    },\n\n\n    add: function ( pl ) {\n        this._planeList.push( pl );\n        this.setupMask();\n    },\n\n    empty: function () {\n        return this._planeList.length === 0;\n    },\n\n    getPlaneList: function () {\n        return this._planeList;\n    },\n\n    setReferenceVertexList: function ( vertices ) {\n        this._referenceVertexList = vertices;\n    },\n\n    getReferenceVertexList: function () {\n        return this._referenceVertexList;\n    },\n\n    setupMask: function ( plength ) {\n        this._resultMask = 0;\n        var pMasklength = ( plength !== undefined ) ? plength : this._planeList.length;\n        for ( var i = 0; i < pMasklength; ++i ) {\n            this._resultMask = ( this._resultMask << 1 ) | 1;\n        }\n        this._maskStack = [];\n        this._maskStack.push( this._resultMask );\n    },\n\n    getCurrentMask: function () {\n        return this._maskStack[ this._maskStack.length - 1 ];\n    },\n\n    setResultMask: function ( mask ) {\n        this._resultMask = mask;\n    },\n\n    getResultMask: function () {\n        return this._resultMask;\n    },\n\n    getMaskStack: function () {\n        return this._maskStack;\n    },\n\n\n    // push but keep current mask\n    pushCurrentMask: function () {\n        this._maskStack.push( this._resultMask );\n    },\n    // pop and restore previous mask\n    popCurrentMask: function () {\n        return this._maskStack.pop();\n    },\n\n\n    /** Check whether a vertex is contained within clipping set.*/\n    containsVertex: function ( v ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;\n\n        var selectorMask = 0x1;\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( ( this._maskStack[ this._maskStack.length - 1 ] & selectorMask ) && ( Plane.distanceToPlane( this._planeList[ i ], v ) < 0.0 ) ) {\n                return false;\n            }\n            selectorMask <<= 1;\n        }\n        return true;\n    },\n\n    /** Check whether any part of vertex list is contained within clipping set.*/\n    containsVertices: function ( vertices ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n\n        for ( var k = 0; k < vertices.length; ++k ) {\n            var v = vertices[ k ];\n            var outside = false;\n            var selectorMask = 0x1;\n            for ( var i = 0; !outside && i < this._planeList.length; ++i ) {\n                if ( ( this._maskStack[ this._maskStack.length - 1 ] & selectorMask ) && ( Plane.distanceToPlane( this._planeList[ i ], v ) < 0.0 ) ) {\n                    outside = true;\n                }\n                selectorMask <<= 1;\n            }\n\n            if ( !outside ) return true;\n        }\n        return false;\n    },\n\n    /** Check whether any part of a bounding sphere is contained within clipping set.\n        Using a mask to determine which planes should be used for the check, and\n        modifying the mask to turn off planes which wouldn't contribute to clipping\n        of any internal objects.  This feature is used in osgUtil::CullVisitor\n        to prevent redundant plane checking.*/\n    containsBoundingSphere: function ( bs ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] || !bs.valid() ) return true;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                var res = Plane.intersectsOrContainsBoundingSphere( this._planeList[ i ], bs );\n                if ( Plane.OUTSIDE === res ) {\n                    // totally outside a clipping set.\n                    return false;\n                } else if ( Plane.INSIDE === res ) {\n                    // subsequent checks against this plane not required.\n                    this._resultMask ^= selectorMask;\n                }\n                // else if ( Plane.INTERSECT === res ) { // last possible case\n                //   can say nothing.\n                // subsequent checks against this plane needed.\n                //}\n            }\n            selectorMask <<= 1;\n        }\n        return true;\n    },\n\n    /** Check whether any part of a bounding box is contained within clipping set.\n        Using a mask to determine which planes should be used for the check, and\n        modifying the mask to turn off planes which wouldn't contribute to clipping\n        of any internal objects.  This feature is used in osgUtil::CullVisitor\n        to prevent redundant plane checking.*/\n    containsBoundingBox: function ( bb ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                var res = Plane.intersectsOrContainsBoundingBox( this._planeList[ i ], bb );\n                if ( Plane.OUTSIDE === res ) return false; // outside clipping set.\n                else if ( Plane.INSIDE === res ) this._resultMask ^= selectorMask; // subsequent checks against this plane not required.\n                // else if ( Plane.INTERSECT === res ) the last case need\n                // no test here but further tests\n            }\n            selectorMask <<= 1;\n        }\n        // correct frustum culling should double check now for\n        // http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n        // which is inside one \"plane\", but outside the convex plane intersection\n        return true;\n    },\n\n    /** Check whether all of vertex list is contained with clipping set.*/\n    containsAllOfVertices: function ( vertices ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                var res = Plane.intersectsOrContainsVertices( this._planeList[ i ], vertices );\n                if ( res < 1 ) return false; // intersects, or is below plane.\n                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.\n            }\n            selectorMask <<= 1;\n        }\n        return true;\n    },\n\n    /** Check whether the entire bounding sphere is contained within clipping set.*/\n    containsAllOfBoundingSphere: function ( bs ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                var res = Plane.intersectsOrContainsBoundingSphere( this._planeList[ i ], bs );\n                if ( res < 1 ) return false; // intersects, or is below plane.\n                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.\n            }\n            selectorMask <<= 1;\n        }\n        return true;\n    },\n\n    /** Check whether the entire bounding box is contained within clipping set.*/\n    containsAllOfBoundingBox: function ( bbox ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                var res = Plane.intersectsOrContainsBoundingBox( this._planeList[ i ], bbox );\n                if ( res < 1 ) return false; // intersects, or is below plane.\n                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.\n            }\n            selectorMask <<= 1;\n        }\n        return true;\n    },\n\n    /** Transform the clipping set by provide a pre inverted matrix.\n     * see transform for details. */\n    transformProvidingInverse: function ( matrix ) {\n        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return;\n\n        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];\n        var selectorMask = 0x1;\n        for ( var i = 0; i < this._planeList.length; ++i ) {\n            if ( this._resultMask & selectorMask ) {\n                Plane.transformProvidingInverse( this._planeList[ i ], matrix );\n                selectorMask <<= 1;\n            }\n        }\n    }\n\n\n\n} );\n\n/*jshint bitwise: true */\n\nmodule.exports = Polytope;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Polytope.js\n// module id = 57\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n\n/** @class Plane Operations */\nvar Plane = MACROUTILS.objectInherit( vec4, {\n    // Many case (frustum, convexity)\n    // needs to know where from a plane it stands,\n    // not just boolean intersection\n    INSIDE: 1,\n    INTERSECT: 2,\n    OUTSIDE: 3,\n    /* Transform the plane */\n    transformProvidingInverse: function () {\n        var iplane = Plane.create();\n        return function ( p, m ) {\n            //Matrix.transformVec4PostMult( matrix, plane, iplane );\n            var x = p[ 0 ];\n            var y = p[ 1 ];\n            var z = p[ 2 ];\n            var w = p[ 3 ];\n\n            iplane[ 0 ] = m[ 0 ] * x + m[ 1 ] * y + m[ 2 ] * z + m[ 3 ] * w;\n            iplane[ 1 ] = m[ 4 ] * x + m[ 5 ] * y + m[ 6 ] * z + m[ 7 ] * w;\n            iplane[ 2 ] = m[ 8 ] * x + m[ 9 ] * y + m[ 10 ] * z + m[ 11 ] * w;\n            iplane[ 3 ] = m[ 12 ] * x + m[ 13 ] * y + m[ 14 ] * z + m[ 15 ] * w;\n\n            Plane.normalizeEquation( iplane );\n            Plane.copy( iplane, p );\n            return p;\n        };\n    },\n\n    normalizeEquation: function ( plane ) {\n        // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.\n        var inv = 1.0 / Math.sqrt( plane[ 0 ] * plane[ 0 ] + plane[ 1 ] * plane[ 1 ] + plane[ 2 ] * plane[ 2 ] );\n        plane[ 0 ] *= inv;\n        plane[ 1 ] *= inv;\n        plane[ 2 ] *= inv;\n        plane[ 3 ] *= inv;\n    },\n    /*only the normal Component*/\n    getNormal: function ( plane, result ) {\n        result[ 0 ] = plane[ 0 ];\n        result[ 1 ] = plane[ 1 ];\n        result[ 2 ] = plane[ 2 ];\n        return result;\n    },\n    setNormal: function ( plane, normal ) {\n        plane[ 0 ] = normal[ 0 ];\n        plane[ 1 ] = normal[ 1 ];\n        plane[ 2 ] = normal[ 2 ];\n    },\n    /* only the distance getter*/\n    getDistance: function ( plane ) {\n        return plane[ 3 ];\n    },\n    setDistance: function ( plane, distance ) {\n        plane[ 3 ] = distance;\n    },\n\n    /* using the plane equation, compute distance to plane of a point*/\n    distanceToPlane: function ( plane, position ) {\n        return vec3.dot( plane, position ) + plane[ 3 ];\n    },\n\n\n    intersectsOrContainsBoundingSphere: function ( plane, bSphere ) {\n        if ( !bSphere.valid() ) return Plane.OUTSIDE;\n        var position = bSphere.center();\n        var radius = bSphere.radius();\n        var d = this.distanceToPlane( plane, position );\n        if ( d < -radius ) {\n            return Plane.OUTSIDE;\n        } else if ( d <= radius ) {\n            return Plane.INTERSECT;\n        }\n        return Plane.INSIDE;\n    },\n\n    instersectsBoundingSphere: function ( plane, bSphere ) {\n        return this.intersectsOrContainsBoundingSphere( plane, bSphere ) === Plane.INTERSECT;\n    },\n\n    // absPlane optional paramter is an optimisation for the\n    // DOD case: on plane, many bounding boxes\n    intersectsOrContainsBoundingBox: function () {\n        var center = vec3.create();\n        var extent = vec3.create();\n        var absTemp = vec3.create();\n        return function ( plane, bbox, absPlane ) {\n            vec3.add( center, bbox.getMax(), bbox.getMin() );\n            vec3.scale( center, center, 0.5 );\n\n            vec3.sub( center, bbox.getMax(), bbox.getMin() );\n            vec3.scale( extent, extent, 0.5 );\n\n            var d = vec3.dot( center, plane );\n            if ( !absPlane ) {\n                absPlane = absTemp;\n                absPlane[ 0 ] = Math.abs( plane[ 0 ] );\n                absPlane[ 1 ] = Math.abs( plane[ 1 ] );\n                absPlane[ 2 ] = Math.abs( plane[ 2 ] );\n            }\n            var r = vec3.dot( extent, absPlane );\n            if ( d + r > 0 ) return Plane.INTERSECT; // partially inside\n            if ( d - r >= 0 ) return Plane.INSIDE; // fully inside\n            return Plane.OUTSIDE;\n        };\n    },\n\n    intersectsBoundingBox: function ( plane, bbox, absPlane ) {\n        return this.intersectsOrContainsBoundingBox( plane, bbox, absPlane ) === Plane.INTERSECT;\n    },\n\n    intersectOrContainsVertices: function ( plane, vertices ) {\n        var side = -1;\n        // all points must be on one side only\n        for ( var i = 0; i < vertices.length; i++ ) {\n            var d = this.distanceToPlane( plane, vertices[ i ] );\n            if ( d < 0.0 ) {\n                if ( side === 1 ) return Plane.INTERSECT;\n                side = 2;\n            } else if ( d > 0.0 ) {\n                if ( side === 2 ) return Plane.INTERSECT;\n                side = 1;\n            } else { //if ( d === 0.0 )\n                return Plane.INTERSECT;\n            }\n        }\n        return ( side > 0 ) ? Plane.INSIDE : Plane.OUTSIDE;\n\n    },\n    intersectVertices: function ( plane, vertices ) {\n        return this.intersectOrContainsVertices( plane, vertices ) === Plane.INTERSECT;\n    }\n\n\n} );\n\nmodule.exports = Plane;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Plane.js\n// module id = 58\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar BoundingSphere = require( 'osg/BoundingSphere' );\nvar Camera = require( 'osg/Camera' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\nvar CullSettings = require( 'osg/CullSettings' );\nvar CullingSet = require( 'osg/CullingSet' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Plane = require( 'osg/Plane' );\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar Transform = require( 'osg/Transform' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\nvar CullStack = function () {\n\n    this._modelViewMatrixStack = [];\n    this._projectionMatrixStack = [];\n    this._viewportStack = [];\n    this._cullingSetStack = [];\n    this._frustumVolume = -1.0;\n    this._bbCornerFar = 0;\n    this._bbCornerNear = 0;\n\n    // keep a matrix in memory to avoid to create matrix\n    this._reservedMatrixStack = new MatrixMemoryPool();\n\n    this._reserveCullingSetStack = [\n        new CullingSet()\n    ];\n    this._reserveCullingSetStack.current = 0;\n\n\n    // data for caching camera matrix inverse for computation of world/view\n    // contains index of the camera node in the nodepath\n    this._cameraIndexStack = [];\n    // contains index of the camera modelview matrix in the modelViewMatrixStack\n    this._cameraModelViewIndexStack = [];\n\n    // contains the id has a key to computed Inverse Matrix\n    this._cameraMatrixInverse = [];\n    this._cameraMatrixInverseRoot = undefined;\n\n};\n\nCullStack.prototype = MACROUTILS.objectInherit( CullSettings.prototype, {\n\n    _getReservedCullingSet: function () {\n        var m = this._reserveCullingSetStack[ this._reserveCullingSetStack.current++ ];\n        if ( this._reserveCullingSetStack.current === this._reserveCullingSetStack.length ) {\n            this._reserveCullingSetStack.push( new CullingSet() );\n        }\n        return m;\n    },\n    reset: function () {\n        this._modelViewMatrixStack.length = 0;\n        this._projectionMatrixStack.length = 0;\n        this._cullingSetStack.length = 0;\n\n        this._reservedMatrixStack.reset();\n        this._reserveCullingSetStack.current = 0;\n\n        this._cameraModelViewIndexStack.length = 0;\n        this._cameraIndexStack.length = 0;\n        this._cameraMatrixInverse.length = 0;\n        this._cameraMatrixInverseRoot = undefined;\n    },\n\n    getProjectionMatrixStack: function () {\n        return this._projectionMatrixStack;\n    },\n    getCurrentProjectionMatrix: function () {\n        return this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\n    },\n\n    getCurrentModelViewMatrix: function () {\n        return this._modelViewMatrixStack[ this._modelViewMatrixStack.length - 1 ];\n    },\n\n    getCameraInverseMatrix: function () {\n\n        // Return or compute and cache the MatrixInverse of the last\n        // active camera in absolute reference\n\n        // if no index the camera inverse is the root with an fake id\n        if ( !this._cameraIndexStack.length )\n            return this._cameraMatrixInverseRoot;\n\n        var idx = this._cameraIndexStack[ this._cameraIndexStack.length - 1 ];\n\n        // get the camera node\n        var camera = this.getNodePath()[ idx ];\n        var id = camera.getInstanceID();\n\n        if ( this._cameraMatrixInverse[ id ] === undefined ) {\n            var indexInModelViewMatrixStack = this._cameraModelViewIndexStack[ this._cameraModelViewIndexStack.length - 1 ];\n            var mat = this._modelViewMatrixStack[ indexInModelViewMatrixStack ];\n            var matInverse = this._reservedMatrixStack.get();\n            mat4.invert( matInverse, mat );\n            this._cameraMatrixInverse[ id ] = matInverse;\n        }\n        return this._cameraMatrixInverse[ id ];\n    },\n\n    getCurrentModelMatrix: function () {\n        // Improvment could be to cache more things\n        // and / or use this method only if the shader use it\n        var invMatrix = this.getCameraInverseMatrix();\n        var m = this._reservedMatrixStack.get();\n        var world = mat4.mul( m, invMatrix, this.getCurrentModelViewMatrix() );\n        return world;\n    },\n\n    getCurrentViewMatrix: function () {\n        // Improvment could be to cache more things\n        // and / or use this method only if the shader use it\n        if ( !this._cameraIndexStack.length )\n            return this._modelViewMatrixStack[ 0 ];\n\n        // also we could keep the index of the current to avoid lenght-1 at each access\n        // it's implemented in osg like that:\n        // https://github.com/openscenegraph/osg/blob/master/include/osg/fast_back_stack\n        var idx = this._cameraModelViewIndexStack[ this._cameraModelViewIndexStack.length - 1 ];\n        return this._modelViewMatrixStack[ idx ];\n    },\n\n    getViewport: function () {\n        if ( this._viewportStack.length === 0 ) {\n            return undefined;\n        }\n        return this._viewportStack[ this._viewportStack.length - 1 ];\n    },\n    getLookVectorLocal: function ( outLookVector ) {\n        var lookVectorLocal = this.getCurrentModelViewMatrix();\n        return vec3.set( outLookVector, -lookVectorLocal[ 2 ], -lookVectorLocal[ 6 ], -lookVectorLocal[ 10 ] );\n    },\n    pushViewport: function ( vp ) {\n        this._viewportStack.push( vp );\n    },\n    popViewport: function () {\n        this._viewportStack.pop();\n    },\n\n    getFrustumPlanes: ( function () {\n\n        var mvp = mat4.create();\n\n        return function ( out, projection, view, withNearFar ) {\n            mat4.mul( mvp, projection, view );\n\n            var computeNearFar = !!withNearFar;\n\n            // Right clipping plane.\n            var right = out[ 0 ];\n            right[ 0 ] = mvp[ 3 ] - mvp[ 0 ];\n            right[ 1 ] = mvp[ 7 ] - mvp[ 4 ];\n            right[ 2 ] = mvp[ 11 ] - mvp[ 8 ];\n            right[ 3 ] = mvp[ 15 ] - mvp[ 12 ];\n\n            // Left clipping plane.\n            var left = out[ 1 ];\n            left[ 0 ] = mvp[ 3 ] + mvp[ 0 ];\n            left[ 1 ] = mvp[ 7 ] + mvp[ 4 ];\n            left[ 2 ] = mvp[ 11 ] + mvp[ 8 ];\n            left[ 3 ] = mvp[ 15 ] + mvp[ 12 ];\n\n            // Bottom clipping plane.\n            var bottom = out[ 2 ];\n            bottom[ 0 ] = mvp[ 3 ] + mvp[ 1 ];\n            bottom[ 1 ] = mvp[ 7 ] + mvp[ 5 ];\n            bottom[ 2 ] = mvp[ 11 ] + mvp[ 9 ];\n            bottom[ 3 ] = mvp[ 15 ] + mvp[ 13 ];\n\n            // Top clipping plane.\n            var top = out[ 3 ];\n            top[ 0 ] = mvp[ 3 ] - mvp[ 1 ];\n            top[ 1 ] = mvp[ 7 ] - mvp[ 5 ];\n            top[ 2 ] = mvp[ 11 ] - mvp[ 9 ];\n            top[ 3 ] = mvp[ 15 ] - mvp[ 13 ];\n\n            if ( computeNearFar ) {\n                // Far clipping plane.\n                var far = out[ 4 ];\n                far[ 0 ] = mvp[ 3 ] - mvp[ 2 ];\n                far[ 1 ] = mvp[ 7 ] - mvp[ 6 ];\n                far[ 2 ] = mvp[ 11 ] - mvp[ 10 ];\n                far[ 3 ] = mvp[ 15 ] - mvp[ 14 ];\n\n                // Near clipping plane.\n                var near = out[ 5 ];\n                near[ 0 ] = mvp[ 3 ] + mvp[ 2 ];\n                near[ 1 ] = mvp[ 7 ] + mvp[ 6 ];\n                near[ 2 ] = mvp[ 11 ] + mvp[ 10 ];\n                near[ 3 ] = mvp[ 15 ] + mvp[ 14 ];\n            }\n\n            //Normalize the planes\n            var j = withNearFar ? 6 : 4;\n            for ( var i = 0; i < j; i++ ) {\n                Plane.normalizeEquation( out[ i ] );\n            }\n\n        };\n    } )(),\n\n    pushCullingSet: function () {\n        var cs = this._getReservedCullingSet();\n        if ( this._enableFrustumCulling ) {\n            mat4.getFrustumPlanes( cs.getFrustum().getPlanes(), this.getCurrentProjectionMatrix(), this.getCurrentModelViewMatrix(), false );\n            // TODO: no far no near.\n            // should check if we have them\n            // should add at least a near 0 clip if not\n            cs.getFrustum().setupMask( 4 );\n        }\n\n        this._cullingSetStack.push( cs );\n    },\n    popCullingSet: function () {\n        return this._cullingSetStack.pop();\n    },\n    getCurrentCullingSet: function () {\n        return this._cullingSetStack[ this._cullingSetStack.length - 1 ];\n    },\n\n\n    pushCurrentMask: function () {\n        var cs = this.getCurrentCullingSet();\n        if ( cs ) cs.pushCurrentMask();\n    },\n    popCurrentMask: function () {\n        var cs = this.getCurrentCullingSet();\n        if ( cs ) cs.popCurrentMask();\n    },\n\n    isVerticesCulled: function ( vertices ) {\n        if ( !this._enableFrustumCulling )\n            return false;\n        return this.getCurrentCullingSet().isVerticesCulled( vertices );\n    },\n\n    isBoundingBoxCulled: function ( bb ) {\n        if ( !this._enableFrustumCulling )\n            return false;\n        return bb.valid() && this.getCurrentCullingSet().isBoundingBoxCulled( bb );\n    },\n\n    isBoundingSphereCulled: function ( bs ) {\n        if ( !this._enableFrustumCulling )\n            return false;\n        return bs.valid() && this.getCurrentCullingSet().isBoundingSphereCulled( bs );\n    },\n\n    isCulled: ( function () {\n        var bsWorld = new BoundingSphere();\n        return function ( node, nodePath ) {\n            if ( !this._enableFrustumCulling )\n                return false;\n            if ( node.isCullingActive() ) {\n                if ( this.getCurrentCullingSet().getCurrentResultMask() === 0 )\n                    return false; // father bounding sphere totally inside\n\n                var matrix = this._reservedMatrixStack.get();\n                mat4.identity( matrix );\n\n                // TODO: Perf just get World Matrix at each node transform\n                // store it in a World Transform Node Path (only world matrix change)\n                // so that it's computed once and reused for each further node getCurrentModel\n                // otherwise, it's 1 mult for each node, each matrix node, and each geometry\n                //matrix = this.getCurrentModelMatrix();\n                // tricky: change push be before isculled, and pop in case of culling\n                // strange bug for now on frustum culling sample with that\n\n                if ( node instanceof Transform ) {\n\n                    // tricky: MatrixTransform getBound is already transformed to\n                    // its local space whereas nodepath also have its matrix ...\n                    // so to get world space, you HAVE to remove that matrix from nodePATH\n                    // TODO: GC Perf of array slice creating new array\n                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( nodePath.slice( 0, nodePath.length - 1 ), true, matrix );\n\n                } else {\n\n                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( nodePath, true, matrix );\n\n                }\n\n                // Matrix.transformBoundingSphere( matrix, node.getBound(), bsWorld );\n                node.getBound().transformMat4( bsWorld, matrix );\n\n                return this.getCurrentCullingSet().isBoundingSphereCulled( bsWorld );\n            } else {\n                this.getCurrentCullingSet().resetCullingMask();\n                return false;\n            }\n        };\n    } )(),\n\n\n\n    pushModelViewMatrix: ( function () {\n        var lookVector = vec3.create();\n        return function ( matrix ) {\n\n            // When pushing a matrix, it can be a transform or camera. To compute\n            // differents matrix type in shader ( ViewMatrix/ModelMatrix/ModelViewMatrix )\n            // we track camera node when using pushModelViewMatrix\n            // To detect a camera, we check on the nodepath the type of the node and if the\n            // camera is relatif or absolute.\n            // When we detect an absolute camera we keep it's index to get it when needed to\n            // compute the World/View matrix\n            // Th    ere is an exception for the root camera, the root camera is not pushed on the\n            // CullVisitor but only its matrixes, so to handle this we compute the inverse camera\n            // when the nodepath has a lenght of 0\n            // To avoid to compute too much inverse matrix, we keep a cache of them during the\n            // traverse and store the result under the instanceID key, except for the root\n            var np = this.getNodePath();\n            var length = np.length;\n            if ( !length ) { // root\n                var matInverse = this._reservedMatrixStack.get();\n                mat4.invert( matInverse, matrix );\n                this._cameraMatrixInverseRoot = matInverse;\n            } else {\n                var index = length - 1;\n                if ( np[ index ].getTypeID() === Camera.getTypeID() && np[ index ].getReferenceFrame() === TransformEnums.ABSOLUTE_RF ) {\n                    this._cameraIndexStack.push( index );\n                    this._cameraModelViewIndexStack.push( this._modelViewMatrixStack.length );\n                }\n            }\n\n            this._modelViewMatrixStack.push( matrix );\n            this.getLookVectorLocal( lookVector );\n\n            /*jshint bitwise: false */\n            this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\n            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\n            /*jshint bitwise: true */\n\n        };\n    } )(),\n    popModelViewMatrix: ( function () {\n        var lookVector = vec3.create();\n\n        return function () {\n\n            // if same index it's a camera and we have to pop it\n            var np = this.getNodePath();\n            var index = np.length - 1;\n            if ( this._cameraIndexStack.length && index === this._cameraIndexStack[ this._cameraIndexStack.length - 1 ] ) {\n                this._cameraIndexStack.pop();\n                this._cameraModelViewIndexStack.pop();\n            }\n\n            this._modelViewMatrixStack.pop();\n\n            if ( this._modelViewMatrixStack.length !== 0 ) {\n                this.getLookVectorLocal( lookVector );\n            } else {\n                vec3.set( lookVector, 0.0, 0.0, -1.0 );\n            }\n\n            /*jshint bitwise: false */\n            this._bbCornerFar = ( lookVector[ 0 ] >= 0.0 ? 1.0 : 0.0 ) | ( lookVector[ 1 ] >= 0 ? 2.0 : 0.0 ) | ( lookVector[ 2 ] >= 0 ? 4.0 : 0.0 );\n            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\n            /*jshint bitwise: true */\n        };\n    } )(),\n\n    pushProjectionMatrix: function ( matrix ) {\n        this._projectionMatrixStack.push( matrix );\n\n        // need to recompute frustum volume.\n        this._frustumVolume = -1.0;\n\n        this.pushCullingSet();\n    },\n    popProjectionMatrix: function () {\n        this._projectionMatrixStack.pop();\n\n        // need to recompute frustum volume.\n        this._frustumVolume = -1.0;\n\n        this.popCullingSet();\n    }\n\n\n} );\n\nmodule.exports = CullStack;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/CullStack.js\n// module id = 59\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar osgMath = require( 'osg/math' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar CullSettings = require( 'osg/CullSettings' );\nvar CullStack = require( 'osg/CullStack' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar AutoTransform = require( 'osg/AutoTransform' );\nvar Projection = require( 'osg/Projection' );\nvar LightSource = require( 'osg/LightSource' );\nvar osgPool = require( 'osgUtil/osgPool' );\nvar Geometry = require( 'osg/Geometry' );\nvar RenderLeaf = require( 'osg/RenderLeaf' );\nvar RenderBin = require( 'osg/RenderBin' );\nvar RenderStage = require( 'osg/RenderStage' );\nvar Node = require( 'osg/Node' );\nvar Lod = require( 'osg/Lod' );\nvar PagedLOD = require( 'osg/PagedLOD' );\nvar Camera = require( 'osg/Camera' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Skeleton = require( 'osgAnimation/Skeleton' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar Bone = require( 'osgAnimation/Bone' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\n\n/**\n * CullVisitor traverse the tree and collect Matrix/State for the rendering traverse\n * @class CullVisitor\n */\nvar CullVisitor = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ACTIVE_CHILDREN );\n    CullSettings.call( this );\n    CullStack.call( this );\n\n    this._rootStateGraph = undefined;\n    this._currentStateGraph = undefined;\n    this._currentRenderBin = undefined;\n    this._currentRenderStage = undefined;\n    this._rootRenderStage = undefined;\n    this._computedNear = Number.POSITIVE_INFINITY;\n    this._computedFar = Number.NEGATIVE_INFINITY;\n\n    var lookVector = vec3.fromValues( 0.0, 0.0, -1.0 );\n    this._camera = undefined;\n    /*jshint bitwise: false */\n    this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\n    this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\n    /*jshint bitwise: true */\n\n    this._reserveLeafStack = [ new RenderLeaf() ];\n    this._reserveLeafStackCurrent = 0;\n\n    this._reserveRenderStageStacks = {};\n\n    this._reserveCullSettingsStack = [ new CullSettings() ];\n    this._reserveCullSettingsStackCurrent = 0;\n\n    this._renderBinStack = [];\n    this.visitorType = NodeVisitor.CULL_VISITOR;\n\n    this._identityMatrix = mat4.create();\n\n    this._renderer = undefined;\n    this._renderStageType = RenderStage;\n\n    this._numCamera = 0;\n    this._numMatrixTransform = 0;\n    this._numProjection = 0;\n    this._numNode = 0;\n    this._numLightSource = 0;\n    this._numGeometry = 0;\n\n};\n\n/** @lends CullVisitor.prototype */\nCullVisitor.prototype = MACROUTILS.objectInherit( CullStack.prototype, MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    distance: function ( coord, matrix ) {\n        return -( coord[ 0 ] * matrix[ 2 ] + coord[ 1 ] * matrix[ 6 ] + coord[ 2 ] * matrix[ 10 ] + matrix[ 14 ] );\n    },\n\n    getComputedNear: function () {\n        return this._computedNear;\n    },\n\n    getComputedFar: function () {\n        return this._computedFar;\n    },\n\n    resetStats: function () {\n        this._numCamera = 0;\n        this._numMatrixTransform = 0;\n        this._numProjection = 0;\n        this._numNode = 0;\n        this._numLightSource = 0;\n        this._numGeometry = 0;\n    },\n\n    handleCullCallbacksAndTraverse: function ( node ) {\n        var ccb = node.getCullCallback();\n        if ( ccb && !ccb.cull( node, this ) )\n            return;\n        this.traverse( node );\n    },\n\n    getCurrentCamera: function () {\n        return this._currentRenderBin.getStage().getCamera();\n    },\n\n    updateCalculatedNearFar: ( function () {\n        var nearVec = vec3.create();\n        var farVec = vec3.create();\n\n        return function ( matrix, drawable ) {\n\n            var bb = drawable.getBoundingBox();\n            var dNear, dFar;\n\n            // efficient computation of near and far, only taking into account the nearest and furthest\n            // corners of the bounding box.\n            dNear = this.distance( bb.corner( this._bbCornerNear, nearVec ), matrix );\n            dFar = this.distance( bb.corner( this._bbCornerFar, farVec ), matrix );\n\n            if ( dNear > dFar ) {\n                var tmp = dNear;\n                dNear = dFar;\n                dFar = tmp;\n            }\n\n            if ( dFar < 0.0 ) {\n                // whole object behind the eye point so discard\n                return false;\n            }\n\n            if ( dNear < this._computedNear ) {\n                this._computedNear = dNear;\n            }\n\n            if ( dFar > this._computedFar ) {\n                this._computedFar = dFar;\n            }\n\n            return true;\n\n        };\n    } )(),\n\n\n    setStateGraph: function ( sg ) {\n        this._rootStateGraph = sg;\n        this._currentStateGraph = sg;\n    },\n    setRenderStage: function ( rg ) {\n        this._rootRenderStage = rg;\n        this._currentRenderBin = rg;\n    },\n    setRenderer: function ( renderer ) {\n        this._renderer = renderer;\n    },\n    getRenderer: function () {\n        return this._renderer;\n    },\n\n    reset: function () {\n        CullStack.prototype.reset.call( this );\n        // Reset the stack before reseting the current leaf index.\n        // Reseting elements and refilling them later is faster than create new elements\n        // That's the reason to have a leafStack, see http://jsperf.com/refill/2\n        this.resetRenderLeafStack();\n        this._reserveLeafStackCurrent = 0;\n\n        this.resetCullSettingsStack();\n        this._reserveCullSettingsStackCurrent = 0;\n\n        // renderstage / renderbin pools\n        for ( var key in this._reserveRenderStageStacks ) {\n            this._reserveRenderStageStacks[ key ].reset();\n        }\n        RenderBin.resetStack();\n\n        this._computedNear = Number.POSITIVE_INFINITY;\n        this._computedFar = Number.NEGATIVE_INFINITY;\n    },\n\n    getCurrentRenderBin: function () {\n        return this._currentRenderBin;\n    },\n\n    setCurrentRenderBin: function ( rb ) {\n        this._currentRenderBin = rb;\n    },\n\n    // mimic the osg implementation\n    // in osg you can push 0, in this case an identity matrix will be loaded\n    addPositionedAttribute: function ( matrix, attribute ) {\n\n        var m = matrix ? matrix : this._identityMatrix;\n        this._currentRenderBin.getStage().positionedAttribute.push( [ m, attribute ] );\n\n    },\n\n    pushStateSet: function ( stateset ) {\n        this._currentStateGraph = this._currentStateGraph.findOrInsert( stateset );\n        if ( stateset.getBinName() !== undefined ) {\n            var renderBinStack = this._renderBinStack;\n            var currentRenderBin = this._currentRenderBin;\n            renderBinStack.push( currentRenderBin );\n            this._currentRenderBin = currentRenderBin.getStage().findOrInsert( stateset.getBinNumber(), stateset.getBinName() );\n        }\n    },\n\n    /** Pop the top state set and hence associated state group.\n     * Move the current state group to the parent of the popped\n     * state group.\n     */\n    popStateSet: function () {\n        var currentStateGraph = this._currentStateGraph;\n        var stateset = currentStateGraph.getStateSet();\n        this._currentStateGraph = currentStateGraph.parent;\n        if ( stateset.getBinName() !== undefined ) {\n            var renderBinStack = this._renderBinStack;\n            if ( renderBinStack.length === 0 ) {\n                this._currentRenderBin = this._currentRenderBin.getStage();\n            } else {\n                this._currentRenderBin = renderBinStack.pop();\n            }\n        }\n    },\n\n    popProjectionMatrix: function () {\n        if ( this._computeNearFar === true && this._computedFar >= this._computedNear ) {\n            var m = this.getCurrentProjectionMatrix();\n            if ( this._clampProjectionMatrixCallback !== undefined ) {\n                this._clampProjectionMatrixCallback( m, this._computedNear, this._computedFar, this._nearFarRatio );\n            } else {\n                this.clampProjectionMatrix( m, this._computedNear, this._computedFar, this._nearFarRatio );\n            }\n        }\n        CullStack.prototype.popProjectionMatrix.call( this );\n    },\n\n\n    clampProjectionMatrix: function ( projection, znear, zfar, nearFarRatio, resultNearFar ) {\n        var epsilon = 1e-6;\n        if ( zfar < znear - epsilon ) {\n            Notify.log( 'clampProjectionMatrix not applied, invalid depth range, znear = ' + znear + '  zfar = ' + zfar, false, true );\n            return false;\n        }\n\n        var desiredZnear, desiredZfar;\n        if ( zfar < znear + epsilon ) {\n            // znear and zfar are too close together and could cause divide by zero problems\n            // late on in the clamping code, so move the znear and zfar apart.\n            var average = ( znear + zfar ) * 0.5;\n            znear = average - epsilon;\n            zfar = average + epsilon;\n            // OSG_INFO << '_clampProjectionMatrix widening znear and zfar to '<<znear<<' '<<zfar<<std::endl;\n        }\n\n        if ( Math.abs( projection[ 3 ] ) < epsilon &&\n            Math.abs( projection[ 7 ] ) < epsilon &&\n            Math.abs( projection[ 11 ] ) < epsilon ) {\n            // OSG_INFO << 'Orthographic matrix before clamping'<<projection<<std::endl;\n\n            var deltaSpan = ( zfar - znear ) * 0.02;\n            if ( deltaSpan < 1.0 ) {\n                deltaSpan = 1.0;\n            }\n            desiredZnear = znear - deltaSpan;\n            desiredZfar = zfar + deltaSpan;\n\n            // assign the clamped values back to the computed values.\n            znear = desiredZnear;\n            zfar = desiredZfar;\n\n            projection[ 10 ] = -2.0 / ( desiredZfar - desiredZnear );\n            projection[ 14 ] = -( desiredZfar + desiredZnear ) / ( desiredZfar - desiredZnear );\n            // OSG_INFO << 'Orthographic matrix after clamping '<<projection<<std::endl;\n        } else {\n\n            // OSG_INFO << 'Persepective matrix before clamping'<<projection<<std::endl;\n            //std::cout << '_computed_znear'<<_computed_znear<<std::endl;\n            //std::cout << '_computed_zfar'<<_computed_zfar<<std::endl;\n\n            var zfarPushRatio = 1.02;\n            var znearPullRatio = 0.98;\n\n            //znearPullRatio = 0.99;\n\n            desiredZnear = znear * znearPullRatio;\n            desiredZfar = zfar * zfarPushRatio;\n\n            // near plane clamping.\n            var minNearPlane = zfar * nearFarRatio;\n            if ( desiredZnear < minNearPlane ) {\n                desiredZnear = minNearPlane;\n            }\n\n            // assign the clamped values back to the computed values.\n            znear = desiredZnear;\n            zfar = desiredZfar;\n\n            var m22 = projection[ 10 ];\n            var m32 = projection[ 14 ];\n            var m23 = projection[ 11 ];\n            var m33 = projection[ 15 ];\n            var transNearPlane = ( -desiredZnear * m22 + m32 ) / ( -desiredZnear * m23 + m33 );\n            var transFarPlane = ( -desiredZfar * m22 + m32 ) / ( -desiredZfar * m23 + m33 );\n\n            var ratio = Math.abs( 2.0 / ( transNearPlane - transFarPlane ) );\n            var center = -( transNearPlane + transFarPlane ) / 2.0;\n\n            var centerRatio = center * ratio;\n            projection[ 2 ] = projection[ 2 ] * ratio + projection[ 3 ] * centerRatio;\n            projection[ 6 ] = projection[ 6 ] * ratio + projection[ 7 ] * centerRatio;\n            projection[ 10 ] = m22 * ratio + m23 * centerRatio;\n            projection[ 14 ] = m32 * ratio + m33 * centerRatio;\n            // same as\n            // var matrix = [ 1.0, 0.0, 0.0, 0.0,\n            //     0.0, 1.0, 0.0, 0.0,\n            //     0.0, 0.0, ratio, 0.0,\n            //     0.0, 0.0, center * ratio, 1.0\n            // ];\n            // mat4.mul( projection , matrix, projection );\n\n            // OSG_INFO << 'Persepective matrix after clamping'<<projection<<std::endl;\n        }\n        if ( resultNearFar !== undefined ) {\n            resultNearFar[ 0 ] = znear;\n            resultNearFar[ 1 ] = zfar;\n        }\n        return true;\n    },\n\n    popCameraModelViewProjectionMatrix: function () {\n        this.popModelViewMatrix();\n        this.popProjectionMatrix();\n    },\n\n    pushCameraModelViewProjectionMatrix: function ( camera, modelview, projection ) {\n        this.pushModelViewMatrix( modelview );\n        this.pushProjectionMatrix( projection );\n    },\n\n    apply: function ( node ) {\n        this[ node.typeID ]( node );\n    },\n\n    createOrReuseRenderStage: function ( classInstance ) {\n\n        var type = !classInstance ? 'RenderStage' : classInstance.className();\n        var classCtor = !classInstance ? RenderStage : classInstance.constructor;\n\n        var stack;\n        if ( this._reserveRenderStageStacks[ type ] ) {\n            stack = this._reserveRenderStageStacks[ type ];\n        } else {\n            stack = new osgPool.OsgObjectMemoryStack( classCtor );\n            this._reserveRenderStageStacks[ type ] = stack;\n        }\n        return stack.get().init();\n\n    },\n\n    createOrReuseRenderLeaf: function () {\n        var l = this._reserveLeafStack[ this._reserveLeafStackCurrent++ ];\n        if ( this._reserveLeafStackCurrent === this._reserveLeafStack.length ) {\n            this._reserveLeafStack.push( new RenderLeaf() );\n        }\n        return l;\n    },\n\n    resetRenderLeafStack: function () {\n        for ( var i = 0, j = this._reserveLeafStackCurrent; i <= j; i++ ) {\n            this._reserveLeafStack[ i ].reset();\n        }\n    },\n\n    createOrReuseCullSettings: function () {\n        var l = this._reserveCullSettingsStack[ this._reserveCullSettingsStackCurrent++ ];\n\n        if ( this._reserveCullSettingsStackCurrent === this._reserveCullSettingsStack.length ) {\n\n            this._reserveCullSettingsStack.push( new CullSettings() );\n\n        }\n        return l;\n    },\n\n    resetCullSettingsStack: function () {\n        for ( var i = 0, j = this._reserveCullSettingsStackCurrent; i <= j; i++ ) {\n            this._reserveCullSettingsStack[ i ].reset();\n        }\n    },\n\n    // function call after the push state in the geometry apply function\n    // the idea is to avoid heavy copy-paste for the rigGeometry apply\n    // since the only difference is that we want to push an additional state\n    // Maybe it will be useful when we'll add morph target geometry or something...\n    postPushGeometry: function ( cull, node ) {\n\n        var sourceGeometry;\n        var geometryStateSetAnimation;\n\n        if ( node instanceof RigGeometry ) {\n\n            geometryStateSetAnimation = node.getStateSetAnimation();\n            if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );\n\n            sourceGeometry = node.getSourceGeometry();\n\n            if ( sourceGeometry instanceof MorphGeometry ) {\n\n                geometryStateSetAnimation = sourceGeometry.getStateSetAnimation();\n                if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );\n\n            }\n\n        } else if ( node instanceof MorphGeometry ) {\n\n            geometryStateSetAnimation = node.getStateSetAnimation();\n            if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );\n\n        }\n\n    },\n\n    // same comment as above (postPushGeometry)\n    prePopGeometry: function ( cull, node ) {\n\n        if ( node instanceof RigGeometry ) {\n\n            var sourceGeometry = node.getSourceGeometry();\n\n            if ( sourceGeometry instanceof MorphGeometry ) {\n\n                if ( sourceGeometry.getStateSetAnimation() ) cull.popStateSet();\n\n            }\n\n            if ( node.getStateSetAnimation() ) cull.popStateSet();\n\n        } else if ( node instanceof MorphGeometry && node.getStateSetAnimation() ) {\n\n            cull.popStateSet();\n\n        }\n\n    },\n\n    pushLeaf: function ( node, depth ) {\n        var leafs = this._currentStateGraph.leafs;\n        if ( leafs.length === 0 ) {\n            this._currentRenderBin.addStateGraph( this._currentStateGraph );\n        }\n\n        var leaf = this.createOrReuseRenderLeaf();\n\n        leaf.init( this._currentStateGraph,\n            node,\n            this.getCurrentProjectionMatrix(),\n            this.getCurrentViewMatrix(),\n            this.getCurrentModelViewMatrix(),\n            this.getCurrentModelMatrix(),\n            depth );\n\n        leafs.push( leaf );\n\n    }\n\n} ) );\n\n\n// Camera cull visitor call\n// ANY CHANGE, any change : double check in rendere Camera code\n// for the first camera\nCullVisitor.prototype[ Camera.typeID ] = function ( camera ) {\n    this._numCamera++;\n\n    var stateset = camera.getStateSet();\n    if ( stateset ) this.pushStateSet( stateset );\n\n    var modelview = this._reservedMatrixStack.get();\n    var projection = this._reservedMatrixStack.get();\n\n    if ( camera.getReferenceFrame() === TransformEnums.RELATIVE_RF ) {\n\n        var lastProjectionMatrix = this.getCurrentProjectionMatrix();\n        mat4.mul( projection, lastProjectionMatrix, camera.getProjectionMatrix() );\n\n        var lastViewMatrix = this.getCurrentModelViewMatrix();\n        mat4.mul( modelview, lastViewMatrix, camera.getViewMatrix() );\n\n    } else {\n\n        // absolute\n        mat4.copy( modelview, camera.getViewMatrix() );\n        mat4.copy( projection, camera.getProjectionMatrix() );\n\n    }\n\n\n    // save current state of the camera\n    var previousZnear = this._computedNear;\n    var previousZfar = this._computedFar;\n\n    // save cullSettings\n    // TODO Perf: why it's not a stack\n    // and is pollutin  GC ?\n    var previousCullsettings = this.createOrReuseCullSettings();\n    previousCullsettings.setCullSettings( this );\n\n    this._computedNear = Number.POSITIVE_INFINITY;\n    this._computedFar = Number.NEGATIVE_INFINITY;\n    //\n\n    this.setCullSettings( camera );\n    // global override\n    // upon who setted the parameter\n    // if it's cullvisitor\n    // it's an OVERRIDER for enableFrustumCulling\n    // allowing for global EnableFrustimCulling\n    if ( previousCullsettings.getSettingSourceOverrider() === this && previousCullsettings.getEnableFrustumCulling() ) {\n        this.setEnableFrustumCulling( true );\n    }\n\n\n    this.pushCameraModelViewProjectionMatrix( camera, modelview, projection );\n\n    if ( camera.getViewport() ) {\n        this.pushViewport( camera.getViewport() );\n    }\n\n\n    // nested camera\n    if ( camera.getRenderOrder() === Camera.NESTED_RENDER ) {\n\n        this.handleCullCallbacksAndTraverse( camera );\n\n    } else {\n        // not tested\n\n        var renderBin = this.getCurrentRenderBin();\n        var previousStage = renderBin.getStage();\n\n        // use render to texture stage\n        var rtts = this.createOrReuseRenderStage( this._rootRenderStage );\n\n        rtts.setCamera( camera );\n        rtts.setClearDepth( camera.getClearDepth() );\n        rtts.setClearColor( camera.getClearColor() );\n        rtts.setClearMask( camera.getClearMask() );\n\n        var vp;\n        if ( camera.getViewport() === undefined ) {\n            vp = previousStage.getViewport();\n        } else {\n            vp = camera.getViewport();\n        }\n        rtts.setViewport( vp );\n\n        // skip positional state for now\n        // ...\n\n        this.setCurrentRenderBin( rtts );\n\n        this.handleCullCallbacksAndTraverse( camera );\n\n        this.setCurrentRenderBin( renderBin );\n\n        if ( camera.getRenderOrder() === Camera.PRE_RENDER ) {\n            this.getCurrentRenderBin().getStage().addPreRenderStage( rtts, camera.renderOrderNum );\n        } else {\n            this.getCurrentRenderBin().getStage().addPostRenderStage( rtts, camera.renderOrderNum );\n        }\n    }\n\n    this.popCameraModelViewProjectionMatrix( camera );\n\n    if ( camera.getViewport() ) {\n        this.popViewport();\n    }\n\n    // restore previous state of the camera\n    this.setCullSettings( previousCullsettings );\n    this._computedNear = previousZnear;\n    this._computedFar = previousZfar;\n\n    if ( stateset ) this.popStateSet();\n\n};\n\n\nCullVisitor.prototype[ MatrixTransform.typeID ] = function ( node ) {\n    this._numMatrixTransform++;\n\n    // Camera and lights must enlarge node parent bounding boxes for this not to cull\n    if ( this.isCulled( node, this.nodePath ) ) {\n        return;\n    }\n    // push the culling mode.\n    this.pushCurrentMask();\n\n    var matrix = this._reservedMatrixStack.get();\n    var lastMatrixStack = this.getCurrentModelViewMatrix();\n    mat4.copy( matrix, lastMatrixStack );\n    node.computeLocalToWorldMatrix( matrix );\n    this.pushModelViewMatrix( matrix );\n\n\n    var stateset = node.getStateSet();\n\n    if ( stateset ) this.pushStateSet( stateset );\n\n    this.handleCullCallbacksAndTraverse( node );\n\n    if ( stateset ) this.popStateSet();\n\n\n    this.popModelViewMatrix();\n\n    // pop the culling mode.\n    this.popCurrentMask();\n};\n\nCullVisitor.prototype[ Projection.typeID ] = function ( node ) {\n    this._numProjection++;\n\n    var lastMatrixStack = this.getCurrentProjectionMatrix();\n    var matrix = this._reservedMatrixStack.get();\n    mat4.mul( matrix, lastMatrixStack, node.getProjectionMatrix() );\n    this.pushProjectionMatrix( matrix );\n\n    var stateset = node.getStateSet();\n    if ( stateset ) this.pushStateSet( stateset );\n\n    this.handleCullCallbacksAndTraverse( node );\n\n    if ( stateset ) this.popStateSet();\n\n    this.popProjectionMatrix();\n};\n\n// here it's treated as a group node for culling\n// as there's isn't any in osgjs\n// so frustumCulling is done here\nCullVisitor.prototype[ Node.typeID ] = function ( node ) {\n    this._numNode++;\n\n    // Camera and lights must enlarge node parent bounding boxes for this not to cull\n    if ( this.isCulled( node, this.nodePath ) ) {\n        return;\n    }\n\n    // push the culling mode.\n    this.pushCurrentMask();\n\n    var stateset = node.getStateSet();\n    if ( stateset ) this.pushStateSet( stateset );\n\n    this.handleCullCallbacksAndTraverse( node );\n\n    if ( stateset ) this.popStateSet();\n\n    // pop the culling mode.\n    this.popCurrentMask();\n};\n\n// same code like MatrixTransform\nCullVisitor.prototype[ AutoTransform.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];\n\n// same code like Node\nCullVisitor.prototype[ Lod.typeID ] = CullVisitor.prototype[ Node.typeID ];\n\n// same code like Node\nCullVisitor.prototype[ PagedLOD.typeID ] = CullVisitor.prototype[ Node.typeID ];\n\n\nCullVisitor.prototype[ LightSource.typeID ] = function ( node ) {\n    this._numLightSource++;\n\n    var stateset = node.getStateSet();\n    if ( stateset ) this.pushStateSet( stateset );\n\n    var light = node.getLight();\n    if ( light ) {\n        if ( node.getReferenceFrame() === TransformEnums.RELATIVE_RF )\n            this.addPositionedAttribute( this.getCurrentModelViewMatrix(), light );\n        else\n            this.addPositionedAttribute( null, light );\n    }\n\n\n    this.handleCullCallbacksAndTraverse( node );\n\n    if ( stateset ) this.popStateSet();\n};\n\nCullVisitor.prototype[ Geometry.typeID ] = ( function () {\n\n    var tempVec = vec3.create();\n    var loggedOnce = false;\n    return function geometryApply( node ) {\n\n        this._numGeometry++;\n\n        var modelview = this.getCurrentModelViewMatrix();\n        var bb = node.getBoundingBox();\n        if ( this._computeNearFar && bb.valid() ) {\n            if ( !this.updateCalculatedNearFar( modelview, node ) ) {\n                return;\n            }\n        }\n\n        // using modelview is not a pb because geometry\n        // is a leaf node, else traversing the graph would be an\n        // issue because we use modelview after\n        var ccb = node.getCullCallback();\n        if ( ccb && !ccb.cull( node, this ) )\n            return;\n\n        var stateset = node.getStateSet();\n        if ( stateset ) this.pushStateSet( stateset );\n\n        this.postPushGeometry( this, node );\n\n        var depth = 0;\n        if ( bb.valid() ) {\n            depth = this.distance( bb.center( tempVec ), modelview );\n        }\n        if ( osgMath.isNaN( depth ) ) {\n\n            if ( !loggedOnce ) {\n                Notify.warn( 'warning geometry has a NaN depth, ' + modelview + ' center ' + tempVec );\n                loggedOnce = true;\n            }\n\n        } else {\n\n            this.pushLeaf( node, depth );\n\n        }\n\n        this.prePopGeometry( this, node );\n        if ( stateset ) this.popStateSet();\n    };\n} )();\n\nCullVisitor.prototype[ Skeleton.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];\n\nCullVisitor.prototype[ RigGeometry.typeID ] = CullVisitor.prototype[ Geometry.typeID ];\n\nCullVisitor.prototype[ MorphGeometry.typeID ] = CullVisitor.prototype[ Geometry.typeID ];\n\nCullVisitor.prototype[ Bone.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];\n\nmodule.exports = CullVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/CullVisitor.js\n// module id = 60\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Transform = require( 'osg/Transform' );\nvar TransformEnums = require( 'osg/transformEnums' );\n\n\n/**\n *  MatrixTransform is a Transform Node that can be customized with user matrix\n *  @class MatrixTransform\n */\nvar MatrixTransform = function () {\n    Transform.call( this );\n    this.matrix = mat4.create();\n};\n\n/** @lends MatrixTransform.prototype */\nMatrixTransform.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Transform.prototype, {\n\n    getMatrix: function () {\n        return this.matrix;\n    },\n\n    setMatrix: function ( m ) {\n        this.matrix = m;\n        this.dirtyBound();\n    },\n\n    // local to \"local world\" (not Global World)\n    computeLocalToWorldMatrix: function ( matrix /*, nodeVisitor */ ) {\n\n        if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n            mat4.mul( matrix, matrix, this.matrix );\n        } else {\n            mat4.copy( matrix, this.matrix );\n        }\n        return true;\n    },\n\n    computeWorldToLocalMatrix: ( function () {\n        var minverse = mat4.create();\n        return function ( matrix /*, nodeVisitor */ ) {\n\n            mat4.invert( minverse, this.matrix );\n            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\n                mat4.mul( matrix, minverse, matrix );\n            } else { // absolute\n                mat4.copy( matrix, minverse );\n            }\n            return true;\n        };\n    } )()\n} ), 'osg', 'MatrixTransform' );\nMACROUTILS.setTypeID( MatrixTransform );\n\nmodule.exports = MatrixTransform;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/MatrixTransform.js\n// module id = 61\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\nvar Projection = function () {\n    Node.call( this );\n    this.projection = mat4.create();\n};\nProjection.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    getProjectionMatrix: function () {\n        return this.projection;\n    },\n    setProjectionMatrix: function ( m ) {\n        this.projection = m;\n    }\n} );\n\nMACROUTILS.setTypeID( Projection );\n\nmodule.exports = Projection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Projection.js\n// module id = 62\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n/**\n *  LightSource is a positioned node to use with StateAttribute Light\n *  @class LightSource\n */\nvar LightSource = function () {\n    Node.call( this );\n    this._light = undefined;\n    this._referenceFrame = TransformEnums.RELATIVE_RF;\n};\n\n/** @lends LightSource.prototype */\nLightSource.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {\n    getLight: function () {\n        return this._light;\n    },\n    setLight: function ( light ) {\n        this._light = light;\n    },\n    setReferenceFrame: function ( value ) {\n        this._referenceFrame = value;\n    },\n    getReferenceFrame: function () {\n        return this._referenceFrame;\n    },\n    computeBoundingSphere: ( function () {\n        var tmp = vec3.create();\n\n        return function ( bsphere ) {\n            Node.prototype.computeBoundingSphere.call( this, bsphere );\n\n            if ( this._light !== undefined && this._referenceFrame === TransformEnums.RELATIVE_RF ) {\n                var position = this._light.getPosition();\n\n                if ( position[ 3 ] !== 0.0 ) {\n                    bsphere.expandByvec3( vec3.scale( tmp, position, 1.0 / position[ 3 ] ) );\n                }\n            }\n\n            return bsphere;\n        };\n    } )()\n\n} ), 'osg', 'LightSource' );\n\nMACROUTILS.setTypeID( LightSource );\n\nmodule.exports = LightSource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/LightSource.js\n// module id = 63\n// module chunks = 0 1 2","'use strict';\nvar StateGraph = require( 'osg/StateGraph' );\n\nvar CacheUniformApply = function ( state, program ) {\n    this.modelUniform = program._uniformsCache[ state.modelMatrix.getName() ];\n    this.viewUniform = program._uniformsCache[ state.viewMatrix.getName() ];\n\n    this.apply = undefined;\n    this.generateUniformsApplyMethods();\n};\n\nCacheUniformApply.prototype = {\n\n\n    generateUniformsApplyMethods: function () {\n\n        var functionStr = [ '//generated by RenderLeaf\\n' ];\n        functionStr.push( 'var gl = state.getGraphicContext();' );\n        functionStr.push( 'var matrixModelViewChanged = state.applyModelViewMatrix( modelview, model );' );\n        functionStr.push( 'state.applyProjectionMatrix( projection );' );\n\n        if ( this.modelUniform !== undefined ) {\n            functionStr.push( 'if ( matrixModelViewChanged ) {' );\n            functionStr.push( '    var modelMatrix = state.modelMatrix;' );\n            functionStr.push( '    modelMatrix.setMatrix4( model );' );\n            functionStr.push( '    modelMatrix.apply( gl, this.modelUniform);' );\n            functionStr.push( '};' );\n        }\n\n        if ( this.viewUniform !== undefined ) {\n            functionStr.push( 'if ( matrixModelViewChanged ) {' );\n            functionStr.push( '    var viewMatrix = state.viewMatrix;' );\n            functionStr.push( '    viewMatrix.setMatrix4( view );' );\n            functionStr.push( '    viewMatrix.apply( gl, this.viewUniform);' );\n            functionStr.push( '};' );\n        }\n\n        // I am the evil, so please bother someone else\n        /*jshint evil: true */\n        // name the function\n        // http://stackoverflow.com/questions/5905492/dynamic-function-name-in-javascript\n        var func = ( new Function( 'state', 'modelview', 'model', 'view', 'projection', 'return function RenderLeafApplyMatrixUniformCache( state, modelview, model, view, projection ) { ' + functionStr.join( '\\n' ) + '}' ) )();\n        /*jshint evil: false */\n\n        this.apply = func;\n    }\n};\n\n\nvar RenderLeaf = function () {\n\n    this._parent = undefined;\n    this._geometry = undefined;\n    this._depth = 0.0;\n\n    this._projection = undefined;\n    this._view = undefined;\n    this._model = undefined;\n    this._modelView = undefined;\n};\n\nRenderLeaf.prototype = {\n\n    reset: function () {\n        this._parent = undefined;\n        this._geometry = undefined;\n        this._depth = 0.0;\n\n        this._projection = undefined;\n        this._view = undefined;\n        this._model = undefined;\n        this._modelView = undefined;\n    },\n\n    init: function ( parent, geom, projection, view, modelView, model, depth ) {\n\n        this._parent = parent;\n        this._geometry = geom;\n        this._depth = depth;\n\n        this._projection = projection;\n        this._view = view;\n        this._model = model;\n        this._modelView = modelView;\n\n    },\n\n    drawGeometry: ( function () {\n\n        return function ( state ) {\n\n\n            var program = state.getLastProgramApplied();\n            var programInstanceID = program.getInstanceID();\n            var cache = state.getCacheUniformsApplyRenderLeaf();\n            var obj = cache[ programInstanceID ];\n\n            if ( !obj ) {\n                obj = new CacheUniformApply( state, program );\n                cache[ programInstanceID ] = obj;\n            }\n\n            obj.apply( state, this._modelView, this._model, this._view, this._projection );\n\n            this._geometry.drawImplementation( state );\n\n        };\n    } )(),\n\n    render: ( function () {\n        var idLastDraw = 0;\n        var lastStateSetStackSize = -1;\n\n        return function ( state, previousLeaf ) {\n\n            var prevRenderGraph;\n            var prevRenderGraphParent;\n            var curRenderGraph = this._parent;\n            var curRenderGraphParent = curRenderGraph.parent;\n            var curRenderGraphStateSet = curRenderGraph.stateset;\n\n            // When rendering a RenderLeaf we try to limit the state change\n            // to do that Graph of State is created during the culling pass.\n            // this graph contains nodes of StateGraph type see the class StateGraph\n            //\n            // So to limit switching of StateSet we check where are the common parent\n            // between previous RenderLeaf and this current.\n            //\n            // There are 3 cases when there is a prev / current render leaf\n            //\n            //\n            // pRG: previousRenderGraph\n            // cRG: currentRenderGraph\n            // pRL: previousRenderLeaf\n            // cRL: currentRenderLeaf\n            // each RG contains a StateSet\n            //\n            //          A                        B                       C\n            // +-----+     +-----+            +-----+                 +-----+\n            // | pRG |     | cRG |         +--+ RG  +--+              | RG  |\n            // +--+--+     +--+--+         |  +-----+  |              +--+--+\n            //    |           |            |           |                 |\n            // +--v--+     +--v--+      +--v--+     +--v--+           +--v--+\n            // | pRG |     | cRG |      | pRG |     | cRG |        +--+ RG  +--+\n            // +--+--+     +--+--+      +--+--+     +--+--+        |  +-----+  |\n            //    |           |            |           |           |           |\n            // +--v--+     +--v--+      +--v--+     +--v--+     +--v--+     +--v--+\n            // | pRL |     | cRL |      | pRL |     | cRL |     | pRL |     | cRL |\n            // +-----+     +-----+      +-----+     +-----+     +-----+     +-----+\n            //\n            //\n            // Case A\n            // no common parent StateGraphNode we need to\n            // popStateSet until we find the common parent and then\n            // pushStateSet from the common parent to the current\n            // RenderLeaf\n            //\n            // Case B\n            // common parent StateGraphNode so we apply the current stateSet\n            //\n            // Case C\n            // the StateGraphNode is common to the previous RenderLeaf so we dont need\n            // to do anything except if we used an insertStateSet\n            //\n\n            if ( previousLeaf !== undefined ) {\n\n                // apply state if required.\n                prevRenderGraph = previousLeaf._parent;\n                prevRenderGraphParent = prevRenderGraph.parent;\n\n                if ( prevRenderGraphParent !== curRenderGraphParent ) {\n\n                    // Case A\n                    StateGraph.moveStateGraph( state, prevRenderGraphParent, curRenderGraphParent );\n\n                    state.applyStateSet( curRenderGraphStateSet );\n\n                } else if ( curRenderGraph !== prevRenderGraph ) {\n\n                    // Case B\n                    state.applyStateSet( curRenderGraphStateSet );\n\n                } else {\n\n                    // Case C\n\n                    // in osg we call apply but actually we dont need\n                    // except if the stateSetStack changed.\n                    // for example if insert/remove StateSet has been used\n                    if ( state._stateSetStackChanged( idLastDraw, lastStateSetStackSize ) ) {\n                        state.applyStateSet( curRenderGraphStateSet );\n                    }\n                }\n\n            } else {\n\n                StateGraph.moveStateGraph( state, undefined, curRenderGraphParent );\n                state.applyStateSet( curRenderGraphStateSet );\n\n            }\n\n            state._setStateSetsDrawID( ++idLastDraw );\n            lastStateSetStackSize = state.getStateSetStackSize();\n\n            this.drawGeometry( state );\n\n        };\n    } )()\n\n};\n\nmodule.exports = RenderLeaf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/RenderLeaf.js\n// module id = 64\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Notify = require( 'osg/notify' );\nvar Object = require( 'osg/Object' );\nvar osgMath = require( 'osg/math' );\n\n\n/**\n * RenderBin base class. Renderbin contains geometries to be rendered as a group,\n * renderbins are rendered once each.  They can improve efficiency or\n * use different rendering algorithms.\n * A renderBin can contain further renderBins producing a tree hierarchy of renderBins.\n *\n * https://github.com/openscenegraph/osg/blob/master/include/osgUtil/RenderBin#L27-L32\n */\nvar RenderBin = function ( sortMode ) {\n    Object.call( this );\n\n    this._leafs = [];\n    this.positionedAttribute = [];\n    this.stateGraphList = [];\n\n    RenderBin.prototype.init.call( this, sortMode );\n};\n\nRenderBin.SORT_BY_STATE = 0;\nRenderBin.SORT_BACK_TO_FRONT = 1;\nRenderBin.SORT_FRONT_TO_BACK = 2;\n\n\n// change it at runtime for default RenderBin if needed\nRenderBin.defaultSortMode = RenderBin.SORT_BY_STATE;\n\nRenderBin.BinPrototypes = {\n    RenderBin: function () {\n        return RenderBin.getOrCreate().init();\n    },\n    DepthSortedBin: function () {\n        return RenderBin.getOrCreate().init( RenderBin.SORT_BACK_TO_FRONT );\n    }\n};\n\n\nvar sortBackToFrontFunction = function ( a, b ) {\n    return b._depth - a._depth;\n};\n\n\nvar sortFrontToBackFunction = function ( a, b ) {\n    return a._depth - b._depth;\n};\n\nvar sortBinNumberFunction = function ( a, b ) {\n    return a._binNum - b._binNum;\n};\n\n\nRenderBin.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( sortMode ) {\n\n        this._leafs.length = 0;\n        this.positionedAttribute.length = 0;\n        this._renderStage = undefined;\n        this._bins = {};\n        this.stateGraphList.length = 0;\n        this._parent = undefined;\n        this._binNum = 0;\n\n        this._sorted = false;\n        this._sortMode = sortMode !== undefined ? sortMode : RenderBin.defaultSortMode;\n\n        this._drawCallback = undefined;\n\n        return this;\n    },\n\n    _createRenderBin: function ( binName ) {\n\n        // default render bin constructor\n        var renderBinConstructor = RenderBin.BinPrototypes.RenderBin;\n\n        if ( binName && RenderBin.BinPrototypes[ binName ] )\n            renderBinConstructor = RenderBin.BinPrototypes[ binName ];\n\n        return renderBinConstructor();\n    },\n\n    getStateGraphList: function () {\n        return this.stateGraphList;\n    },\n\n    copyLeavesFromStateGraphListToRenderLeafList: function () {\n\n        this._leafs.splice( 0, this._leafs.length );\n        var detectedNaN = false;\n\n        for ( var i = 0, l = this.stateGraphList.length; i < l; i++ ) {\n            var leafs = this.stateGraphList[ i ].leafs;\n            for ( var j = 0, k = leafs.length; j < k; j++ ) {\n                var leaf = leafs[ j ];\n                if ( osgMath.isNaN( leaf._depth ) ) {\n                    detectedNaN = true;\n                } else {\n                    this._leafs.push( leaf );\n                }\n            }\n        }\n\n        if ( detectedNaN ) {\n            Notify.debug( 'warning: RenderBin::copyLeavesFromStateGraphListToRenderLeafList() detected NaN depth values, database may be corrupted.' );\n        }\n        // empty the render graph list to prevent it being drawn along side the render leaf list (see drawImplementation.)\n        this.stateGraphList.splice( 0, this.stateGraphList.length );\n    },\n\n    getSortMode: function () {\n        return this._sortMode;\n    },\n\n    sortBackToFront: function () {\n        this.copyLeavesFromStateGraphListToRenderLeafList();\n        this._leafs.sort( sortBackToFrontFunction );\n    },\n\n    sortFrontToBack: function () {\n        this.copyLeavesFromStateGraphListToRenderLeafList();\n        this._leafs.sort( sortFrontToBackFunction );\n    },\n\n    sortImplementation: function () {\n        var SortMode = RenderBin;\n        switch ( this._sortMode ) {\n        case SortMode.SORT_BACK_TO_FRONT:\n            this.sortBackToFront();\n            break;\n        case SortMode.SORT_FRONT_TO_BACK:\n            this.sortFrontToBack();\n            break;\n        case SortMode.SORT_BY_STATE:\n            // do nothing\n            break;\n        }\n    },\n\n    sort: function () {\n        if ( this._sorted ) {\n            return;\n        }\n\n        for ( var keyBin in this._bins ) {\n            this._bins[ keyBin ].sort();\n        }\n        this.sortImplementation();\n\n        this._sorted = true;\n    },\n\n    setParent: function ( parent ) {\n        this._parent = parent;\n    },\n\n    getParent: function () {\n        return this._parent;\n    },\n\n    getBinNumber: function () {\n        return this._binNum;\n    },\n\n    findOrInsert: function ( binNum, binName ) {\n        var bin = this._bins[ binNum ];\n\n        if ( !bin ) {\n            bin = this._createRenderBin( binName );\n            bin._parent = this;\n            bin._binNum = binNum;\n            bin._renderStage = this._renderStage;\n            this._bins[ binNum ] = bin;\n        }\n\n        return bin;\n    },\n\n    getStage: function () {\n        return this._renderStage;\n    },\n\n    addStateGraph: function ( sg ) {\n        this.stateGraphList.push( sg );\n    },\n\n    reset: function () {\n        this.stateGraphList.length = 0;\n        this._bins = {};\n        this.positionedAttribute.length = 0;\n        this._leafs.length = 0;\n        this._sorted = false;\n    },\n\n    draw: function ( state, previousRenderLeaf ) {\n\n        var previousLeaf = previousRenderLeaf;\n        // use callback drawImplementation if exist\n        if ( this._drawCallback && this._drawCallback.drawImplementation ) {\n            previousLeaf = this._drawCallback.drawImplementation( this, state, previousLeaf );\n        } else {\n            previousLeaf = this.drawImplementation( state, previousLeaf );\n        }\n\n        return previousLeaf;\n    },\n\n    applyPositionedAttribute: function ( state, positionedAttributes ) {\n        // the idea is to set uniform 'globally' in uniform map.\n        for ( var index = 0, l = positionedAttributes.length; index < l; index++ ) {\n            var element = positionedAttributes[ index ];\n            // add or set uniforms in state\n            var stateAttribute = element[ 1 ];\n            var matrix = element[ 0 ];\n            state.setGlobalDefaultAttribute( stateAttribute );\n            stateAttribute.apply( state );\n            stateAttribute.applyPositionedUniform( matrix, state );\n            state.haveAppliedAttribute( stateAttribute );\n        }\n    },\n\n    drawImplementation: function ( state, previousRenderLeaf ) {\n\n        var previousLeaf = previousRenderLeaf;\n\n        var binsArray = [];\n        for ( var keyBin in this._bins ) {\n            binsArray.push( this._bins[ keyBin ] );\n        }\n        binsArray.sort( sortBinNumberFunction );\n\n        var current = 0;\n        var end = binsArray.length;\n\n        var bin;\n        // draw pre bins\n        for ( ; current < end; current++ ) {\n            bin = binsArray[ current ];\n            if ( bin.getBinNumber() > 0 ) {\n                break;\n            }\n            previousLeaf = bin.draw( state, previousLeaf );\n        }\n\n        // draw leafs\n        previousLeaf = this.drawLeafs( state, previousLeaf );\n\n        // draw post bins\n        for ( ; current < end; current++ ) {\n            bin = binsArray[ current ];\n            previousLeaf = bin.draw( state, previousLeaf );\n        }\n        return previousLeaf;\n    },\n\n\n    drawLeafs: function ( state, previousRenderLeaf ) {\n\n        var stateList = this.stateGraphList;\n        var leafs = this._leafs;\n        var previousLeaf = previousRenderLeaf;\n        var leaf;\n\n\n        // draw fine grained ordering.\n        for ( var d = 0, dl = leafs.length; d < dl; d++ ) {\n            leaf = leafs[ d ];\n            leaf.render( state, previousLeaf );\n            previousLeaf = leaf;\n        }\n\n\n        // draw coarse grained ordering.\n        for ( var i = 0, l = stateList.length; i < l; i++ ) {\n\n            var sg = stateList[ i ];\n\n            for ( var j = 0, ll = sg.leafs.length; j < ll; j++ ) {\n\n                leaf = sg.leafs[ j ];\n                leaf.render( state, previousLeaf );\n                previousLeaf = leaf;\n\n            }\n        }\n        return previousLeaf;\n    }\n} ), 'osg', 'RenderBin' );\n\n\nRenderBin.getOrCreate = function () {\n\n    var l = RenderBin._reservedStack[ RenderBin._reservedStackCurrent++ ];\n    if ( RenderBin._reservedStackCurrent === RenderBin._reservedStack.length ) {\n        RenderBin._reservedStack.push( new RenderBin() );\n    }\n    return l;\n\n};\n\nRenderBin.resetStack = function () {\n    RenderBin._reservedStackCurrent = 0;\n};\n\nRenderBin._reservedStack = [ new RenderBin() ];\nRenderBin._reservedStackCurrent = 0;\n\nmodule.exports = RenderBin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/RenderBin.js\n// module id = 65\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Camera = require( 'osg/Camera' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar Notify = require( 'osg/notify' );\nvar RenderBin = require( 'osg/RenderBin' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n\n/**\n * From OpenSceneGraph http://www.openscenegraph.org\n * RenderStage base class. Used for encapsulate a complete stage in\n * rendering - setting up of viewport, the projection and model\n * matrices and rendering the RenderBin's enclosed with this RenderStage.\n * RenderStage also has a dependency list of other RenderStages, each\n * of which must be called before the rendering of this stage.  These\n * 'pre' rendering stages are used for advanced rendering techniques\n * like multistage pixel shading or impostors.\n */\nvar RenderStage = function () {\n\n    RenderBin.call( this );\n    this.clearColor = vec4.create();\n    this.preRenderList = [];\n    this.postRenderList = [];\n    // calling prototype to make sure\n    // we call renderstage and not renderbin init\n    RenderStage.prototype.init.call( this );\n\n};\n\nRenderStage.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( RenderBin.prototype, {\n\n    // temporary, Utils.createPrototypeClass will solve this\n    constructor: RenderStage,\n\n\n    init: function () {\n\n        RenderBin.prototype.init.call( this );\n        this.positionedAttribute.length = 0;\n        this.clearDepth = 1.0;\n        vec4.set( this.clearColor, 0.0, 0.0, 0.0, 1.0 );\n        /*jshint bitwise: false */\n        this.clearMask = Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT;\n        /*jshint bitwise: true */\n        this.camera = undefined;\n        this.viewport = undefined;\n        this.preRenderList.length = 0;\n        this.postRenderList.length = 0;\n        this._renderStage = this;\n\n        return this;\n    },\n\n    reset: function () {\n        RenderBin.prototype.reset.call( this );\n        this.preRenderList.length = 0;\n        this.postRenderList.length = 0;\n    },\n\n    setClearDepth: function ( depth ) {\n        this.clearDepth = depth;\n    },\n\n    getClearDepth: function () {\n        return this.clearDepth;\n    },\n\n    setClearColor: function ( color ) {\n        vec4.copy( this.clearColor, color );\n    },\n\n    getClearColor: function () {\n        return this.clearColor;\n    },\n\n    setClearMask: function ( mask ) {\n        this.clearMask = mask;\n    },\n\n    getClearMask: function () {\n        return this.clearMask;\n    },\n\n    setViewport: function ( vp ) {\n        this.viewport = vp;\n    },\n\n    getViewport: function () {\n        return this.viewport;\n    },\n\n    setCamera: function ( camera ) {\n        this.camera = camera;\n    },\n\n    getCamera: function () {\n        return this.camera;\n    },\n\n    getPositionedAttribute: function () {\n        return this.positionedAttribute;\n    },\n\n    getPreRenderStageList: function () {\n        return this.preRenderList;\n    },\n\n    getPostRenderStageList: function () {\n        return this.postRenderList;\n    },\n\n    addPreRenderStage: function ( rs, order ) {\n        for ( var i = 0, l = this.preRenderList.length; i < l; i++ ) {\n            var render = this.preRenderList[ i ];\n            if ( order < render.order ) {\n                break;\n            }\n        }\n        if ( i < this.preRenderList.length ) {\n            this.preRenderList = this.preRenderList.splice( i, 0, {\n                'order': order,\n                'renderStage': rs\n            } );\n        } else {\n            this.preRenderList.push( {\n                'order': order,\n                'renderStage': rs\n            } );\n        }\n    },\n\n    addPostRenderStage: function ( rs, order ) {\n        for ( var i = 0, l = this.postRenderList.length; i < l; i++ ) {\n            var render = this.postRenderList[ i ];\n            if ( order < render.order ) {\n                break;\n            }\n        }\n        if ( i < this.postRenderList.length ) {\n            this.postRenderList = this.postRenderList.splice( i, 0, {\n                'order': order,\n                'renderStage': rs\n            } );\n        } else {\n            this.postRenderList.push( {\n                'order': order,\n                'renderStage': rs\n            } );\n        }\n    },\n\n    drawPreRenderStages: function ( state, previousRenderLeaf ) {\n        var previousLeaf = previousRenderLeaf;\n        for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {\n            var sg = this.preRenderList[ i ].renderStage;\n            previousLeaf = sg.draw( state, previousLeaf );\n        }\n        return previousLeaf;\n    },\n\n    draw: function ( state, previousRenderLeaf ) {\n\n        if ( this.camera && this.camera.getInitialDrawCallback() ) {\n            // if we have a camera with a final callback invoke it.\n            this.camera.getInitialDrawCallback()( state );\n        }\n\n        var previousLeaf = this.drawPreRenderStages( state, previousRenderLeaf );\n\n        previousLeaf = this.drawImplementation( state, previousLeaf );\n\n        previousLeaf = this.drawPostRenderStages( state, previousLeaf );\n\n        if ( this.camera && this.camera.getFinalDrawCallback() ) {\n            // if we have a camera with a final callback invoke it.\n            this.camera.getFinalDrawCallback()( state );\n        }\n\n        return previousLeaf;\n\n    },\n\n    sort: function () {\n        for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {\n            this.preRenderList[ i ].renderStage.sort();\n        }\n\n        RenderBin.prototype.sort.call( this );\n\n        for ( var j = 0, k = this.postRenderList.length; j < k; ++j ) {\n            this.postRenderList[ j ].renderStage.sort();\n        }\n    },\n\n    drawPostRenderStages: function ( state, previousRenderLeaf ) {\n        var previousLeaf = previousRenderLeaf;\n        for ( var i = 0, l = this.postRenderList.length; i < l; ++i ) {\n            var sg = this.postRenderList[ i ].renderStage;\n            previousLeaf = sg.draw( state, previousLeaf );\n        }\n        return previousLeaf;\n    },\n\n    applyCamera: function ( state ) {\n        var gl = state.getGraphicContext();\n        if ( this.camera === undefined ) {\n            gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n            return;\n        }\n        var viewport = this.camera.getViewport();\n        var fbo = this.camera.frameBufferObject;\n\n        if ( !fbo ) {\n            fbo = new FrameBufferObject();\n            this.camera.frameBufferObject = fbo;\n        }\n\n        if ( fbo.isDirty() ) {\n\n            var attachments = this.camera.getAttachments();\n\n            // framebuffer texture and renderbuffer must be same dimension\n            // otherwise framebuffer is incomplete\n            var framebufferWidth, framebufferHeight;\n            var colorAttachment = attachments[ FrameBufferObject.COLOR_ATTACHMENT0 ];\n            if ( colorAttachment && colorAttachment.texture ) {\n                framebufferWidth = colorAttachment.texture.getWidth();\n                framebufferHeight = colorAttachment.texture.getHeight();\n            }\n\n            // we should use a map in camera to avoid to regenerate the keys\n            // each time. But because we dont have a lot of camera I guess\n            // it does not change a lot\n            // texture and renderbuffer must be same size.\n            for ( var keyAttachment in attachments ) {\n                colorAttachment = attachments[ keyAttachment ];\n\n                var attach = {};\n                attach.attachment = colorAttachment.attachment;\n\n                if ( colorAttachment.texture === undefined ) { //renderbuffer\n\n                    attach.format = colorAttachment.format;\n                    attach.width = framebufferWidth !== undefined ? framebufferWidth : viewport.width();\n                    attach.height = framebufferHeight !== undefined ? framebufferHeight : viewport.height();\n\n                } else {\n\n                    attach.texture = colorAttachment.texture;\n                    attach.textureTarget = colorAttachment.textureTarget;\n\n                    if ( colorAttachment.format ) {\n                        attach.format = colorAttachment.format;\n                    }\n                }\n\n                fbo.setAttachment( attach );\n            }\n        }\n        fbo.apply( state );\n    },\n\n    drawImplementation: function ( state, previousRenderLeaf ) {\n        var gl = state.getGraphicContext();\n\n        this.applyCamera( state );\n\n        // projection clipping\n        if ( this.viewport === undefined ) {\n            Notify.log( 'RenderStage does not have a valid viewport' );\n        }\n        state.applyAttribute( this.viewport );\n\n        // fragment clipping\n        if ( this.camera ) {\n            var scissor = this.camera.getStateSet() && this.camera.getStateSet().getAttribute( 'Scissor' );\n            if ( scissor ) state.applyAttribute( scissor );\n        }\n\n        /*jshint bitwise: false */\n        if ( this.clearMask !== 0x0 ) {\n            if ( this.clearMask & gl.COLOR_BUFFER_BIT ) {\n                gl.clearColor( this.clearColor[ 0 ], this.clearColor[ 1 ], this.clearColor[ 2 ], this.clearColor[ 3 ] );\n            }\n            if ( this.clearMask & gl.DEPTH_BUFFER_BIT ) {\n                gl.depthMask( true );\n                gl.clearDepth( this.clearDepth );\n            }\n            /*jshint bitwise: true */\n            gl.clear( this.clearMask );\n        }\n\n        if ( this.positionedAttribute.length !== 0 ) {\n            this.applyPositionedAttribute( state, this.positionedAttribute );\n        }\n\n        var previousLeaf = RenderBin.prototype.drawImplementation.call( this, state, previousRenderLeaf );\n\n        return previousLeaf;\n    }\n} ), 'osg', 'RenderStage' );\n\n\nmodule.exports = RenderStage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/RenderStage.js\n// module id = 66\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar GLObject = require( 'osg/GLObject' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Timer = require( 'osg/Timer' );\nvar WebglCaps = require( 'osg/WebGLCaps' );\n\n/**\n * FrameBufferObject manage fbo / rtt\n * @class FrameBufferObject\n */\nvar FrameBufferObject = function () {\n\n    GLObject.call( this );\n    StateAttribute.call( this );\n\n    this._fbo = undefined;\n    this._rbo = undefined;\n    this._attachments = [];\n    this._dirty = true;\n    this._hasMRT = WebglCaps.instance().getWebGLExtension( 'WEBGL_draw_buffers' );\n};\n\nFrameBufferObject.COLOR_ATTACHMENT0 = 0x8CE0;\nFrameBufferObject.DEPTH_ATTACHMENT = 0x8D00;\nFrameBufferObject.DEPTH_COMPONENT16 = 0x81A5;\n\n// static cache of glFrameBuffer flagged for deletion, which will actually\n// be deleted in the correct GL context.\nFrameBufferObject._sDeletedGLFrameBufferCache = new window.Map();\n\n// static method to delete FrameBuffers\nFrameBufferObject.deleteGLFrameBuffer = function ( gl, fb ) {\n\n    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) )\n        FrameBufferObject._sDeletedGLFrameBufferCache.set( gl, [] );\n\n    FrameBufferObject._sDeletedGLFrameBufferCache.get( gl ).push( fb );\n};\n\n// static method to flush all the cached glFrameBuffers which need to be deleted in the GL context specified\nFrameBufferObject.flushDeletedGLFrameBuffers = function ( gl, availableTime ) {\n\n    // if no time available don't try to flush objects.\n    if ( availableTime <= 0.0 ) return availableTime;\n\n    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) ) return availableTime;\n\n    var elapsedTime = 0.0;\n    var beginTime = Timer.instance().tick();\n    var deleteList = FrameBufferObject._sDeletedGLFrameBufferCache.get( gl );\n    var numBuffers = deleteList.length;\n\n    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {\n        gl.deleteFramebuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n    }\n\n    return availableTime - elapsedTime;\n};\n\nFrameBufferObject.flushAllDeletedGLFrameBuffers = function ( gl ) {\n\n    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) ) return;\n\n    var deleteList = FrameBufferObject._sDeletedGLFrameBufferCache.get( gl );\n    var numBuffers = deleteList.length;\n\n    for ( var i = numBuffers - 1; i >= 0; i-- ) {\n        gl.deleteFramebuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n    }\n};\n\n\n// static cache of glRenderBuffer flagged for deletion, which will actually\n// be deleted in the correct GL context.\nFrameBufferObject._sDeletedGLRenderBufferCache = new window.Map();\n\n// static method to delete RenderBuffers\nFrameBufferObject.deleteGLRenderBuffer = function ( gl, fb ) {\n\n    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) )\n        FrameBufferObject._sDeletedGLRenderBufferCache.set( gl, [] );\n\n    FrameBufferObject._sDeletedGLRenderBufferCache.get( gl ).push( fb );\n};\n\n\n// static method to flush all the cached glRenderBuffers which need to be deleted in the GL context specified\nFrameBufferObject.flushDeletedGLRenderBuffers = function ( gl, availableTime ) {\n\n    // if no time available don't try to flush objects.\n    if ( availableTime <= 0.0 ) return availableTime;\n\n    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) ) return availableTime;\n\n    var elapsedTime = 0.0;\n    var beginTime = Timer.instance().tick();\n    var deleteList = FrameBufferObject._sDeletedGLRenderBufferCache.get( gl );\n    var numBuffers = deleteList.length;\n\n    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {\n        gl.deleteRenderbuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n    }\n\n    return availableTime - elapsedTime;\n};\n\nFrameBufferObject.flushAllDeletedGLRenderBuffers = function ( gl ) {\n\n    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) ) return;\n\n    var deleteList = FrameBufferObject._sDeletedGLRenderBufferCache.get( gl );\n    var numBuffers = deleteList.length;\n\n    for ( var i = numBuffers - 1; i >= 0; i-- ) {\n        gl.deleteRenderbuffer( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n    }\n};\n\n/** @lends FrameBufferObject.prototype */\nFrameBufferObject.prototype = MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'FrameBufferObject',\n\n    cloneType: function () {\n        return new FrameBufferObject();\n    },\n\n    dirty: function () {\n        this._dirty = true;\n    },\n\n    isDirty: function () {\n        return this._dirty;\n    },\n\n    setAttachment: function ( attachment ) {\n        this._attachments.push( attachment );\n    },\n\n    releaseGLObjects: function () {\n\n        if ( this._fbo !== undefined && this._gl !== undefined ) {\n            FrameBufferObject.deleteGLFrameBuffer( this._gl, this._fbo );\n        }\n        this._fbo = undefined;\n\n        if ( this._rbo !== undefined && this._gl !== undefined ) {\n            FrameBufferObject.deleteGLRenderBuffer( this._gl, this._rbo );\n        }\n        this._rbo = undefined;\n\n    },\n\n    _reportFrameBufferError: function ( code ) {\n        switch ( code ) {\n        case 0x8CD6:\n            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT' );\n            break;\n        case 0x8CD7:\n            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT' );\n            break;\n        case 0x8CD9:\n            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS' );\n            break;\n        case 0x8CDD:\n            Notify.debug( 'FRAMEBUFFER_UNSUPPORTED' );\n            break;\n        default:\n            Notify.debug( 'FRAMEBUFFER unknown error ' + code.toString( 16 ) );\n        }\n    },\n\n    reset: function () {\n        this.releaseGLObjects();\n        this._attachments = [];\n    },\n\n    getFrameBufferObject: function () {\n        return this._fbo;\n    },\n\n    createFrameBufferObject: function ( state ) {\n        this.setGraphicContext( state.getGraphicContext() );\n        this._fbo = this._gl.createFramebuffer();\n    },\n\n    createRenderBuffer: function ( format, width, height ) {\n        var gl = this._gl;\n        var renderBuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer( gl.RENDERBUFFER, renderBuffer );\n        gl.renderbufferStorage( gl.RENDERBUFFER, format, width, height );\n\n        return renderBuffer;\n    },\n\n    framebufferRenderBuffer: function ( attachment, renderBuffer ) {\n\n        var gl = this._gl;\n        gl.bindRenderbuffer( gl.RENDERBUFFER, renderBuffer );\n        gl.framebufferRenderbuffer( gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer );\n\n    },\n\n    framebufferTexture2D: function ( state, attachment, textureTarget, texture ) {\n\n        var gl = this._gl;\n\n        // apply on unit 1 to init it\n        // make sure we do bind it whatever state stack\n        // texture is cached\n        state.applyTextureAttribute( 1, texture );\n\n        if ( texture.isDirty() || !texture.getTextureObject() ) {\n            // image wasn't ready, texture not allocated due to lack of gpu MEM\n            return false;\n        }\n\n        // gl2 vs gl1\n        var target = gl.DRAW_FRAMEBUFFER || gl.FRAMEBUFFER;\n        gl.framebufferTexture2D( target, attachment, textureTarget, texture.getTextureObject().id(), 0 );\n\n\n        return true;\n    },\n\n    bindFrameBufferObject: function () {\n        var gl = this._gl;\n        gl.bindFramebuffer( gl.FRAMEBUFFER, this._fbo );\n    },\n\n    checkStatus: function () {\n\n        var gl = this._gl;\n        var status = gl.checkFramebufferStatus( gl.FRAMEBUFFER );\n        if ( status !== gl.FRAMEBUFFER_COMPLETE ) {\n            this._reportFrameBufferError( status );\n        }\n    },\n\n    _checkAllowedSize: function ( w, h ) {\n\n        var maxSize = WebglCaps.instance().getWebGLParameter( 'MAX_RENDERBUFFER_SIZE' );\n\n        if ( w === 0 || h === 0 || h > maxSize || w > maxSize ) {\n            Notify.error( 'width (' + w + ') or height (' + w + ') makes frame buffer not bindable. Max RenderBuffer is \"' + maxSize + '\"' );\n            return false;\n        }\n\n        return true;\n\n    },\n\n    apply: function ( state ) {\n\n        if ( !this._gl ) this.setGraphicContext( state.getGraphicContext() );\n        var gl = this._gl;\n\n        var attachments = this._attachments;\n\n        // ?\n        if ( attachments.length === 0 && !this._fbo ) {\n            gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n            return;\n        }\n\n        // each frame\n        if ( !this.isDirty() ) {\n            gl.bindFramebuffer( gl.FRAMEBUFFER, this._fbo );\n            if ( Notify.reportWebGLError === true ) this.checkStatus();\n            return;\n        }\n\n        // if the fbo is created manually, we want to just bind it\n        if ( !this._fbo ) this.createFrameBufferObject( state );\n\n        this.bindFrameBufferObject();\n\n        // Check extDrawBuffers extension\n        var bufs = this._hasMRT ? [] : undefined;\n        var hasRenderBuffer = false;\n\n        for ( var i = 0, l = attachments.length; i < l; ++i ) {\n\n            var attachment = attachments[ i ];\n\n            // render buffer\n            if ( !attachment.texture ) {\n\n                if ( !this._checkAllowedSize( attachment.width, attachment.height ) ) {\n                    this.releaseGLObjects();\n                    return;\n                }\n\n                this._rbo = this.createRenderBuffer( attachment.format, attachment.width, attachment.height );\n                this.framebufferRenderBuffer( attachment.attachment, this._rbo );\n                hasRenderBuffer = true;\n\n            } else {\n\n                // use texture\n                var texture = attachment.texture;\n\n                if ( !this._checkAllowedSize( texture.getWidth(), texture.getHeight() ) ) {\n                    this.releaseGLObjects();\n                    return;\n                }\n\n                // Not sure is needed to check the attachment.attachment\n                if ( this._hasMRT && attachment.attachment >= gl.COLOR_ATTACHMENT0 && attachment.attachment <= gl.COLOR_ATTACHMENT15 ) {\n                    bufs.push( attachment.attachment );\n                }\n\n                if ( !this.framebufferTexture2D( state, attachment.attachment, attachment.textureTarget, texture ) ) {\n                    this.releaseGLObjects();\n                    return;\n\n                }\n            }\n        }\n\n        if ( bufs && bufs.length > 0 )\n            gl.drawBuffers( bufs );\n\n        this.checkStatus();\n\n        // set it to null only if used renderbuffer\n        if ( hasRenderBuffer )\n            gl.bindRenderbuffer( gl.RENDERBUFFER, null );\n\n        this._dirty = false;\n    }\n} ) );\n\n\nmodule.exports = FrameBufferObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/FrameBufferObject.js\n// module id = 67\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar BoundingSphere = require( 'osg/BoundingSphere' );\n\n/**\n *  Lod that can contains child node\n *  @class Lod\n */\nvar Lod = function () {\n    Node.call( this );\n    this._radius = -1;\n    this._range = [];\n    this._rangeMode = Lod.DISTANCE_FROM_EYE_POINT;\n    this._userDefinedCenter = [];\n    this._centerMode = Lod.USE_BOUNDING_SPHERE_CENTER;\n};\n\nLod.DISTANCE_FROM_EYE_POINT = 0;\nLod.PIXEL_SIZE_ON_SCREEN = 1;\n\nLod.USE_BOUNDING_SPHERE_CENTER = 0;\nLod.USER_DEFINED_CENTER = 1;\nLod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED = 2;\n\n/** @lends Lod.prototype */\nLod.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {\n    // Functions here\n    getRadius: function () {\n        return this._radius;\n    },\n\n    /** Set the object-space reference radius of the volume enclosed by the LOD.\n     * Used to determine the bounding sphere of the LOD in the absence of any children.*/\n    setRadius: function ( radius ) {\n        this._radius = radius;\n    },\n\n    setCenter: function ( center ) {\n        if ( this._centerMode !== Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED )\n            this._centerMode = Lod.USER_DEFINED_CENTER;\n        this._userDefinedCenter = center;\n    },\n\n    getCenter: function () {\n        if ( ( this._centerMode === Lod.USER_DEFINED_CENTER ) || ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED ) )\n            return this._userDefinedCenter;\n        else return this.getBound().center();\n    },\n\n    setCenterMode: function ( centerMode ) {\n        this._centerMode = centerMode;\n    },\n\n    computeBoundingSphere: function ( bsphere ) {\n        if ( this._centerMode === Lod.USER_DEFINED_CENTER && this._radius >= 0.0 ) {\n            bsphere.set( this._userDefinedCenter, this._radius );\n            return bsphere;\n        } else if ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED && this._radius >= 0.0 ) {\n            bsphere.set( this._userDefinedCenter, this._radius );\n            var bs = new BoundingSphere();\n            bsphere.expandByBoundingSphere( Node.prototype.computeBoundingSphere.call( this, bs ) );\n            return bsphere;\n        } else {\n            Node.prototype.computeBoundingSphere.call( this, bsphere );\n            return bsphere;\n        }\n    },\n\n    projectBoundingSphere: ( function () {\n        // from http://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm\n        // Sample code at http://www.shadertoy.com/view/XdBGzd?\n        var o = vec3.create();\n        return function ( sph, camMatrix, fle ) {\n            vec3.transformMat4( o, sph.center(), camMatrix );\n            var r2 = sph.radius2();\n            var z2 = o[ 2 ] * o[ 2 ];\n            var l2 = vec3.sqrLen( o );\n            var area = -Math.PI * fle * fle * r2 * Math.sqrt( Math.abs( ( l2 - r2 ) / ( r2 - z2 ) ) ) / ( r2 - z2 );\n            return area;\n        };\n    } )(),\n\n    setRangeMode: function ( mode ) {\n        //TODO: check if mode is correct\n        this._rangeMode = mode;\n    },\n\n    addChildNode: function ( node ) {\n\n        Node.prototype.addChild.call( this, node );\n        if ( this.children.length > this._range.length ) {\n            var r = [];\n            var max = 0.0;\n            if ( this._range.lenght > 0 )\n                max = this._range[ this._range.length - 1 ][ 1 ];\n            r.push( vec2.fromValues( max, max ) );\n            this._range.push( r );\n        }\n        return true;\n    },\n\n    addChild: function ( node, min, max ) {\n        Node.prototype.addChild.call( this, node );\n\n        if ( this.children.length > this._range.length ) {\n            var r = [];\n            r.push( vec2.fromValues( min, min ) );\n            this._range.push( r );\n        }\n        this._range[ this.children.length - 1 ][ 0 ] = min;\n        this._range[ this.children.length - 1 ][ 1 ] = max;\n        return true;\n    },\n\n    traverse: ( function () {\n\n        // avoid to generate variable on the heap to limit garbage collection\n        // instead create variable and use the same each time\n        var zeroVector = vec3.create();\n        var eye = vec3.create();\n        var viewModel = mat4.create();\n\n        return function ( visitor ) {\n            var traversalMode = visitor.traversalMode;\n\n            switch ( traversalMode ) {\n\n            case NodeVisitor.TRAVERSE_ALL_CHILDREN:\n\n                for ( var index = 0; index < this.children.length; index++ ) {\n                    this.children[ index ].accept( visitor );\n                }\n                break;\n\n            case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):\n                var requiredRange = 0;\n                var matrix = visitor.getCurrentModelViewMatrix();\n                mat4.invert( viewModel, matrix );\n                // Calculate distance from viewpoint\n                if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {\n                    vec3.transformMat4( eye, zeroVector, viewModel );\n                    var d = vec3.distance( this.getBound().center(), eye );\n                    requiredRange = d * visitor.getLODScale();\n                } else {\n                    // Let's calculate pixels on screen\n                    var projmatrix = visitor.getCurrentProjectionMatrix();\n                    // focal lenght is the value stored in projmatrix[0]\n                    requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );\n                    // Multiply by a factor to get the real area value\n                    requiredRange = ( ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25 ) / visitor.getLODScale();\n                }\n\n                var numChildren = this.children.length;\n                if ( this._range.length < numChildren ) numChildren = this._range.length;\n\n                for ( var j = 0; j < numChildren; ++j ) {\n                    if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {\n                        this.children[ j ].accept( visitor );\n                    }\n                }\n                break;\n\n            default:\n                break;\n            }\n        };\n    } )()\n\n} ), 'osg', 'Lod' );\n\nMACROUTILS.setTypeID( Lod );\nmodule.exports = Lod;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Lod.js\n// module id = 68\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Lod = require( 'osg/Lod' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n\n/**\n *  PagedLOD that can contains paged child nodes\n *  @class PagedLod\n */\nvar PagedLOD = function () {\n    Lod.call( this );\n    this._perRangeDataList = [];\n    this._loading = false;\n    this._expiryTime = 0.0;\n    this._expiryFrame = 0;\n    this._centerMode = Lod.USER_DEFINED_CENTER;\n    this._frameNumberOfLastTraversal = 0;\n    this._databasePath = '';\n    this._numChildrenThatCannotBeExpired = 0;\n};\n\n/**\n *  PerRangeData utility structure to store per range values\n *  @class PerRangeData\n */\nvar PerRangeData = function () {\n    this.filename = '';\n    this.function = undefined;\n    this.loaded = false;\n    this.timeStamp = 0.0;\n    this.frameNumber = 0;\n    this.frameNumberOfLastTraversal = 0;\n    this.dbrequest = undefined;\n};\n\n/** @lends PagedLOD.prototype */\nPagedLOD.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Lod.prototype, {\n    // Functions here\n    setRange: function ( childNo, min, max ) {\n        if ( childNo >= this._range.length ) {\n            var r = [];\n            r.push( [ min, min ] );\n            this._range.push( r );\n        }\n        this._range[ childNo ][ 0 ] = min;\n        this._range[ childNo ][ 1 ] = max;\n    },\n\n    setExpiryTime: function ( expiryTime ) {\n        this._expiryTime = expiryTime;\n    },\n\n    setDatabasePath: function ( path ) {\n        this._databasePath = path;\n    },\n\n    getDatabasePath: function () {\n        return this._databasePath;\n    },\n\n    setFileName: function ( childNo, filename ) {\n        // May we should expand the vector first?\n        if ( childNo >= this._perRangeDataList.length ) {\n            var rd = new PerRangeData();\n            rd.filename = filename;\n            this._perRangeDataList.push( rd );\n        } else {\n            this._perRangeDataList[ childNo ].filename = filename;\n        }\n    },\n    setFunction: function ( childNo, func ) {\n        if ( childNo >= this._perRangeDataList.length ) {\n            var rd = new PerRangeData();\n            rd.function = func;\n            this._perRangeDataList.push( rd );\n        } else {\n            this._perRangeDataList[ childNo ].function = func;\n        }\n    },\n\n    addChild: function ( node, min, max ) {\n        Lod.prototype.addChild.call( this, node, min, max );\n        this._perRangeDataList.push( new PerRangeData() );\n    },\n\n    addChildNode: function ( node ) {\n        Lod.prototype.addChildNode.call( this, node );\n    },\n\n    setFrameNumberOfLastTraversal: function ( frameNumber ) {\n        this._frameNumberOfLastTraversal = frameNumber;\n    },\n\n    getFrameNumberOfLastTraversal: function () {\n        return this._frameNumberOfLastTraversal;\n    },\n    setTimeStamp: function ( childNo, timeStamp ) {\n        this._perRangeDataList[ childNo ].timeStamp = timeStamp;\n    },\n    setFrameNumber: function ( childNo, frameNumber ) {\n        this._perRangeDataList[ childNo ].frameNumber = frameNumber;\n    },\n    setNumChildrenThatCannotBeExpired: function ( num ) {\n        this._numChildrenThatCannotBeExpired = num;\n    },\n    getNumChildrenThatCannotBeExpired: function () {\n        return this._numChildrenThatCannotBeExpired;\n    },\n    getDatabaseRequest: function ( childNo ) {\n        return this._perRangeDataList[ childNo ].dbrequest;\n    },\n    removeExpiredChildren: function ( expiryTime, expiryFrame, removedChildren ) {\n        if ( this.children.length <= this._numChildrenThatCannotBeExpired ) return;\n        var i = this.children.length - 1;\n        var timed, framed;\n        timed = this._perRangeDataList[ i ].timeStamp + this._expiryTime;\n        framed = this._perRangeDataList[ i ].frameNumber + this._expiryFrame;\n        if ( timed < expiryTime && framed < expiryFrame && ( this._perRangeDataList[ i ].filename.length > 0 ||\n                this._perRangeDataList[ i ].function !== undefined ) ) {\n            removedChildren.push( this.children[ i ] );\n            this.removeChild( this.children[ i ] );\n            this._perRangeDataList[ i ].loaded = false;\n            if ( this._perRangeDataList[ i ].dbrequest !== undefined ) {\n                this._perRangeDataList[ i ].dbrequest._groupExpired = true;\n            }\n        }\n    },\n\n    traverse: ( function () {\n\n        // avoid to generate variable on the heap to limit garbage collection\n        // instead create variable and use the same each time\n        var zeroVector = vec3.create();\n        var eye = vec3.create();\n        var viewModel = mat4.create();\n\n        return function ( visitor ) {\n\n            var traversalMode = visitor.traversalMode;\n            var updateTimeStamp = false;\n\n            if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {\n                this._frameNumberOfLastTraversal = visitor.getFrameStamp().getFrameNumber();\n                updateTimeStamp = true;\n            }\n\n            switch ( traversalMode ) {\n\n            case NodeVisitor.TRAVERSE_ALL_CHILDREN:\n\n                for ( var index = 0; index < this.children.length; index++ ) {\n                    this.children[ index ].accept( visitor );\n                }\n                break;\n\n            case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):\n                var requiredRange = 0;\n\n                // Calculate distance from viewpoint\n                var matrix = visitor.getCurrentModelViewMatrix();\n                mat4.invert( viewModel, matrix );\n                if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {\n                    vec3.transformMat4( eye, zeroVector, viewModel );\n                    var d = vec3.distance( this.getBound().center(), eye );\n                    requiredRange = d * visitor.getLODScale();\n                } else {\n                    // Calculate pixels on screen\n                    var projmatrix = visitor.getCurrentProjectionMatrix();\n                    // focal lenght is the value stored in projmatrix[0]\n                    requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );\n                    // Get the real area value and apply LODScale\n                    requiredRange = ( ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25 ) / visitor.getLODScale();\n                    if ( requiredRange < 0 ) requiredRange = this._range[ this._range.length - 1 ][ 0 ];\n                }\n\n                var needToLoadChild = false;\n                var lastChildTraversed = -1;\n                for ( var j = 0; j < this._range.length; ++j ) {\n                    if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {\n                        if ( j < this.children.length ) {\n\n                            if ( updateTimeStamp ) {\n                                this._perRangeDataList[ j ].timeStamp = visitor.getFrameStamp().getSimulationTime();\n                                this._perRangeDataList[ j ].frameNumber = visitor.getFrameStamp().getFrameNumber();\n                            }\n\n                            this.children[ j ].accept( visitor );\n                            lastChildTraversed = j;\n                        } else {\n                            needToLoadChild = true;\n                        }\n                    }\n                }\n                if ( needToLoadChild ) {\n                    var numChildren = this.children.length;\n                    if ( numChildren > 0 && ( ( numChildren - 1 ) !== lastChildTraversed ) ) {\n\n                        if ( updateTimeStamp ) {\n                            this._perRangeDataList[ numChildren - 1 ].timeStamp = visitor.getFrameStamp().getSimulationTime();\n                            this._perRangeDataList[ numChildren - 1 ].frameNumber = visitor.getFrameStamp().getFrameNumber();\n                        }\n\n                        this.children[ numChildren - 1 ].accept( visitor );\n                    }\n                    // now request the loading of the next unloaded child.\n                    if ( numChildren < this._perRangeDataList.length ) {\n                        // compute priority from where abouts in the required range the distance falls.\n                        var priority = ( this._range[ numChildren ][ 0 ] - requiredRange ) / ( this._range[ numChildren ][ 1 ] - this._range[ numChildren ][ 0 ] );\n                        if ( this._rangeMode === Lod.PIXEL_SIZE_ON_SCREEN ) {\n                            priority = -priority;\n                        }\n                        // Here we do the request\n                        var group = visitor.nodePath[ visitor.nodePath.length - 1 ];\n                        if ( this._perRangeDataList[ numChildren ].loaded === false ) {\n                            this._perRangeDataList[ numChildren ].loaded = true;\n                            var dbhandler = visitor.getDatabaseRequestHandler();\n                            this._perRangeDataList[ numChildren ].dbrequest = dbhandler.requestNodeFile( this._perRangeDataList[ numChildren ].function, this._databasePath + this._perRangeDataList[ numChildren ].filename, group, visitor.getFrameStamp().getSimulationTime(), priority );\n                        } else {\n                            // Update timestamp of the request.\n                            if ( this._perRangeDataList[ numChildren ].dbrequest !== undefined ) {\n                                this._perRangeDataList[ numChildren ].dbrequest._timeStamp = visitor.getFrameStamp().getSimulationTime();\n                                this._perRangeDataList[ numChildren ].dbrequest._priority = priority;\n                            } else {\n                                // The DB request is undefined, so the DBPager was not accepting requests, we need to ask for the child again.\n                                this._perRangeDataList[ numChildren ].loaded = false;\n                            }\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n        };\n    } )()\n\n\n} ), 'osg', 'PagedLOD' );\n\nMACROUTILS.setTypeID( PagedLOD );\nmodule.exports = PagedLOD;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/PagedLOD.js\n// module id = 69\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar UpdateSkeleton = require( 'osgAnimation/UpdateSkeleton' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar UpdateMatrixTransform = require( 'osgAnimation/UpdateMatrixTransform' );\nvar Bone = require( 'osgAnimation/Bone' );\n\n\nvar ResetRestPoseVisitor = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n};\nResetRestPoseVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    apply: function ( node ) {\n        if ( node.getTypeID() === Bone.getTypeID() ) {\n            var cb = node.getUpdateCallback();\n            if ( cb instanceof UpdateMatrixTransform ) {\n                var stackedTransforms = cb._stackedTransforms;\n                for ( var st = 0, l = stackedTransforms.length; st < l; st++ ) {\n                    var stackedTransform = stackedTransforms[ st ];\n                    stackedTransform.resetToDefaultValue();\n                }\n                cb.computeChannels();\n            }\n        }\n        this.traverse( node );\n    }\n} );\n\nvar resetter = new ResetRestPoseVisitor();\n\nvar Skeleton = function () {\n    MatrixTransform.call( this );\n};\n\nSkeleton.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( MatrixTransform.prototype, {\n\n    setDefaultUpdateCallback: function () {\n        this.addUpdateCallback( new UpdateSkeleton() );\n    },\n\n    setRestPose: function () {\n        this.accept( resetter );\n    }\n\n} ), 'osgAnimation', 'Skeleton' );\nMACROUTILS.setTypeID( Skeleton );\n\nmodule.exports = Skeleton;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/Skeleton.js\n// module id = 70\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Bone = require( 'osgAnimation/Bone' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Notify = require( 'osg/notify' );\nvar Object = require( 'osg/Object' );\n\n\n/**\n *  ValidateSkeletonVisitor\n *  @class ValidateSkeletonVisitor\n */\nvar ValidateSkeletonVisitor = function () {\n    NodeVisitor.call( this );\n};\n\nValidateSkeletonVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    apply: function ( node ) {\n        if ( node.getTypeID() !== Bone.getTypeID() ) {\n            return;\n        }\n        var foundNonBone = false;\n\n        var children = node.getChildren();\n        for ( var i = 0, l = node.getChildren().length; i < l; i++ ) {\n            var child = children[ i ];\n            if ( child.getTypeID() === Bone.getTypeID() ) {\n                if ( foundNonBone ) {\n                    Notify.warn( 'Warning: a Bone was found after a non-Bone child ' +\n                        'within a Skeleton. Children of a Bone must be ordered ' +\n                        'with all child Bones first for correct update order.' );\n                    //this.traversalMode = NodeVisitor.TRAVERSE_NONE;\n                    return;\n                }\n            } else {\n                foundNonBone = true;\n            }\n        }\n        this.traverse( node );\n    }\n\n} );\n\nvar compareBone = function ( x, y ) {\n    var a = x instanceof Bone ? 0 : 1;\n    var b = y instanceof Bone ? 0 : 1;\n\n    return a - b;\n};\n\n/**\n *  UpdateSkeleton\n *  @class UpdateSkeleton\n */\nvar UpdateSkeleton = function () {\n    this._needValidate = true;\n};\n\nUpdateSkeleton.prototype = MACROUTILS.objectInherit( Object.prototype, {\n    needToValidate: function () {\n        return this._needValidate;\n    },\n\n    update: function ( node, nv ) {\n        if ( this._needValidate && nv.getVisitorType() === NodeVisitor.UPDATE_VISITOR ) {\n            if ( node.className && node.className() === 'Skeleton' ) {\n                var validateSkeletonVisitor = new ValidateSkeletonVisitor();\n                var children = node.getChildren();\n                for ( var i = 0, l = children.length; i < l; i++ ) {\n                    var child = children[ i ];\n                    child.accept( validateSkeletonVisitor );\n                }\n\n                //Re-order skeleton children to force correct bones update, we should put bones first\n                children.sort( compareBone );\n\n                this._needValidate = false;\n            }\n        }\n        return true;\n    }\n} );\n\nmodule.exports = UpdateSkeleton;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/UpdateSkeleton.js\n// module id = 71\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar UpdateBone = require( 'osgAnimation/UpdateBone' );\n\n\n/**\n *  Bone\n *  @class Bone\n */\nvar Bone = function ( name ) {\n    if ( name !== undefined )\n        this.setName( name );\n\n    MatrixTransform.call( this );\n    this._invBindInSkeletonSpace = mat4.create();\n    this._boneInSkeletonSpace = mat4.create();\n    this._boneBoundingBox = new BoundingBox();\n};\n\nBone.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( MatrixTransform.prototype, {\n\n    // consistent color depending of id\n    // _rand: function ( id ) {\n    //     var x = Math.sin( id * 45.233 ) * 43758.5453;\n    //     return x - Math.floor( x );\n    // },\n    // _generateBoneColor: function ( id ) {\n    //     return vec3.fromValues( this._rand( id + 2.16 ), this._rand( id * 57.27 ), this._rand( id * 0.874 ) );\n    // },\n\n    getOrCreateDebugColor: function () {\n        // for bone display (debugging, etc)\n        if ( this._boneColor ) return this._boneColor;\n        // this._boneColor = this._generateBoneColor( this.getInstanceID() );\n        this._boneColor = vec3.fromValues( Math.random(), Math.random(), Math.random() );\n        return this._boneColor;\n    },\n\n    getBoneBoundingBox: function () {\n        return this._boneBoundingBox;\n    },\n\n    setBoneBoundingBox: function ( bb ) {\n        this._boneBoundingBox = bb;\n    },\n\n    getMatrixInSkeletonSpace: function () {\n        return this._boneInSkeletonSpace;\n    },\n\n    getInvBindMatrixInSkeletonSpace: function () {\n        return this._invBindInSkeletonSpace;\n    },\n\n    setMatrixInSkeletonSpace: function ( m ) {\n        mat4.copy( this._boneInSkeletonSpace, m );\n    },\n\n    setInvBindMatrixInSkeletonSpace: function ( m ) {\n        mat4.copy( this._invBindInSkeletonSpace, m );\n    },\n\n    getBoneParent: function () {\n        var parents = this.getParents();\n        for ( var i = 0, l = parents.length; i < l; i++ ) {\n            var typeID = parents[ i ].getTypeID();\n            if ( typeID === Bone.getTypeID() ) {\n                return parents[ i ];\n            }\n        }\n        return undefined;\n    },\n\n    setDefaultUpdateCallback: function ( name ) {\n        this.addUpdateCallback( new UpdateBone( ( name !== undefined ) ? name : this.getName() ) );\n    }\n} ), 'osgAnimation', 'Bone' );\nMACROUTILS.setTypeID( Bone );\n\nmodule.exports = Bone;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/Bone.js\n// module id = 72\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Notify = require( 'osg/notify' );\nvar UpdateMatrixTransform = require( 'osgAnimation/UpdateMatrixTransform' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar NodeVisitor = require( 'osg/NodeVisitor' );\n\n\n/**\n *  UpdateBone\n *  @class UpdateBone\n */\nvar UpdateBone = function () {\n    UpdateMatrixTransform.call( this );\n};\n\n/** @lends UpdateBone.prototype */\nUpdateBone.prototype = MACROUTILS.objectInherit( UpdateMatrixTransform.prototype, {\n\n    update: function ( node, nv ) {\n\n        if ( nv.getVisitorType() === NodeVisitor.UPDATE_VISITOR ) {\n\n            if ( node.className && node.className() !== 'Bone' ) {\n                Notify.warn( 'Warning: UpdateBone set on non-Bone object.' );\n                return false;\n            }\n\n            var bone = node;\n\n            UpdateMatrixTransform.prototype.update.call( this, node );\n            bone.setMatrix( bone.getMatrix() );\n            var matrix = bone.getMatrix();\n            var parent = bone.getBoneParent();\n\n            if ( parent ) {\n                mat4.mul( bone.getMatrixInSkeletonSpace(), parent.getMatrixInSkeletonSpace(), matrix );\n            } else {\n                bone.setMatrixInSkeletonSpace( matrix );\n            }\n        }\n        return true;\n    }\n\n} );\n\nmodule.exports = UpdateBone;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/UpdateBone.js\n// module id = 73\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar AnimationUpdateCallback = require( 'osgAnimation/AnimationUpdateCallback' );\n\n\n/**\n *  UpdateMatrixTransform\n */\nvar UpdateMatrixTransform = function () {\n    AnimationUpdateCallback.call( this );\n\n    // maybe could have a more generic name and used by all AnimationUpdateCallback\n    this._stackedTransforms = [];\n\n    this._matrix = mat4.create();\n\n    this._dirty = false;\n};\n\n\nUpdateMatrixTransform.prototype = MACROUTILS.objectInherit( AnimationUpdateCallback.prototype, {\n\n    getStackedTransforms: function () {\n        return this._stackedTransforms;\n    },\n\n    computeChannels: function () {\n        this._dirty = true;\n        var matrix = this._matrix;\n        mat4.identity( matrix );\n        var transforms = this._stackedTransforms;\n\n        for ( var i = 0, l = transforms.length; i < l; i++ ) {\n            var transform = transforms[ i ];\n            transform.applyToMatrix( matrix );\n        }\n    },\n\n    update: function ( node /*, nv */ ) {\n        mat4.copy( node.getMatrix(), this._matrix );\n        if ( this._dirty ) {\n            node.dirtyBound();\n            this._dirty = false;\n        }\n        return true;\n    }\n\n} );\n\nmodule.exports = UpdateMatrixTransform;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/UpdateMatrixTransform.js\n// module id = 74\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\n\n\n/**\n *  AnimationUpdateCallback\n *  @class AnimationUpdateCallback\n */\nvar AnimationUpdateCallback = function () {\n    Object.call( this );\n};\n\n// check if the path is animated, it could be elsewhere though\nAnimationUpdateCallback.checkPathIsAnimated = function ( path ) {\n\n    for ( var i = 0, nbNodes = path.length; i < nbNodes; ++i ) {\n        var node = path[ i ];\n\n        if ( node instanceof MatrixTransform ) {\n            var ups = node.getUpdateCallbackList();\n            for ( var j = 0, nbUp = ups.length; j < nbUp; ++j ) {\n                if ( ups[ j ] instanceof AnimationUpdateCallback )\n                    return true;\n            }\n        }\n\n    }\n\n    return false;\n};\n\n/** @lends AnimationUpdateCallback.prototype */\nAnimationUpdateCallback.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    linkChannel: function () {},\n    linkAnimation: function ( anim ) {\n        var name = this.getName();\n        if ( name.length === 0 ) {\n            Notify.log( 'no name on an update callback, discard' );\n            return 0;\n        }\n        var nbLinks = 0;\n        var channels = anim.getChannels();\n        for ( var i = 0, l = channels.length; i < l; i++ ) {\n            var channel = channels[ i ];\n            if ( channel.getTargetName() === name ) {\n                this.linkChannel( channel );\n                nbLinks++;\n            }\n        }\n        return nbLinks;\n    }\n} );\n\nmodule.exports = AnimationUpdateCallback;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/AnimationUpdateCallback.js\n// module id = 75\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Geometry = require( 'osg/Geometry' );\nvar Notify = require( 'osg/notify' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar StateSet = require( 'osg/StateSet' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\nvar UpdateRigGeometry = require( 'osgAnimation/UpdateRigGeometry' );\nvar RigTransformHardware = require( 'osgAnimation/RigTransformHardware' );\nvar AnimationUpdateCallback = require( 'osgAnimation/AnimationUpdateCallback' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\n\n\n// RigGeometry is a Geometry deformed by bones\n// To connect bones to RigGeometry it requires:\n//     - a map of bones with index / weight eg also called VertexInfluenceMap\n// {\n//     bone0: { index: [],  // vertex index\n//              weight: []  // weight for this index\n//            },\n//     bone2: { index: [],\n//              weight: []\n//            }\n// }\n\n\nvar RigGeometry = function () {\n\n    Geometry.call( this );\n\n    this._shape = null; // by default no kdtree/shape for rig\n\n    this.addUpdateCallback( new UpdateRigGeometry() );\n\n    // handle matrixFromSkeletonToGeometry and invMatrixFromSkeletonToGeometry computation\n    this._root = undefined;\n    this._pathToRoot = undefined;\n    this._isAnimatedPath = false;\n\n    this._boneNameID = {};\n\n    this._matrixFromSkeletonToGeometry = mat4.create();\n    this._invMatrixFromSkeletonToGeometry = mat4.create();\n\n    this._rigTransformImplementation = new RigTransformHardware();\n\n    // RigGeometry have a special stateset that will be pushed at the very end of the culling\n    // this stateSet only represents animation (and shouldn't contain any rendering attributes)\n    // It's a way to make every RigGeometry unique (in term of stateSet stack)\n    this._stateSetAnimation = new StateSet();\n\n    this._needToComputeMatrix = true;\n\n};\n\nRigGeometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Geometry.prototype, {\n\n    getStateSetAnimation: function () {\n        return this._stateSetAnimation;\n    },\n\n    getSkeleton: function () {\n        return this._root;\n    },\n\n    setSkeleton: function ( root ) {\n        this._root = root;\n    },\n\n    setPathToSkeleton: function ( path ) {\n        this._pathToRoot = path;\n        this._isAnimatedPath = AnimationUpdateCallback.checkPathIsAnimated( path );\n    },\n\n    setNeedToComputeMatrix: function ( needToComputeMatrix ) {\n        this._needToComputeMatrix = needToComputeMatrix;\n    },\n\n    getNeedToComputeMatrix: function () {\n        return this._needToComputeMatrix;\n    },\n\n    computeBoundingBox: function ( boundingBox ) {\n\n        boundingBox.init();\n\n        var vertexArray = this.getVertexAttributeList().Vertex;\n        var weightsArray = this.getVertexAttributeList().Weights;\n        // mainly copy paste of geometry computeBoundingBox code, except we only\n        // take into account the non-influenced vertices\n\n        // we do that only for the non-influenced vertices because the rigged ones\n        // can't be statically computed (full moving bbox of rigs should be computed externally\n        // through bones or cpu rigged colision mesh, etc)\n        // bbox is important for culling (near/far)\n\n        if ( vertexArray && weightsArray && vertexArray.getElements() && vertexArray.getItemSize() > 2 ) {\n\n            var weights = weightsArray.getElements();\n            var vertexes = vertexArray.getElements();\n            var itemSize = vertexArray.getItemSize();\n\n            var min = boundingBox.getMin();\n            var max = boundingBox.getMax();\n\n            var minx = min[ 0 ];\n            var miny = min[ 1 ];\n            var minz = min[ 2 ];\n            var maxx = max[ 0 ];\n            var maxy = max[ 1 ];\n            var maxz = max[ 2 ];\n\n            for ( var idx = 0, idb = 0, l = vertexes.length; idx < l; idx += itemSize, idb += 4 ) {\n\n                if ( weights[ idx ] !== 0.0 || weights[ idx + 1 ] !== 0.0 || weights[ idx + 2 ] !== 0.0 || weights[ idx + 3 ] !== 0.0 )\n                    continue;\n\n                var v1 = vertexes[ idx ];\n                var v2 = vertexes[ idx + 1 ];\n                var v3 = vertexes[ idx + 2 ];\n                if ( v1 < minx ) minx = v1;\n                if ( v1 > maxx ) maxx = v1;\n                if ( v2 < miny ) miny = v2;\n                if ( v2 > maxy ) maxy = v2;\n                if ( v3 < minz ) minz = v3;\n                if ( v3 > maxz ) maxz = v3;\n            }\n\n            min[ 0 ] = minx;\n            min[ 1 ] = miny;\n            min[ 2 ] = minz;\n            max[ 0 ] = maxx;\n            max[ 1 ] = maxy;\n            max[ 2 ] = maxz;\n        }\n\n        return boundingBox;\n    },\n\n    computeMatrixFromRootSkeleton: function () {\n\n        if ( !this._root ) {\n            Notify.warn( 'Warning ' + this.className() + '.computeMatrixFromRootSkeleton if you have this message it means you miss to call buildTransformer( root ), or your RigGeometry (' + this.getName() + ') is not attached to a Skeleton subgraph' );\n            return;\n        }\n\n        mat4.identity( this._matrixFromSkeletonToGeometry );\n        ComputeMatrixFromNodePath.computeLocalToWorld( this._pathToRoot, true, this._matrixFromSkeletonToGeometry );\n        mat4.invert( this._invMatrixFromSkeletonToGeometry, this._matrixFromSkeletonToGeometry );\n\n        if ( !this._isAnimatedPath )\n            this._needToComputeMatrix = false;\n    },\n\n    getMatrixFromSkeletonToGeometry: function () {\n        return this._matrixFromSkeletonToGeometry;\n    },\n\n    getInvMatrixFromSkeletonToGeometry: function () {\n        return this._invMatrixFromSkeletonToGeometry;\n    },\n\n    getSourceGeometry: function () {\n        return this._geometry;\n    },\n\n    setSourceGeometry: function ( geometry ) {\n        this._geometry = geometry;\n    },\n\n    getBoneNameID: function () {\n        return this._boneNameID;\n    },\n\n    setBoneNameID: function ( boneMap ) {\n        this._boneNameID = boneMap;\n    },\n\n    mergeChildrenVertexAttributeList: function () {\n\n        if ( this._geometry instanceof MorphGeometry )\n            this._geometry.mergeChildrenVertexAttributeList();\n\n        var sourceGeometryVertexAttributeList = this._geometry.getVertexAttributeList();\n\n        Geometry.appendVertexAttributeToList( sourceGeometryVertexAttributeList, this.getVertexAttributeList() );\n\n    },\n\n    mergeChildrenData: function () {\n\n        // move to the rig the vertex attributes, the primitives and the stateset\n\n        this.mergeChildrenVertexAttributeList();\n        var primitiveSetList = this._geometry.getPrimitiveSetList();\n\n        this.getPrimitiveSetList().length = 0;\n        for ( var i = 0, il = primitiveSetList.length; i < il; i++ )\n            this.getPrimitiveSetList()[ i ] = primitiveSetList[ i ];\n\n        if ( this.getStateSet() )\n            console.error( 'A stateset in the rig is already present : ' + this.getStateSet() );\n        this.setStateSet( this._geometry.getStateSet() );\n    },\n\n    update: function () {\n        this._rigTransformImplementation.update( this );\n    },\n\n    computeTransformedVertex: function ( id, out ) {\n        out = out || vec3.create();\n\n        var vList = this.getVertexAttributeList();\n        var vWeights = vList.Weights.getElements();\n        var vBones = vList.Bones.getElements();\n\n        var x = 0.0;\n        var y = 0.0;\n        var z = 0.0;\n        if ( this._geometry.computeTransformedVertex ) {\n            this._geometry.computeTransformedVertex( id, out );\n            x = out[ 0 ];\n            y = out[ 1 ];\n            z = out[ 2 ];\n        } else {\n            var verts = vList.Vertex.getElements();\n            x = verts[ id * 3 ];\n            y = verts[ id * 3 + 1 ];\n            z = verts[ id * 3 + 2 ];\n        }\n\n        var id4 = id * 4;\n\n        var palette = this._rigTransformImplementation._skinningAttribute.getMatrixPalette();\n        var m0 = 0.0;\n        var m1 = 0.0;\n        var m2 = 0.0;\n        var m4 = 0.0;\n        var m5 = 0.0;\n        var m6 = 0.0;\n        var m8 = 0.0;\n        var m9 = 0.0;\n        var m10 = 0.0;\n        var m12 = 0.0;\n        var m13 = 0.0;\n        var m14 = 0.0;\n        var m15 = 0.0;\n\n        var doSkin = false;\n        for ( var i = 0; i < 4; ++i ) {\n            var w = vWeights[ id4 + i ];\n            if ( w === 0.0 )\n                continue;\n\n            var idBone = vBones[ id4 + i ] * 12;\n\n            m0 += palette[ idBone + 0 ] * w;\n            m4 += palette[ idBone + 1 ] * w;\n            m8 += palette[ idBone + 2 ] * w;\n            m12 += palette[ idBone + 3 ] * w;\n\n            m1 += palette[ idBone + 4 ] * w;\n            m5 += palette[ idBone + 5 ] * w;\n            m9 += palette[ idBone + 6 ] * w;\n            m13 += palette[ idBone + 7 ] * w;\n\n            m2 += palette[ idBone + 8 ] * w;\n            m6 += palette[ idBone + 9 ] * w;\n            m10 += palette[ idBone + 10 ] * w;\n            m14 += palette[ idBone + 11 ] * w;\n\n            m15 += w;\n            doSkin = true;\n        }\n\n        if ( !doSkin ) {\n            out[ 0 ] = x;\n            out[ 1 ] = y;\n            out[ 2 ] = z;\n        }\n\n        var d = 1.0 / m15;\n        out[ 0 ] = ( m0 * x + m4 * y + m8 * z + m12 ) * d;\n        out[ 1 ] = ( m1 * x + m5 * y + m9 * z + m13 ) * d;\n        out[ 2 ] = ( m2 * x + m6 * y + m10 * z + m14 ) * d;\n\n        return out;\n    },\n\n    computeTransformedVertices: function () {\n\n        // obviously slow as it can't rely on kdTree AND we transform everything cpu side\n\n        var vList = this.getVertexAttributeList();\n        var verts = this._geometry.computeTransformedVertices ? this._geometry.computeTransformedVertices() : vList.Vertex.getElements();\n        var vWeights = vList.Weights.getElements();\n        var vBones = vList.Bones.getElements();\n\n        var riggedVerts = this._riggedVerts || new Float32Array( verts.length );\n\n        // /!\\ if the geometry has several parents inside a skeleton\n        // it might not work as it will just take the last compute matrix palette\n        var palette = this._rigTransformImplementation._skinningAttribute.getMatrixPalette();\n\n        // verbose... but fast\n        for ( var idv = 0, idr = 0, len = verts.length; idv < len; idv += 3, idr += 4 ) {\n\n            var m0 = 0.0;\n            var m1 = 0.0;\n            var m2 = 0.0;\n\n            var m4 = 0.0;\n            var m5 = 0.0;\n            var m6 = 0.0;\n\n            var m8 = 0.0;\n            var m9 = 0.0;\n            var m10 = 0.0;\n\n            var m12 = 0.0;\n            var m13 = 0.0;\n            var m14 = 0.0;\n            var m15 = 0.0;\n\n            var doSkin = false;\n\n            var w = vWeights[ idr ];\n            var idBone;\n            if ( w !== 0.0 ) {\n                idBone = vBones[ idr ] * 12;\n                m0 += palette[ idBone + 0 ] * w;\n                m4 += palette[ idBone + 1 ] * w;\n                m8 += palette[ idBone + 2 ] * w;\n                m12 += palette[ idBone + 3 ] * w;\n\n                m1 += palette[ idBone + 4 ] * w;\n                m5 += palette[ idBone + 5 ] * w;\n                m9 += palette[ idBone + 6 ] * w;\n                m13 += palette[ idBone + 7 ] * w;\n\n                m2 += palette[ idBone + 8 ] * w;\n                m6 += palette[ idBone + 9 ] * w;\n                m10 += palette[ idBone + 10 ] * w;\n                m14 += palette[ idBone + 11 ] * w;\n\n                m15 += w;\n                doSkin = true;\n            }\n\n            w = vWeights[ idr + 1 ];\n            if ( w !== 0.0 ) {\n                idBone = vBones[ idr + 1 ] * 12;\n                m0 += palette[ idBone + 0 ] * w;\n                m4 += palette[ idBone + 1 ] * w;\n                m8 += palette[ idBone + 2 ] * w;\n                m12 += palette[ idBone + 3 ] * w;\n\n                m1 += palette[ idBone + 4 ] * w;\n                m5 += palette[ idBone + 5 ] * w;\n                m9 += palette[ idBone + 6 ] * w;\n                m13 += palette[ idBone + 7 ] * w;\n\n                m2 += palette[ idBone + 8 ] * w;\n                m6 += palette[ idBone + 9 ] * w;\n                m10 += palette[ idBone + 10 ] * w;\n                m14 += palette[ idBone + 11 ] * w;\n\n                m15 += w;\n                doSkin = true;\n            }\n\n            w = vWeights[ idr + 2 ];\n            if ( w !== 0.0 ) {\n                idBone = vBones[ idr + 2 ] * 12;\n\n                m0 += palette[ idBone + 0 ] * w;\n                m4 += palette[ idBone + 1 ] * w;\n                m8 += palette[ idBone + 2 ] * w;\n                m12 += palette[ idBone + 3 ] * w;\n\n                m1 += palette[ idBone + 4 ] * w;\n                m5 += palette[ idBone + 5 ] * w;\n                m9 += palette[ idBone + 6 ] * w;\n                m13 += palette[ idBone + 7 ] * w;\n\n                m2 += palette[ idBone + 8 ] * w;\n                m6 += palette[ idBone + 9 ] * w;\n                m10 += palette[ idBone + 10 ] * w;\n                m14 += palette[ idBone + 11 ] * w;\n\n                m15 += w;\n                doSkin = true;\n            }\n\n            w = vWeights[ idr + 3 ];\n            if ( w !== 0.0 ) {\n                idBone = vBones[ idr + 3 ] * 12;\n\n                m0 += palette[ idBone + 0 ] * w;\n                m4 += palette[ idBone + 1 ] * w;\n                m8 += palette[ idBone + 2 ] * w;\n                m12 += palette[ idBone + 3 ] * w;\n\n                m1 += palette[ idBone + 4 ] * w;\n                m5 += palette[ idBone + 5 ] * w;\n                m9 += palette[ idBone + 6 ] * w;\n                m13 += palette[ idBone + 7 ] * w;\n\n                m2 += palette[ idBone + 8 ] * w;\n                m6 += palette[ idBone + 9 ] * w;\n                m10 += palette[ idBone + 10 ] * w;\n                m14 += palette[ idBone + 11 ] * w;\n\n                m15 += w;\n                doSkin = true;\n            }\n\n            var x = verts[ idv ];\n            var y = verts[ idv + 1 ];\n            var z = verts[ idv + 2 ];\n\n            if ( !doSkin ) {\n                riggedVerts[ idv ] = x;\n                riggedVerts[ idv + 1 ] = y;\n                riggedVerts[ idv + 2 ] = z;\n                continue;\n            }\n\n            var d = 1.0 / m15;\n            riggedVerts[ idv ] = ( m0 * x + m4 * y + m8 * z + m12 ) * d;\n            riggedVerts[ idv + 1 ] = ( m1 * x + m5 * y + m9 * z + m13 ) * d;\n            riggedVerts[ idv + 2 ] = ( m2 * x + m6 * y + m10 * z + m14 ) * d;\n        }\n\n        return riggedVerts;\n    }\n\n} ), 'osgAnimation', 'RigGeometry' );\n\nMACROUTILS.setTypeID( RigGeometry );\n\nmodule.exports = RigGeometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/RigGeometry.js\n// module id = 76\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar BufferArrayProxy = require( 'osg/BufferArrayProxy' );\nvar Notify = require( 'osg/notify' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Geometry = require( 'osg/Geometry' );\nvar StateSet = require( 'osg/StateSet' );\nvar MorphAttribute = require( 'osgAnimation/MorphAttribute' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar BoundingBox = require( 'osg/BoundingBox' );\n\n\n/**\n * MorphGeometry manage up to MorphGeometry.MAX_MORPH_GPU morphTargets\n * @class MorphGeometry\n * @inherits Geometry\n */\n\nvar MorphGeometry = function () {\n    Geometry.call( this );\n\n    this._shape = null; // by default no kdtree/shape for morph\n\n    this._targets = []; // Target list (Geometry)\n    this._stateSetAnimation = new StateSet(); // StateSet to handle morphAttribute\n    this._targetWeights = new Float32Array( MorphGeometry.MAX_MORPH_GPU ); // Fixed length array feed by UpdateMorph\n\n    this._morphAttribute = undefined;\n    this._morphTargetNames = undefined;\n\n    this._maxMorphGPU = MorphGeometry.MAX_MORPH_GPU; // used by updateMorph to limit the number of morphed attributes done by the gpu\n\n    this._isInitialized = false;\n};\n\n// sync with UpdateMorph\nvar EFFECTIVE_EPS = MorphGeometry.EFFECTIVE_EPS = 0.05;\n\n// this should be constant, if you change it only do it at parse time, otherwise it's better to call setMaximumPossibleMorphGPU\nMorphGeometry.MAX_MORPH_GPU = 4;\n\nMorphGeometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Geometry.prototype, {\n\n    init: function () {\n        if ( this._morphAttribute ) {\n            this._isInitialized = true;\n            return;\n        }\n\n        this._morphAttribute = new MorphAttribute( Math.min( this._maxMorphGPU, this.getMorphTargets().length ) );\n        this.getStateSetAnimation().setAttributeAndModes( this._morphAttribute, StateAttribute.ON );\n        this._morphAttribute.setTargetWeights( this.getTargetsWeight() );\n\n        if ( this._targets[ 0 ] ) {\n            this._morphTargetNames = window.Object.keys( this._targets[ 0 ].getVertexAttributeList() );\n            this._morphAttribute.copyTargetNames( this._morphTargetNames );\n        } else {\n            this._morphTargetNames = [];\n            Notify.error( 'No Targets in the MorphGeometry !' );\n        }\n\n        this._isInitialized = true;\n        return true;\n    },\n\n    getMaximumPossibleMorphGPU: function () {\n        return this._maxMorphGPU;\n    },\n\n    setMaximumPossibleMorphGPU: function ( nb ) {\n        this._maxMorphGPU = nb;\n        this._isInitialized = false; // it's mostly UpdateMorph that we want to dirty\n        if ( this._morphAttribute ) this._morphAttribute.setNumTargets( nb );\n    },\n\n    getMorphTargetNames: function () {\n        return this._morphTargetNames;\n    },\n\n    getStateSetAnimation: function () {\n        return this._stateSetAnimation;\n    },\n\n    getMorphTargets: function () {\n        return this._targets;\n    },\n\n    isInitialized: function () {\n        return this._isInitialized;\n    },\n\n    getTargetsWeight: function () {\n        return this._targetWeights;\n    },\n\n    computeBoundingBox: ( function () {\n        var tmpBox = new BoundingBox();\n\n        return function ( boundingBox ) {\n            Geometry.prototype.computeBoundingBox.call( this, boundingBox );\n\n            // expand bb with targets\n            // Note : if the morphs have many many targets it can be done more smartly in\n            // the UpdateMorph on each frame by just taking into account the \"active morphs\"\n            for ( var i = 0, l = this._targets.length; i < l; i++ ) {\n                boundingBox.expandByBoundingBox( this._targets[ i ].computeBoundingBox( tmpBox ) );\n            }\n\n            return boundingBox;\n        };\n    } )(),\n\n    mergeChildrenVertexAttributeList: function () {\n\n        for ( var i = 0, l = this._targets.length; i < l; i++ ) {\n\n            var target = this._targets[ i ];\n\n            // change BufferArray to BufferArrayProxy\n            var attributeList = target.getVertexAttributeList();\n            for ( var keyAttribute in attributeList ) {\n                var att = attributeList[ keyAttribute ];\n                // check it's a buffer array before swtiching to proxy\n                if ( att && !att.getBufferArray ) {\n\n                    attributeList[ keyAttribute ] = new BufferArrayProxy( att );\n\n                }\n\n            }\n\n            Geometry.appendVertexAttributeToList( target.getVertexAttributeList(), this.getVertexAttributeList(), i );\n\n        }\n\n    },\n\n    _computeEffectiveSumWeights: function () {\n        var sum = 0.0;\n        var weights = this._targetWeights;\n        for ( var i = 0, nb = weights.length; i < nb; ++i ) {\n\n            var weight = weights[ i ];\n            if ( Math.abs( weight ) < EFFECTIVE_EPS )\n                continue;\n\n            sum += weight;\n        }\n        var eps = 1e-5;\n        if ( Math.abs( sum ) > eps ) return sum;\n        return sum < 0.0 ? -eps : eps;\n    },\n\n    computeTransformedVertex: function ( id, out ) {\n        out = out || vec3.create();\n\n        var id3 = id * 3;\n\n        var weights = this._targetWeights;\n        var vList = this.getVertexAttributeList();\n\n        var baseVerts = vList.Vertex.getElements();\n\n        var sumWeights = 1.0 - this._computeEffectiveSumWeights();\n        out[ 0 ] = sumWeights * baseVerts[ id3 ];\n        out[ 1 ] = sumWeights * baseVerts[ id3 + 1 ];\n        out[ 2 ] = sumWeights * baseVerts[ id3 + 2 ];\n\n        for ( var j = 0, nb = weights.length; j < nb; ++j ) {\n\n            var weight = weights[ j ];\n            if ( Math.abs( weight ) < EFFECTIVE_EPS )\n                continue;\n\n            var morphElts = vList[ 'Vertex_' + j ].getElements();\n            out[ 0 ] += weight * morphElts[ id3 ];\n            out[ 1 ] += weight * morphElts[ id3 + 1 ];\n            out[ 2 ] += weight * morphElts[ id3 + 2 ];\n        }\n\n        return out;\n    },\n\n    computeTransformedVertices: function () {\n\n        var weights = this._targetWeights;\n        var vList = this.getVertexAttributeList();\n\n        var baseVerts = vList.Vertex.getElements();\n        var vertexLen = baseVerts.length;\n\n        var morphedVerts = this._morphedVerts = this._morphedVerts || new Float32Array( vertexLen );\n\n        // base vertex influence\n        var baseWeight = 1.0 - this._computeEffectiveSumWeights();\n        for ( var i = 0; i < vertexLen; ++i ) {\n            morphedVerts[ i ] = baseWeight * baseVerts[ i ];\n        }\n\n        for ( var j = 0, nb = weights.length; j < nb; ++j ) {\n\n            var weight = weights[ j ];\n            if ( Math.abs( weight ) < EFFECTIVE_EPS )\n                continue;\n\n            // important : we should not take getInitialBufferArray as we should take the partially computed cpu morph from UpdateMorph\n            var morphElts = vList[ 'Vertex_' + j ].getElements();\n            for ( var k = 0; k < vertexLen; ++k ) {\n                morphedVerts[ k ] += weight * morphElts[ k ];\n            }\n        }\n\n        return morphedVerts;\n    }\n\n\n} ), 'osgAnimation', 'MorphGeometry' );\n\nMACROUTILS.setTypeID( MorphGeometry );\n\nmodule.exports = MorphGeometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/MorphGeometry.js\n// module id = 77\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\n\n\n/**\n * MorphAttribute encapsulate Animation State\n * @class MorphAttribute\n * @inherits StateAttribute\n */\nvar MorphAttribute = function ( nbTarget, disable ) {\n    StateAttribute.call( this );\n    this._nbTarget = nbTarget;\n    this._enable = !disable;\n\n    this._targetNames = {};\n    this._hashNames = ''; // compute only once target hash names\n\n    this._hash = ''; // cache of hash\n};\n\nMorphAttribute.uniforms = {};\n\nMorphAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Morph',\n\n    cloneType: function () {\n        return new MorphAttribute( undefined, true );\n    },\n\n    hasTarget: function ( name ) {\n        return !!this._targetNames[ name ];\n    },\n\n    copyTargetNames: function ( names ) {\n        var tNames = this._targetNames;\n        var hash = '';\n        var nbNames = tNames.length = names.length;\n\n        for ( var i = 0; i < nbNames; ++i ) {\n            var att = names[ i ];\n            tNames[ att ] = true;\n            hash += att;\n        }\n\n        this._hashNames = hash;\n        this._hash = '';\n    },\n\n    getOrCreateUniforms: function () {\n        var obj = MorphAttribute;\n        var unifHash = this.getNumTargets();\n\n        if ( obj.uniforms[ unifHash ] ) return obj.uniforms[ unifHash ];\n\n        obj.uniforms[ unifHash ] = {\n            uTargetWeights: Uniform.createFloat4( 'uTargetWeights' )\n        };\n\n        return obj.uniforms[ unifHash ];\n    },\n\n    setNumTargets: function ( nb ) {\n        this._nbTarget = nb;\n        this._hash = '';\n    },\n\n    getNumTargets: function () {\n        return this._nbTarget;\n    },\n\n    setTargetWeights: function ( targetWeight ) {\n        this._targetWeights = targetWeight;\n    },\n\n    getTargetWeights: function () {\n        return this._targetWeights;\n    },\n\n    isEnabled: function () {\n        return this._enable;\n    },\n\n    getHash: function () {\n        if ( !this._hash ) this._hash = this.getTypeMember() + this._hashNames + this.getNumTargets() + this.isEnabled();\n        return this._hash;\n    },\n\n    apply: function () {\n\n        if ( !this._enable ) return;\n\n        var uniformMap = this.getOrCreateUniforms();\n        uniformMap.uTargetWeights.setFloat4( this._targetWeights );\n\n    }\n\n} ), 'osgAnimation', 'MorphAttribute' );\n\nMACROUTILS.setTypeID( MorphAttribute );\n\nmodule.exports = MorphAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/MorphAttribute.js\n// module id = 78\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Notify = require( 'osg/notify' );\nvar ObjectBase = require( 'osg/Object' );\nvar FindNearestParentSkeleton = require( 'osgAnimation/FindNearestParentSkeleton' );\n\n\n// converted from C++ probably it could be merged into RigGeometry\n// it could probably inlined into RigGeometry code\nvar UpdateRigGeometry = function () {\n    ObjectBase.call( this );\n};\n\nUpdateRigGeometry.prototype = MACROUTILS.objectInherit( ObjectBase.prototype, {\n\n    init: function ( geom ) {\n\n        var finder = new FindNearestParentSkeleton();\n        if ( geom.getParents().length > 1 )\n            Notify.warn( 'A RigGeometry should not have multi parent ( ' + geom.getName() + ' )' );\n\n        geom.getParents()[ 0 ].accept( finder );\n\n        if ( !finder._root ) {\n            Notify.warn( 'A RigGeometry did not find a parent skeleton for RigGeometry ( ' + geom.getName() + ' )' );\n            return;\n        }\n\n        geom.setSkeleton( finder._root );\n        geom.setPathToSkeleton( finder._pathToRoot );\n    },\n\n    update: function ( node /*, nv*/ ) {\n\n        // Circular ref\n        if ( node && node.className() !== 'RigGeometry' ) return true;\n\n        var geom = node;\n\n        // maybe this code could simpler\n        if ( !geom.getSkeleton() && geom.getParents().length !== 0 ) this.init( geom );\n        if ( !geom.getSkeleton() ) return true;\n\n        if ( geom.getNeedToComputeMatrix() ) geom.computeMatrixFromRootSkeleton();\n\n        geom.update();\n\n        return true;\n    }\n\n} );\n\nmodule.exports = UpdateRigGeometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/UpdateRigGeometry.js\n// module id = 79\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Skeleton = require( 'osgAnimation/Skeleton' );\n\n\n/**\n * FindNearestParentSkeleton\n */\n\nvar FindNearestParentSkeleton = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );\n    this._root = undefined;\n\n    // node path to skeleton (without skeleton node though)\n    this._pathToRoot = undefined;\n};\n\nFindNearestParentSkeleton.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    apply: function ( node ) {\n\n        if ( this._root ) return;\n\n        if ( node.typeID === Skeleton.typeID ) {\n            this._root = node;\n            this._pathToRoot = this.nodePath.slice( 1 );\n            return;\n        }\n\n        this.traverse( node );\n    }\n} );\n\nmodule.exports = FindNearestParentSkeleton;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/FindNearestParentSkeleton.js\n// module id = 80\n// module chunks = 0 1 2","'use strict';\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar SkinningAttribute = require( 'osgAnimation/SkinningAttribute' );\nvar CollectBoneVisitor = require( 'osgAnimation/CollectBoneVisitor' );\n\n\n/**\n * Hardware implementation for rigGeometry\n *\n */\nvar RigTransformHardware = function () {\n    this._isInitialized = false;\n\n    // bones are sorted to be used directly by\n    // computeMatrixPalette\n    // means the\n    this._bones = [];\n};\n\n\nRigTransformHardware.prototype = {\n\n    // boneNameID contains a map: boneName: id\n    // {\n    //    'bone0' : 1,\n    //    'bone4' : 0,\n    // }\n    //\n    // boneMap contains a map: boneName: Bone\n    // {\n    //    'bone0: : Bone object,\n    //    'bone1: : Bone object,\n    // }\n    //\n    // return index / bone object\n    // [\n    //    Bone4 object,\n    //    Bone0 object\n    // ]\n    computeBonePalette: function ( boneMap, boneNameID ) {\n        var bones = this._bones;\n        for ( var boneName in boneMap ) {\n            var index = boneNameID[ boneName ];\n            var bone = boneMap[ boneName ];\n\n            if ( index !== undefined )\n                bones[ index ] = bone;\n        }\n\n        return bones;\n    },\n\n\n    init: function ( geom ) {\n\n        // init the bones map\n\n        // stop here\n        // compute bonemap / index\n        var mapVisitor = new CollectBoneVisitor();\n        geom.getSkeleton().accept( mapVisitor );\n        var bm = mapVisitor.getBoneMap();\n\n        this.computeBonePalette( bm, geom._boneNameID );\n\n        // matrix are 4x3\n        var nbVec4Uniforms = this._bones.length * 3;\n        var animAttrib = this._skinningAttribute = new SkinningAttribute();\n        animAttrib.setMatrixPalette( new Float32Array( nbVec4Uniforms * 4 ) );\n        geom.getStateSetAnimation().setAttributeAndModes( animAttrib, StateAttribute.ON );\n\n        this._isInitialized = true;\n        return true;\n    },\n\n\n    computeMatrixPalette: ( function () {\n\n        var mTmp = mat4.create();\n\n        return function ( transformFromSkeletonToGeometry, invTransformFromSkeletonToGeometry ) {\n\n            var bones = this._bones;\n            var matPalette = this._skinningAttribute.getMatrixPalette();\n            var uniformIndex = 0;\n\n            for ( var i = 0, l = bones.length; i < l; i++ ) {\n                var bone = bones[ i ];\n\n                var invBindMatrix = bone.getInvBindMatrixInSkeletonSpace();\n                var boneMatrix = bone.getMatrixInSkeletonSpace();\n\n                mat4.mul( mTmp, boneMatrix, invBindMatrix );\n                mat4.mul( mTmp, invTransformFromSkeletonToGeometry, mTmp );\n                mat4.mul( mTmp, mTmp, transformFromSkeletonToGeometry );\n\n                // TODO: maybe change upload order so that we can use\n                // glsl constructor :\n                // mat4(uBones[index], uBones[index+1], uBones[index+2], vec4(0.0, 0.0, 0.0, 1.0))\n                // for faster glsl\n                matPalette[ uniformIndex++ ] = mTmp[ 0 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 4 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 8 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 12 ];\n\n                matPalette[ uniformIndex++ ] = mTmp[ 1 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 5 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 9 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 13 ];\n\n                matPalette[ uniformIndex++ ] = mTmp[ 2 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 6 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 10 ];\n                matPalette[ uniformIndex++ ] = mTmp[ 14 ];\n            }\n        };\n\n    } )(),\n\n    update: function ( geom ) {\n\n        if ( !this._isInitialized )\n            this.init( geom );\n\n        this.computeMatrixPalette( geom.getMatrixFromSkeletonToGeometry(), geom.getInvMatrixFromSkeletonToGeometry() );\n    }\n};\n\n\nmodule.exports = RigTransformHardware;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/RigTransformHardware.js\n// module id = 81\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\n\n\n/**\n * SkinningAttribute encapsulate Animation State\n * @class SkinningAttribute\n * @inherits StateAttribute\n */\nvar SkinningAttribute = function ( disable, boneUniformSize ) {\n    StateAttribute.call( this );\n    this._enable = !disable;\n    // optional, if it's not provided, it will fall back to the maximum bone uniform size\n    // boneUniformSize represents the number of vec4 (uniform) used in the shader for all the bones\n    this._boneUniformSize = boneUniformSize;\n};\n\nSkinningAttribute.uniforms = {};\nSkinningAttribute.maxBoneUniformSize = 1;\nSkinningAttribute.maxBoneUniformAllowed = Infinity; // can be overriden by application specific limit on startup (typically gl limit)\n\nSkinningAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Skinning',\n\n    cloneType: function () {\n        return new SkinningAttribute( true );\n    },\n\n    getBoneUniformSize: function () {\n        return this._boneUniformSize !== undefined ? this._boneUniformSize : SkinningAttribute.maxBoneUniformSize;\n    },\n\n    getOrCreateUniforms: function () {\n        var obj = SkinningAttribute;\n        var boneSize = this.getBoneUniformSize();\n\n        if ( obj.uniforms[ boneSize ] ) return obj.uniforms[ boneSize ];\n\n        obj.uniforms[ boneSize ] = {\n            uBones: Uniform.createFloat4Array( 'uBones', boneSize )\n        };\n\n        return obj.uniforms[ boneSize ];\n    },\n\n    setMatrixPalette: function ( matrixPalette ) {\n        this._matrixPalette = matrixPalette;\n        // update max bone size\n        if ( this._boneUniformSize === undefined ) {\n            SkinningAttribute.maxBoneUniformSize = Math.max( SkinningAttribute.maxBoneUniformSize, matrixPalette.length / 4 );\n            SkinningAttribute.maxBoneUniformSize = Math.min( SkinningAttribute.maxBoneUniformAllowed, SkinningAttribute.maxBoneUniformSize );\n        }\n    },\n\n    getMatrixPalette: function () {\n        return this._matrixPalette;\n    },\n\n    // need a isEnabled to let the ShaderGenerator to filter\n    // StateAttribute from the shader compilation\n    isEnabled: function () {\n        return this._enable;\n    },\n\n    getHash: function () {\n        // bone uniform size is hashed because the size of uniform is statically declared in the shader\n        return this.getTypeMember() + this.getBoneUniformSize() + this.isEnabled();\n    },\n\n    apply: function () {\n\n        if ( !this._enable ) return;\n\n        this.getOrCreateUniforms().uBones.getInternalArray().set( this._matrixPalette );\n\n    }\n\n} ), 'osgAnimation', 'SkinningAttribute' );\n\nMACROUTILS.setTypeID( SkinningAttribute );\n\nmodule.exports = SkinningAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/SkinningAttribute.js\n// module id = 82\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Notify = require( 'osg/notify' );\nvar Bone = require( 'osgAnimation/Bone' );\n\n\nvar CollectBoneVisitor = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n    this._boneMap = {};\n};\n\nCollectBoneVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    apply: function ( node ) {\n\n        if ( node.typeID === Bone.typeID ) {\n\n            var name = node.getName();\n\n            if ( !name ) {\n                Notify.warn( 'found Bone without name' );\n            } else {\n                this._boneMap[ name ] = node;\n            }\n        }\n\n        this.traverse( node );\n    },\n\n    getBoneMap: function () {\n        return this._boneMap;\n    }\n\n} );\n\nmodule.exports = CollectBoneVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/CollectBoneVisitor.js\n// module id = 83\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\nvar Depth = function ( func, near, far, writeMask ) {\n    StateAttribute.call( this );\n\n    this._func = Depth.LESS;\n    this._near = 0.0;\n    this._far = 1.0;\n    this._writeMask = true;\n\n    if ( func !== undefined ) {\n        if ( typeof ( func ) === 'string' ) {\n            this._func = Depth[ func ];\n        } else {\n            this._func = func;\n        }\n    }\n    if ( near !== undefined ) {\n        this._near = near;\n    }\n    if ( far !== undefined ) {\n        this._far = far;\n    }\n    if ( writeMask !== undefined ) {\n        this._writeMask = writeMask;\n    }\n};\n\nDepth.DISABLE = 0x0000;\nDepth.NEVER = 0x0200;\nDepth.LESS = 0x0201;\nDepth.EQUAL = 0x0202;\nDepth.LEQUAL = 0x0203;\nDepth.GREATER = 0x0204;\nDepth.NOTEQUAL = 0x0205;\nDepth.GEQUAL = 0x0206;\nDepth.ALWAYS = 0x0207;\n\nDepth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n    attributeType: 'Depth',\n    cloneType: function () {\n        return new Depth();\n    },\n    setRange: function ( near, far ) {\n        this._near = near;\n        this._far = far;\n    },\n    setWriteMask: function ( mask ) {\n        this._writeMask = mask;\n    },\n    getWriteMask: function () {\n        return this._writeMask;\n    },\n    getFunc: function () {\n        return this._func;\n    },\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        if ( this._func === 0 ) {\n            gl.disable( gl.DEPTH_TEST );\n        } else {\n            gl.enable( gl.DEPTH_TEST );\n            gl.depthFunc( this._func );\n            gl.depthMask( this._writeMask );\n            gl.depthRange( this._near, this._far );\n        }\n    }\n} ), 'osg', 'Depth' );\n\nmodule.exports = Depth;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Depth.js\n// module id = 84\n// module chunks = 0 1 2","'use strict';\n\n/**\n * DrawArrayLengths manage rendering primitives\n * @class DrawArrayLengths\n */\nvar DrawArrayLengths = function ( mode, first, array ) {\n    this._mode = mode;\n    this._first = first;\n    this._arrayLengths = array.slice( 0 );\n};\n\n/** @lends DrawArrayLengths.prototype */\nDrawArrayLengths.prototype = {\n    draw: function ( state ) {\n        var gl = state.getGraphicContext();\n        var mode = this._mode;\n        var first = this._first;\n        var array = this._arrayLengths;\n        for ( var i = 0, l = array.length; i < l; i++ ) {\n            var count = array[ i ];\n            gl.drawArrays( mode, first, count );\n            first += count;\n        }\n    },\n    getMode: function () {\n        return this._mode;\n    },\n    getNumIndices: function () {\n        var count = 0;\n        var array = this._arrayLengths;\n        for ( var i = 0, l = array.length; i < l; i++ ) {\n            count += array[ i ];\n        }\n        return count;\n    },\n    getCount: function () {\n        return this.getNumIndices();\n    },\n    getArrayLengths: function () {\n        return this._arrayLengths;\n    },\n    getFirst: function () {\n        return this._first;\n    },\n    setFirst: function ( first ) {\n        this._first = first;\n    }\n};\n\nmodule.exports = DrawArrayLengths;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/DrawArrayLengths.js\n// module id = 85\n// module chunks = 0 1 2","'use strict';\nvar PrimitiveSet = require( 'osg/primitiveSet' );\n\n\n/**\n * DrawArrays manage rendering primitives\n * @class DrawArrays\n */\nvar DrawArrays = function ( mode, first, count ) {\n    this.mode = mode;\n    if ( mode !== undefined ) {\n        if ( typeof ( mode ) === 'string' ) {\n            mode = PrimitiveSet[ mode ];\n        }\n        this.mode = mode;\n    }\n    this.first = first;\n    this.count = count;\n};\n\n/** @lends DrawArrays.prototype */\nDrawArrays.prototype = {\n    draw: function ( state ) {\n        if ( this.count === 0 )\n            return;\n        var gl = state.getGraphicContext();\n        gl.drawArrays( this.mode, this.first, this.count );\n    },\n    getMode: function () {\n        return this.mode;\n    },\n    setCount: function ( count ) {\n        this.count = count;\n    },\n    getCount: function () {\n        return this.count;\n    },\n    setFirst: function ( first ) {\n        this.first = first;\n    },\n    getFirst: function () {\n        return this.first;\n    },\n    getNumIndices: function () {\n        return this.count;\n    },\n    index: function ( i ) {\n        return this.first + i;\n    }\n\n};\n\nmodule.exports = DrawArrays;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/DrawArrays.js\n// module id = 86\n// module chunks = 0 1 2","'use strict';\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n\nvar EllipsoidModel = function () {\n    this._radiusEquator = EllipsoidModel.WGS_84_RADIUS_EQUATOR;\n    this._radiusPolar = EllipsoidModel.WGS_84_RADIUS_POLAR;\n    this.computeCoefficients();\n};\n\nEllipsoidModel.WGS_84_RADIUS_EQUATOR = 6378137.0;\nEllipsoidModel.WGS_84_RADIUS_POLAR = 6356752.3142;\n\nEllipsoidModel.prototype = {\n    setRadiusEquator: function ( radius ) {\n        this._radiusEquator = radius;\n        this.computeCoefficients();\n    },\n    getRadiusEquator: function () {\n        return this._radiusEquator;\n    },\n    setRadiusPolar: function ( radius ) {\n        this._radiusPolar = radius;\n        this.computeCoefficients();\n    },\n    getRadiusPolar: function () {\n        return this._radiusPolar;\n    },\n    convertLatLongHeightToXYZ: function ( latitude, longitude, height, result ) {\n        var sinLatitude = Math.sin( latitude );\n        var cosLatitude = Math.cos( latitude );\n        var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );\n        var X = ( N + height ) * cosLatitude * Math.cos( longitude );\n        var Y = ( N + height ) * cosLatitude * Math.sin( longitude );\n        var Z = ( N * ( 1.0 - this._eccentricitySquared ) + height ) * sinLatitude;\n        result[ 0 ] = X;\n        result[ 1 ] = Y;\n        result[ 2 ] = Z;\n        return result;\n    },\n    convertXYZToLatLongHeight: function ( X, Y, Z, result ) {\n        // http://www.colorado.edu/geography/gcraft/notes/datum/gif/xyzllh.gif\n        var p = Math.sqrt( X * X + Y * Y );\n        var theta = Math.atan2( Z * this._radiusEquator, ( p * this._radiusPolar ) );\n        var eDashSquared = ( this._radiusEquator * this._radiusEquator - this._radiusPolar * this._radiusPolar ) / ( this._radiusPolar * this._radiusPolar );\n\n        var sinTheta = Math.sin( theta );\n        var cosTheta = Math.cos( theta );\n\n        var latitude = Math.atan( ( Z + eDashSquared * this._radiusPolar * sinTheta * sinTheta * sinTheta ) /\n            ( p - this._eccentricitySquared * this._radiusEquator * cosTheta * cosTheta * cosTheta ) );\n        var longitude = Math.atan2( Y, X );\n\n        var sinLatitude = Math.sin( latitude );\n        var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );\n\n        var cosLat = Math.cos( latitude );\n        if ( cosLat === 0 ) cosLat = 1;\n        var height = p / cosLat - N;\n        result[ 0 ] = latitude;\n        result[ 1 ] = longitude;\n        result[ 2 ] = height;\n        return result;\n    },\n    computeLocalUpVector: function ( X, Y, Z ) {\n        // Note latitude is angle between normal to ellipsoid surface and XY-plane\n        var latitude, longitude, altitude;\n        var coord = this.convertXYZToLatLongHeight( X, Y, Z, vec3.create() );\n        latitude = coord[ 0 ];\n        longitude = coord[ 1 ];\n        altitude = coord[ 2 ];\n\n        // Compute up vector\n        return [ Math.cos( longitude ) * Math.cos( latitude ),\n            Math.sin( longitude ) * Math.cos( latitude ),\n            Math.sin( latitude )\n        ];\n    },\n    isWGS84: function () {\n        return ( this._radiusEquator === EllipsoidModel.WGS_84_RADIUS_EQUATOR && this._radiusPolar === EllipsoidModel.WGS_84_RADIUS_POLAR );\n    },\n\n    computeCoefficients: function () {\n        var flattening = ( this._radiusEquator - this._radiusPolar ) / this._radiusEquator;\n        this._eccentricitySquared = 2.0 * flattening - flattening * flattening;\n    },\n    computeLocalToWorldTransformFromLatLongHeight: function ( latitude, longitude, height, result ) {\n        var pos = this.convertLatLongHeightToXYZ( latitude, longitude, height, result );\n        mat4.fromTranslation( result, pos );\n        this.computeCoordinateFrame( latitude, longitude, result );\n        return result;\n    },\n    computeLocalToWorldTransformFromXYZ: function ( X, Y, Z ) {\n        var lla = this.convertXYZToLatLongHeight( X, Y, Z, vec3.create() );\n        var m = mat4.fromTranslation( mat4.create(), vec3.fromValues( X, Y, Z ) );\n        this.computeCoordinateFrame( lla[ 0 ], lla[ 1 ], m );\n        return m;\n    },\n    computeCoordinateFrame: ( function () {\n        var up = vec3.create();\n        var east = vec3.create();\n        var north = vec3.create();\n        return function ( latitude, longitude, localToWorld ) {\n            // Compute up vector\n            up[ 0 ] = Math.cos( longitude ) * Math.cos( latitude );\n            up[ 1 ] = Math.sin( longitude ) * Math.cos( latitude );\n            up[ 2 ] = Math.sin( latitude );\n\n            // Compute east vector\n            east[ 0 ] = -Math.sin( longitude );\n            east[ 1 ] = -Math.cos( longitude );\n\n            // Compute north vector = outer product up x east\n            vec3.cross( north, up, east );\n\n            // set matrix\n            mat4.set( localToWorld,\n                east[ 0 ], east[ 1 ], east[ 2 ], 0,\n                north[ 0 ], north[ 1 ], north[ 2 ], 0,\n                up[ 0 ], up[ 1 ], up[ 2 ], 0,\n                0, 0, 0, 1 );\n        };\n    } )()\n};\n\nmodule.exports = EllipsoidModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/EllipsoidModel.js\n// module id = 87\n// module chunks = 0 1 2","'use strict';\n\nvar FrameStamp = function () {\n    this._frame = 0;\n    this._startSimulation = 0.0;\n    this._currentSimulation = 0.0;\n    this._deltaTime = 0.0; // last time elapsed since the next traversal\n};\n\nFrameStamp.prototype = {\n    setReferenceTime: function ( s ) {\n        this._startSimulation = s;\n    },\n    getReferenceTime: function () {\n        return this._startSimulation;\n    },\n    setSimulationTime: function ( s ) {\n        this._currentSimulation = s;\n    },\n    getSimulationTime: function () {\n        return this._currentSimulation;\n    },\n    setDeltaTime: function ( d ) {\n        this._deltaTime = d;\n    },\n    getDeltaTime: function () {\n        return this._deltaTime;\n    },\n    setFrameNumber: function ( n ) {\n        this._frame = n;\n    },\n    getFrameNumber: function () {\n        return this._frame;\n    }\n};\n\nmodule.exports = FrameStamp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/FrameStamp.js\n// module id = 88\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Image = require( 'osg/Image' );\n\n\nvar ImageStream = function ( video ) {\n    Image.call( this, video );\n    this._canPlayDefered = undefined;\n};\n\nImageStream.PAUSE = 0;\nImageStream.PLAYING = 1;\n\nImageStream.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Image.prototype, {\n\n    isDirty: function () {\n        return this._status === ImageStream.PLAYING; // video is dirty if playing\n    },\n\n    setImage: function ( video ) {\n        Image.prototype.setImage.call( this, video );\n\n        this._status = ImageStream.STOP;\n\n        // event at the end of the stream\n        video.addEventListener( 'ended', function () {\n            if ( !this._imageObject.loop )\n                this.stop();\n        }.bind( this ), true );\n\n        this.dirty();\n    },\n\n    setLooping: function ( bool ) {\n        this._imageObject.loop = bool;\n    },\n\n    play: function () {\n        this._imageObject.play();\n        this._status = ImageStream.PLAYING;\n    },\n\n    stop: function () {\n        this._imageObject.pause();\n        this._status = ImageStream.PAUSE;\n    },\n\n    whenReady: function () {\n\n        if ( !this._imageObject ) {\n            return P.reject();\n        }\n\n        if ( !this._canPlayDefered ) {\n            this._canPlayDefered = P.defer();\n            // resolve directly if the event is already fired\n            if ( this._imageObject.readyState > 3 ) this._canPlayDefered.resolve( this );\n            else this._imageObject.addEventListener( 'canplaythrough', this._canPlayDefered.resolve.bind( this._canPlayDefered, this ), true );\n        }\n\n        return this._canPlayDefered.promise;\n    }\n\n\n} ), 'osg', 'ImageStream' );\n\nMACROUTILS.setTypeID( ImageStream );\n\nmodule.exports = ImageStream;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/ImageStream.js\n// module id = 89\n// module chunks = 0 1 2","module.exports = __WEBPACK_EXTERNAL_MODULE_90__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"P\",\"commonjs2\":\"bluebird\",\"commonjs\":\"bluebird\",\"amd\":\"bluebird\"}\n// module id = 90\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar TriangleIndexFunctor = require( 'osg/TriangleIndexFunctor' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar KdTreeLineSegmentIntersector = require( 'osg/KdTreeLineSegmentIntersector' );\nvar KdTreeSphereIntersector = require( 'osg/KdTreeSphereIntersector' );\n\n\n// **** GENERAL INFO ON KDTREE ****\n// A KdTree is a Spatial Partitionning Tree (http://en.wikipedia.org/wiki/Space_partitioning)\n// The type of tree is sort of defined by the splitting axis method:\n// - Per Axis split (octree/ kdtree)\n// - Arbritrary direction split (bsp)\n\n// The algorithm used for splitting, the name for finding best split is 'Surface Area Heuristic (SAH)'\n// Octree divide the space in 8 subspace (one box -> 8 sub boxes)\n// whereas kdtree does it by splitting population number in two equal group\n\n// Kd Tree http://en.wikipedia.org/wiki/K-d_tree\n// a given set of points is sorted along one Axis (e.g. X).\n// The sorted list is split at the median.\n// The result are two sets, one for each half-space (left and right).\n\n// Then, for the current node, the splitting-plane position (or the median-point) and depth is saved.\n// Finally, if the point-set has more than n point and the tree depth is below m\n// (with n,m chosen by the user, as build options), two child-nodes (L/R one for each point-set)\n// are created which themselfs repeat the pocedure.\n\n// The split-axis gets alternated at each depth, the split order is computed by checking the main\n// bounding box the length of its axis\n// **** GENERAL INFO ON KDTREE ****\n\n// The KdTree implemented here is flattened, ie, a node and its children all lie in the same array\n// The most important thing is the understanding of the variables first and second for each node\n// Their semantic depend if the node is a leaf or not\n// if it's a leaf :\n//   first and second defines a range in the triangles array (triangles in the cell)\n// if it's not a leaf :\n// - first and second respectively represents the left and right sub children\n// We know that a node is a leaf if first is negative, in that case the range will be defined by\n// [ -first - 1, -first-1 + second ]\nvar KdNode = function ( first, second ) {\n    this._bb = new BoundingBox();\n    this._first = first;\n    this._second = second;\n    // These variables represent the local clipped ray (for intersection test)\n    // They are mostly temporary because they are recomputed for each intersection test\n    this._nodeRayStart = vec3.create();\n    this._nodeRayEnd = vec3.create();\n};\n\nvar BuildKdTree = function ( kdTree ) {\n    this._kdTree = kdTree;\n    this._bb = new BoundingBox();\n    this._primitiveIndices = null; // Uint32Array\n    this._centers = null; // Float32Array\n    this._axisOrder = vec3.create();\n    this._stackLength = 0;\n};\n\nBuildKdTree.prototype = {\n    build: function ( options, geom ) {\n        var targetTris = options._targetNumTrianglesPerLeaf;\n        var vertexAttrib = geom.getVertexAttributeList().Vertex;\n        if ( !vertexAttrib )\n            return false;\n        var vertices = vertexAttrib.getElements();\n        if ( !vertices )\n            return false;\n        var nbVertices = vertices.length / 3;\n        if ( nbVertices < targetTris )\n            return false;\n\n        this._bb.copy( geom.getBoundingBox() );\n        this._kdTree.setVertices( vertices );\n\n        this.computeDivisions( options );\n        options._numVerticesProcessed += nbVertices;\n\n        this.computeTriangles( geom );\n\n        var node = new KdNode( -1, this._primitiveIndices.length );\n        node._bb.copy( this._bb );\n        var nodeNum = this._kdTree.addNode( node );\n\n        var bb = new BoundingBox();\n        bb.copy( this._bb );\n        nodeNum = this.divide( options, bb, nodeNum, 0 );\n\n        // Here we re-order the triangle list so that we can have a flat tree\n        // _primitiveIndices is the ordered array of the triangle indices\n        var triangles = this._kdTree.getTriangles();\n        var primitives = this._primitiveIndices;\n        var nbPrimitives = primitives.length;\n        var triangleOrdered = new MACROUTILS.Uint32Array( triangles.length );\n        for ( var i = 0, j = 0; i < nbPrimitives; ++i, j += 3 ) {\n            var id = primitives[ i ] * 3;\n            triangleOrdered[ j ] = triangles[ id ];\n            triangleOrdered[ j + 1 ] = triangles[ id + 1 ];\n            triangleOrdered[ j + 2 ] = triangles[ id + 2 ];\n        }\n        this._kdTree.setTriangles( triangleOrdered );\n        return this._kdTree.getNodes().length > 0;\n    },\n    // The function first gather all the triangles of the geometry\n    // It then computes the centroid for each triangle and initialize\n    // of triangles indices that will refer to the main triangles array\n    computeTriangles: function ( geom ) {\n        var kdTree = this._kdTree;\n\n        var totalLenArray = 0;\n        var geomPrimitives = geom.getPrimitiveSetList();\n        var nbPrimitives = geomPrimitives.length;\n        var i = 0;\n        for ( i = 0; i < nbPrimitives; i++ ) {\n            var prim = geomPrimitives[ i ];\n            var mode = prim.getMode();\n            // ignore points and line stuffs\n            if ( mode === PrimitiveSet.TRIANGLES )\n                totalLenArray += prim.getCount();\n            else if ( mode === PrimitiveSet.TRIANGLE_STRIP || mode === PrimitiveSet.TRIANGLE_FAN )\n                totalLenArray += Math.abs( ( prim.getCount() - 2 ) ) * 3;\n        }\n        var indices = new MACROUTILS.Uint32Array( totalLenArray );\n        var next = 0;\n        var cb = function ( i1, i2, i3 ) {\n            if ( i1 === i2 || i1 === i3 || i2 === i3 )\n                return;\n            indices[ next ] = i1;\n            indices[ next + 1 ] = i2;\n            indices[ next + 2 ] = i3;\n            next += 3;\n        };\n\n\n        var tif = new TriangleIndexFunctor();\n        tif.init( geom, cb );\n        tif.apply();\n\n        indices = indices.subarray( 0, next );\n\n        var nbTriangles = indices.length;\n        kdTree.setTriangles( indices );\n\n        var vertices = kdTree.getVertices();\n\n        this._centers = new MACROUTILS.Float32Array( nbTriangles );\n        var centers = this._centers;\n        this._primitiveIndices = new MACROUTILS.Uint32Array( nbTriangles / 3 );\n        var primitives = this._primitiveIndices;\n\n        var j = 0;\n        for ( i = 0, j = 0; i < nbTriangles; i += 3, ++j ) {\n            var iv0 = indices[ i ];\n            var iv1 = indices[ i + 1 ];\n            var iv2 = indices[ i + 2 ];\n\n            // discard degenerate points\n            if ( iv0 === iv1 || iv1 === iv2 || iv0 === iv2 )\n                return;\n\n            iv0 *= 3;\n            iv1 *= 3;\n            iv2 *= 3;\n\n            var v0x = vertices[ iv0 ];\n            var v0y = vertices[ iv0 + 1 ];\n            var v0z = vertices[ iv0 + 2 ];\n\n            var v1x = vertices[ iv1 ];\n            var v1y = vertices[ iv1 + 1 ];\n            var v1z = vertices[ iv1 + 2 ];\n\n            var v2x = vertices[ iv2 ];\n            var v2y = vertices[ iv2 + 1 ];\n            var v2z = vertices[ iv2 + 2 ];\n\n            var minx = Math.min( v0x, Math.min( v1x, v2x ) );\n            var miny = Math.min( v0y, Math.min( v1y, v2y ) );\n            var minz = Math.min( v0z, Math.min( v1z, v2z ) );\n\n            var maxx = Math.max( v0x, Math.max( v1x, v2x ) );\n            var maxy = Math.max( v0y, Math.max( v1y, v2y ) );\n            var maxz = Math.max( v0z, Math.max( v1z, v2z ) );\n            centers[ i ] = ( minx + maxx ) * 0.5;\n            centers[ i + 1 ] = ( miny + maxy ) * 0.5;\n            centers[ i + 2 ] = ( minz + maxz ) * 0.5;\n            primitives[ j ] = j;\n        }\n    },\n    computeDivisions: function ( options ) {\n        this._stackLength = options._maxNumLevels;\n        var max = this._bb._max;\n        var min = this._bb._min;\n        var dx = max[ 0 ] - min[ 0 ];\n        var dy = max[ 1 ] - min[ 1 ];\n        var dz = max[ 2 ] - min[ 2 ];\n        var axisOrder = this._axisOrder;\n\n        // We set the cutting order (longest edge aabb first)\n        axisOrder[ 0 ] = ( dx >= dy && dx >= dz ) ? 0 : ( dy >= dz ) ? 1 : 2;\n        axisOrder[ 2 ] = ( dx < dy && dx < dz ) ? 0 : ( dy < dz ) ? 1 : 2;\n        var sum = axisOrder[ 0 ] + axisOrder[ 2 ];\n        axisOrder[ 1 ] = sum === 3 ? 0 : sum === 2 ? 1 : 2;\n    },\n    // The core function of the kdtree building\n    // It checks if the node need to be subdivide or not\n    // If it decides it's a leaf, it computes the final bounding box of the node\n    // and it ends here\n    // If it's a node, then it puts the splitting axis position on the median population\n    // On the same time it reorder the triangle index array\n    divide: function ( options, bb, nodeIndex, level ) {\n        var kdTree = this._kdTree;\n        var primitives = this._primitiveIndices;\n        var nodes = kdTree.getNodes();\n        var node = nodes[ nodeIndex ];\n\n        var first = node._first;\n        var second = node._second;\n\n        var needToDivide = level < this._stackLength && first < 0 && second > options._targetNumTrianglesPerLeaf;\n        var istart = -first - 1;\n        var iend = istart + second - 1;\n\n        if ( !needToDivide ) {\n            if ( first < 0 ) {\n                // leaf is done, now compute bound on it.\n                this.computeNodeBox( node, istart, iend );\n            }\n            return nodeIndex;\n        }\n\n        if ( first >= 0 )\n            return nodeIndex;\n        // leaf node as first < 0, so look at dividing it.\n\n        var axis = this._axisOrder[ level % 3 ];\n        var originalMin = bb._min[ axis ];\n        var originalMax = bb._max[ axis ];\n\n        var mid = ( originalMin + originalMax ) * 0.5;\n\n        var originalLeftChildIndex = 0;\n        var originalRightChildIndex = 0;\n        var insitueDivision = false;\n\n        var left = istart;\n        var right = iend;\n\n        var centers = this._centers;\n        while ( left < right ) {\n            while ( left < right && ( centers[ primitives[ left ] * 3 + axis ] <= mid ) ) {\n                ++left;\n            }\n\n            while ( left < right && ( centers[ primitives[ right ] * 3 + axis ] > mid ) ) {\n                --right;\n            }\n\n            if ( left < right ) {\n                var tmp = primitives[ left ];\n                primitives[ left ] = primitives[ right ];\n                primitives[ right ] = tmp;\n                ++left;\n                --right;\n            }\n        }\n\n        if ( left === right ) {\n            if ( centers[ primitives[ left ] * 3 + axis ] <= mid ) ++left;\n            else --right;\n        }\n\n        if ( ( right - istart ) <= -1 ) {\n            originalLeftChildIndex = 0;\n            originalRightChildIndex = nodeIndex;\n            insitueDivision = true;\n        } else if ( ( iend - left ) <= -1 ) {\n            originalLeftChildIndex = nodeIndex;\n            originalRightChildIndex = 0;\n            insitueDivision = true;\n        } else {\n            originalLeftChildIndex = kdTree.addNode( new KdNode( -istart - 1, ( right - istart ) + 1 ) );\n            originalRightChildIndex = kdTree.addNode( new KdNode( -left - 1, ( iend - left ) + 1 ) );\n        }\n\n\n        var restore = bb._max[ axis ];\n        bb._max[ axis ] = mid;\n\n        var leftChildIndex = originalLeftChildIndex !== 0 ? this.divide( options, bb, originalLeftChildIndex, level + 1 ) : 0;\n\n        bb._max[ axis ] = restore;\n\n        restore = bb._min[ axis ];\n        bb._min[ axis ] = mid;\n\n        var rightChildIndex = originalRightChildIndex !== 0 ? this.divide( options, bb, originalRightChildIndex, level + 1 ) : 0;\n\n        bb._min[ axis ] = restore;\n\n        if ( !insitueDivision ) {\n            node._first = leftChildIndex;\n            node._second = rightChildIndex;\n\n            insitueDivision = true;\n\n            var bnode = node._bb;\n            bnode.init();\n            if ( leftChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ leftChildIndex ]._bb );\n            if ( rightChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ rightChildIndex ]._bb );\n        }\n        return nodeIndex;\n    },\n    // It computes the bounding box of the node so that the box contains all the triangles\n    // of the cell\n    computeNodeBox: function ( node, istart, iend ) {\n        var minx = Infinity,\n            miny = Infinity,\n            minz = Infinity,\n            maxx = -Infinity,\n            maxy = -Infinity,\n            maxz = -Infinity;\n        var triangles = this._kdTree.getTriangles();\n        var vertices = this._kdTree.getVertices();\n        var primitives = this._primitiveIndices;\n        for ( var i = istart; i <= iend; ++i ) {\n            var id = primitives[ i ] * 3;\n            var iv0 = triangles[ id ] * 3;\n            var iv1 = triangles[ id + 1 ] * 3;\n            var iv2 = triangles[ id + 2 ] * 3;\n\n            var v0x = vertices[ iv0 ];\n            var v0y = vertices[ iv0 + 1 ];\n            var v0z = vertices[ iv0 + 2 ];\n\n            var v1x = vertices[ iv1 ];\n            var v1y = vertices[ iv1 + 1 ];\n            var v1z = vertices[ iv1 + 2 ];\n\n            var v2x = vertices[ iv2 ];\n            var v2y = vertices[ iv2 + 1 ];\n            var v2z = vertices[ iv2 + 2 ];\n\n            minx = Math.min( minx, Math.min( v0x, Math.min( v1x, v2x ) ) );\n            miny = Math.min( miny, Math.min( v0y, Math.min( v1y, v2y ) ) );\n            minz = Math.min( minz, Math.min( v0z, Math.min( v1z, v2z ) ) );\n\n            maxx = Math.max( maxx, Math.max( v0x, Math.max( v1x, v2x ) ) );\n            maxy = Math.max( maxy, Math.max( v0y, Math.max( v1y, v2y ) ) );\n            maxz = Math.max( maxz, Math.max( v0z, Math.max( v1z, v2z ) ) );\n        }\n        var epsilon = 1E-6;\n        var bnode = node._bb;\n        var bmin = bnode._min;\n        var bmax = bnode._max;\n        bmin[ 0 ] = minx - epsilon;\n        bmin[ 1 ] = miny - epsilon;\n        bmin[ 2 ] = minz - epsilon;\n        bmax[ 0 ] = maxx + epsilon;\n        bmax[ 1 ] = maxy + epsilon;\n        bmax[ 2 ] = maxz + epsilon;\n    }\n};\n\nvar KdTree = function () {\n    this._vertices = null;\n    this._kdNodes = [];\n    this._triangles = null; // Float32Array\n};\n\nKdTree.prototype = MACROUTILS.objectLibraryClass( {\n    getVertices: function () {\n        return this._vertices;\n    },\n    setVertices: function ( vertices ) {\n        this._vertices = vertices;\n    },\n    getNodes: function () {\n        return this._kdNodes;\n    },\n    getTriangles: function () {\n        return this._triangles;\n    },\n    setTriangles: function ( triangles ) {\n        this._triangles = triangles;\n    },\n    addNode: function ( node ) {\n        this._kdNodes.push( node );\n        return this._kdNodes.length - 1;\n    },\n    build: function ( options, geom ) {\n        var buildTree = new BuildKdTree( this );\n        return buildTree.build( options, geom );\n    },\n    intersectRay: function ( start, end, intersections, nodePath ) {\n        if ( this._kdNodes.length === 0 ) {\n            return false;\n        }\n\n        var numIntersectionsBefore = intersections.length;\n\n        if ( !this._rayIntersector ) {\n            this._rayIntersector = new KdTreeLineSegmentIntersector();\n            this._rayIntersector.setKdtree( this._vertices, this._kdNodes, this._triangles );\n        }\n        this._rayIntersector.init( intersections, start, end, nodePath );\n        this._rayIntersector.intersect( this.getNodes()[ 0 ], start, end );\n\n        return numIntersectionsBefore !== intersections.length;\n    },\n    intersectSphere: function ( center, radius, intersections, nodePath ) {\n        if ( this._kdNodes.length === 0 ) {\n            return false;\n        }\n\n        var numIntersectionsBefore = intersections.length;\n\n        if ( !this._sphereIntersector ) {\n            this._sphereIntersector = new KdTreeSphereIntersector();\n            this._sphereIntersector.setKdtree( this._vertices, this._kdNodes, this._triangles );\n        }\n        this._sphereIntersector.init( intersections, center, radius, nodePath );\n        this._sphereIntersector.intersect( this.getNodes()[ 0 ] );\n\n        return numIntersectionsBefore !== intersections.length;\n    }\n}, 'osg', 'KdTree' );\n\nmodule.exports = KdTree;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/KdTree.js\n// module id = 91\n// module chunks = 0 1 2","'use strict';\n\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar DrawArrays = require( 'osg/DrawArrays' );\n\n// This class can be used to visit all the triangles of a geometry\nvar TriangleIndexFunctor = function () {};\n\nvar functorDrawElements = TriangleIndexFunctor.functorDrawElements = [];\nvar functorDrawArrays = TriangleIndexFunctor.functorDrawArrays = [];\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLES ] = function ( offset, count, indexes, cb ) {\n    var end = offset + count;\n    for ( var i = offset; i < end; i += 3 ) {\n        cb( indexes[ i ], indexes[ i + 1 ], indexes[ i + 2 ] );\n    }\n};\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLE_STRIP ] = function ( offset, count, indexes, cb ) {\n    for ( var i = 2, j = offset; i < count; ++i, ++j ) {\n        if ( i % 2 ) cb( indexes[ j ], indexes[ j + 2 ], indexes[ j + 1 ] );\n        else cb( indexes[ j ], indexes[ j + 1 ], indexes[ j + 2 ] );\n    }\n};\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLE_FAN ] = function ( offset, count, indexes, cb ) {\n    var first = indexes[ offset ];\n    for ( var i = 2, j = offset + 1; i < count; ++i, ++j ) {\n        cb( first, indexes[ j ], indexes[ j + 1 ] );\n    }\n};\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLES ] = function ( first, count, cb ) {\n    for ( var i = 2, pos = first; i < count; i += 3, pos += 3 ) {\n        cb( pos, pos + 1, pos + 2 );\n    }\n};\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLE_STRIP ] = function ( first, count, cb ) {\n    for ( var i = 2, pos = first; i < count; ++i, ++pos ) {\n        if ( i % 2 ) cb( pos, pos + 2, pos + 1 );\n        else cb( pos, pos + 1, pos + 2 );\n    }\n};\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLE_FAN ] = function ( first, count, cb ) {\n    for ( var i = 2, pos = first + 1; i < count; ++i, ++pos ) {\n        cb( first, pos, pos + 1 );\n    }\n};\n\n\nTriangleIndexFunctor.prototype = {\n\n    // You feed it with a callback that will be called for each triangle\n    // (with the 3 indexes of vertices as arguments)\n    init: function ( geom, cb ) {\n        this._geom = geom;\n        this._cb = cb;\n    },\n\n    apply: function () {\n        var geom = this._geom;\n        var primitives = geom.getPrimitiveSetList();\n        if ( !primitives )\n            return;\n\n        var cb = this._cb;\n        var cbFunctor;\n\n        var nbPrimitives = primitives.length;\n        for ( var i = 0; i < nbPrimitives; i++ ) {\n\n            var primitive = primitives[ i ];\n            if ( primitive instanceof DrawElements ) {\n\n                cbFunctor = functorDrawElements[ primitive.getMode() ];\n                if ( cbFunctor ) {\n                    var indexes = primitive.indices.getElements();\n                    cbFunctor( primitive.getFirst() / indexes.BYTES_PER_ELEMENT, primitive.getCount(), indexes, cb );\n                }\n\n            } else if ( primitive instanceof DrawArrays ) {\n\n                cbFunctor = functorDrawArrays[ primitive.getMode() ];\n                if ( cbFunctor ) {\n                    cbFunctor( primitive.getFirst(), primitive.getCount(), cb );\n                }\n\n            }\n        }\n    }\n};\n\nmodule.exports = TriangleIndexFunctor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/TriangleIndexFunctor.js\n// module id = 92\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar TriangleLineSegmentIntersector = require( 'osgUtil/TriangleLineSegmentIntersector' );\n\nvar KdTreeLineSegmentIntersector = function () {\n    this._intersector = new TriangleLineSegmentIntersector();\n    this._dInvX = vec3.create();\n    this._dInvY = vec3.create();\n    this._dInvZ = vec3.create();\n};\n\nKdTreeLineSegmentIntersector.prototype = {\n    setKdtree: function ( vertices, nodes, triangles ) {\n        this._vertices = vertices;\n        this._kdNodes = nodes;\n        this._triangles = triangles;\n    },\n    init: ( function () {\n\n        var dir = vec3.create();\n\n        return function ( intersections, start, end, nodePath ) {\n            var d = vec3.sub( dir, end, start );\n            var len = vec3.length( d );\n            var invLen = 0.0;\n            if ( len !== 0.0 )\n                invLen = 1.0 / len;\n            vec3.scale( d, d, invLen );\n            if ( d[ 0 ] !== 0.0 ) vec3.scale( this._dInvX, d, 1.0 / d[ 0 ] );\n            if ( d[ 1 ] !== 0.0 ) vec3.scale( this._dInvY, d, 1.0 / d[ 1 ] );\n            if ( d[ 2 ] !== 0.0 ) vec3.scale( this._dInvZ, d, 1.0 / d[ 2 ] );\n\n            this._intersector._intersections = intersections;\n            this._intersector.setNodePath( nodePath );\n            this._intersector.set( start, end );\n        };\n    } )(),\n    // Classic ray intersection test\n    // If it's a leaf it does ray-triangles intersection with the triangles in the cell\n    // If it's not a leaf, it descend in the tree in a recursive way as long as the ray\n    // intersects the boundinbox of the nodes\n    intersect: ( function () {\n\n        var v0 = vec3.create();\n        var v1 = vec3.create();\n        var v2 = vec3.create();\n\n        return function ( node, ls, le ) {\n            var first = node._first;\n            var second = node._second;\n            var triangles = this._triangles;\n            var vertices = this._vertices;\n\n            if ( first < 0 ) {\n                // treat as a leaf\n                var istart = -first - 1;\n                var iend = istart + second;\n                var intersector = this._intersector;\n                intersector.index = istart;\n\n                for ( var i = istart; i < iend; ++i ) {\n                    var id = i * 3;\n                    var iv0 = triangles[ id ];\n                    var iv1 = triangles[ id + 1 ];\n                    var iv2 = triangles[ id + 2 ];\n\n                    var j = iv0 * 3;\n                    v0[ 0 ] = vertices[ j ];\n                    v0[ 1 ] = vertices[ j + 1 ];\n                    v0[ 2 ] = vertices[ j + 2 ];\n\n                    j = iv1 * 3;\n                    v1[ 0 ] = vertices[ j ];\n                    v1[ 1 ] = vertices[ j + 1 ];\n                    v1[ 2 ] = vertices[ j + 2 ];\n\n                    j = iv2 * 3;\n                    v2[ 0 ] = vertices[ j ];\n                    v2[ 1 ] = vertices[ j + 1 ];\n                    v2[ 2 ] = vertices[ j + 2 ];\n\n                    intersector.intersect( v0, v1, v2, iv0, iv1, iv2 );\n                }\n            } else {\n                var s = node._nodeRayStart;\n                var e = node._nodeRayEnd;\n                var kNodes = this._kdNodes;\n\n                var kNode;\n                vec3.copy( s, ls );\n                vec3.copy( e, le );\n                if ( first > 0 ) {\n                    kNode = kNodes[ first ];\n                    if ( this.intersectAndClip( s, e, kNode._bb ) ) {\n                        this.intersect( kNode, s, e );\n                    }\n                }\n                if ( second > 0 ) {\n                    vec3.copy( s, ls );\n                    vec3.copy( e, le );\n                    kNode = kNodes[ second ];\n                    if ( this.intersectAndClip( s, e, kNode._bb ) ) {\n                        this.intersect( kNode, s, e );\n                    }\n                }\n            }\n        };\n    } )(),\n    // This method do 2 things\n    // It test if the ray intersects the node\n    // If so... it clip the ray so that the start and end point of the ray are\n    // snapped to the bounding box of the nodes\n    intersectAndClip: ( function () {\n\n        return function ( s, e, bb ) {\n            var min = bb._min;\n            var xmin = min[ 0 ];\n            var ymin = min[ 1 ];\n            var zmin = min[ 2 ];\n\n            var max = bb._max;\n            var xmax = max[ 0 ];\n            var ymax = max[ 1 ];\n            var zmax = max[ 2 ];\n\n            var invX = this._dInvX;\n            var invY = this._dInvY;\n            var invZ = this._dInvZ;\n\n            if ( s[ 0 ] <= e[ 0 ] ) {\n                // trivial reject of segment wholely outside.\n                if ( e[ 0 ] < xmin ) return false;\n                if ( s[ 0 ] > xmax ) return false;\n\n                if ( s[ 0 ] < xmin ) {\n                    // clip s to xMin.\n                    vec3.scaleAndAdd( s, s, invX, xmin - s[ 0 ] );\n                }\n\n                if ( e[ 0 ] > xmax ) {\n                    // clip e to xMax.\n                    vec3.scaleAndAdd( e, s, invX, xmax - s[ 0 ] );\n                }\n            } else {\n                if ( s[ 0 ] < xmin ) return false;\n                if ( e[ 0 ] > xmax ) return false;\n\n                if ( e[ 0 ] < xmin ) {\n                    // clip s to xMin.\n                    vec3.scaleAndAdd( e, s, invX, xmin - s[ 0 ] );\n                }\n\n                if ( s[ 0 ] > xmax ) {\n                    // clip e to xMax.\n                    vec3.scaleAndAdd( s, s, invX, xmax - s[ 0 ] );\n                }\n            }\n\n            // compate s and e against the yMin to yMax range of bb.\n            if ( s[ 1 ] <= e[ 1 ] ) {\n\n                // trivial reject of segment wholely outside.\n                if ( e[ 1 ] < ymin ) return false;\n                if ( s[ 1 ] > ymax ) return false;\n\n                if ( s[ 1 ] < ymin ) {\n                    // clip s to yMin.\n                    vec3.scaleAndAdd( s, s, invY, ymin - s[ 1 ] );\n                }\n\n                if ( e[ 1 ] > ymax ) {\n                    // clip e to yMax.\n                    vec3.scaleAndAdd( e, s, invY, ymax - s[ 1 ] );\n                }\n            } else {\n                if ( s[ 1 ] < ymin ) return false;\n                if ( e[ 1 ] > ymax ) return false;\n\n                if ( e[ 1 ] < ymin ) {\n                    // clip s to yMin.\n                    vec3.scaleAndAdd( e, s, invY, ymin - s[ 1 ] );\n                }\n\n                if ( s[ 1 ] > ymax ) {\n                    // clip e to yMax.\n                    vec3.scaleAndAdd( s, s, invY, ymax - s[ 1 ] );\n                }\n            }\n\n            // compate s and e against the zMin to zMax range of bb.\n            if ( s[ 2 ] <= e[ 2 ] ) {\n                // trivial reject of segment wholely outside.\n                if ( e[ 2 ] < zmin ) return false;\n                if ( s[ 2 ] > zmax ) return false;\n\n                if ( s[ 2 ] < zmin ) {\n                    // clip s to zMin.\n                    vec3.scaleAndAdd( s, s, invZ, zmin - s[ 2 ] );\n                }\n\n                if ( e[ 2 ] > zmax ) {\n                    // clip e to zMax.\n                    vec3.scaleAndAdd( e, s, invZ, zmax - s[ 2 ] );\n                }\n            } else {\n                if ( s[ 2 ] < zmin ) return false;\n                if ( e[ 2 ] > zmax ) return false;\n\n                if ( e[ 2 ] < zmin ) {\n                    // clip s to zMin.\n                    vec3.scaleAndAdd( e, s, invZ, zmin - s[ 2 ] );\n                }\n\n                if ( s[ 2 ] > zmax ) {\n                    // clip e to zMax.\n                    vec3.scaleAndAdd( s, s, invZ, zmax - s[ 2 ] );\n                }\n            }\n            return true;\n        };\n    } )()\n};\n\nmodule.exports = KdTreeLineSegmentIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/KdTreeLineSegmentIntersector.js\n// module id = 93\n// module chunks = 0 1 2","'use strict';\n\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar TriangleIndexFunctor = require( 'osg/TriangleIndexFunctor' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\n\nvar TriangleLineSegmentIntersection = function ( normal, i1, i2, i3, r1, r2, r3 ) {\n    this.normal = normal;\n\n    this.i1 = i1;\n    this.i2 = i2;\n    this.i3 = i3;\n\n    this.r1 = r1;\n    this.r2 = r2;\n    this.r3 = r3;\n};\n\nvar TriangleLineSegmentIntersector = function () {\n\n    this._intersections = [];\n    this._nodePath = [];\n    this._dir = vec3.create();\n};\n\nTriangleLineSegmentIntersector.prototype = {\n    reset: function () {\n        this._intersections.length = 0;\n    },\n    setNodePath: function ( np ) {\n        this._nodePath = np;\n    },\n    set: function ( start, end ) {\n        this._start = start;\n        this._end = end;\n        this._dir = vec3.sub( this._dir, end, start );\n        this._length = vec3.length( this._dir );\n        this._invLength = 1.0 / this._length;\n        vec3.scale( this._dir, this._dir, this._invLength );\n    },\n\n    apply: ( function () {\n\n        var v1 = vec3.create();\n        var v2 = vec3.create();\n        var v3 = vec3.create();\n        var tif = new TriangleIndexFunctor();\n\n        return function ( node ) {\n\n            if ( !node.getAttributes().Vertex ) {\n                return;\n            }\n            var vertices = node.getAttributes().Vertex.getElements();\n            var self = this;\n\n            var cb = function ( i1, i2, i3 ) {\n\n                if ( i1 === i2 || i1 === i3 || i2 === i3 )\n                    return;\n\n                var j = i1 * 3;\n                v1[ 0 ] = vertices[ j ];\n                v1[ 1 ] = vertices[ j + 1 ];\n                v1[ 2 ] = vertices[ j + 2 ];\n\n                j = i2 * 3;\n                v2[ 0 ] = vertices[ j ];\n                v2[ 1 ] = vertices[ j + 1 ];\n                v2[ 2 ] = vertices[ j + 2 ];\n\n                j = i3 * 3;\n                v3[ 0 ] = vertices[ j ];\n                v3[ 1 ] = vertices[ j + 1 ];\n                v3[ 2 ] = vertices[ j + 2 ];\n\n                self.intersect( v1, v2, v3, i1, i2, i3 );\n            };\n            tif.init( node, cb );\n            tif.apply();\n\n        };\n    } )(),\n\n    isBackFace: ( function () {\n\n        var mat = mat4.create();\n\n        return function ( det, nodepath ) {\n            mat4.identity( mat );\n            // http://gamedev.stackexchange.com/questions/54505/negative-scale-in-matrix-4x4\n            // https://en.wikipedia.org/wiki/Determinant#Orientation_of_a_basis\n            // you can't exactly extract scale of a matrix but the determinant will tell you\n            // if the orientation is preserved\n            ComputeMatrixFromNodePath.computeLocalToWorld( nodepath, true, mat );\n            var detMat = mat4.determinant( mat );\n            return detMat * det < 0.0;\n        };\n\n    } )(),\n\n    intersect: ( function () {\n\n        var normal = vec3.create();\n        var e2 = vec3.create();\n        var e1 = vec3.create();\n        var tvec = vec3.create();\n        var pvec = vec3.create();\n        var qvec = vec3.create();\n        var epsilon = 1E-20;\n\n        return function ( v0, v1, v2, i0, i1, i2 ) {\n\n            var d = this._dir;\n\n            vec3.sub( e2, v2, v0 );\n            vec3.sub( e1, v1, v0 );\n            vec3.cross( pvec, d, e2 );\n\n            var det = vec3.dot( pvec, e1 );\n            if ( det > -epsilon && det < epsilon )\n                return;\n            var invDet = 1.0 / det;\n\n            vec3.sub( tvec, this._start, v0 );\n\n            var u = vec3.dot( pvec, tvec ) * invDet;\n            if ( u < 0.0 || u > 1.0 )\n                return;\n\n            vec3.cross( qvec, tvec, e1 );\n\n            var v = vec3.dot( qvec, d ) * invDet;\n            if ( v < 0.0 || ( u + v ) > 1.0 )\n                return;\n\n            var t = vec3.dot( qvec, e2 ) * invDet;\n\n            if ( t < epsilon || t > this._length ) //no intersection\n                return;\n\n            var r0 = 1.0 - u - v;\n            var r1 = u;\n            var r2 = v;\n            var r = t * this._invLength;\n\n            var interX = v0[ 0 ] * r0 + v1[ 0 ] * r1 + v2[ 0 ] * r2;\n            var interY = v0[ 1 ] * r0 + v1[ 1 ] * r1 + v2[ 1 ] * r2;\n            var interZ = v0[ 2 ] * r0 + v1[ 2 ] * r1 + v2[ 2 ] * r2;\n\n            vec3.cross( normal, e1, e2 );\n            vec3.normalize( normal, normal );\n\n            // GC TriangleIntersection & Point\n            this._intersections.push( {\n                ratio: r,\n                backface: this.isBackFace( det, this._nodePath ),\n                nodepath: this._nodePath.slice( 0 ), // Note: If you are computing intersections from a viewer the first node is the camera of the viewer\n                TriangleIntersection: new TriangleLineSegmentIntersection( vec3.clone( normal ), i0, i1, i2, r0, r1, r2 ),\n                point: vec3.fromValues( interX, interY, interZ )\n            } );\n            this.hit = true;\n        };\n    } )()\n};\n\nmodule.exports = TriangleLineSegmentIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/TriangleLineSegmentIntersector.js\n// module id = 94\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar KdTreeLineSegmentIntersector = require( 'osg/KdTreeLineSegmentIntersector' );\nvar TriangleSphereIntersector = require( 'osgUtil/TriangleSphereIntersector' );\n\n\nvar KdTreeSphereIntersector = function () {\n    this._intersector = new TriangleSphereIntersector();\n};\n\nKdTreeSphereIntersector.prototype = MACROUTILS.objectInherit( KdTreeLineSegmentIntersector.prototype, {\n\n    init: function ( intersections, center, radius, nodePath ) {\n\n        this._intersector._intersections = intersections;\n        this._intersector.setNodePath( nodePath );\n        this._intersector.set( center, radius );\n        this._center = center;\n        this._radius = radius;\n\n    },\n\n    intersect: ( function () {\n\n        var v0 = vec3.create();\n        var v1 = vec3.create();\n        var v2 = vec3.create();\n\n        return function ( node ) {\n            var first = node._first;\n            var second = node._second;\n            var triangles = this._triangles;\n            var vertices = this._vertices;\n\n            if ( first < 0 ) {\n                // treat as a leaf\n                var istart = -first - 1;\n                var iend = istart + second;\n                var intersector = this._intersector;\n                intersector.index = istart;\n\n                for ( var i = istart; i < iend; ++i ) {\n                    var id = i * 3;\n                    var iv0 = triangles[ id ];\n                    var iv1 = triangles[ id + 1 ];\n                    var iv2 = triangles[ id + 2 ];\n\n                    var j = iv0 * 3;\n                    v0[ 0 ] = vertices[ j ];\n                    v0[ 1 ] = vertices[ j + 1 ];\n                    v0[ 2 ] = vertices[ j + 2 ];\n\n                    j = iv1 * 3;\n                    v1[ 0 ] = vertices[ j ];\n                    v1[ 1 ] = vertices[ j + 1 ];\n                    v1[ 2 ] = vertices[ j + 2 ];\n\n                    j = iv2 * 3;\n                    v2[ 0 ] = vertices[ j ];\n                    v2[ 1 ] = vertices[ j + 1 ];\n                    v2[ 2 ] = vertices[ j + 2 ];\n\n                    intersector.intersect( v0, v1, v2, iv0, iv1, iv2 );\n                }\n            } else {\n                if ( first > 0 ) {\n                    if ( this.intersectSphere( this._kdNodes[ first ]._bb ) ) {\n                        this.intersect( this._kdNodes[ first ] );\n                    }\n                }\n                if ( second > 0 ) {\n                    if ( this.intersectSphere( this._kdNodes[ second ]._bb ) ) {\n                        this.intersect( this._kdNodes[ second ] );\n                    }\n                }\n            }\n        };\n    } )(),\n    intersectSphere: ( function () {\n        var tmp = vec3.create();\n        return function ( bb ) {\n            var r = this._radius + bb.radius();\n            return vec3.sqrDist( bb.center( tmp ), this._center ) <= r * r;\n        };\n    } )()\n} );\n\nmodule.exports = KdTreeSphereIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/KdTreeSphereIntersector.js\n// module id = 95\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar TriangleLineSegmentIntersector = require( 'osgUtil/TriangleLineSegmentIntersector' );\n\n// implicitly match with TriangleLineSegment intersection\nvar TriangleSphereIntersection = function ( normal, i1, i2, i3, r1, r2, r3 ) {\n    this.normal = normal;\n\n    this.i1 = i1;\n    this.i2 = i2;\n    this.i3 = i3;\n\n    this.r1 = r1;\n    this.r2 = r2;\n    this.r3 = r3;\n};\n\nvar TriangleSphereIntersector = function () {\n    TriangleLineSegmentIntersector.apply( this );\n};\n\nTriangleSphereIntersector.prototype = MACROUTILS.objectInherit( TriangleLineSegmentIntersector.prototype, {\n    set: function ( center, radius ) {\n        this._center = center;\n        this._radius = radius;\n    },\n\n    //\n    // \\2|\n    //  \\|\n    //   \\\n    // 3 |\\  1\n    //   |0\\\n    // __|__\\___\n    // 4 | 5 \\ 6\n    //\n    // from http://www.geometrictools.com/Source/Distance3D.html#PointPlanar\n    // js : https://github.com/stephomi/sculptgl/blob/master/src/math3d/Geometry.js#L89\n    intersect: ( function () {\n        var edge1 = vec3.create();\n        var edge2 = vec3.create();\n        var diff = vec3.create();\n        return function ( v1, v2, v3, i1, i2, i3 ) {\n\n            // sphere is a 'volume' here (so if the triangle is inside the ball it will intersects)\n\n            vec3.sub( edge1, v2, v1 );\n            vec3.sub( edge2, v3, v1 );\n            var a00 = vec3.sqrLen( edge1 );\n            var a01 = vec3.dot( edge1, edge2 );\n            var a11 = vec3.sqrLen( edge2 );\n\n            vec3.sub( diff, v1, this._center );\n            var b0 = vec3.dot( diff, edge1 );\n            var b1 = vec3.dot( diff, edge2 );\n            var c = vec3.sqrLen( diff );\n            var det = Math.abs( a00 * a11 - a01 * a01 );\n            if ( det < 1e-10 )\n                return;\n\n            var s = a01 * b1 - a11 * b0;\n            var t = a01 * b0 - a00 * b1;\n            var sqrDistance;\n            var zone = 4;\n\n            if ( s + t <= det ) {\n                if ( s < 0.0 ) {\n                    if ( t < 0.0 ) { // region 4\n                        zone = 4;\n                        if ( b0 < 0.0 ) {\n                            t = 0.0;\n                            if ( -b0 >= a00 ) {\n                                s = 1.0;\n                                sqrDistance = a00 + 2.0 * b0 + c;\n                            } else {\n                                s = -b0 / a00;\n                                sqrDistance = b0 * s + c;\n                            }\n                        } else {\n                            s = 0.0;\n                            if ( b1 >= 0.0 ) {\n                                t = 0.0;\n                                sqrDistance = c;\n                            } else if ( -b1 >= a11 ) {\n                                t = 1.0;\n                                sqrDistance = a11 + 2.0 * b1 + c;\n                            } else {\n                                t = -b1 / a11;\n                                sqrDistance = b1 * t + c;\n                            }\n                        }\n                    } else { // region 3\n                        zone = 3;\n                        s = 0.0;\n                        if ( b1 >= 0.0 ) {\n                            t = 0.0;\n                            sqrDistance = c;\n                        } else if ( -b1 >= a11 ) {\n                            t = 1.0;\n                            sqrDistance = a11 + 2.0 * b1 + c;\n                        } else {\n                            t = -b1 / a11;\n                            sqrDistance = b1 * t + c;\n                        }\n                    }\n                } else if ( t < 0.0 ) { // region 5\n                    zone = 5;\n                    t = 0.0;\n                    if ( b0 >= 0.0 ) {\n                        s = 0.0;\n                        sqrDistance = c;\n                    } else if ( -b0 >= a00 ) {\n                        s = 1.0;\n                        sqrDistance = a00 + 2.0 * b0 + c;\n                    } else {\n                        s = -b0 / a00;\n                        sqrDistance = b0 * s + c;\n                    }\n                } else { // region 0\n                    zone = 0;\n                    // minimum at interior point\n                    var invDet = 1.0 / det;\n                    s *= invDet;\n                    t *= invDet;\n                    sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;\n                }\n            } else {\n                var tmp0, tmp1, numer, denom;\n\n                if ( s < 0.0 ) { // region 2\n                    zone = 2;\n                    tmp0 = a01 + b0;\n                    tmp1 = a11 + b1;\n                    if ( tmp1 > tmp0 ) {\n                        numer = tmp1 - tmp0;\n                        denom = a00 - 2.0 * a01 + a11;\n                        if ( numer >= denom ) {\n                            s = 1.0;\n                            t = 0.0;\n                            sqrDistance = a00 + 2.0 * b0 + c;\n                        } else {\n                            s = numer / denom;\n                            t = 1.0 - s;\n                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;\n                        }\n                    } else {\n                        s = 0.0;\n                        if ( tmp1 <= 0.0 ) {\n                            t = 1.0;\n                            sqrDistance = a11 + 2.0 * b1 + c;\n                        } else if ( b1 >= 0.0 ) {\n                            t = 0.0;\n                            sqrDistance = c;\n                        } else {\n                            t = -b1 / a11;\n                            sqrDistance = b1 * t + c;\n                        }\n                    }\n                } else if ( t < 0.0 ) { // region 6\n                    zone = 6;\n                    tmp0 = a01 + b1;\n                    tmp1 = a00 + b0;\n                    if ( tmp1 > tmp0 ) {\n                        numer = tmp1 - tmp0;\n                        denom = a00 - 2.0 * a01 + a11;\n                        if ( numer >= denom ) {\n                            t = 1.0;\n                            s = 0.0;\n                            sqrDistance = a11 + 2.0 * b1 + c;\n                        } else {\n                            t = numer / denom;\n                            s = 1.0 - t;\n                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;\n                        }\n                    } else {\n                        t = 0.0;\n                        if ( tmp1 <= 0.0 ) {\n                            s = 1.0;\n                            sqrDistance = a00 + 2.0 * b0 + c;\n                        } else if ( b0 >= 0.0 ) {\n                            s = 0.0;\n                            sqrDistance = c;\n                        } else {\n                            s = -b0 / a00;\n                            sqrDistance = b0 * s + c;\n                        }\n                    }\n                } else { // region 1\n                    zone = 1;\n                    numer = a11 + b1 - a01 - b0;\n                    if ( numer <= 0.0 ) {\n                        s = 0.0;\n                        t = 1.0;\n                        sqrDistance = a11 + 2.0 * b1 + c;\n                    } else {\n                        denom = a00 - 2.0 * a01 + a11;\n                        if ( numer >= denom ) {\n                            s = 1.0;\n                            t = 0.0;\n                            sqrDistance = a00 + 2.0 * b0 + c;\n                        } else {\n                            s = numer / denom;\n                            t = 1.0 - s;\n                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;\n                        }\n                    }\n                }\n            }\n\n            // Account for numerical round-off error.\n            if ( sqrDistance < 0.0 )\n                sqrDistance = 0.0;\n\n            if ( sqrDistance > ( this._radius * this._radius ) )\n                return;\n\n            var closest = vec3.create();\n            if ( closest ) {\n                closest[ 0 ] = v1[ 0 ] + s * edge1[ 0 ] + t * edge2[ 0 ];\n                closest[ 1 ] = v1[ 1 ] + s * edge1[ 1 ] + t * edge2[ 1 ];\n                closest[ 2 ] = v1[ 2 ] + s * edge1[ 2 ] + t * edge2[ 2 ];\n            }\n\n            var normal = vec3.create();\n            vec3.cross( normal, edge1, edge2 );\n            vec3.normalize( normal, normal );\n\n            // TODO: gc TriangleIntersection, closest, normal ? (stack pool)\n            this._intersections.push( {\n                ratio: Math.sqrt( sqrDistance ),\n                nodepath: this._nodePath.slice( 0 ),\n                TriangleIntersection: new TriangleSphereIntersection( normal, i1, i2, i3, 1 - s - t, s, t ),\n                point: closest,\n                zone: zone\n            } );\n            this.hit = true;\n        };\n    } )()\n} );\n\nmodule.exports = TriangleSphereIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/TriangleSphereIntersector.js\n// module id = 96\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar KdTree = require( 'osg/KdTree' );\n\n\nvar KdTreeBuilder = function ( options ) {\n    NodeVisitor.call( this );\n    this._buildOptions = options !== undefined ? options : {\n        _numVerticesProcessed: 0,\n        _targetNumTrianglesPerLeaf: 50,\n        _maxNumLevels: 20\n    };\n};\n\nKdTreeBuilder.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    apply: function ( node ) {\n        if ( node.getShape ) {\n            var shape = node.getShape();\n            // we test if the kdTree is already built and if we can build it (null means we skip it)\n            if ( shape === undefined ) {\n                var kdTree = new KdTree();\n                if ( kdTree.build( this._buildOptions, node ) ) {\n                    node.setShape( kdTree );\n                }\n            }\n        }\n        this.traverse( node );\n    }\n} );\n\nmodule.exports = KdTreeBuilder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/KdTreeBuilder.js\n// module id = 97\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n// use the same kind of opengl lights\n// see http://www.glprogramming.com/red/chapter05.html\n\n\nvar Light = function ( lightNum, disable ) {\n    StateAttribute.call( this );\n\n    var lightNumber = lightNum !== undefined ? lightNum : 0;\n\n    this._ambient = vec4.fromValues( 0.2, 0.2, 0.2, 1.0 );\n    this._diffuse = vec4.fromValues( 0.8, 0.8, 0.8, 1.0 );\n    this._specular = vec4.fromValues( 0.2, 0.2, 0.2, 1.0 );\n\n    // Default is directional as postion[3] is 0\n    this._position = vec4.fromValues( 0.0, 0.0, 1.0, 0.0 );\n    this._direction = vec3.fromValues( 0.0, 0.0, -1.0 );\n\n    // TODO : refactor lights management w=1.0 (isHemi), w=-1.0\n    // (isNotHemi) _ground contains the color but w says if it's\n    // an hemi or not\n    this._ground = vec4.fromValues( 0.2, 0.2, 0.2, -1.0 );\n\n    this._spotCutoff = 180.0;\n    this._spotBlend = 0.01;\n\n    // the array contains constant, linear, quadratic factor\n    this._attenuation = vec4.fromValues( 1.0, 0.0, 0.0, 0.0 );\n\n    this._lightNumber = lightNumber;\n\n    this._enable = !disable;\n\n};\n\nLight.DIRECTION = 'DIRECTION';\nLight.SPOT = 'SPOT';\nLight.POINT = 'POINT';\nLight.HEMI = 'HEMI';\n\nLight.uniforms = {};\nLight.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Light',\n\n    cloneType: function () {\n        return new Light( this._lightNumber, true );\n    },\n\n    getTypeMember: function () {\n        return this.attributeType + this._lightNumber;\n    },\n\n    getUniformName: function ( name ) {\n        var prefix = this.getType() + this._lightNumber.toString();\n        return 'u' + prefix + '_' + name;\n    },\n\n    getHash: function () {\n        return this.getTypeMember() + this.getLightType() + this.isEnabled().toString();\n    },\n\n    getOrCreateUniforms: function () {\n\n        var obj = Light;\n        var typeMember = this.getTypeMember();\n\n        if ( obj.uniforms[ typeMember ] ) return obj.uniforms[ typeMember ];\n\n        obj.uniforms[ typeMember ] = {\n            ambient: Uniform.createFloat4( this.getUniformName( 'ambient' ) ),\n            diffuse: Uniform.createFloat4( this.getUniformName( 'diffuse' ) ),\n            specular: Uniform.createFloat4( this.getUniformName( 'specular' ) ),\n            attenuation: Uniform.createFloat4( this.getUniformName( 'attenuation' ) ),\n            position: Uniform.createFloat4( this.getUniformName( 'position' ) ),\n            direction: Uniform.createFloat3( this.getUniformName( 'direction' ) ),\n            spotCutOff: Uniform.createFloat1( this.getUniformName( 'spotCutOff' ) ),\n            spotBlend: Uniform.createFloat1( this.getUniformName( 'spotBlend' ) ),\n            ground: Uniform.createFloat4( this.getUniformName( 'ground' ) ),\n            matrix: Uniform.createMatrix4( this.getUniformName( 'matrix' ) ),\n            invMatrix: Uniform.createMatrix4( this.getUniformName( 'invMatrix' ) )\n        };\n\n        return obj.uniforms[ typeMember ];\n    },\n\n    // enable / disable is not implemented in uniform\n    // we should add it\n    isEnabled: function () {\n        return this._enable;\n    },\n\n    setEnabled: function ( bool ) {\n        this._enable = bool;\n    },\n\n    // colors\n    setAmbient: function ( a ) {\n        vec4.copy( this._ambient, a );\n    },\n\n    getAmbient: function () {\n        return this._ambient;\n    },\n\n    setDiffuse: function ( a ) {\n        vec4.copy( this._diffuse, a );\n    },\n\n    getDiffuse: function () {\n        return this._diffuse;\n    },\n\n    setSpecular: function ( a ) {\n        vec4.copy( this._specular, a );\n    },\n\n    getSpecular: function () {\n        return this._specular;\n    },\n\n\n    // position, also used for directional light\n    // position[3] === 0 means directional\n    // see creating lightsources http://www.glprogramming.com/red/chapter05.html\n    setPosition: function ( a ) {\n        vec4.copy( this._position, a );\n    },\n\n    getPosition: function () {\n        return this._position;\n    },\n\n    // unused for directional\n    setDirection: function ( a ) {\n        vec3.copy( this._direction, a );\n    },\n\n    getDirection: function () {\n        return this._direction;\n    },\n\n\n    setSpotCutoff: function ( a ) {\n        this._spotCutoff = a;\n    },\n\n    getSpotCutoff: function () {\n        return this._spotCutoff;\n    },\n\n    setSpotBlend: function ( a ) {\n        this._spotBlend = a;\n    },\n\n    getSpotBlend: function () {\n        return this._spotBlend;\n    },\n\n    // set/get the color of the ground\n    setGround: function ( a ) {\n        vec3.copy( this._ground, a );\n    },\n\n    getGround: function () {\n        return this._ground;\n    },\n\n    // attenuation coeff\n    setConstantAttenuation: function ( value ) {\n        this._attenuation[ 0 ] = value;\n    },\n\n    getConstantAttenuation: function () {\n        return this._attenuation[ 0 ];\n    },\n\n    setLinearAttenuation: function ( value ) {\n        this._attenuation[ 1 ] = value;\n    },\n\n    getLinearAttenuation: function () {\n        return this._attenuation[ 1 ];\n    },\n\n    setQuadraticAttenuation: function ( value ) {\n        this._attenuation[ 2 ] = value;\n    },\n\n    getQuadraticAttenuation: function () {\n        return this._attenuation[ 2 ];\n    },\n\n    setLightType: function ( type ) {\n        if ( type === Light.DIRECTION )\n            return this.setLightAsDirection();\n        else if ( type === Light.SPOT )\n            return this.setLightAsSpot();\n        else if ( type === Light.HEMI )\n            return this.setLightAsHemi();\n        return this.setLightAsPoint();\n    },\n\n    getLightType: function () {\n        if ( this.isDirectionLight() )\n            return Light.DIRECTION;\n        else if ( this.isSpotLight() )\n            return Light.SPOT;\n        else if ( this.isHemiLight() )\n            return Light.HEMI;\n        return Light.POINT;\n    },\n\n    setLightAsSpot: function () {\n        vec4.set( this._position, 0.0, 0.0, 0.0, 1.0 );\n        vec3.set( this._direction, 0.0, 0.0, -1.0 );\n        this._ground[ 3 ] = -1.0;\n        this._spotCutoff = 90;\n    },\n\n    setLightAsPoint: function () {\n        vec4.set( this._position, 0.0, 0.0, 0.0, 1.0 );\n        vec3.set( this._direction, 0.0, 0.0, -1.0 );\n        this._ground[ 3 ] = -1.0;\n    },\n\n    setLightAsDirection: function () {\n        vec4.set( this._position, 0.0, 0.0, 1.0, 0.0 );\n        this._spotCutoff = 180;\n        this._ground[ 3 ] = -1.0;\n    },\n\n    setLightAsHemi: function () {\n        vec4.set( this._position, 0.0, 0.0, 1.0, 0.0 );\n        this._spotCutoff = 180;\n        this._ground[ 3 ] = 1.0;\n    },\n\n    setLightNumber: function ( unit ) {\n        this._lightNumber = unit;\n    },\n\n    getLightNumber: function () {\n        return this._lightNumber;\n    },\n\n    // internal helper\n    isSpotLight: function () {\n        return this._spotCutoff < 180.0;\n    },\n\n    isDirectionLight: function () {\n        return this._position[ 3 ] === 0.0 && this._ground[ 3 ] === -1.0;\n    },\n\n    isHemiLight: function () {\n        return this._ground[ 3 ] === 1.0;\n    },\n\n    // matrix is current model view, which can mean:\n    // world (node refAbsolute)\n    // world+camera (camera is refAbsolute)\n    // world+camera+camera+... (camera relative...)\n    applyPositionedUniform: function ( matrix ) {\n\n        var uniformMap = this.getOrCreateUniforms();\n\n        var matrixArray = uniformMap.matrix.getInternalArray();\n        var invMatrixArray = uniformMap.invMatrix.getInternalArray();\n\n        mat4.copy( matrixArray, matrix );\n        mat4.copy( invMatrixArray, matrix );\n\n        invMatrixArray[ 12 ] = 0.0;\n        invMatrixArray[ 13 ] = 0.0;\n        invMatrixArray[ 14 ] = 0.0;\n\n        mat4.invert( invMatrixArray, invMatrixArray );\n        mat4.transpose( invMatrixArray, invMatrixArray );\n    },\n\n    apply: function () {\n\n        if ( !this._enable ) return;\n\n        var uniformMap = this.getOrCreateUniforms();\n\n        uniformMap.position.setFloat4( this._position );\n\n        if ( this.isSpotLight() ) {\n            var spotsize = Math.cos( this._spotCutoff * Math.PI / 180.0 );\n            uniformMap.spotCutOff.setFloat( spotsize );\n            uniformMap.spotBlend.setFloat( ( 1.0 - spotsize ) * this._spotBlend );\n            uniformMap.direction.setFloat3( this._direction );\n        }\n\n        if ( this.isHemiLight() )\n            uniformMap.ground.setFloat4( this._ground );\n\n        uniformMap.attenuation.setFloat4( this._attenuation );\n        uniformMap.diffuse.setFloat4( this._diffuse );\n        uniformMap.specular.setFloat4( this._specular );\n        uniformMap.ambient.setFloat4( this._ambient );\n    }\n\n} ), 'osg', 'Light' );\n\nMACROUTILS.setTypeID( Light );\n\nmodule.exports = Light;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Light.js\n// module id = 98\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\nvar LineWidth = function ( lineWidth ) {\n    StateAttribute.call( this );\n    this.lineWidth = 1.0;\n    if ( lineWidth !== undefined ) {\n        this.lineWidth = lineWidth;\n    }\n};\nLineWidth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n    attributeType: 'LineWidth',\n    cloneType: function () {\n        return new LineWidth();\n    },\n    apply: function ( state ) {\n        state.getGraphicContext().lineWidth( this.lineWidth );\n    }\n} ), 'osg', 'LineWidth' );\n\nmodule.exports = LineWidth;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/LineWidth.js\n// module id = 99\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar Uniform = require( 'osg/Uniform' );\n\n// Define a material attribute\nvar Material = function () {\n    StateAttribute.call( this );\n    this._ambient = vec4.fromValues( 0.2, 0.2, 0.2, 1.0 );\n    this._diffuse = vec4.fromValues( 0.8, 0.8, 0.8, 1.0 );\n    this._specular = vec4.fromValues( 0.0, 0.0, 0.0, 1.0 );\n    this._emission = vec4.fromValues( 0.0, 0.0, 0.0, 1.0 );\n    this._shininess = 12.5;\n};\n\nMaterial.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Material',\n\n    cloneType: function () {\n        return new Material();\n    },\n\n    getParameterName: function ( name ) {\n        return 'u' + this.getType() + '_' + name;\n    },\n\n    getOrCreateUniforms: function () {\n        var obj = Material;\n        if ( obj.uniforms ) return obj.uniforms;\n\n        obj.uniforms = {\n            ambient: Uniform.createFloat4( 'uMaterialAmbient' ),\n            diffuse: Uniform.createFloat4( 'uMaterialDiffuse' ),\n            specular: Uniform.createFloat4( 'uMaterialSpecular' ),\n            emission: Uniform.createFloat4( 'uMaterialEmission' ),\n            shininess: Uniform.createFloat1( 'uMaterialShininess' )\n        };\n\n        return obj.uniforms;\n    },\n\n    setEmission: function ( a ) {\n        vec4.copy( this._emission, a );\n    },\n\n    getEmission: function () {\n        return this._emission;\n    },\n\n    setAmbient: function ( a ) {\n        vec4.copy( this._ambient, a );\n    },\n\n    getAmbient: function () {\n        return this._ambient;\n    },\n\n    setSpecular: function ( a ) {\n        vec4.copy( this._specular, a );\n    },\n\n    getSpecular: function () {\n        return this._specular;\n    },\n\n    setDiffuse: function ( a ) {\n        vec4.copy( this._diffuse, a );\n    },\n\n    getDiffuse: function () {\n        return this._diffuse;\n    },\n\n    setShininess: function ( a ) {\n        this._shininess = a;\n    },\n\n    getShininess: function () {\n        return this._shininess;\n    },\n\n    setTransparency: function ( a ) {\n        this._diffuse[ 3 ] = 1.0 - a;\n    },\n\n    getTransparency: function () {\n        return this._diffuse[ 3 ];\n    },\n\n    apply: function () {\n        var uniforms = this.getOrCreateUniforms();\n\n        uniforms.ambient.setFloat4( this._ambient );\n        uniforms.diffuse.setFloat4( this._diffuse );\n        uniforms.specular.setFloat4( this._specular );\n        uniforms.emission.setFloat4( this._emission );\n        uniforms.shininess.setFloat( this._shininess );\n\n    }\n\n\n} ), 'osg', 'Material' );\n\nmodule.exports = Material;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Material.js\n// module id = 100\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\n\n\nvar PointSizeAttribute = function ( disable ) {\n    StateAttribute.call( this );\n\n    this._enable = !disable;\n    this._pointSize = 1.0;\n    // careful with this option if there is lines/triangles under the stateset\n    this._circleShape = false;\n};\n\nPointSizeAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'PointSize',\n\n    cloneType: function () {\n        return new PointSizeAttribute( true );\n    },\n\n    setCircleShape: function ( bool ) {\n        this._circleShape = bool;\n    },\n\n    isCircleShape: function () {\n        return this._circleShape;\n    },\n\n    setEnabled: function ( state ) {\n        this._enable = state;\n    },\n\n    isEnabled: function () {\n        return this._enable;\n    },\n\n    setPointSize: function ( size ) {\n        this._pointSize = size;\n    },\n\n    getOrCreateUniforms: function () {\n        var obj = PointSizeAttribute;\n        if ( obj.uniforms ) return obj.uniforms;\n\n        obj.uniforms = {\n            pointSize: Uniform.createFloat( 1.0, 'uPointSize' )\n        };\n\n        return obj.uniforms;\n    },\n\n    getHash: function () {\n        return this.getTypeMember() + ( this.isEnabled() ? '1' : '0' ) + ( this._circleShape ? '1' : '0' );\n    },\n\n    apply: function () {\n\n        if ( !this._enable ) return;\n\n        var uniforms = this.getOrCreateUniforms();\n        uniforms.pointSize.setFloat( this._pointSize );\n\n    }\n\n} ), 'osg', 'PointSizeAttribute' );\n\nMACROUTILS.setTypeID( PointSizeAttribute );\n\nmodule.exports = PointSizeAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/PointSizeAttribute.js\n// module id = 101\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar DrawArrays = require( 'osg/DrawArrays' );\n\n/**\n * PrimitiveFunctor emulates the TemplatePrimitiveFunctor class in OSG and can\n * be used to get access to the vertices that compose the things drawn by osgjs.\n * Feed it with a callback that will be called for geometry.\n * The callback must be a closure and have the next structure:\n *\n * var myCallback = function(  ) {\n *     return {\n *          operatorPoint : function ( v ) { }, // Do your point operations here\n *          operatorLine : function ( v1, v2 ){ }, // Do you line operations here\n *          operatorTriangle : function ( v1, v2, v3 ) { } // Do your triangle operations here\n *      }\n * };\n *\n * Important Note: You should take into account that you are accesing the actual vertices of the primitive\n * you might want to do a copy of these values in your callback to avoid to modify the primitive geometry\n *  @class PrimitiveFunctor\n */\n\nvar PrimitiveFunctor = function ( geom, cb, vertices ) {\n    this._geom = geom;\n    this._cb = cb;\n    this._vertices = vertices;\n};\n\nvar functorDrawElements = PrimitiveFunctor.functorDrawElements = [];\nvar functorDrawArrays = PrimitiveFunctor.functorDrawArrays = [];\n\nfunctorDrawElements[ PrimitiveSet.POINTS ] = ( function () {\n    var v = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var end = offset + count;\n        for ( var i = offset; i < end; ++i ) {\n            var j = indexes[ i ] * 3;\n            v[ 0 ] = vertices[ j ];\n            v[ 1 ] = vertices[ j + 1 ];\n            v[ 2 ] = vertices[ j + 2 ];\n            cb.operatorPoint( v );\n        }\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.LINES ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var end = offset + count;\n        for ( var i = offset; i < end - 1; i += 2 ) {\n            var j = indexes[ i ] * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ i + 1 ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.LINE_STRIP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var end = offset + count;\n        for ( var i = offset; i < end - 1; ++i ) {\n            var j = indexes[ i ] * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ i + 1 ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.LINE_LOOP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var last = offset + count - 1;\n        for ( var i = offset; i < last; ++i ) {\n            var j = indexes[ i ] * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ i + 1 ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n        last = indexes[ last ] * 3;\n        v1[ 0 ] = vertices[ last ];\n        v1[ 1 ] = vertices[ last + 1 ];\n        v1[ 2 ] = vertices[ last + 2 ];\n        var first = indexes[ 0 ] * 3;\n        v2[ 0 ] = vertices[ first ];\n        v2[ 1 ] = vertices[ first + 1 ];\n        v2[ 2 ] = vertices[ first + 2 ];\n        cb.operatorLine( v1, v2 );\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLES ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var end = offset + count;\n        for ( var i = offset; i < end; i += 3 ) {\n            var j = indexes[ i ] * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ i + 1 ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ i + 2 ] * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            cb.operatorTriangle( v1, v2, v3 );\n        }\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLE_STRIP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        for ( var i = 2, pos = offset; i < count; ++i, ++pos ) {\n            var j = indexes[ pos ] * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ pos + 1 ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ pos + 2 ] * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            if ( i % 2 ) {\n                cb.operatorTriangle( v1, v3, v2 );\n            } else {\n                cb.operatorTriangle( v1, v2, v3 );\n            }\n        }\n    };\n} )();\n\nfunctorDrawElements[ PrimitiveSet.TRIANGLE_FAN ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( offset, count, indexes, cb, vertices ) {\n\n        var first = indexes[ offset ];\n        for ( var i = 2, pos = offset + 1; i < count; ++i, ++pos ) {\n            v1[ 0 ] = vertices[ first ];\n            v1[ 1 ] = vertices[ first + 1 ];\n            v1[ 2 ] = vertices[ first + 2 ];\n            var j = indexes[ pos ] * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = indexes[ pos + 1 ] * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            cb.operatorTriangle( v1, v2, v3 );\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.POINTS ] = ( function () {\n    var v = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = first; i < first + count; ++i ) {\n            var j = i * 3;\n            v[ 0 ] = vertices[ j ];\n            v[ 1 ] = vertices[ j + 1 ];\n            v[ 2 ] = vertices[ j + 2 ];\n            cb.operatorPoint( v );\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.LINES ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = first; i < first + count - 1; i += 2 ) {\n            var j = i * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = ( i + 1 ) * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.LINE_STRIP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = first; i < first + count - 1; ++i ) {\n            var j = i * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = ( i + 1 ) * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.LINE_LOOP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        var last = first + count - 1;\n        for ( var i = first; i < last; ++i ) {\n            var j = i * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = ( i + 1 ) * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            cb.operatorLine( v1, v2 );\n        }\n        last = last * 3;\n        v1[ 0 ] = vertices[ last ];\n        v1[ 1 ] = vertices[ last + 1 ];\n        v1[ 2 ] = vertices[ last + 2 ];\n        first = first * 3;\n        v2[ 0 ] = vertices[ first ];\n        v2[ 1 ] = vertices[ first + 1 ];\n        v2[ 2 ] = vertices[ first + 2 ];\n        cb.operatorLine( v1, v2 );\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLES ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = first; i < first + count; i += 3 ) {\n            var j = i * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = ( i + 1 ) * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = ( i + 2 ) * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            cb.operatorTriangle( v1, v2, v3 );\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLE_STRIP ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = 2, pos = first; i < count; ++i, ++pos ) {\n            var j = pos * 3;\n            v1[ 0 ] = vertices[ j ];\n            v1[ 1 ] = vertices[ j + 1 ];\n            v1[ 2 ] = vertices[ j + 2 ];\n            j = ( pos + 1 ) * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = ( pos + 2 ) * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            if ( i % 2 ) {\n                cb.operatorTriangle( v1, v3, v2 );\n            } else {\n                cb.operatorTriangle( v1, v2, v3 );\n            }\n        }\n    };\n} )();\n\nfunctorDrawArrays[ PrimitiveSet.TRIANGLE_FAN ] = ( function () {\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n    return function ( first, count, cb, vertices ) {\n\n        for ( var i = 2, pos = first + 1; i < count; ++i, ++pos ) {\n            v1[ 0 ] = vertices[ first ];\n            v1[ 1 ] = vertices[ first + 1 ];\n            v1[ 2 ] = vertices[ first + 2 ];\n            var j = pos * 3;\n            v2[ 0 ] = vertices[ j ];\n            v2[ 1 ] = vertices[ j + 1 ];\n            v2[ 2 ] = vertices[ j + 2 ];\n            j = ( pos + 1 ) * 3;\n            v3[ 0 ] = vertices[ j ];\n            v3[ 1 ] = vertices[ j + 1 ];\n            v3[ 2 ] = vertices[ j + 2 ];\n            cb.operatorTriangle( v1, v2, v3 );\n        }\n    };\n} )();\n\nPrimitiveFunctor.prototype = {\n    apply: function () {\n        var geom = this._geom;\n        var primitives = geom.getPrimitiveSetList();\n        if ( !primitives )\n            return;\n\n        var cb = this._cb();\n        var cbFunctor;\n        var vertices = this._vertices;\n\n        var nbPrimitives = primitives.length;\n        for ( var i = 0; i < nbPrimitives; i++ ) {\n\n            var primitive = primitives[ i ];\n            if ( primitive instanceof DrawElements ) {\n\n                cbFunctor = functorDrawElements[ primitive.getMode() ];\n                if ( cbFunctor ) {\n                    var indexes = primitive.indices.getElements();\n                    cbFunctor( primitive.getFirst() / indexes.BYTES_PER_ELEMENT, primitive.getCount(), indexes, cb, vertices );\n                }\n\n            } else if ( primitive instanceof DrawArrays ) {\n\n                cbFunctor = functorDrawArrays[ primitive.getMode() ];\n                if ( cbFunctor ) {\n                    cbFunctor( primitive.getFirst(), primitive.getCount(), cb, vertices );\n                }\n\n            }\n        }\n    }\n};\n\nmodule.exports = PrimitiveFunctor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/PrimitiveFunctor.js\n// module id = 102\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Notify = require( 'osg/notify' );\nvar GLObject = require( 'osg/GLObject' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar ShaderProcessor = require( 'osgShader/ShaderProcessor' );\nvar Timer = require( 'osg/Timer' );\n\n// singleton\nvar sp = new ShaderProcessor();\n\n/**\n * Program encapsulate an vertex and fragment shader\n * @class Program\n */\nvar Program = function ( vShader, fShader ) {\n    GLObject.call( this );\n    StateAttribute.call( this );\n    this._program = null;\n\n    // used to know if it's a default program\n    // a default program does nothing but avoid to do some\n    // useless logic\n    // if we vertex or fragment shader are set it's not a default\n    // program anymore\n    this._nullProgram = true;\n\n    this._vertex = undefined;\n    this._fragment = undefined;\n\n    this._uniformsCache = undefined;\n    this._attributesCache = undefined;\n    this._activeUniforms = undefined;\n    this._foreignUniforms = undefined;\n    this._trackAttributes = undefined;\n\n    if ( vShader )\n        this.setVertexShader( vShader );\n\n    if ( fShader )\n        this.setFragmentShader( fShader );\n\n    this._dirty = true;\n};\n\n\nvar getAttributeList = function ( vertexShader ) {\n    var attributeMap = {};\n\n    var i, l, attr;\n    var r = vertexShader.match( /attribute\\s+\\w+\\s+\\w+/g );\n    if ( r !== null ) {\n        for ( i = 0, l = r.length; i < l; i++ ) {\n            attr = r[ i ].match( /attribute\\s+\\w+\\s+(\\w+)/ )[ 1 ];\n            attributeMap[ attr ] = true;\n        }\n    } else {\n        r = vertexShader.match( /in\\s+\\w+\\s+\\w+\\s*;/g );\n        for ( i = 0, l = r.length; i < l; i++ ) {\n            attr = r[ i ].match( /in\\s+\\w+\\s+(\\w+)\\s*;/ )[ 1 ];\n            attributeMap[ attr ] = true;\n        }\n    }\n\n    return attributeMap;\n};\n\n\n// static cache of glPrograms flagged for deletion, which will actually\n// be deleted in the correct GL context.\nProgram._sDeletedGLProgramCache = new window.Map();\n\n// static method to delete Program\nProgram.deleteGLProgram = function ( gl, program ) {\n\n    if ( !Program._sDeletedGLProgramCache.has( gl ) )\n        Program._sDeletedGLProgramCache.set( gl, [] );\n\n    Program._sDeletedGLProgramCache.get( gl ).push( program );\n};\n\n// static method to flush all the cached glPrograms which need to be deleted in the GL context specified\nProgram.flushDeletedGLPrograms = function ( gl, availableTime ) {\n\n    // if no time available don't try to flush objects.\n    if ( availableTime <= 0.0 ) return availableTime;\n\n    if ( !Program._sDeletedGLProgramCache.has( gl ) ) return availableTime;\n\n    var elapsedTime = 0.0;\n    var beginTime = Timer.instance().tick();\n    var deleteList = Program._sDeletedGLProgramCache.get( gl );\n    var numPrograms = deleteList.length;\n\n    for ( var i = numPrograms - 1; i >= 0 && elapsedTime < availableTime; i-- ) {\n        gl.deleteProgram( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n    }\n\n    return availableTime - elapsedTime;\n};\n\nProgram.flushAllDeletedGLPrograms = function ( gl ) {\n\n    if ( !Program._sDeletedGLProgramCache.has( gl ) ) return;\n\n    var deleteList = Program._sDeletedGLProgramCache.get( gl );\n    var numPrograms = deleteList.length;\n\n    for ( var i = numPrograms - 1; i >= 0; i-- ) {\n        gl.deleteProgram( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n    }\n};\n\n/** @lends Program.prototype */\nProgram.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Program',\n\n    cloneType: function () {\n        return new Program();\n    },\n\n    setVertexShader: function ( vs ) {\n        this._vertex = vs;\n        this._nullProgram = false;\n        vs.setText( sp.processShader( vs.getText() ) );\n    },\n\n    setFragmentShader: function ( fs ) {\n        this._fragment = fs;\n        this._nullProgram = false;\n        fs.setText( sp.processShader( fs.getText() ) );\n    },\n\n    getVertexShader: function () {\n        return this._vertex;\n    },\n    getFragmentShader: function () {\n        return this._fragment;\n    },\n\n    getProgram: function () {\n        return this._program;\n    },\n\n    setActiveUniforms: function ( activeUniforms ) {\n        this._activeUniforms = activeUniforms;\n    },\n\n    getActiveUniforms: function () {\n        return this._activeUniforms;\n    },\n\n    setForeignUniforms: function ( foreignUniforms ) {\n        this._foreignUniforms = foreignUniforms;\n    },\n\n    getForeignUniforms: function () {\n        return this._foreignUniforms;\n    },\n\n    setUniformsCache: function ( uniformsCache ) {\n        this._uniformsCache = uniformsCache;\n    },\n\n    getUniformsCache: function () {\n        return this._uniformsCache;\n    },\n\n    setAttributesCache: function ( attributesCache ) {\n        this._attributesCache = attributesCache;\n    },\n\n    getAttributesCache: function () {\n        return this._attributesCache;\n    },\n\n    setTrackAttributes: function ( trackAttributes ) {\n        this._trackAttributes = trackAttributes;\n    },\n\n    getTrackAttributes: function () {\n        return this._trackAttributes;\n    },\n\n    releaseGLObjects: function () {\n        // Call to releaseGLOBjects on shaders\n        if ( this._vertex !== undefined ) this._vertex.releaseGLObjects();\n        if ( this._fragment !== undefined ) this._fragment.releaseGLObjects();\n        if ( this._program === null ) return;\n        if ( this._gl !== undefined ) {\n            Program.deleteGLProgram( this._gl, this._program );\n        }\n        this._program = undefined;\n    },\n\n    apply: function ( state ) {\n\n        if ( this._nullProgram ) return;\n\n        if ( !this._gl ) {\n            this.setGraphicContext( state.getGraphicContext() );\n        }\n        var gl = this._gl;\n        if ( !this._program || this._dirty ) {\n\n            var compileClean;\n\n            if ( !this._vertex.shader ) {\n                compileClean = this._vertex.compile( gl );\n            }\n\n            if ( !this._fragment.shader ) {\n                compileClean = this._fragment.compile( gl );\n            }\n\n            var attributeMap = getAttributeList( this._vertex.getText() );\n\n            if ( compileClean ) {\n\n                this._program = gl.createProgram();\n\n                if ( attributeMap.Vertex ) {\n                    // force Vertex to be on 0\n                    gl.bindAttribLocation( this._program, 0, 'Vertex' );\n                }\n\n                gl.attachShader( this._program, this._vertex.shader );\n                gl.attachShader( this._program, this._fragment.shader );\n                MACROUTILS.timeStamp( 'osgjs.metrics:linkShader' );\n                gl.linkProgram( this._program );\n\n                if ( !gl.getProgramParameter( this._program, gl.LINK_STATUS ) && !gl.isContextLost() ) {\n                    var errLink = gl.getProgramInfoLog( this._program );\n\n                    Notify.errorFold( errLink, 'can\\'t link program\\nvertex shader:\\n' + this._vertex.text + '\\n fragment shader:\\n' + this._fragment.text );\n\n                    // rawgl trick is for webgl inspector\n                    var debugShader = ( gl.rawgl !== undefined ? gl.rawgl : gl );\n                    if ( debugShader !== undefined && debugShader.getExtension !== undefined ) debugShader = debugShader.getExtension( 'WEBGL_debug_shaders' );\n                    if ( debugShader && errLink === 'Failed to create D3D shaders.\\n' ) {\n\n                        Notify.error( debugShader.getTranslatedShaderSource( this._vertex.shader ) );\n                        Notify.error( debugShader.getTranslatedShaderSource( this._fragment.shader ) );\n                    }\n\n                    compileClean = false;\n                }\n                // TODO: better usage of validate.\n                // as it's intended at shader program usage\n                // validating against current gl state\n                // Not for compilation stage\n                // gl.validateProgram( this._program );\n\n            }\n\n            if ( !compileClean ) {\n\n                // Any error, Any\n                // Pink must die.\n\n                var program = gl.createProgram();\n                this._vertex.failSafe( gl, this._vertex.getText() );\n                this._fragment.failSafe( gl, this._fragment.getText() );\n\n                gl.attachShader( program, this._vertex.shader );\n                gl.attachShader( program, this._fragment.shader );\n                gl.linkProgram( program );\n                gl.validateProgram( program );\n\n                Notify.warn( 'FailSafe shader Activated ' );\n                this._program = program;\n            }\n\n            this._uniformsCache = {};\n            this._attributesCache = {};\n\n            this.cacheUniformList( gl, this._vertex.text );\n            this.cacheUniformList( gl, this._fragment.text );\n\n            this.cacheAttributeList( gl, window.Object.keys( attributeMap ) );\n\n            this._dirty = false;\n        }\n\n        state.applyProgram( this._program );\n    },\n\n    cacheUniformList: function ( gl, str ) {\n\n        var r = str.match( /uniform\\s+\\w+\\s+\\w+((\\s)?\\[(.*?)\\])?/g );\n        var map = this._uniformsCache;\n        if ( r !== null ) {\n            for ( var i = 0, l = r.length; i < l; i++ ) {\n                var uniform = r[ i ].match( /uniform\\s+\\w+\\s+(\\w+)/ )[ 1 ];\n                var uniformName = r[ i ].match( /uniform\\s+\\w+\\s+(\\w+)(\\s?\\[.*?\\])?/ )[ 1 ];\n                var location = gl.getUniformLocation( this._program, uniform );\n                if ( location !== undefined && location !== null ) {\n                    if ( map[ uniformName ] === undefined ) {\n                        map[ uniformName ] = location;\n                    }\n                }\n            }\n        }\n\n    },\n\n    cacheAttributeList: function ( gl, attributeList ) {\n\n        var map = this._attributesCache;\n        for ( var i = 0, l = attributeList.length; i < l; i++ ) {\n\n            var attr = attributeList[ i ];\n            var location = gl.getAttribLocation( this._program, attr );\n\n            if ( location !== -1 && location !== undefined ) {\n                if ( map[ attr ] === undefined ) {\n                    map[ attr ] = location;\n                }\n            }\n        }\n\n    }\n} ) ), 'osg', 'Program' );\n\nmodule.exports = Program;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Program.js\n// module id = 103\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar shaderLib = require( 'osgShader/shaderLib' );\nvar shadowShaderLib = require( 'osgShadow/shaderLib' );\nvar WebglCaps = require( 'osg/WebGLCaps' );\n\n\n// webgl2 protected variable names : sample, texture\n\n//     Shader as vert/frag/glsl files Using requirejs text plugin\n//     Preprocess features like:    //\n//     - Handle (recursive) include, avoiding code repeat and help code factorization\n//     - Handle per shader and global define/precision\n\nvar ShaderProcessor = function ( createInstance ) {\n\n    if ( !createInstance ) {\n        if ( ShaderProcessor.instance ) {\n            return ShaderProcessor.instance;\n        }\n        ShaderProcessor.instance = this;\n    }\n\n    this.addShaders( shaderLib );\n    this.addShaders( shadowShaderLib );\n    return this;\n};\n\nShaderProcessor.prototype = {\n    _shadersText: {},\n    _shadersList: {},\n    _globalDefaultprecision: '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif',\n    _debugLines: false,\n    _includeR: /#pragma include \"([^\"]+)\"/g,\n    _includeCondR: /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g,\n    _defineR: /\\#define\\s+([a-zA-Z_0-9]+)/,\n    _precisionR: /precision\\s+(high|low|medium)p\\s+float/,\n\n    // {\n    //     'functions.glsl': textShaderFunctions,\n    //     'lights.glsl': textShaderFunctions,\n    //     'textures.glsl': textShaderFunctions\n    // };\n    addShaders: function ( shaders ) {\n\n        for ( var key in shaders ) {\n            this._shadersList[ key ] = key;\n            this._shadersText[ key ] = shaders[ key ];\n        }\n\n    },\n\n    instrumentShaderlines: function ( content, sourceID ) {\n        // TODO instrumentShaderlines\n        // http://immersedcode.org/2012/1/12/random-notes-on-webgl/\n        // one ID per \"file\"\n        // Each file has its line number starting at 0\n        //   handle include, the do that numbering also in preprocess...\n        // Then on shader error using sourceID and line you can point the correct line...\n        // has to attach that info to osg.shader object.\n        /*\n          var allLines = content.split('\\n');\n          var i = 0;\n          for (var k = 0; k _< allLines.length; k++) {\n          if (!this._includeR.test(allLines[k])) {\n          allLines[k] = \"#line \" + (i++) + \" \" + sourceID + '\\n' + allLines[k] ;\n          }\n          }\n          content = allLines.join('\\n');\n        */\n\n        // seems just  prefixing first line seems ok to help renumbering error mesg\n        return '\\n#line ' + 0 + ' ' + sourceID + '\\n' + content;\n    },\n\n    getShaderTextPure: function ( shaderName ) {\n\n        var preShader = this._shadersText[ shaderName ];\n\n        if ( !preShader ) {\n            Notify.error( 'shader file/text: ' + shaderName + ' not registered' );\n            preShader = '';\n        }\n\n        return preShader;\n    },\n\n    getShader: function ( shaderName, defines, extensions, type ) {\n        var shader = this.getShaderTextPure( shaderName );\n        return this.processShader( shader, defines, extensions, type );\n    },\n\n    // recursively  handle #include external glsl\n    // files (for now in the same folder.)\n    preprocess: function ( content, sourceID, includeList, inputsDefines /*, type */ ) {\n        var self = this;\n        return content.replace( this._includeCondR, function ( _, strMatch ) {\n            var includeOpt = strMatch.split( ' ' );\n            var includeName = includeOpt[ 0 ].replace( /\"/g, '' );\n\n            // pure include is\n            // \\#pragma include \"name\";\n\n            // conditionnal include is name included if _PCF defined\n            // \\#pragma include \"name\" \"_PCF\";\n            if ( includeOpt.length > 1 && inputsDefines ) {\n\n                // some conditions here.\n                // if not defined we do not include\n                var found = false;\n                var defines = inputsDefines.map( function ( defineString ) {\n                    // find '#define', remove duplicate whitespace, split on space and return the define Text\n                    return self._defineR.test( defineString ) && defineString.replace( /\\s+/g, ' ' ).split( ' ' )[ 1 ];\n                } );\n\n                for ( var i = 1; i < includeOpt.length && !found; i++ ) {\n                    var key = includeOpt[ i ].replace( /\"/g, '' );\n                    for ( var k = 0; k < defines.length && !found; k++ ) {\n\n                        if ( defines[ k ] !== false && defines[ k ] === key ) {\n                            found = true;\n                            break;\n                        }\n\n                    }\n                }\n                if ( !found )\n                    return '';\n            }\n\n            // already included\n            if ( includeList.indexOf( includeName ) !== -1 ) return '';\n            // avoid endless loop, not calling the impure\n            var txt = this.getShaderTextPure( includeName );\n            // make sure it's not included twice\n            includeList.push( includeName );\n            if ( this._debugLines ) {\n                txt = this.instrumentShaderlines( txt, sourceID );\n            }\n            sourceID++;\n            // to the infinite and beyond !\n            txt = this.preprocess( txt, sourceID, includeList, inputsDefines );\n            return txt;\n        }.bind( this ) );\n\n    },\n\n    _getSortedUnique: ( function () {\n\n        var filterDuplicate = function ( item, pos, self ) {\n            return !pos || item !== self[ pos - 1 ];\n        };\n\n        return function ( array ) {\n            return array && array.sort().filter( filterDuplicate );\n        };\n    } )(),\n\n    _convertExtensionsToWebGL2: ( function () {\n\n        var cbRenamer = function ( match, extension ) {\n            return 'core_' + extension;\n        };\n\n        var cbDefiner = function ( match, extension ) {\n            return '#define ' + extension;\n        };\n\n        var extensions = '(GL_EXT_shader_texture_lod|GL_OES_standard_derivatives|GL_EXT_draw_buffers|GL_EXT_frag_depth)';\n        var definer = new RegExp( '#\\\\s*extension\\\\s+' + extensions + '.*', 'g' );\n        var renamer = new RegExp( extensions, 'g' );\n\n        return function ( strShader ) {\n            strShader = strShader.replace( definer, cbDefiner ); // replace #extension by #define\n            strShader = strShader.replace( renamer, cbRenamer ); // rename extension\n            return strShader;\n        };\n    } )(),\n\n    _convertToWebGL2: ( function () {\n\n        var frags = [];\n        var replaceMRT = function ( match, number ) {\n            var varName = 'glFragData_' + number;\n            frags[ number ] = 'layout(location = ' + number + ') out vec4 ' + varName + ';';\n            return varName;\n        };\n\n        return function ( strShader, isFragment ) {\n            if ( !strShader ) return strShader;\n\n            strShader = strShader.replace( /attribute\\s+/g, 'in ' );\n            strShader = strShader.replace( /varying\\s+/g, isFragment ? 'in ' : 'out ' );\n            strShader = strShader.replace( /(texture2D|textureCube)\\s*\\(/g, 'texture(' );\n            strShader = strShader.replace( /(textureCubeLodEXT)\\s*\\(/g, 'textureLod(' );\n\n            strShader = this._convertExtensionsToWebGL2( strShader );\n\n            if ( isFragment ) {\n                frags.length = 0;\n                strShader = strShader.replace( /gl_FragData\\s*\\[\\s*(\\d+)\\s*\\]/g, replaceMRT );\n\n                if ( !frags.length ) frags.push( 'out vec4 glFragColor_0;' );\n                strShader = strShader.replace( /gl_FragColor/g, 'glFragColor_0' );\n                strShader = strShader.replace( /void\\s+main\\s*\\(/g, frags.join( '\\n' ) + '\\nvoid main(' );\n            }\n\n            return strShader;\n        };\n    } )(),\n\n    _hasVersion: function ( shader ) {\n        // match first line starting with #\n        var version = shader.match( /^#(.*)$/m );\n        return version && version[ 0 ].indexOf( 'version' ) !== -1;\n    },\n\n    // process shader\n    // - declare version, extensions, precision and defines\n    // - resolve pragma include\n    // - Convert webgl1 to webgl2 (glsl 100 to glsl 330 es)\n    processShader: function ( shader, defines, extensions, type ) {\n\n        // if the shader has #version statement we skip the shader processing\n        if ( this._hasVersion( shader ) ) {\n            return shader;\n        }\n\n        var includeList = [];\n        var preShader = shader;\n        var sourceID = 0;\n        if ( this._debugLines ) {\n            preShader = this.instrumentShaderlines( preShader, sourceID );\n            sourceID++;\n        }\n\n        // removes duplicates\n        defines = this._getSortedUnique( defines );\n        extensions = this._getSortedUnique( extensions );\n\n        var strCore = this.preprocess( preShader, sourceID, includeList, defines, type );\n\n        var isFragment = strCore.indexOf( 'gl_Position' ) === -1;\n        var convertToWebGL2 = WebglCaps.instance().isWebGL2();\n\n        var strVersion = convertToWebGL2 ? '#version 300 es' : '#version 100';\n        strVersion += '\\n';\n\n        var strExtensions = extensions ? extensions.join( '\\n' ) + '\\n' : '';\n\n        var strDefines = defines ? defines.join( '\\n' ) + '\\n' : '';\n\n        if ( convertToWebGL2 ) {\n            strExtensions = this._convertExtensionsToWebGL2( strExtensions );\n            strDefines = this._convertToWebGL2( strDefines, isFragment );\n            strCore = this._convertToWebGL2( strCore, isFragment );\n        }\n\n        // vertex shader uses highp per default BUT if FS is using mediump then VS should too (conflict with varying/uniform otherwise)\n        // also make sure precision is not already providen\n        var strPrecision = '';\n        if ( this._globalDefaultprecision && !this._precisionR.test( strCore ) ) {\n            strPrecision = this._globalDefaultprecision + '\\n';\n        }\n\n\n        // order is important\n        // See https://khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf (p14-15: extension before any non-processor token)\n        return strVersion + strExtensions + strPrecision + strDefines + strCore;\n    }\n};\nmodule.exports = ShaderProcessor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/ShaderProcessor.js\n// module id = 104\n// module chunks = 0 1 2","'use strict';\nvar functions = require( 'osgShader/node/functions.glsl' );\nvar lights = require( 'osgShader/node/lights.glsl' );\nvar skinning = require( 'osgShader/node/skinning.glsl' );\nvar textures = require( 'osgShader/node/textures.glsl' );\nvar colorEncode = require( 'osgShader/node/colorEncode.glsl' );\nvar noise = require( 'osgShader/node/noise.glsl' );\nvar billboard = require( 'osgShader/node/billboard.glsl' );\nmodule.exports = {\n    'functions.glsl': functions,\n    'lights.glsl': lights,\n    'skinning.glsl': skinning,\n    'textures.glsl': textures,\n    'colorEncode.glsl': colorEncode,\n    'noise.glsl': noise,\n    'billboard.glsl': billboard\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/shaderLib.js\n// module id = 105\n// module chunks = 0 1 2","module.exports = \"// the approximation :\\n// http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html\\n// introduced slightly darker colors and more slight banding in the darks.\\n// The reference implementation (or even a single pow approx) did not introduced these effects.\\n\\n// so for now we stick with the reference implementation :\\n// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt\\n// with the slight changes :\\n// - we always assume the color is >= 0.0 (so no check)\\n// - unlike the previous approximation, linear to srgb is monotonic so we don't need to check if the color is > 1\\n\\n#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055\\nfloat linearTosRGB(const in float c) {\\n    return LIN_SRGB(c);\\n}\\nvec3 linearTosRGB(const in vec3 c) {\\n    return vec3(LIN_SRGB(c.r), LIN_SRGB(c.g), LIN_SRGB(c.b));\\n}\\nvec4 linearTosRGB(const in vec4 c) {\\n    return vec4(LIN_SRGB(c.r), LIN_SRGB(c.g), LIN_SRGB(c.b), c.a);\\n}\\n\\n#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)\\nfloat sRGBToLinear(const in float c) {\\n    return SRGB_LIN(c);\\n}\\nvec3 sRGBToLinear(const in vec3 c) {\\n    return vec3(SRGB_LIN(c.r), SRGB_LIN(c.g), SRGB_LIN(c.b));\\n}\\nvec4 sRGBToLinear(const in vec4 c) {\\n    return vec4(SRGB_LIN(c.r), SRGB_LIN(c.g), SRGB_LIN(c.b), c.a);\\n}\\n\\n//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\\nvec3 RGBMToRGB( const in vec4 rgba ) {\\n    const float maxRange = 8.0;\\n    return rgba.rgb * maxRange * rgba.a;\\n}\\n\\nconst mat3 LUVInverse = mat3( 6.0013,    -2.700,   -1.7995,\\n                              -1.332,    3.1029,   -5.7720,\\n                              0.3007,    -1.088,    5.6268 );\\n\\nvec3 LUVToRGB( const in vec4 vLogLuv ) {\\n    float Le = vLogLuv.z * 255.0 + vLogLuv.w;\\n    vec3 Xp_Y_XYZp;\\n    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\\n    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\\n    vec3 vRGB = LUVInverse * Xp_Y_XYZp;\\n    return max(vRGB, 0.0);\\n}\\n\\n// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\\nvec4 encodeRGBM(const in vec3 col, const in float range) {\\n    if(range <= 0.0)\\n        return vec4(col, 1.0);\\n    vec4 rgbm;\\n    vec3 color = col / range;\\n    rgbm.a = clamp( max( max( color.r, color.g ), max( color.b, 1e-6 ) ), 0.0, 1.0 );\\n    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;\\n    rgbm.rgb = color / rgbm.a;\\n    return rgbm;\\n}\\n\\nvec3 decodeRGBM(const in vec4 col, const in float range) {\\n    if(range <= 0.0)\\n        return col.rgb;\\n    return range * col.rgb * col.a;\\n}\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/functions.glsl\n// module id = 106\n// module chunks = 0 1 2","module.exports = \"////////////////\\n// ATTENUATION\\n/////////////\\nfloat getLightAttenuation(const in float dist, const in vec4 lightAttenuation) {\\n    // lightAttenuation(constantEnabled, linearEnabled, quadraticEnabled)\\n    // TODO find a vector alu instead of 4 scalar\\n    float constant = lightAttenuation.x;\\n    float linear = lightAttenuation.y*dist;\\n    float quadratic = lightAttenuation.z*dist*dist;\\n    return 1.0 / ( constant + linear + quadratic );\\n}\\n//\\n// LIGHTING EQUATION TERMS\\n///\\nvoid specularCookTorrance(const in vec3 n, const in vec3 l, const in vec3 v, const in float hard, const in vec3 materialSpecular, const in vec3 lightSpecular, out vec3 specularContrib) {\\n    vec3 h = normalize(v + l);\\n    float nh = dot(n, h);\\n    float specfac = 0.0;\\n\\n    if(nh > 0.0) {\\n        float nv = max( dot(n, v), 0.0 );\\n        float i = pow(nh, hard);\\n        i = i / (0.1 + nv);\\n        specfac = i;\\n    }\\n    // ugly way to fake an energy conservation (mainly to avoid super bright stuffs with low glossiness)\\n    float att = hard > 100.0 ? 1.0 : smoothstep(0.0, 1.0, hard * 0.01);\\n    specularContrib = specfac*materialSpecular*lightSpecular*att;\\n}\\n\\nvoid lambert(const in float ndl,  const in vec3 materialDiffuse, const in vec3 lightDiffuse, out vec3 diffuseContrib) {\\n    diffuseContrib = ndl*materialDiffuse*lightDiffuse;\\n}\\n////////////////////////\\n/// Main func\\n///////////////////////\\n\\n/// for each light\\n//direction, dist, NDL, attenuation, compute diffuse, compute specular\\n\\nvec3 computeSpotLightShading(\\n    const in vec3 normal,\\n    const in vec3 eyeVector,\\n\\n    const in vec3 materialAmbient,\\n    const in vec3 materialDiffuse,\\n    const in vec3 materialSpecular,\\n    const in float materialShininess,\\n\\n    const in vec3 lightAmbient,\\n    const in vec3 lightDiffuse,\\n    const in vec3 lightSpecular,\\n\\n    const in vec3  lightSpotDirection,\\n    const in vec4  lightAttenuation,\\n    const in vec4  lightSpotPosition,\\n    const in float lightCosSpotCutoff,\\n    const in float lightSpotBlend,\\n\\n    const in mat4 lightMatrix,\\n    const in mat4 lightInvMatrix,\\n\\n    out vec3 eyeLightPos,\\n    out vec3 eyeLightDir,\\n    out bool lighted) {\\n    lighted = false;\\n    eyeLightPos = vec3(lightMatrix * lightSpotPosition);\\n    eyeLightDir = eyeLightPos - vViewVertex.xyz;\\n    // compute dist\\n    float dist = length(eyeLightDir);\\n    // compute attenuation\\n    float attenuation = getLightAttenuation(dist, lightAttenuation);\\n    if (attenuation != 0.0) {\\n        // compute direction\\n        eyeLightDir = dist > 0.0 ? eyeLightDir / dist :  vec3( 0.0, 1.0, 0.0 );\\n        if (lightCosSpotCutoff > 0.0) {\\n            //compute lightSpotBlend\\n            vec3 lightSpotDirectionEye = normalize(mat3(vec3(lightInvMatrix[0]), vec3(lightInvMatrix[1]), vec3(lightInvMatrix[2]))*lightSpotDirection);\\n\\n            float cosCurAngle = dot(-eyeLightDir, lightSpotDirectionEye);\\n            float diffAngle = cosCurAngle - lightCosSpotCutoff;\\n            float spot = 1.0;\\n            if ( diffAngle < 0.0 ) {\\n                spot = 0.0;\\n            } else {\\n                if ( lightSpotBlend > 0.0 )\\n                    spot = cosCurAngle * smoothstep(0.0, 1.0, (cosCurAngle - lightCosSpotCutoff) / (lightSpotBlend));\\n            }\\n\\n            if (spot > 0.0) {\\n                // compute NdL\\n                float NdotL = dot(eyeLightDir, normal);\\n                if (NdotL > 0.0) {\\n                    lighted = true;\\n                    vec3 diffuseContrib;\\n                    lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\\n                    vec3 specularContrib;\\n                    specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\\n                    return spot * attenuation * (diffuseContrib + specularContrib);\\n                }\\n            }\\n        }\\n    }\\n    return vec3(0.0);\\n}\\n\\nvec3 computePointLightShading(\\n    const in vec3 normal,\\n    const in vec3 eyeVector,\\n\\n    const in vec3 materialAmbient,\\n    const in vec3 materialDiffuse,\\n    const in vec3 materialSpecular,\\n    const in float materialShininess,\\n\\n    const in vec3 lightAmbient,\\n    const in vec3 lightDiffuse,\\n    const in vec3 lightSpecular,\\n\\n    const in vec4 lightPosition,\\n    const in vec4 lightAttenuation,\\n\\n    const in mat4 lightMatrix,\\n\\n    out vec3 eyeLightPos,\\n    out vec3 eyeLightDir,\\n    out bool lighted) {\\n\\n    eyeLightPos =  vec3(lightMatrix * lightPosition);\\n    eyeLightDir = eyeLightPos - vViewVertex.xyz;\\n    float dist = length(eyeLightDir);\\n    // compute dist\\n    // compute attenuation\\n    float attenuation = getLightAttenuation(dist, lightAttenuation);\\n    if (attenuation != 0.0) {\\n        // compute direction\\n        eyeLightDir = dist > 0.0 ? eyeLightDir / dist :  vec3( 0.0, 1.0, 0.0 );\\n        // compute NdL\\n        float NdotL = dot(eyeLightDir, normal);\\n        if (NdotL > 0.0) {\\n            lighted = true;\\n            vec3 diffuseContrib;\\n            lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\\n            vec3 specularContrib;\\n            specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\\n            return attenuation * (diffuseContrib + specularContrib);\\n        }\\n    }\\n    return vec3(0.0);\\n}\\n\\nvec3 computeSunLightShading(\\n\\n    const in vec3 normal,\\n    const in vec3 eyeVector,\\n\\n    const in vec3 materialAmbient,\\n    const in vec3 materialDiffuse,\\n    const in vec3 materialSpecular,\\n    const in float materialShininess,\\n\\n    const in vec3 lightAmbient,\\n    const in vec3 lightDiffuse,\\n    const in vec3 lightSpecular,\\n\\n    const in vec4 lightPosition,\\n\\n    const in mat4 lightMatrix,\\n\\n    out vec3 eyeLightDir,\\n    out bool lighted) {\\n\\n    lighted = false;\\n    eyeLightDir = normalize( vec3(lightMatrix * lightPosition ) );\\n    // compute NdL   // compute NdL\\n    float NdotL = dot(eyeLightDir, normal);\\n    if (NdotL > 0.0) {\\n        lighted = true;\\n        vec3 diffuseContrib;\\n        lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\\n        vec3 specularContrib;\\n        specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\\n        return (diffuseContrib + specularContrib);\\n    }\\n    return vec3(0.0);\\n}\\n\\nvec3 computeHemiLightShading(\\n\\n    const in vec3 normal,\\n    const in vec3 eyeVector,\\n\\n    const in vec3 materialDiffuse,\\n    const in vec3 materialSpecular,\\n    const in float materialShininess,\\n\\n    const in vec3 lightDiffuse,\\n    const in vec3 lightGround,\\n\\n    const in vec4 lightPosition,\\n\\n    const in mat4 lightMatrix,\\n\\n    out vec3 eyeLightDir,\\n    out bool lighted) {\\n\\n    lighted = false;\\n\\n    eyeLightDir = normalize( vec3(lightMatrix * lightPosition ) );\\n    float NdotL = dot(eyeLightDir, normal);\\n    float weight = 0.5 * NdotL + 0.5;\\n    vec3 diffuseContrib = materialDiffuse * mix(lightGround, lightDiffuse, weight);\\n\\n    // same cook-torrance as above for sky/ground\\n    float skyWeight = 0.5 * dot(normal, normalize(eyeVector + eyeLightDir)) + 0.5;\\n    float gndWeight = 0.5 * dot(normal, normalize(eyeVector - eyeLightDir)) + 0.5;\\n    float skySpec = pow(skyWeight, materialShininess);\\n    float skyGround = pow(gndWeight, materialShininess);\\n    float divisor = (0.1 + max( dot(normal, eyeVector), 0.0 ));\\n    float att = materialShininess > 100.0 ? 1.0 : smoothstep(0.0, 1.0, materialShininess * 0.01);\\n    vec3 specularContrib = lightDiffuse * materialSpecular * weight * att * (skySpec + skyGround) / divisor;\\n\\n    return diffuseContrib + specularContrib;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/lights.glsl\n// module id = 107\n// module chunks = 0 1 2","module.exports = \"//////////////////////////////\\n// OPTIMIZED VERSION (NO IF)\\n//////////////////////////////\\nmat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\\n    mat4 outMat_1;\\n    mat4 tmpMat_2;\\n    highp ivec4 tmpvar_3;\\n    tmpvar_3 = (3 * ivec4(bonesIdx));\\n    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\\n    vec4 tmpvar_4;\\n    tmpvar_4 = -(abs(weightsVec));\\n    tmpMat_2[0] = uBones[tmpvar_3.x];\\n    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];\\n    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];\\n    outMat_1 = ((float(\\n    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))\\n    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weightsVec.x * tmpMat_2));\\n    tmpMat_2[0] = uBones[tmpvar_3.y];\\n    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];\\n    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];\\n    outMat_1 = (outMat_1 + (weightsVec.y * tmpMat_2));\\n    tmpMat_2[0] = uBones[tmpvar_3.z];\\n    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];\\n    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];\\n    outMat_1 = (outMat_1 + (weightsVec.z * tmpMat_2));\\n    tmpMat_2[0] = uBones[tmpvar_3.w];\\n    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];\\n    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];\\n    outMat_1 = (outMat_1 + (weightsVec.w * tmpMat_2));\\n\\n    return outMat_1;\\n}\\n\\n//////////////////////////////\\n// UN-OPTIMIZED VERSION (WITH IF)\\n//////////////////////////////\\n\\n// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html\\n// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {\\n//     // We have to use a global variable because we can't access dynamically\\n//     // matrix is transpose so we should do vec * matrix\\n//     myMat[0] = uBones[ index ];\\n//     myMat[1] = uBones[ index + 1];\\n//     myMat[2] = uBones[ index + 2];\\n//     return myMat;\\n// }\\n\\n// mat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\\n//     ivec4 idx =  3 * ivec4(bonesIdx);\\n//     mat4 tmpMat = mat4(1.0);\\n//     mat4 outMat = mat4(0.0);\\n\\n//     // we handle negative weights\\n//     if(all(equal(weightsVec, vec4(0.0)))) return tmpMat;\\n\\n//     if(weightsVec.x != 0.0) outMat += weightsVec.x * getMat4FromVec4( idx.x, tmpMat );\\n//     if(weightsVec.y != 0.0) outMat += weightsVec.y * getMat4FromVec4( idx.y, tmpMat );\\n//     if(weightsVec.z != 0.0) outMat += weightsVec.z * getMat4FromVec4( idx.z, tmpMat );\\n//     if(weightsVec.w != 0.0) outMat += weightsVec.w * getMat4FromVec4( idx.w, tmpMat );\\n//     return outMat;\\n// }\\n\\n//////////////////////////////\\n// UN-OPTIMIZED VERSION (NO IF)\\n//////////////////////////////\\n\\n// mat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\\n//     ivec4 idx =  3 * ivec4(bonesIdx);\\n//     mat4 tmpMat = mat4(1.0);\\n\\n//     // if sum is 0, return identity\\n//     vec4 absWeights = -abs(weightsVec);\\n//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;\\n\\n//     // we handle negative weights\\n//     // outMat[3][3] += weightsVec.x + weightsVec.y + weightsVec.z + weightsVec.w;\\n\\n//     tmpMat[0] = uBones[ idx.x ];\\n//     tmpMat[1] = uBones[ idx.x + 1];\\n//     tmpMat[2] = uBones[ idx.x + 2];\\n//     outMat += weightsVec.x * tmpMat;\\n\\n//     tmpMat[0] = uBones[ idx.y ];\\n//     tmpMat[1] = uBones[ idx.y + 1];\\n//     tmpMat[2] = uBones[ idx.y + 2];\\n//     outMat += weightsVec.y * tmpMat;\\n\\n//     tmpMat[0] = uBones[ idx.z ];\\n//     tmpMat[1] = uBones[ idx.z + 1];\\n//     tmpMat[2] = uBones[ idx.z + 2];\\n//     outMat += weightsVec.z * tmpMat;\\n\\n//     tmpMat[0] = uBones[ idx.w ];\\n//     tmpMat[1] = uBones[ idx.w + 1];\\n//     tmpMat[2] = uBones[ idx.w + 2];\\n//     outMat += weightsVec.w * tmpMat;\\n\\n//     return outMat;\\n// }\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/skinning.glsl\n// module id = 108\n// module chunks = 0 1 2","module.exports = \"vec3 textureRGB(const in sampler2D tex, const in vec2 uv) {\\n    return texture2D(tex, uv.xy ).rgb;\\n}\\n\\nvec4 textureRGBA(const in sampler2D tex, const in vec2 uv) {\\n    return texture2D(tex, uv.xy ).rgba;\\n}\\n\\nfloat textureIntensity(const in sampler2D tex, const in vec2 uv) {\\n    return texture2D(tex, uv).r;\\n}\\n\\nfloat textureAlpha(const in sampler2D tex, const in vec2 uv) {\\n    return texture2D(tex, uv.xy ).a;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/textures.glsl\n// module id = 109\n// module chunks = 0 1 2","module.exports = \"\\nfloat decodeFloatRGBA( vec4 rgba ) {\\n    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );\\n}\\n\\nvec4 encodeFloatRGBA( float v ) {\\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;\\n    enc = fract(enc);\\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\n    return enc;\\n}\\n\\nvec2 decodeHalfFloatRGBA( vec4 rgba ) {\\n    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));\\n}\\n\\nvec4 encodeHalfFloatRGBA( vec2 v ) {\\n    const vec2 bias = vec2(1.0 / 255.0, 0.0);\\n    vec4 enc;\\n    enc.xy = vec2(v.x, fract(v.x * 255.0));\\n    enc.xy = enc.xy - (enc.yy * bias);\\n\\n    enc.zw = vec2(v.y, fract(v.y * 255.0));\\n    enc.zw = enc.zw - (enc.ww * bias);\\n    return enc;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/colorEncode.glsl\n// module id = 110\n// module chunks = 0 1 2","module.exports = \"#pragma include \\\"hash.glsl\\\"\\n\\n//// noise glsl\\n\\n// Based on Morgan McGuire @morgan3d\\n// https://www.shadertoy.com/view/4dS3Wd\\nfloat noise2D(const in vec2 x) {\\n    vec2 i = floor(x);\\n    vec2 f = fract(x);\\n\\n    // Four corners in 2D of a tile\\n    float a = hash21(i);\\n    float b = hash21(i + vec2(1.0, 0.0));\\n    float c = hash21(i + vec2(0.0, 1.0));\\n    float d = hash21(i + vec2(1.0, 1.0));\\n\\n    vec2 u = f * f * (3.0 - 2.0 * f);\\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\\n}\\n\\n//// end noise glsl\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/noise.glsl\n// module id = 111\n// module chunks = 0 1 2","module.exports = \"vec3 getScale( const in mat4 matrix ) {\\n      // Only working with positive scales.\\n      float xs = matrix[0][0] * matrix[0][1] * matrix[0][2] * matrix[0][3] < 0. ? -1. : 1.;\\n      float ys = matrix[1][0] * matrix[1][1] * matrix[1][2] * matrix[1][3] < 0. ? -1. : 1.;\\n      float zs = matrix[2][0] * matrix[2][1] * matrix[2][2] * matrix[2][3] < 0. ? -1. : 1.;\\n      vec3 scale;\\n      scale.x = xs * sqrt( matrix[0][0] * matrix[0][0] + matrix[0][1] * matrix[0][1] + matrix[0][2] * matrix[0][2]);\\n      scale.y = ys * sqrt( matrix[1][0] * matrix[1][0] + matrix[1][1] * matrix[1][1] + matrix[1][2] * matrix[1][2]);\\n      scale.z = zs * sqrt( matrix[2][0] * matrix[2][0] + matrix[2][1] * matrix[2][1] + matrix[2][2] * matrix[2][2]);\\n      return scale;\\n}\\n\\nvec4 billboard( const in vec3 vertex, const in mat4 modelViewMatrix, const in mat4 projectionMatrix ) {\\n      vec3 scale = getScale( modelViewMatrix );\\n      return projectionMatrix * ( vec4( scale.x* vertex.x , scale.y * vertex.y, scale.z * vertex.z, 1.0 ) + vec4( modelViewMatrix[ 3 ].xyz, 0.0 ) );\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/billboard.glsl\n// module id = 112\n// module chunks = 0 1 2","'use strict';\nvar shadowsCastFrag = require( 'osgShadow/shaders/shadowsCastFrag.glsl' );\nvar shadowsReceive = require( 'osgShadow/shaders/shadowsReceive.glsl' );\nvar shadowsReceiveMain = require( 'osgShadow/shaders/shadowsReceiveMain.glsl' );\nvar shadowLinearSoft = require( 'osgShadow/shaders/shadowLinearSoft.glsl' );\nvar pcf = require( 'osgShadow/shaders/pcf.glsl' );\nvar tapPCF = require( 'osgShadow/shaders/tapPCF.glsl' );\nvar hash = require( 'osgShadow/shaders/hash.glsl' );\n\nmodule.exports = {\n    'shadowsCastFrag.glsl': shadowsCastFrag,\n    'shadowsReceive.glsl': shadowsReceive,\n    'shadowsReceiveMain.glsl': shadowsReceiveMain,\n    'shadowLinearSoft.glsl': shadowLinearSoft,\n    'pcf.glsl': pcf,\n    'tapPCF.glsl': tapPCF,\n    'hash.glsl': hash\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaderLib.js\n// module id = 113\n// module chunks = 0 1 2","module.exports = \"\\n#pragma include \\\"colorEncode.glsl\\\"\\n\\n\\nvec4 computeShadowDepth(const in vec4 fragEye,\\n                        const in vec4 shadowRange){\\n    // distance to camera\\n    float depth =  -fragEye.z * fragEye.w;\\n    // most precision near 0, make sure we are near 0 and in  [0,1]\\n    depth = (depth - shadowRange.x ) * shadowRange.w;\\n\\n    vec4 outputFrag;\\n\\n#if defined (_FLOATTEX) \\n    outputFrag = vec4(depth, 0.0, 0.0, 1.0);\\n#else\\n    outputFrag = encodeFloatRGBA(depth);\\n#endif\\n\\n    return outputFrag;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/shadowsCastFrag.glsl\n// module id = 114\n// module chunks = 0 1 2","module.exports = \"//begin shadows\\n\\n#pragma include \\\"colorEncode.glsl\\\"\\n\\n// end Float codec\\nfloat getSingleFloatFromTex(const in sampler2D depths, const in vec2 uv){\\n#ifndef _FLOATTEX\\n    return  decodeFloatRGBA(texture2D(depths, uv));\\n#else\\n    return texture2D(depths, uv).x;\\n#endif\\n}\\n\\nvec2 getDoubleFloatFromTex(const in sampler2D depths, const in vec2 uv){\\n#ifndef _FLOATTEX\\n    return decodeHalfFloatRGBA(texture2D(depths, uv));\\n#else\\n    return texture2D(depths, uv).xy;\\n#endif\\n}\\n\\nvec4 getQuadFloatFromTex(const in sampler2D depths, const in vec2 uv){\\n    return texture2D(depths, uv).xyzw;\\n}\\n// end Float codec\\n\\n#pragma include \\\"pcf.glsl\\\" \"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/shadowsReceive.glsl\n// module id = 115\n// module chunks = 0 1 2","module.exports = \"// 0 for early out\\nbool earlyOut = false;\\n\\n// Calculate shadow amount\\nfloat shadow = 1.0;\\n\\nif(!lighted) {\\n    shadow = 0.0;\\n    earlyOut = true;\\n}\\n\\nif (depthRange.x == depthRange.y) {\\n    earlyOut = true;\\n}\\n\\nvec4 shadowVertexEye;\\nvec4 shadowNormalEye;\\nfloat shadowReceiverZ = 0.0;\\nvec4 shadowVertexProjected;\\nvec2 shadowUV;\\nfloat N_Dot_L;\\n\\nif(!earlyOut) {\\n\\n    shadowVertexEye =  shadowViewMatrix *  vec4(vertexWorld, 1.0);\\n\\n    vec3 shadowLightDir = vec3(0.0, 0.0, 1.0); // in shadow view light is camera\\n    vec4 normalFront = vec4(normalWorld, 0.0);\\n    shadowNormalEye =  shadowViewMatrix * normalFront;\\n    N_Dot_L = dot(shadowNormalEye.xyz, shadowLightDir);\\n\\n    if(!earlyOut) {\\n\\n#ifdef _NORMAL_OFFSET\\n\\n        // http://www.dissidentlogic.com/old/images/NormalOffsetShadows/GDC_Poster_NormalOffset.png\\n        float normalOffsetScale = clamp(1.0  - N_Dot_L, 0.0 , 1.0);\\n\\n        normalOffsetScale *= abs((shadowVertexEye.z - depthRange.x) * depthRange.w) * max(shadowProjectionMatrix[0][0], shadowProjectionMatrix[1][1]);\\n\\n        normalOffsetScale *= normalBias*depthRange.w;\\n\\n        shadowNormalEye =  shadowViewMatrix *  (normalFront * normalOffsetScale);\\n\\n        shadowVertexProjected = shadowProjectionMatrix * (shadowVertexEye + shadowNormalEye);\\n\\n#else\\n\\n        shadowVertexProjected = shadowProjectionMatrix * shadowVertexEye;\\n\\n#endif\\n\\n        if (shadowVertexProjected.w < 0.0) {\\n            earlyOut = true; // notably behind camera\\n        }\\n\\n    }\\n\\n\\n\\n\\n    if(!earlyOut) {\\n\\n        shadowUV.xy = shadowVertexProjected.xy / shadowVertexProjected.w;\\n        shadowUV.xy = shadowUV.xy * 0.5 + 0.5;// mad like\\n\\n        if(any(bvec4 ( shadowUV.x > 1., shadowUV.x < 0., shadowUV.y > 1., shadowUV.y < 0.))) {\\n            earlyOut = true;// limits of light frustum\\n        }\\n\\n        // most precision near 0, make sure we are near 0 and in [0,1]\\n        shadowReceiverZ = - shadowVertexEye.z;\\n        shadowReceiverZ =  (shadowReceiverZ - depthRange.x)* depthRange.w;\\n\\n        if(shadowReceiverZ < 0.0) {\\n            earlyOut = true; // notably behind camera\\n        }\\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n// pcf pbias to add on offset\\nvec2 shadowBiasPCF = vec2 (0.);\\n\\n#ifdef GL_OES_standard_derivatives\\n\\n\\n//#define _RECEIVERPLANEDEPTHBIAS\\n#ifdef _RECEIVERPLANEDEPTHBIAS\\nvec2 biasUV;\\n\\nvec3 texCoordDY = dFdx(shadowVertexEye.xyz);\\nvec3 texCoordDX = dFdy(shadowVertexEye.xyz);\\n\\nbiasUV.x = texCoordDY.y * texCoordDX.z - texCoordDX.y * texCoordDY.z;\\nbiasUV.y = texCoordDX.x * texCoordDY.z - texCoordDY.x * texCoordDX.z;\\nbiasUV *= 1.0 / ((texCoordDX.x * texCoordDY.y) - (texCoordDX.y * texCoordDY.x));\\n\\n// Static depth biasing to make up for incorrect fractional sampling on the shadow map grid\\nfloat fractionalSamplingError = dot(vec2(1.0, 1.0) * shadowTextureSize.zw, abs(biasUV));\\nfloat receiverDepthBias = min(fractionalSamplingError, 0.01);\\n\\nshadowBiasPCF.x = biasUV.x;\\nshadowBiasPCF.y = biasUV.y;\\n\\n\\nshadowReceiverZ += receiverDepthBias;\\n\\n#else\\n\\nshadowBiasPCF.x = clamp(dFdx(shadowReceiverZ)* shadowTextureSize.z, -1.0, 1.0 );\\nshadowBiasPCF.y = clamp(dFdy(shadowReceiverZ)* shadowTextureSize.w, -1.0, 1.0 );\\n\\n#endif\\n#endif\\n\\n\\nvec4 clampDimension;\\n\\n#ifdef _ATLAS_SHADOW\\n\\nshadowUV.xy  = ((shadowUV.xy * shadowMapSize.zw ) + shadowMapSize.xy) / shadowTextureSize.xy;\\n\\n// clamp uv bias/filters by half pixel to avoid point filter on border\\nclampDimension.xy = shadowMapSize.xy + vec2(0.5);\\nclampDimension.zw = (shadowMapSize.xy + shadowMapSize.zw) - vec2(0.5);\\n\\nclampDimension = clampDimension / (shadowTextureSize.xyxy);\\n\\n\\n#else\\n\\nclampDimension = vec4(0.0, 0.0, 1.0, 1.0);\\n\\n#endif\\n\\n\\n// now that derivatives is done\\n// and we don't access any mipmapped/texgrad texture\\n// we can early out\\n// see http://teknicool.tumblr.com/post/77263472964/glsl-dynamic-branching-and-texture-samplers\\nif (earlyOut) {\\n    // empty statement because of weird gpu intel bug\\n} else {\\n\\n\\n// depth bias: fighting shadow acne (depth imprecsion z-fighting)\\nfloat shadowBias = 0.0;\\n\\n\\n\\n\\n// cosTheta is dot( n, l ), clamped between 0 and 1\\n//float shadowBias = 0.005*tan(acos(N_Dot_L));\\n// same but 4 cycles instead of 15\\nshadowBias += 0.05 *  sqrt( 1. -  N_Dot_L*N_Dot_L) / clamp(N_Dot_L, 0.0005,  1.0);\\n\\n//That makes sure that plane perpendicular to light doesn't flicker due to\\n//selfshadowing and 1 = dot(Normal, Light) using a min bias\\nshadowBias = clamp(shadowBias, 0.00005,  2.0*bias);\\n\\n// shadowZ must be clamped to [0,1]\\n// otherwise it's not comparable to\\n// shadow caster depth map\\n// which is clamped to [0,1]\\n// Not doing that makes ALL shadowReceiver > 1.0 black\\n// because they ALL becomes behind any point in Caster depth map\\nshadowReceiverZ = clamp(shadowReceiverZ, 0., 1. - shadowBias);\\n\\nshadowReceiverZ -= shadowBias;\\n\\n// Now computes Shadow\\n\\nshadow = getShadowPCF(tex, shadowTextureSize, shadowUV, shadowReceiverZ, shadowBiasPCF, clampDimension);\\n\\n}\\n\\nreturn shadow;\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/shadowsReceiveMain.glsl\n// module id = 116\n// module chunks = 0 1 2","module.exports = \"\\n// simulation of texture2Dshadow glsl call on HW\\n// http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/\\nfloat texture2DCompare(const in sampler2D depths, const in vec2 uv, const in float compare, const in vec4 clampDimension){\\n\\n    float depth = getSingleFloatFromTex(depths, clamp(uv, clampDimension.xy, clampDimension.zw));\\n    return step(compare, depth);\\n\\n}\\n\\n// simulates linear fetch like texture2d shadow\\nfloat texture2DShadowLerp(const in sampler2D depths, const in vec4 size, const in vec2 uv, const in float compare, const in vec4 clampDimension){\\n\\n    vec2 f = fract(uv*size.xy+0.5);\\n    vec2 centroidUV = floor(uv*size.xy+0.5)*size.zw;\\n\\n    float lb = texture2DCompare(depths, centroidUV+size.zw*vec2(0.0, 0.0), compare, clampDimension);\\n    float lt = texture2DCompare(depths, centroidUV+size.zw*vec2(0.0, 1.0), compare, clampDimension);\\n    float rb = texture2DCompare(depths, centroidUV+size.zw*vec2(1.0, 0.0), compare, clampDimension);\\n    float rt = texture2DCompare(depths, centroidUV+size.zw*vec2(1.0, 1.0), compare, clampDimension);\\n    float a = mix(lb, lt, f.y);\\n    float b = mix(rb, rt, f.y);\\n    float c = mix(a, b, f.x);\\n    return c;\\n\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/shadowLinearSoft.glsl\n// module id = 117\n// module chunks = 0 1 2","module.exports = \"\\n#pragma include \\\"tapPCF.glsl\\\"\\n\\n#ifdef _ATLAS_SHADOW\\n\\nfloat computeShadow(const in bool lighted,\\n                    const in sampler2D tex,\\n                    const in vec4 shadowMapSize,\\n                    const in vec4 shadowTextureSize,\\n                    const in mat4 shadowProjectionMatrix,\\n                    const in mat4 shadowViewMatrix,\\n                    const in vec4 depthRange,\\n                    const in vec3 normalWorld,\\n                    const in vec3 vertexWorld,                    \\n                    const in float bias\\n#ifdef _NORMAL_OFFSET\\n                    ,const in float normalBias\\n#endif //_NORMAL_OFFSET\\n                    \\n    )\\n#else\\n    \\nfloat computeShadow(const in bool lighted,\\n                    const in sampler2D tex,\\n                    const in vec4 shadowTextureSize,\\n                    const in mat4 shadowProjectionMatrix,\\n                    const in mat4 shadowViewMatrix,\\n                    const in vec4 depthRange,\\n                    const in vec3 normalWorld,\\n                    const in vec3 vertexWorld,\\n                    const in float bias\\n#ifdef _NORMAL_OFFSET\\n                    ,const in float normalBias\\n#endif //_NORMAL_OFFSET\\n\\n   )\\n    \\n#endif\\n{\\n                        \\n    #pragma include \\\"shadowsReceiveMain.glsl\\\"\\n\\n}\\n\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/pcf.glsl\n// module id = 118\n// module chunks = 0 1 2","module.exports = \"\\n#pragma include \\\"shadowLinearSoft.glsl\\\"\\n\\nfloat getShadowPCF(const in sampler2D depths, const in vec4 size, const in vec2 uv, const in float compare, const in vec2 biasPCF, const in vec4 clampDimension)\\n{\\n\\n     float res = 0.0;\\n     res += texture2DShadowLerp(depths, size,   uv + biasPCF, compare, clampDimension);\\n\\n#if defined(_PCFx1)\\n\\n#else\\n\\n    float dx0 = -size.z;\\n    float dy0 = -size.w;\\n    float dx1 = size.z;\\n    float dy1 = size.w;\\n\\n#define TSF(o1,o2) texture2DShadowLerp(depths, size, uv + vec2(o1, o2) + biasPCF,  compare, clampDimension)\\n\\n    res += TSF(dx0, dx0);\\n    res += TSF(dx0, .0);\\n    res += TSF(dx0, dx1);\\n\\n#if defined(_PCFx4)\\n\\n    res /=4.0;\\n\\n#elif defined(_PCFx9)\\n    res += TSF(.0, dx0);\\n    res += TSF(.0, dx1);\\n\\n    res += TSF(dx1, dx0);\\n    res += TSF(dx1, .0);\\n    res += TSF(dx1, dx1);\\n\\n\\n    res /=9.0;\\n\\n#elif defined(_PCFx25)\\n\\n    float dx02 = -2.0*size.z;\\n    float dy02 = -2.0*size.w;\\n    float dx2 = 2.0*size.z;\\n    float dy2 = 2.0*size.w;\\n\\n    // complete row above\\n    res += TSF(dx0, dx02);\\n    res += TSF(dx0, dx2);\\n\\n    res += TSF(.0, dx02);\\n    res += TSF(.0, dx2);\\n\\n    res += TSF(dx1, dx02);\\n    res += TSF(dx1, dx2);\\n\\n    // two new col\\n    res += TSF(dx02, dx02);\\n    res += TSF(dx02, dx0);\\n    res += TSF(dx02, .0);\\n    res += TSF(dx02, dx1);\\n    res += TSF(dx02, dx2);\\n\\n    res += TSF(dx2, dx02);\\n    res += TSF(dx2, dx0);\\n    res += TSF(dx2, .0);\\n    res += TSF(dx2, dx1);\\n    res += TSF(dx2, dx2);\\n\\n\\n    res/=25.0;\\n\\n#endif\\n\\n#undef TSF\\n\\n#endif\\n    return res;\\n}\\n/////// end Tap\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/tapPCF.glsl\n// module id = 119\n// module chunks = 0 1 2","module.exports = \"//// hash glsl\\n\\n// Dave Hoskins: hash without sin\\n//https://www.shadertoy.com/view/4djSRW\\n#define MOD2 vec2(443.8975,397.2973)\\n//----------------------------------------------------------------------------------------\\n//  1 out, 1 in...\\n//note: normalized uniform random, [0;1[\\nfloat hash11(const in float p)\\n{\\n    vec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n    return fract(p2.x * p2.y);\\n}\\n//note: normalized uniform random, [0;1[\\n//  2 out, 1 in...\\nfloat hash21(const in vec2 p)\\n{\\n    vec2 p2 = fract(p * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n    return fract(p2.x * p2.y);\\n}\\n\\n\\n// Based on Morgan McGuire @morgan3d\\n// https://www.shadertoy.com/view/4dS3Wd\\n// using Sin\\n//  1 out, 1 in...\\nfloat hashSin11( const in float n )\\n{\\n    return fract(sin(n)*43758.5453);\\n}\\n\\n//note: normalized uniform random, [0;1[\\n//  2 out, 1 in...\\nfloat hashSin21( const in vec2 n ) {\\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\\n}\\n\\n// note: [-1;1]\\n// iq: https://www.shadertoy.com/view/Xsl3Dl\\n// note: value noise\\n//  2 out, 2 in...\\nvec2 hashSin22( const in vec2 n )\\n{\\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* vec2(43758.5453,35458.5734));\\n}\\n//  3 out, 3 in...\\nvec3 hashSin33( in vec3 p )\\n{\\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\\n              dot(p,vec3(269.5,183.3,246.1)),\\n              dot(p,vec3(113.5,271.9,124.6)));\\n    return fract(sin(p)*43758.5453123);\\n}\\n\\n// Returns a random number based on a vec3 and an int.\\nfloat hashSin41(const in vec4 seed){\\n    return fract(sin(dot(seed, vec4(12.9898,78.233,45.164,94.673)) * 43758.5453));\\n}\\n\\n/////// end hash\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/shaders/hash.glsl\n// module id = 120\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Timer = require( 'osg/Timer' );\nvar GLObject = require( 'osg/GLObject' );\n\n\n/**\n * Shader manage shader for vertex and fragment, you need both to create a glsl program.\n * @class Shader\n */\nvar Shader = function ( type, text ) {\n    GLObject.call( this );\n    var t = type;\n    if ( typeof ( type ) === 'string' ) {\n        t = Shader[ type ];\n    }\n    this.type = t;\n    this.setText( text );\n};\n\nShader.VERTEX_SHADER = 0x8B31;\nShader.FRAGMENT_SHADER = 0x8B30;\n\n// Debug Pink shader for when shader fails\nvar debugName = '\\n#define SHADER_NAME FailSafe';\nShader.VS_DBG = '#define _DEBUG 1\\n#ifdef _DEBUG\\nattribute vec3 Vertex;uniform mat4 uModelViewMatrix;uniform mat4 uProjectionMatrix;void main(void) {  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex, 1.0);}\\n';\nShader.FS_DBG = '#define _DEBUG 1\\n#ifdef _DEBUG\\n precision lowp float; void main(void) { gl_FragColor = vec4(1.0, 0.6, 0.6, 1.0);}\\n';\n\n\n\n// static cache of glShaders flagged for deletion, which will actually\n// be deleted in the correct GL context.\nShader._sDeletedGLShaderCache = new window.Map();\n\n// static method to delete Program\nShader.deleteGLShader = function ( gl, shader ) {\n    if ( !Shader._sDeletedGLShaderCache.has( gl ) )\n        Shader._sDeletedGLShaderCache.set( gl, [] );\n    Shader._sDeletedGLShaderCache.get( gl ).push( shader );\n};\n\n// static method to flush all the cached glShaders which need to be deleted in the GL context specified\nShader.flushDeletedGLShaders = function ( gl, availableTime ) {\n    // if no time available don't try to flush objects.\n    if ( availableTime <= 0.0 ) return availableTime;\n    if ( !Shader._sDeletedGLShaderCache.has( gl ) ) return availableTime;\n    var elapsedTime = 0.0;\n    var beginTime = Timer.instance().tick();\n    var deleteList = Shader._sDeletedGLShaderCache.get( gl );\n    var numShaders = deleteList.length;\n    for ( var i = numShaders - 1; i >= 0 && elapsedTime < availableTime; i-- ) {\n        gl.deleteShader( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n    }\n    return availableTime - elapsedTime;\n};\n\nShader.flushAllDeletedGLShaders = function ( gl ) {\n    if ( !Shader._sDeletedGLShaderCache.has( gl ) ) return;\n    var deleteList = Shader._sDeletedGLShaderCache.get( gl );\n    var numShaders = deleteList.length;\n    for ( var i = numShaders - 1; i >= 0; i-- ) {\n        gl.deleteShader( deleteList[ i ] );\n        deleteList.splice( i, 1 );\n    }\n    return;\n};\n\n/** @lends Shader.prototype */\nShader.prototype = MACROUTILS.objectInherit( GLObject.prototype, {\n    setText: function ( text ) {\n        this.text = text;\n    },\n    getText: function () {\n        return this.text;\n    },\n    // this is where it creates a fail safe shader that should work everywhere\n    failSafe: function ( gl, shaderText ) {\n\n        this.shader = gl.createShader( this.type );\n\n        // concat failsafe and broken shader under separate _DEBUG defines blocks\n        var name = shaderText.match( /#define[\\s]+SHADER_NAME[\\s]+([\\S]+)(\\n|$)/ );\n        if ( name ) name = name ? name[ 1 ] : '';\n        var debugShaderTxt = ( this.type === Shader.VERTEX_SHADER ? Shader.VS_DBG : Shader.FS_DBG );\n        debugShaderTxt += debugName + name + '\\n#else\\n' + shaderText + '\\n#endif\\n';\n        gl.shaderSource( this.shader, debugShaderTxt );\n        gl.compileShader( this.shader );\n    },\n    // webgl shader compiler error to source contextualization\n    // for better console log messages\n    processErrors: function ( errors, source ) {\n        // regex to extract error message and line from webgl compiler reporting\n        var r = /ERROR: [\\d]+:([\\d]+): (.+)/gmi;\n        // split sources in indexable per line array\n        var lines = source.split( '\\n' );\n        var linesLength = lines.length;\n        if ( linesLength === 0 ) return;\n\n        var i, m;\n\n        // IE reporting is not the same\n        if ( r.exec( errors ) === null ) {\n            r = /Shader compilation errors\\n\\((\\d+)\\, \\d+\\): (.+)/gmi;\n        }\n\n        // we dont understand error try to print it instead of nothing\n        if ( r.exec( errors ) === null ) {\n            Notify.error( errors );\n            return;\n        }\n\n        // reset index to start.\n        r.lastIndex = 0;\n\n        while ( ( m = r.exec( errors ) ) !== null ) {\n            if ( m.index === r.lastIndex ) {\n                // moving between errors\n                r.lastIndex++;\n            }\n            // get error line\n            var line = parseInt( m[ 1 ], 10 );\n\n            if ( line > linesLength ) continue;\n            // webgl error report.\n            Notify.error( 'ERROR ' + m[ 2 ] + ' in line ' + line );\n\n            var minLine = Math.max( 0, line - 7 );\n            var maxLine = Math.max( 0, line - 2 );\n            // for context\n            // log surrounding line priori to error with bof check\n            for ( i = minLine; i <= maxLine; i++ ) {\n                Notify.warn( lines[ i ].replace( /^[ \\t]+/g, '' ) );\n            }\n\n            // Warn adds a lovely /!\\ icon in front of the culprit line\n            maxLine = Math.max( 0, line - 1 );\n            Notify.error( lines[ maxLine ].replace( /^[ \\t]+/g, '' ) );\n\n            minLine = Math.min( linesLength, line );\n            maxLine = Math.min( linesLength, line + 5 );\n            // for context\n            // surrounding line posterior to error (with eof check)\n            for ( i = minLine; i < maxLine; i++ ) {\n                Notify.warn( lines[ i ].replace( /^[ \\t]+/g, '' ) );\n            }\n        }\n    },\n\n    compile: function ( gl ) {\n        if ( !this._gl ) this.setGraphicContext( gl );\n        this.shader = gl.createShader( this.type );\n\n        var shaderText = this.text;\n        if ( Shader.enableGLSLOptimizer && Shader.glslOptimizer ) {\n            var shaderTypeString = this.type === Shader.VERTEX_SHADER ? 'vertex' : 'fragment';\n            Notify.infoFold( shaderTypeString + ' shader before optimization', shaderText );\n            // 1: opengl\n            // 2: opengl es 2.0\n            // 3: opengl es 3.0\n            var optimized = Shader.glslOptimizer( shaderText, '2', this.type === Shader.VERTEX_SHADER );\n            if ( optimized.indexOf( 'Error:' ) !== -1 ) {\n                Notify.error( optimized );\n            } else if ( optimized.length <= 1 ) {\n                Notify.warnFold( 'glsl optimizer returned an empty shader, the original will be used', shaderText );\n            } else {\n                Notify.infoFold( shaderTypeString + ' shader after optimization', optimized );\n                shaderText = optimized;\n            }\n        }\n\n        gl.shaderSource( this.shader, shaderText );\n        MACROUTILS.timeStamp( 'osgjs.metrics:compileShader' );\n        gl.compileShader( this.shader );\n        if ( !gl.getShaderParameter( this.shader, gl.COMPILE_STATUS ) && !gl.isContextLost() ) {\n\n            var err = gl.getShaderInfoLog( this.shader );\n            this.processErrors( err, shaderText );\n\n            var tmpText = shaderText;\n            var splittedText = tmpText.split( '\\n' );\n            var newText = '\\n';\n            for ( var i = 0, l = splittedText.length; i < l; ++i ) {\n                newText += i + ' ' + splittedText[ i ] + '\\n';\n            }\n            // still logging whole source but folded\n            Notify.errorFold( 'can\\'t compile shader', newText );\n\n            return false;\n        }\n        return true;\n    },\n    releaseGLObjects: function () {\n        if ( this._gl !== undefined ) {\n            Shader.deleteGLShader( this._gl, this.shader );\n        }\n        this.shader = undefined;\n    }\n} );\n\nmodule.exports = Shader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Shader.js\n// module id = 121\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar BufferArray = require( 'osg/BufferArray' );\nvar Geometry = require( 'osg/Geometry' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n\n/**\n * Create a Textured Box on the given center with given size\n * @name createTexturedBox\n */\nvar createTexturedBoxGeometry = function ( cx, cy, cz,\n    sx, sy, sz ) {\n\n    var centerx = cx !== undefined ? cx : 0.0;\n    var centery = cy !== undefined ? cy : 0.0;\n    var centerz = cz !== undefined ? cz : 0.0;\n\n    var sizex = sx !== undefined ? sx : 1.0;\n    var sizey = sy !== undefined ? sy : 1.0;\n    var sizez = sz !== undefined ? sz : 1.0;\n\n    var g = new Geometry();\n    var dx, dy, dz;\n    dx = sizex / 2.0;\n    dy = sizey / 2.0;\n    dz = sizez / 2.0;\n\n    var vertexes = new MACROUTILS.Float32Array( 72 );\n    var uv = new MACROUTILS.Float32Array( 48 );\n    var normal = new MACROUTILS.Float32Array( 72 );\n\n    // -ve y plane\n    vertexes[ 0 ] = centerx - dx;\n    vertexes[ 1 ] = centery - dy;\n    vertexes[ 2 ] = centerz + dz;\n    normal[ 0 ] = 0.0;\n    normal[ 1 ] = -1.0;\n    normal[ 2 ] = 0.0;\n    uv[ 0 ] = 0.0;\n    uv[ 1 ] = 1.0;\n\n    vertexes[ 3 ] = centerx - dx;\n    vertexes[ 4 ] = centery - dy;\n    vertexes[ 5 ] = centerz - dz;\n    normal[ 3 ] = 0.0;\n    normal[ 4 ] = -1.0;\n    normal[ 5 ] = 0.0;\n    uv[ 2 ] = 0.0;\n    uv[ 3 ] = 0.0;\n\n    vertexes[ 6 ] = centerx + dx;\n    vertexes[ 7 ] = centery - dy;\n    vertexes[ 8 ] = centerz - dz;\n    normal[ 6 ] = 0.0;\n    normal[ 7 ] = -1.0;\n    normal[ 8 ] = 0.0;\n    uv[ 4 ] = 1.0;\n    uv[ 5 ] = 0.0;\n\n    vertexes[ 9 ] = centerx + dx;\n    vertexes[ 10 ] = centery - dy;\n    vertexes[ 11 ] = centerz + dz;\n    normal[ 9 ] = 0.0;\n    normal[ 10 ] = -1.0;\n    normal[ 11 ] = 0.0;\n    uv[ 6 ] = 1.0;\n    uv[ 7 ] = 1.0;\n\n\n    // +ve y plane\n    vertexes[ 12 ] = centerx + dx;\n    vertexes[ 13 ] = centery + dy;\n    vertexes[ 14 ] = centerz + dz;\n    normal[ 12 ] = 0.0;\n    normal[ 13 ] = 1.0;\n    normal[ 14 ] = 0.0;\n    uv[ 8 ] = 0.0;\n    uv[ 9 ] = 1.0;\n\n    vertexes[ 15 ] = centerx + dx;\n    vertexes[ 16 ] = centery + dy;\n    vertexes[ 17 ] = centerz - dz;\n    normal[ 15 ] = 0.0;\n    normal[ 16 ] = 1.0;\n    normal[ 17 ] = 0.0;\n    uv[ 10 ] = 0.0;\n    uv[ 11 ] = 0.0;\n\n    vertexes[ 18 ] = centerx - dx;\n    vertexes[ 19 ] = centery + dy;\n    vertexes[ 20 ] = centerz - dz;\n    normal[ 18 ] = 0.0;\n    normal[ 19 ] = 1.0;\n    normal[ 20 ] = 0.0;\n    uv[ 12 ] = 1.0;\n    uv[ 13 ] = 0.0;\n\n    vertexes[ 21 ] = centerx - dx;\n    vertexes[ 22 ] = centery + dy;\n    vertexes[ 23 ] = centerz + dz;\n    normal[ 21 ] = 0.0;\n    normal[ 22 ] = 1.0;\n    normal[ 23 ] = 0.0;\n    uv[ 14 ] = 1.0;\n    uv[ 15 ] = 1.0;\n\n\n    // +ve x plane\n    vertexes[ 24 ] = centerx + dx;\n    vertexes[ 25 ] = centery - dy;\n    vertexes[ 26 ] = centerz + dz;\n    normal[ 24 ] = 1.0;\n    normal[ 25 ] = 0.0;\n    normal[ 26 ] = 0.0;\n    uv[ 16 ] = 0.0;\n    uv[ 17 ] = 1.0;\n\n    vertexes[ 27 ] = centerx + dx;\n    vertexes[ 28 ] = centery - dy;\n    vertexes[ 29 ] = centerz - dz;\n    normal[ 27 ] = 1.0;\n    normal[ 28 ] = 0.0;\n    normal[ 29 ] = 0.0;\n    uv[ 18 ] = 0.0;\n    uv[ 19 ] = 0.0;\n\n    vertexes[ 30 ] = centerx + dx;\n    vertexes[ 31 ] = centery + dy;\n    vertexes[ 32 ] = centerz - dz;\n    normal[ 30 ] = 1.0;\n    normal[ 31 ] = 0.0;\n    normal[ 32 ] = 0.0;\n    uv[ 20 ] = 1.0;\n    uv[ 21 ] = 0.0;\n\n    vertexes[ 33 ] = centerx + dx;\n    vertexes[ 34 ] = centery + dy;\n    vertexes[ 35 ] = centerz + dz;\n    normal[ 33 ] = 1.0;\n    normal[ 34 ] = 0.0;\n    normal[ 35 ] = 0.0;\n    uv[ 22 ] = 1.0;\n    uv[ 23 ] = 1.0;\n\n    // -ve x plane\n    vertexes[ 36 ] = centerx - dx;\n    vertexes[ 37 ] = centery + dy;\n    vertexes[ 38 ] = centerz + dz;\n    normal[ 36 ] = -1.0;\n    normal[ 37 ] = 0.0;\n    normal[ 38 ] = 0.0;\n    uv[ 24 ] = 0.0;\n    uv[ 25 ] = 1.0;\n\n    vertexes[ 39 ] = centerx - dx;\n    vertexes[ 40 ] = centery + dy;\n    vertexes[ 41 ] = centerz - dz;\n    normal[ 39 ] = -1.0;\n    normal[ 40 ] = 0.0;\n    normal[ 41 ] = 0.0;\n    uv[ 26 ] = 0.0;\n    uv[ 27 ] = 0.0;\n\n    vertexes[ 42 ] = centerx - dx;\n    vertexes[ 43 ] = centery - dy;\n    vertexes[ 44 ] = centerz - dz;\n    normal[ 42 ] = -1.0;\n    normal[ 43 ] = 0.0;\n    normal[ 44 ] = 0.0;\n    uv[ 28 ] = 1.0;\n    uv[ 29 ] = 0.0;\n\n    vertexes[ 45 ] = centerx - dx;\n    vertexes[ 46 ] = centery - dy;\n    vertexes[ 47 ] = centerz + dz;\n    normal[ 45 ] = -1.0;\n    normal[ 46 ] = 0.0;\n    normal[ 47 ] = 0.0;\n    uv[ 30 ] = 1.0;\n    uv[ 31 ] = 1.0;\n\n    // top\n    // +ve z plane\n    vertexes[ 48 ] = centerx - dx;\n    vertexes[ 49 ] = centery + dy;\n    vertexes[ 50 ] = centerz + dz;\n    normal[ 48 ] = 0.0;\n    normal[ 49 ] = 0.0;\n    normal[ 50 ] = 1.0;\n    uv[ 32 ] = 0.0;\n    uv[ 33 ] = 1.0;\n\n    vertexes[ 51 ] = centerx - dx;\n    vertexes[ 52 ] = centery - dy;\n    vertexes[ 53 ] = centerz + dz;\n    normal[ 51 ] = 0.0;\n    normal[ 52 ] = 0.0;\n    normal[ 53 ] = 1.0;\n    uv[ 34 ] = 0.0;\n    uv[ 35 ] = 0.0;\n\n    vertexes[ 54 ] = centerx + dx;\n    vertexes[ 55 ] = centery - dy;\n    vertexes[ 56 ] = centerz + dz;\n    normal[ 54 ] = 0.0;\n    normal[ 55 ] = 0.0;\n    normal[ 56 ] = 1.0;\n    uv[ 36 ] = 1.0;\n    uv[ 37 ] = 0.0;\n\n    vertexes[ 57 ] = centerx + dx;\n    vertexes[ 58 ] = centery + dy;\n    vertexes[ 59 ] = centerz + dz;\n    normal[ 57 ] = 0.0;\n    normal[ 58 ] = 0.0;\n    normal[ 59 ] = 1.0;\n    uv[ 38 ] = 1.0;\n    uv[ 39 ] = 1.0;\n\n    // bottom\n    // -ve z plane\n    vertexes[ 60 ] = centerx + dx;\n    vertexes[ 61 ] = centery + dy;\n    vertexes[ 62 ] = centerz - dz;\n    normal[ 60 ] = 0.0;\n    normal[ 61 ] = 0.0;\n    normal[ 62 ] = -1.0;\n    uv[ 40 ] = 0.0;\n    uv[ 41 ] = 1.0;\n\n    vertexes[ 63 ] = centerx + dx;\n    vertexes[ 64 ] = centery - dy;\n    vertexes[ 65 ] = centerz - dz;\n    normal[ 63 ] = 0.0;\n    normal[ 64 ] = 0.0;\n    normal[ 65 ] = -1.0;\n    uv[ 42 ] = 0.0;\n    uv[ 43 ] = 0.0;\n\n    vertexes[ 66 ] = centerx - dx;\n    vertexes[ 67 ] = centery - dy;\n    vertexes[ 68 ] = centerz - dz;\n    normal[ 66 ] = 0.0;\n    normal[ 67 ] = 0.0;\n    normal[ 68 ] = -1.0;\n    uv[ 44 ] = 1.0;\n    uv[ 45 ] = 0.0;\n\n    vertexes[ 69 ] = centerx - dx;\n    vertexes[ 70 ] = centery + dy;\n    vertexes[ 71 ] = centerz - dz;\n    normal[ 69 ] = 0.0;\n    normal[ 70 ] = 0.0;\n    normal[ 71 ] = -1.0;\n    uv[ 46 ] = 1.0;\n    uv[ 47 ] = 1.0;\n\n    var indexes = new MACROUTILS.Uint16Array( 36 );\n    indexes[ 0 ] = 0;\n    indexes[ 1 ] = 1;\n    indexes[ 2 ] = 2;\n    indexes[ 3 ] = 0;\n    indexes[ 4 ] = 2;\n    indexes[ 5 ] = 3;\n\n    indexes[ 6 ] = 4;\n    indexes[ 7 ] = 5;\n    indexes[ 8 ] = 6;\n    indexes[ 9 ] = 4;\n    indexes[ 10 ] = 6;\n    indexes[ 11 ] = 7;\n\n    indexes[ 12 ] = 8;\n    indexes[ 13 ] = 9;\n    indexes[ 14 ] = 10;\n    indexes[ 15 ] = 8;\n    indexes[ 16 ] = 10;\n    indexes[ 17 ] = 11;\n\n    indexes[ 18 ] = 12;\n    indexes[ 19 ] = 13;\n    indexes[ 20 ] = 14;\n    indexes[ 21 ] = 12;\n    indexes[ 22 ] = 14;\n    indexes[ 23 ] = 15;\n\n    indexes[ 24 ] = 16;\n    indexes[ 25 ] = 17;\n    indexes[ 26 ] = 18;\n    indexes[ 27 ] = 16;\n    indexes[ 28 ] = 18;\n    indexes[ 29 ] = 19;\n\n    indexes[ 30 ] = 20;\n    indexes[ 31 ] = 21;\n    indexes[ 32 ] = 22;\n    indexes[ 33 ] = 20;\n    indexes[ 34 ] = 22;\n    indexes[ 35 ] = 23;\n\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\n    g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );\n    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uv, 2 );\n\n    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );\n    g.getPrimitives().push( primitive );\n    return g;\n};\n\n// better perf\n// no more pixel shader hurt for nothing\n// http://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/\n// It's a Singleton, as it's rendering invariant\n// so same remove uneeded state change when same geom\nvar createTexturedFullScreenFakeQuadGeometry = ( function () {\n    var g = new Geometry();\n\n    var uvs = new MACROUTILS.Float32Array( [ -1.0, -1.0, -1.0, 4.0, 4.0, -1.0 ] );\n    var vertexes = new MACROUTILS.Float32Array( [ -1.0, -1.0, -1.0, 4.0, 4.0, -1.0 ] );\n\n    var indexes = new MACROUTILS.Uint16Array( 3 );\n    indexes[ 0 ] = 2;\n    indexes[ 1 ] = 1;\n    indexes[ 2 ] = 0;\n\n    // Further optim: no index, no uv (uv.xy = position.xy in vertex shader)\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 2 );\n    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uvs, 2 );\n\n    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );\n    g.getPrimitives().push( primitive );\n\n    return function () {\n        return g;\n    };\n} )();\n\n\nvar createTexturedQuadGeometry = function ( cornerx, cornery, cornerz,\n    wx, wy, wz,\n    hx, hy, hz,\n    l, b, r, t ) {\n\n    if ( r === undefined && t === undefined ) {\n        r = l;\n        t = b;\n        l = 0.0;\n        b = 0.0;\n    }\n\n    var g = new Geometry();\n\n    var vertexes = new MACROUTILS.Float32Array( 12 );\n    vertexes[ 0 ] = cornerx + hx;\n    vertexes[ 1 ] = cornery + hy;\n    vertexes[ 2 ] = cornerz + hz;\n\n    vertexes[ 3 ] = cornerx;\n    vertexes[ 4 ] = cornery;\n    vertexes[ 5 ] = cornerz;\n\n    vertexes[ 6 ] = cornerx + wx;\n    vertexes[ 7 ] = cornery + wy;\n    vertexes[ 8 ] = cornerz + wz;\n\n    vertexes[ 9 ] = cornerx + wx + hx;\n    vertexes[ 10 ] = cornery + wy + hy;\n    vertexes[ 11 ] = cornerz + wz + hz;\n\n    if ( r === undefined ) {\n        r = 1.0;\n    }\n    if ( t === undefined ) {\n        t = 1.0;\n    }\n\n    var uvs = new MACROUTILS.Float32Array( 8 );\n    uvs[ 0 ] = l;\n    uvs[ 1 ] = t;\n\n    uvs[ 2 ] = l;\n    uvs[ 3 ] = b;\n\n    uvs[ 4 ] = r;\n    uvs[ 5 ] = b;\n\n    uvs[ 6 ] = r;\n    uvs[ 7 ] = t;\n\n    var n = vec3.fromValues( wx, wy, wz );\n    vec3.cross( n, n, vec3.fromValues( hx, hy, hz ) );\n    vec3.normalize( n, n );\n\n    var normal = new MACROUTILS.Float32Array( 12 );\n    normal[ 0 ] = n[ 0 ];\n    normal[ 1 ] = n[ 1 ];\n    normal[ 2 ] = n[ 2 ];\n\n    normal[ 3 ] = n[ 0 ];\n    normal[ 4 ] = n[ 1 ];\n    normal[ 5 ] = n[ 2 ];\n\n    normal[ 6 ] = n[ 0 ];\n    normal[ 7 ] = n[ 1 ];\n    normal[ 8 ] = n[ 2 ];\n\n    normal[ 9 ] = n[ 0 ];\n    normal[ 10 ] = n[ 1 ];\n    normal[ 11 ] = n[ 2 ];\n\n\n    var indexes = new MACROUTILS.Uint16Array( 6 );\n    indexes[ 0 ] = 0;\n    indexes[ 1 ] = 1;\n    indexes[ 2 ] = 2;\n    indexes[ 3 ] = 0;\n    indexes[ 4 ] = 2;\n    indexes[ 5 ] = 3;\n\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\n    g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );\n    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uvs, 2 );\n\n    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );\n    g.getPrimitives().push( primitive );\n    return g;\n};\n\nvar createAxisGeometry = function ( size ) {\n    if ( size === undefined ) {\n        size = 1.0;\n    }\n    if ( createAxisGeometry.getShader === undefined ) {\n        createAxisGeometry.getShader = function () {\n            if ( createAxisGeometry.getShader.program === undefined ) {\n                var vertexshader = [\n                    '#ifdef GL_ES',\n                    'precision highp float;',\n                    '#endif',\n                    'attribute vec3 Vertex;',\n                    'attribute vec4 Color;',\n                    'uniform mat4 uModelViewMatrix;',\n                    'uniform mat4 uProjectionMatrix;',\n                    '',\n                    'varying vec4 vColor;',\n                    '',\n                    'void main(void) {',\n                    '  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(Vertex, 1.0));',\n                    '  vColor = Color;',\n                    '}'\n                ].join( '\\n' );\n\n                var fragmentshader = [\n                    '#ifdef GL_ES',\n                    'precision highp float;',\n                    '#endif',\n                    'varying vec4 vColor;',\n\n                    'void main(void) {',\n                    'gl_FragColor = vColor;',\n                    '}'\n                ].join( '\\n' );\n\n                var program = new Program( new Shader( 'VERTEX_SHADER', vertexshader ),\n                    new Shader( 'FRAGMENT_SHADER', fragmentshader ) );\n                createAxisGeometry.getShader.program = program;\n            }\n            return createAxisGeometry.getShader.program;\n        };\n    }\n\n    var g = new Geometry();\n\n    var vertexes = new MACROUTILS.Float32Array( 18 );\n    vertexes[ 3 ] = size;\n    vertexes[ 10 ] = size;\n    vertexes[ 17 ] = size;\n\n    var colors = new MACROUTILS.Float32Array( 24 );\n    //red color\n    colors[ 0 ] = colors[ 3 ] = 1.0;\n    colors[ 4 ] = colors[ 4 + 3 ] = 1.0;\n    //green color\n    colors[ 4 * 2 + 1 ] = colors[ 4 * 2 + 3 ] = 1.0;\n    colors[ 4 * 3 + 1 ] = colors[ 4 * 3 + 3 ] = 1.0;\n    //blue color\n    colors[ 4 * 4 + 2 ] = colors[ 4 * 4 + 3 ] = 1.0;\n    colors[ 4 * 5 + 2 ] = colors[ 4 * 5 + 3 ] = 1.0;\n\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\n    g.getAttributes().Color = new BufferArray( BufferArray.ARRAY_BUFFER, colors, 4 );\n\n    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 6 );\n    g.getPrimitives().push( primitive );\n    g.getOrCreateStateSet().setAttributeAndModes( createAxisGeometry.getShader() );\n\n    return g;\n};\n\n/**\n * Create a Textured Sphere on the given center with given radius\n * @name createTexturedSphere\n * @author Darrell Esau\n */\nvar createTexturedSphere = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n    radius = radius || 1.0;\n\n    phiStart = phiStart !== undefined ? phiStart : 0.0;\n    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n    var segmentsX = Math.max( 3, Math.floor( widthSegments ) || 8 );\n    var segmentsY = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n    var useDrawArrays = ( ( segmentsX * segmentsY ) / 3 ) >= 65536;\n    var nbPrim = useDrawArrays ? segmentsX * segmentsY * 6 : segmentsX * segmentsY * 4;\n    var fullVerticesList = new MACROUTILS.Float32Array( nbPrim * 3 );\n    var fullNormalsList = new MACROUTILS.Float32Array( nbPrim * 3 );\n    var fullUVList = new MACROUTILS.Float32Array( nbPrim * 2 );\n    var indexes = !useDrawArrays ? new MACROUTILS.Uint16Array( segmentsX * segmentsY * 6 ) : undefined;\n    var vtxCount = 0;\n    var triCount = 0;\n\n    var v1 = new MACROUTILS.Float32Array( 3 );\n    var v2 = new MACROUTILS.Float32Array( 3 );\n    var v3 = new MACROUTILS.Float32Array( 3 );\n    var v4 = new MACROUTILS.Float32Array( 3 );\n    var n1 = new MACROUTILS.Float32Array( 3 );\n    var n2 = new MACROUTILS.Float32Array( 3 );\n    var n3 = new MACROUTILS.Float32Array( 3 );\n    var n4 = new MACROUTILS.Float32Array( 3 );\n    var uv1 = new MACROUTILS.Float32Array( 2 );\n    var uv2 = new MACROUTILS.Float32Array( 2 );\n    var uv3 = new MACROUTILS.Float32Array( 2 );\n    var uv4 = new MACROUTILS.Float32Array( 2 );\n    var getCoordAndUvSphere = function ( u, v, coord, norm, uv ) {\n        coord[ 0 ] = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n        coord[ 1 ] = radius * Math.cos( thetaStart + v * thetaLength );\n        coord[ 2 ] = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n        vec3.normalize( norm, coord );\n        uv[ 0 ] = u;\n        uv[ 1 ] = 1 - v;\n    };\n    for ( var y = 0; y < segmentsY; y++ ) {\n        for ( var x = 0; x < segmentsX; x++ ) {\n            getCoordAndUvSphere( ( x + 1 ) / segmentsX, y / segmentsY, v1, n1, uv1 );\n            getCoordAndUvSphere( x / segmentsX, y / segmentsY, v2, n2, uv2 );\n            getCoordAndUvSphere( x / segmentsX, ( y + 1 ) / segmentsY, v3, n3, uv3 );\n            getCoordAndUvSphere( ( x + 1 ) / segmentsX, ( y + 1 ) / segmentsY, v4, n4, uv4 );\n\n            var idv = vtxCount * 3;\n            fullVerticesList[ idv ] = v1[ 0 ];\n            fullVerticesList[ idv + 1 ] = v1[ 1 ];\n            fullVerticesList[ idv + 2 ] = v1[ 2 ];\n            fullVerticesList[ idv + 3 ] = v2[ 0 ];\n            fullVerticesList[ idv + 4 ] = v2[ 1 ];\n            fullVerticesList[ idv + 5 ] = v2[ 2 ];\n            fullVerticesList[ idv + 6 ] = v3[ 0 ];\n            fullVerticesList[ idv + 7 ] = v3[ 1 ];\n            fullVerticesList[ idv + 8 ] = v3[ 2 ];\n\n            fullNormalsList[ idv ] = n1[ 0 ];\n            fullNormalsList[ idv + 1 ] = n1[ 1 ];\n            fullNormalsList[ idv + 2 ] = n1[ 2 ];\n            fullNormalsList[ idv + 3 ] = n2[ 0 ];\n            fullNormalsList[ idv + 4 ] = n2[ 1 ];\n            fullNormalsList[ idv + 5 ] = n2[ 2 ];\n            fullNormalsList[ idv + 6 ] = n3[ 0 ];\n            fullNormalsList[ idv + 7 ] = n3[ 1 ];\n            fullNormalsList[ idv + 8 ] = n3[ 2 ];\n\n            var idu = vtxCount * 2;\n            fullUVList[ idu ] = uv1[ 0 ];\n            fullUVList[ idu + 1 ] = uv1[ 1 ];\n            fullUVList[ idu + 2 ] = uv2[ 0 ];\n            fullUVList[ idu + 3 ] = uv2[ 1 ];\n            fullUVList[ idu + 4 ] = uv3[ 0 ];\n            fullUVList[ idu + 5 ] = uv3[ 1 ];\n\n            vtxCount += 3;\n            if ( useDrawArrays ) {\n                idv = vtxCount * 3;\n                fullVerticesList[ idv ] = v1[ 0 ];\n                fullVerticesList[ idv + 1 ] = v1[ 1 ];\n                fullVerticesList[ idv + 2 ] = v1[ 2 ];\n                fullVerticesList[ idv + 3 ] = v3[ 0 ];\n                fullVerticesList[ idv + 4 ] = v3[ 1 ];\n                fullVerticesList[ idv + 5 ] = v3[ 2 ];\n                fullVerticesList[ idv + 6 ] = v4[ 0 ];\n                fullVerticesList[ idv + 7 ] = v4[ 1 ];\n                fullVerticesList[ idv + 8 ] = v4[ 2 ];\n\n                fullNormalsList[ idv ] = n1[ 0 ];\n                fullNormalsList[ idv + 1 ] = n1[ 1 ];\n                fullNormalsList[ idv + 2 ] = n1[ 2 ];\n                fullNormalsList[ idv + 3 ] = n3[ 0 ];\n                fullNormalsList[ idv + 4 ] = n3[ 1 ];\n                fullNormalsList[ idv + 5 ] = n3[ 2 ];\n                fullNormalsList[ idv + 6 ] = n4[ 0 ];\n                fullNormalsList[ idv + 7 ] = n4[ 1 ];\n                fullNormalsList[ idv + 8 ] = n4[ 2 ];\n\n                idu = vtxCount * 2;\n                fullUVList[ idu ] = uv1[ 0 ];\n                fullUVList[ idu + 1 ] = uv1[ 1 ];\n                fullUVList[ idu + 2 ] = uv3[ 0 ];\n                fullUVList[ idu + 3 ] = uv3[ 1 ];\n                fullUVList[ idu + 4 ] = uv4[ 0 ];\n                fullUVList[ idu + 5 ] = uv4[ 1 ];\n                vtxCount += 3;\n            } else {\n                idv = vtxCount * 3;\n                fullVerticesList[ idv ] = v4[ 0 ];\n                fullVerticesList[ idv + 1 ] = v4[ 1 ];\n                fullVerticesList[ idv + 2 ] = v4[ 2 ];\n\n                fullNormalsList[ idv ] = n4[ 0 ];\n                fullNormalsList[ idv + 1 ] = n4[ 1 ];\n                fullNormalsList[ idv + 2 ] = n4[ 2 ];\n\n                idu = vtxCount * 2;\n                fullUVList[ idu ] = uv4[ 0 ];\n                fullUVList[ idu + 1 ] = uv4[ 1 ];\n\n                var iStart = triCount * 3;\n                var tristart = vtxCount - 3;\n                indexes[ iStart ] = tristart;\n                indexes[ iStart + 1 ] = tristart + 1;\n                indexes[ iStart + 2 ] = tristart + 2;\n                indexes[ iStart + 3 ] = tristart;\n                indexes[ iStart + 4 ] = tristart + 2;\n                indexes[ iStart + 5 ] = tristart + 3;\n                triCount += 2;\n                vtxCount += 1;\n            }\n        }\n    }\n\n    var g = new Geometry();\n    g.getAttributes().Vertex = new BufferArray( 'ARRAY_BUFFER', fullVerticesList, 3 );\n    g.getAttributes().Normal = new BufferArray( 'ARRAY_BUFFER', fullNormalsList, 3 );\n    g.getAttributes().TexCoord0 = new BufferArray( 'ARRAY_BUFFER', fullUVList, 2 );\n\n    if ( useDrawArrays )\n        g.getPrimitives().push( new DrawArrays( PrimitiveSet.TRIANGLES, 0, fullVerticesList.length / 3 ) );\n    else\n        g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( 'ELEMENT_ARRAY_BUFFER', indexes, 1 ) ) );\n    return g;\n};\n\nvar createGridGeometry = function ( cx, cy, cz, wx, wy, wz, hx, hy, hz, res1, res2 ) {\n    cx = cx !== undefined ? cx : -0.5;\n    cy = cy !== undefined ? cy : -0.5;\n    cz = cz !== undefined ? cz : 0.0;\n\n    wx = wx !== undefined ? wx : 1.0;\n    wy = wy !== undefined ? wy : 0.0;\n    wz = wz !== undefined ? wz : 0.0;\n\n    hx = hx !== undefined ? hx : 0.0;\n    hy = hy !== undefined ? hy : 1.0;\n    hz = hz !== undefined ? hz : 0.0;\n\n    res1 = res1 !== undefined ? res1 : 5;\n    res2 = res2 !== undefined ? res2 : res1;\n    res1 += 2;\n    res2 += 2;\n\n    var g = new Geometry();\n    var vertices = new Float32Array( ( res1 + res2 ) * 2 * 3 );\n    var i = 0;\n    var j = 0;\n    var sx = wx / ( res1 - 1 );\n    var sy = wy / ( res1 - 1 );\n    var sz = wz / ( res1 - 1 );\n    var ux = cx + wx + hx;\n    var uy = cy + wy + hy;\n    var uz = cz + wz + hz;\n    for ( i = 0; i < res1; ++i ) {\n        j = i * 6;\n        vertices[ j ] = cx + sx * i;\n        vertices[ j + 1 ] = cy + sy * i;\n        vertices[ j + 2 ] = cz + sz * i;\n        vertices[ j + 3 ] = ux - sx * ( res1 - i - 1 );\n        vertices[ j + 4 ] = uy - sy * ( res1 - i - 1 );\n        vertices[ j + 5 ] = uz - sz * ( res1 - i - 1 );\n    }\n    sx = hx / ( res2 - 1 );\n    sy = hy / ( res2 - 1 );\n    sz = hz / ( res2 - 1 );\n    for ( i = 0; i < res2; ++i ) {\n        j = ( res1 + i ) * 6;\n        vertices[ j ] = cx + sx * i;\n        vertices[ j + 1 ] = cy + sy * i;\n        vertices[ j + 2 ] = cz + sz * i;\n        vertices[ j + 3 ] = ux - sx * ( res2 - i - 1 );\n        vertices[ j + 4 ] = uy - sy * ( res2 - i - 1 );\n        vertices[ j + 5 ] = uz - sz * ( res2 - i - 1 );\n    }\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, ( res1 + res2 ) * 2 );\n    g.getPrimitives().push( primitive );\n    return g;\n};\n\n/*\n * debug lines showing bounding box abstraction\n * @param col bbox color\n */\nvar createBoundingBoxGeometry = function ( col ) {\n\n    var g = new Geometry();\n    //unit cube centered on 0\n    var vertices = new Float32Array( [ -0.5, -0.5, -0.5,\n        0.5, -0.5, -0.5,\n        0.5, 0.5, -0.5, -0.5, 0.5, -0.5, -0.5, -0.5, 0.5,\n        0.5, -0.5, 0.5,\n        0.5, 0.5, 0.5, -0.5, 0.5, 0.5\n    ] );\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n\n    // use color or red\n    if ( !col ) col = [ 1.0, 0.0, 0.0, 1.0 ];\n    var colors = new MACROUTILS.Float32Array( 8 * 4 );\n    for ( var i = 0; i < 8; i++ ) {\n        for ( var k = 0; k < 4; k++ ) {\n            colors[ i * 3 + k ] = col[ k ];\n        }\n    }\n\n    g.getAttributes().Color = new BufferArray( BufferArray.ARRAY_BUFFER, colors, 4 );\n\n    var indexes = new MACROUTILS.Uint16Array(\n        [\n            //up\n            0, 1,\n            1, 2,\n            2, 3,\n            3, 0,\n            //down\n            4, 5,\n            5, 6,\n            6, 7,\n            7, 4,\n            // side\n            0, 4,\n            1, 5,\n            2, 6,\n            3, 7\n\n        ] );\n\n    g.getPrimitives().push( new DrawElements( PrimitiveSet.LINES, new BufferArray( 'ELEMENT_ARRAY_BUFFER', indexes, 1 ) ) );\n\n    return g;\n\n};\n\nmodule.exports = {\n    createTexturedBoxGeometry: createTexturedBoxGeometry,\n    createTexturedQuadGeometry: createTexturedQuadGeometry,\n    createTexturedSphereGeometry: createTexturedSphere,\n    createTexturedFullScreenFakeQuadGeometry: createTexturedFullScreenFakeQuadGeometry,\n    createAxisGeometry: createAxisGeometry,\n    createTexturedSphere: createTexturedSphere,\n    createGridGeometry: createGridGeometry,\n    createBoundingBoxGeometry: createBoundingBoxGeometry\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/shape.js\n// module id = 122\n// module chunks = 0 1 2","'use strict';\nvar Stack = function () {\n    this.globalDefault = undefined;\n    this.lastApplied = undefined;\n    this.asChanged = false;\n\n    this._values = [];\n    this._back = undefined;\n};\n\nStack.prototype = {\n    empty: function () {\n        return this._values.length === 0;\n    },\n    values: function () {\n        return this._values;\n    },\n    back: function () {\n        return this._back;\n    },\n    push: function ( value ) {\n        this._values.push( value );\n        this._back = value;\n    },\n    pop: function () {\n        var value = this._values.pop();\n        this._back = this._values[ this._values.length - 1 ];\n        return value;\n    }\n};\n\nmodule.exports = Stack;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Stack.js\n// module id = 123\n// module chunks = 0 1 2","'use strict';\n\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar mat3 = require( 'osg/glMatrix' ).mat3;\nvar Notify = require( 'osg/notify' );\nvar Object = require( 'osg/Object' );\nvar Program = require( 'osg/Program' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Stack = require( 'osg/Stack' );\nvar Uniform = require( 'osg/Uniform' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\n\n\nvar checkUniformCache = [\n    undefined,\n    function uniformCheck1( uniformArray, cacheArray ) {\n        if ( uniformArray[ 0 ] === cacheArray[ 0 ] ) return true;\n        cacheArray[ 0 ] = uniformArray[ 0 ];\n        return false;\n    },\n\n    function uniformCheck2( uniformArray, cacheArray ) {\n        if ( uniformArray[ 0 ] === cacheArray[ 0 ] && uniformArray[ 1 ] === cacheArray[ 1 ] ) return true;\n        cacheArray[ 0 ] = uniformArray[ 0 ];\n        cacheArray[ 1 ] = uniformArray[ 1 ];\n        return false;\n    },\n\n    function uniformCheck3( uniformArray, cacheArray ) {\n        if ( uniformArray[ 0 ] === cacheArray[ 0 ] && uniformArray[ 1 ] === cacheArray[ 1 ] && uniformArray[ 2 ] === cacheArray[ 2 ] ) return true;\n        cacheArray[ 0 ] = uniformArray[ 0 ];\n        cacheArray[ 1 ] = uniformArray[ 1 ];\n        cacheArray[ 2 ] = uniformArray[ 2 ];\n        return false;\n    },\n\n    function uniformCheck4( uniformArray, cacheArray ) {\n        if ( uniformArray[ 0 ] === cacheArray[ 0 ] && uniformArray[ 1 ] === cacheArray[ 1 ] && uniformArray[ 2 ] === cacheArray[ 2 ] && uniformArray[ 3 ] === cacheArray[ 3 ] ) return true;\n        cacheArray[ 0 ] = uniformArray[ 0 ];\n        cacheArray[ 1 ] = uniformArray[ 1 ];\n        cacheArray[ 2 ] = uniformArray[ 2 ];\n        cacheArray[ 3 ] = uniformArray[ 3 ];\n        return false;\n    }\n];\n\n\nvar State = function ( shaderGeneratorProxy ) {\n    Object.call( this );\n\n    this._graphicContext = undefined;\n    this._shaderGeneratorProxy = shaderGeneratorProxy;\n\n    if ( shaderGeneratorProxy === undefined )\n        console.break();\n\n    this._currentVAO = null;\n    this._currentIndexVBO = null;\n\n    this.vertexAttribList = [];\n    this.stateSets = new Stack();\n    this._shaderGeneratorNames = new Stack();\n    this.uniforms = {};\n\n    this.textureAttributeMapList = [];\n\n    this.attributeMap = {};\n\n    this.projectionMatrix = Uniform.createMatrix4( mat4.create(), 'uProjectionMatrix' );\n    this.modelMatrix = Uniform.createMatrix4( mat4.create(), 'uModelMatrix' );\n    this.viewMatrix = Uniform.createMatrix4( mat4.create(), 'uViewMatrix' );\n    this.modelViewMatrix = Uniform.createMatrix4( mat4.create(), 'uModelViewMatrix' );\n    this.modelNormalMatrix = Uniform.createMatrix3( mat3.create(), 'uModelNormalMatrix' );\n    this.modelViewNormalMatrix = Uniform.createMatrix3( mat3.create(), 'uModelViewNormalMatrix' );\n\n    // track uniform for color array enabled\n    var arrayColorEnable = new Stack();\n    arrayColorEnable.globalDefault = Uniform.createFloat1( 0.0, 'uArrayColorEnabled' );\n\n    this.uniforms.ArrayColorEnabled = arrayColorEnable;\n\n    this._previousColorAttribPair = {};\n    this.vertexAttribMap = {};\n    this.vertexAttribMap._disable = [];\n    this.vertexAttribMap._keys = [];\n\n    this._frameStamp = undefined;\n\n    // we dont use Map because in this use case with a few entries\n    // {} is faster\n    this._programCommonUniformsCache = {};\n\n    // keep pointer on the last applied modelview matrix\n    this._modelViewMatrix = undefined;\n    // keep pointer on the last applied projection matrix\n    this._projectionMatrix = undefined;\n\n\n    // keep track of last applied program\n    this._program = undefined;\n    // inject a default program to initialize the stack Program\n    this.applyAttribute( new Program() );\n\n    this._numPushStateSet = 0;\n    this._numApply = 0;\n\n    this._programUniformCache = [];\n    this._cacheUniformId = 0;\n};\n\nState.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    getCacheUniformsApplyRenderLeaf: function () {\n        return this._programCommonUniformsCache;\n    },\n\n    setGraphicContext: function ( graphicContext ) {\n        this._graphicContext = graphicContext;\n        this._extVAO = WebGLCaps.instance( graphicContext ).getWebGLExtension( 'OES_vertex_array_object' );\n    },\n\n    getGraphicContext: function () {\n        return this._graphicContext;\n    },\n\n    getShaderGeneratorProxy: function () {\n        return this._shaderGeneratorProxy;\n    },\n\n    pushCheckOverride: function ( stack, object, maskValue ) {\n        // object can be a Uniform, an Attribute, or a shader generator name\n        if ( stack.values().length === 0 ) {\n            stack.push( this.getObjectPair( object, maskValue ) );\n        } else if ( ( stack.back().value & StateAttribute.OVERRIDE ) && !( maskValue & StateAttribute.PROTECTED ) ) {\n            stack.push( stack.back() );\n        } else {\n            stack.push( this.getObjectPair( object, maskValue ) );\n        }\n    },\n\n    pushStateSet: function ( stateset ) {\n        this._numPushStateSet++;\n        this.stateSets.push( stateset );\n\n        if ( stateset.attributeMap ) {\n            this.pushAttributeMap( this.attributeMap, stateset.attributeMap );\n        }\n\n        if ( stateset.textureAttributeMapList ) {\n            var list = stateset.textureAttributeMapList;\n            for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {\n                if ( !list[ textureUnit ] ) {\n                    continue;\n                }\n\n                var textureUnitAttributeMap = this.getOrCreateTextureAttributeMap( textureUnit );\n                this.pushAttributeMap( textureUnitAttributeMap, list[ textureUnit ] );\n            }\n        }\n\n        if ( stateset.uniforms ) {\n            this.pushUniformsList( this.uniforms, stateset.uniforms );\n        }\n        var generatorPair = stateset.getShaderGeneratorPair();\n        if ( generatorPair )\n            this.pushCheckOverride( this._shaderGeneratorNames, generatorPair.getShaderGeneratorName(), generatorPair.getValue() );\n    },\n\n    getStateSetStackSize: function () {\n        return this.stateSets.values().length;\n    },\n\n    insertStateSet: ( function () {\n        var tmpStack = [];\n\n        return function ( pos, stateSet ) {\n\n            tmpStack.length = 0;\n            var length = this.getStateSetStackSize();\n            while ( length > pos ) {\n                tmpStack.push( this.stateSets.back() );\n                this.popStateSet();\n                length--;\n            }\n\n            this.pushStateSet( stateSet );\n\n            for ( var i = tmpStack.length - 1; i >= 0; i-- ) {\n                this.pushStateSet( tmpStack[ i ] );\n            }\n\n        };\n    } )(),\n\n    removeStateSet: ( function () {\n        var tmpStack = [];\n\n        return function ( pos ) {\n\n            var length = this.getStateSetStackSize();\n            if ( pos >= length ) {\n                Notify.warn( 'Warning State:removeStateSet ' + pos + ' out of range' );\n                return;\n            }\n\n            tmpStack.length = 0;\n\n            // record the StateSet above the one we intend to remove\n            while ( length - 1 > pos ) {\n                tmpStack.push( this.stateSets.back() );\n                this.popStateSet();\n                length--;\n            }\n\n            // remove the intended StateSet as well\n            this.popStateSet();\n\n            // push back the original ones that were above the remove StateSet\n            for ( var i = tmpStack.length - 1; i >= 0; i-- ) {\n                this.pushStateSet( tmpStack[ i ] );\n            }\n\n        };\n    } )(),\n\n\n    // needed because we use a cache during the frame to avoid\n    // applying uniform or operation. At each frame we need to\n    // invalidate those informations\n    resetCacheFrame: function () {\n        this._modelViewMatrix = this._projectionMatrix = undefined;\n    },\n\n    resetStats: function () {\n        this._numApply = 0;\n        this._numPushStateSet = 0;\n    },\n\n    // apply program if needed\n    applyProgram: function ( program ) {\n        if ( this._program === program ) return;\n        this._program = program;\n        this.getGraphicContext().useProgram( program );\n    },\n\n    applyModelViewMatrix: ( function () {\n\n        var normal = mat3.create();\n\n        return function StateApplyModelViewMatrix( matrix, matrixModel ) {\n\n            if ( this._modelViewMatrix === matrix ) return false;\n\n            var program = this.getLastProgramApplied();\n            var uniformCache = program.getUniformsCache();\n            var mu = this.modelViewMatrix;\n            var mul = uniformCache.uModelViewMatrix;\n            var gc = this.getGraphicContext();\n            if ( mul ) {\n\n                mu.setMatrix4( matrix );\n                mu.apply( gc, mul );\n            }\n\n            var sendNormal;\n            if ( this._modelViewMatrix ) {\n\n                // check if we need to push normal\n                // test rotation component, if not diff\n                // we dont need to send normal\n                var m2 = this._modelViewMatrix;\n                for ( var i = 0; i < 11; i++ ) {\n                    if ( matrix[ i ] !== m2[ i ] ) {\n                        sendNormal = true;\n                        break;\n                    }\n                }\n            } else {\n                sendNormal = true;\n            }\n\n            if ( sendNormal ) {\n                mu = this.modelViewNormalMatrix;\n                mul = uniformCache.uModelViewNormalMatrix;\n                if ( mul ) {\n                    mat3.normalFromMat4( normal, matrix );\n                    mu.setMatrix3( normal );\n                    mu.apply( gc, mul );\n                }\n\n                mul = uniformCache.uModelNormalMatrix;\n                if ( mul ) {\n                    mat3.normalFromMat4( normal, matrixModel );\n                    mu.setMatrix3( normal );\n                    mu.apply( gc, mul );\n                }\n            }\n\n            this._modelViewMatrix = matrix;\n            return true;\n        };\n    } )(),\n\n    applyProjectionMatrix: function ( matrix ) {\n\n        if ( this._projectionMatrix === matrix ) return;\n\n        this._projectionMatrix = matrix;\n        var program = this.getLastProgramApplied();\n        var mu = this.projectionMatrix;\n\n        var mul = program.getUniformsCache()[ mu.getName() ];\n        if ( mul ) {\n\n            mu.setMatrix4( matrix );\n            mu.apply( this.getGraphicContext(), mul );\n\n        }\n    },\n\n    applyStateSet: function ( stateset ) {\n        this.pushStateSet( stateset );\n        this.apply();\n        this.popStateSet();\n    },\n\n    popAllStateSets: function () {\n        while ( this.stateSets.values().length ) {\n            this.popStateSet();\n        }\n    },\n\n    popStateSet: function () {\n\n        if ( this.stateSets.empty() ) return;\n\n        var stateset = this.stateSets.pop();\n\n        if ( stateset.attributeMap ) {\n            this.popAttributeMap( this.attributeMap, stateset.attributeMap );\n        }\n\n        if ( stateset.textureAttributeMapList ) {\n            var list = stateset.textureAttributeMapList;\n            for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {\n                if ( !list[ textureUnit ] ) {\n                    continue;\n                }\n                this.popAttributeMap( this.textureAttributeMapList[ textureUnit ], list[ textureUnit ] );\n            }\n        }\n\n        if ( stateset.uniforms ) {\n            this.popUniformsList( this.uniforms, stateset.uniforms );\n        }\n\n        if ( stateset.getShaderGeneratorPair() ) {\n            this._shaderGeneratorNames.pop();\n        }\n    },\n\n    _createAttributeStack: function ( attributeMap, key, globalDefault ) {\n\n        var attributeStack = new Stack();\n\n        attributeMap[ key ] = attributeStack;\n        attributeMap[ key ].globalDefault = globalDefault;\n\n        return attributeStack;\n\n    },\n\n    haveAppliedAttribute: function ( attribute ) {\n\n        var key = attribute.getTypeMember();\n        var attributeStack = this.attributeMap[ key ];\n        if ( !attributeStack ) {\n            attributeStack = this._createAttributeStack( this.attributeMap, key, attribute.cloneType() );\n        }\n        attributeStack.lastApplied = attribute;\n        attributeStack.asChanged = true;\n\n    },\n\n    applyAttribute: function ( attribute ) {\n\n        var key = attribute.getTypeMember();\n\n        var attributeMap = this.attributeMap;\n        var attributeStack = attributeMap[ key ];\n        if ( !attributeStack ) {\n            attributeStack = this._createAttributeStack( this.attributeMap, key, attribute.cloneType() );\n        }\n\n        if ( attributeStack.lastApplied !== attribute ) {\n\n            if ( attribute.apply ) {\n                attribute.apply( this );\n            }\n            attributeStack.lastApplied = attribute;\n            attributeStack.asChanged = true;\n        }\n    },\n\n    applyTextureAttribute: function ( unit, attribute ) {\n\n\n        var gl = this.getGraphicContext();\n        gl.activeTexture( gl.TEXTURE0 + unit );\n        var key = attribute.getTypeMember();\n\n        if ( !this.textureAttributeMapList[ unit ] ) {\n            this.textureAttributeMapList[ unit ] = {};\n        }\n\n        var textureUnitAttributeMap = this.getOrCreateTextureAttributeMap( unit );\n        var attributeStack = textureUnitAttributeMap[ key ];\n        if ( !attributeStack ) {\n            attributeStack = this._createAttributeStack( textureUnitAttributeMap, key, attribute.cloneType() );\n        }\n\n\n        if ( attributeStack.lastApplied !== attribute ) {\n\n            if ( attribute.apply ) {\n\n                // there is a texture we bind it.\n                attribute.apply( this, unit );\n\n                // TODO: optimization:\n                // if attribute.isTextureNull()\n                // only bind if last Framebuffer Texture Binded\n                // are the same as those we try to write from\n                // need rewrite of the fbo attachments system to keep history\n                // and state to keep last fbo textures binded.\n                // (applyTextureAttributeStack concerned too)\n            }\n            attributeStack.lastApplied = attribute;\n            attributeStack.asChanged = true;\n        }\n    },\n\n    getLastProgramApplied: function () {\n        return this.attributeMap.Program.lastApplied;\n    },\n\n    applyDefault: function () {\n        // reset GL State To Default\n        // we skip the textures/uniforms/shaders call since they are not necessary\n\n        // noticed that we accumulate lot of stack, maybe because of the stateGraph\n        // CP: ^^ really ? check it / report an issue\n        this.popAllStateSets();\n\n        this.applyAttributeMap( this.attributeMap );\n        this.applyTextureAttributeMapList( this.textureAttributeMapList );\n    },\n\n    apply: function () {\n\n        var lastProgram = this.getLastProgramApplied();\n\n        this.applyAttributeMap( this.attributeMap );\n        this.applyTextureAttributeMapList( this.textureAttributeMapList );\n\n        var generatedProgram = this._generateAndApplyProgram();\n\n        if ( generatedProgram ) {\n            // will cache uniform and apply them with the program\n\n            this._applyGeneratedProgramUniforms( this.attributeMap.Program.lastApplied );\n\n        } else {\n\n            // custom program so we will iterate on uniform from the program and apply them\n            // but in order to be able to use Attribute in the state graph we will check if\n            // our program want them. It must be defined by the user\n            this._applyCustomProgramUniforms( this.attributeMap.Program.lastApplied );\n\n        }\n\n        // reset reference of last applied matrix\n        if ( lastProgram !== this.getLastProgramApplied() ) {\n            this._modelViewMatrix = undefined;\n            this._projectionMatrix = undefined;\n        }\n    },\n\n\n    applyAttributeMap: function ( attributeMap ) {\n\n        var attributeStack;\n        for ( var key in attributeMap ) {\n            attributeStack = attributeMap[ key ];\n            if ( !attributeStack || !attributeStack.asChanged ) {\n                continue;\n            }\n\n            var attribute;\n            if ( attributeStack.values().length === 0 ) {\n                attribute = attributeStack.globalDefault;\n            } else {\n                attribute = attributeStack.back().object;\n            }\n\n\n\n            if ( attributeStack.lastApplied !== attribute ) {\n\n                if ( attribute.apply )\n                    attribute.apply( this );\n\n                attributeStack.lastApplied = attribute;\n\n            }\n            attributeStack.asChanged = false;\n\n        }\n    },\n\n    getObjectPair: function ( object, value ) {\n        return {\n            object: object,\n            value: value\n        };\n    },\n\n    pushUniformsList: function ( uniformMap, stateSetUniformMap ) {\n        /*jshint bitwise: false */\n        var name;\n        var uniform;\n\n        for ( var key in stateSetUniformMap ) {\n            var uniformPair = stateSetUniformMap[ key ];\n            uniform = uniformPair.getUniform();\n            name = uniform.getName();\n            if ( !uniformMap[ name ] ) {\n                this._createAttributeStack( uniformMap, name, uniform );\n            }\n\n            this.pushCheckOverride( uniformMap[ name ], uniform, uniformPair.getValue() );\n        }\n        /*jshint bitwise: true */\n    },\n\n    popUniformsList: function ( uniformMap, stateSetUniformMap ) {\n\n        for ( var key in stateSetUniformMap ) {\n            uniformMap[ key ].pop();\n        }\n    },\n\n\n    // this funtion must called only if stack has changed\n    // check applyTextureAttributeMapList\n    _applyTextureAttributeStack: function ( gl, textureUnit, attributeStack ) {\n\n        var attribute;\n        if ( attributeStack.values().length === 0 ) {\n            attribute = attributeStack.globalDefault;\n        } else {\n            attribute = attributeStack.back().object;\n        }\n\n        // if the the stack has changed but the last applied attribute is the same\n        // then we dont need to apply it again\n        if ( attributeStack.lastApplied !== attribute ) {\n\n            gl.activeTexture( gl.TEXTURE0 + textureUnit );\n            attribute.apply( this, textureUnit );\n\n            attributeStack.lastApplied = attribute;\n        }\n\n        attributeStack.asChanged = false;\n    },\n\n    applyTextureAttributeMapList: function ( textureAttributesMapList ) {\n        var gl = this._graphicContext;\n        var textureAttributeMap;\n\n        for ( var textureUnit = 0, l = textureAttributesMapList.length; textureUnit < l; textureUnit++ ) {\n            textureAttributeMap = textureAttributesMapList[ textureUnit ];\n            if ( !textureAttributeMap ) {\n                continue;\n            }\n\n\n            for ( var key in textureAttributeMap ) {\n                var attributeStack = textureAttributeMap[ key ];\n\n                // skip if not stack or not changed in stack\n                if ( !attributeStack || !attributeStack.asChanged ) continue;\n\n                this._applyTextureAttributeStack( gl, textureUnit, attributeStack );\n                // var attribute;\n                // if ( attributeStack.values().length === 0 ) {\n                //     attribute = attributeStack.globalDefault;\n                // } else {\n                //     attribute = attributeStack.back().object;\n                // }\n                // if ( attributeStack.asChanged ) {\n\n                //     gl.activeTexture( gl.TEXTURE0 + textureUnit );\n                //     attribute.apply( this, textureUnit );\n                //     attributeStack.lastApplied = attribute;\n                //     attributeStack.asChanged = false;\n\n                // }\n            }\n        }\n    },\n\n    setGlobalDefaultAttribute: function ( attribute ) {\n        var typeMember = attribute.getTypeMember();\n        var attributeMap = this.attributeMap;\n\n        if ( attributeMap[ typeMember ] === undefined ) {\n            this._createAttributeStack( attributeMap, typeMember, attribute );\n        } else {\n            attributeMap[ typeMember ].globalDefault = attribute;\n        }\n    },\n\n    getGlobalDefaultAttribute: function ( typeMember ) {\n        var attributeMap = this.attributeMap;\n        if ( attributeMap[ typeMember ] === undefined ) return undefined;\n\n        return attributeMap[ typeMember ].globalDefault;\n    },\n\n    setGlobalDefaultTextureAttribute: function ( unit, attribute ) {\n        var attributeMap = this.getOrCreateTextureAttributeMap( unit );\n\n        var typeMember = attribute.getTypeMember();\n\n        if ( attributeMap[ typeMember ] === undefined ) {\n            this._createAttributeStack( attributeMap, typeMember, attribute );\n        } else {\n            attributeMap[ typeMember ].globalDefault = attribute;\n        }\n\n    },\n\n    getGlobalDefaultTextureAttribute: function ( unit, typeMember ) {\n        var attributeMap = this.getOrCreateTextureAttributeMap( unit );\n        var as = attributeMap[ typeMember ];\n        return as.globalDefault;\n    },\n\n    getOrCreateTextureAttributeMap: function ( unit ) {\n        if ( !this.textureAttributeMapList[ unit ] ) this.textureAttributeMapList[ unit ] = {};\n        return this.textureAttributeMapList[ unit ];\n    },\n\n    pushAttributeMap: function ( attributeMap, stateSetAttributeMap ) {\n\n        for ( var type in stateSetAttributeMap ) {\n            var attributePair = stateSetAttributeMap[ type ];\n            var attribute = attributePair.getAttribute();\n\n            if ( attributeMap[ type ] === undefined ) {\n                this._createAttributeStack( attributeMap, type, attribute.cloneType() );\n            }\n\n            var attributeStack = attributeMap[ type ];\n            this.pushCheckOverride( attributeStack, attribute, attributePair.getValue() );\n            attributeStack.asChanged = true;\n        }\n    },\n\n    popAttributeMap: function ( attributeMap, stateSetAttributeMap ) {\n\n        for ( var type in stateSetAttributeMap ) {\n            var attributeStack = attributeMap[ type ];\n            attributeStack.pop();\n            attributeStack.asChanged = true;\n\n        }\n    },\n\n    setIndexArray: function ( array ) {\n\n        var gl = this._graphicContext;\n\n        if ( this._currentIndexVBO !== array ) {\n            array.bind( gl );\n            this._currentIndexVBO = array;\n        }\n\n        if ( array.isDirty() ) {\n            array.compile( gl );\n        }\n\n    },\n\n    lazyDisablingOfVertexAttributes: function () {\n        var keys = this.vertexAttribMap._keys;\n        for ( var i = 0, l = keys.length; i < l; i++ ) {\n            var attr = keys[ i ];\n            if ( this.vertexAttribMap[ attr ] ) {\n                this.vertexAttribMap._disable[ attr ] = true;\n            }\n        }\n    },\n\n    enableVertexColor: function () {\n\n        var program = this.attributeMap.Program.lastApplied;\n\n        if ( !program.getUniformsCache().uArrayColorEnabled ||\n            !program.getAttributesCache().Color ) return; // no color uniform or attribute used, exit\n\n        // update uniform\n        var uniform = this.uniforms.ArrayColorEnabled.globalDefault;\n\n        var previousColorEnabled = this._previousColorAttribPair[ program.getInstanceID() ];\n\n        if ( !previousColorEnabled ) {\n            uniform.setFloat( 1.0 );\n            uniform.apply( this.getGraphicContext(), program.getUniformsCache().uArrayColorEnabled );\n            this._previousColorAttribPair[ program.getInstanceID() ] = true;\n        }\n\n    },\n\n\n    disableVertexColor: function () {\n\n        var program = this.attributeMap.Program.lastApplied;\n\n        if ( !program.getUniformsCache().uArrayColorEnabled ||\n            !program.getAttributesCache().Color ) return; // no color uniform or attribute used, exit\n\n        // update uniform\n        var uniform = this.uniforms.ArrayColorEnabled.globalDefault;\n\n        var previousColorEnabled = this._previousColorAttribPair[ program.getInstanceID() ];\n\n        if ( previousColorEnabled ) {\n            uniform.setFloat( 0.0 );\n            uniform.apply( this.getGraphicContext(), program.getUniformsCache().uArrayColorEnabled );\n            this._previousColorAttribPair[ program.getInstanceID() ] = false;\n        }\n\n    },\n\n\n    applyDisablingOfVertexAttributes: function () {\n\n        var keys = this.vertexAttribMap._keys;\n        for ( var i = 0, l = keys.length; i < l; i++ ) {\n            if ( this.vertexAttribMap._disable[ keys[ i ] ] === true ) {\n                var attr = keys[ i ];\n                this._graphicContext.disableVertexAttribArray( attr );\n                this.vertexAttribMap._disable[ attr ] = false;\n                this.vertexAttribMap[ attr ] = false;\n            }\n        }\n    },\n\n    clearVertexAttribCache: function () {\n\n        var vertexAttribMap = this.vertexAttribMap;\n        var keys = vertexAttribMap._keys;\n        for ( var i = 0, l = keys.length; i < l; i++ ) {\n            var attr = keys[ i ];\n            vertexAttribMap[ attr ] = undefined;\n            vertexAttribMap._disable[ attr ] = false;\n        }\n\n        this.vertexAttribMap._disable.length = 0;\n        this.vertexAttribMap._keys.length = 0;\n\n    },\n\n    /**\n     *  set a vertex array object.\n     *  return true if binded the vao and false\n     *  if was already binded\n     */\n    setVertexArrayObject: function ( vao ) {\n\n        if ( this._currentVAO !== vao ) {\n\n            this._graphicContext.bindVertexArray( vao );\n            this._currentVAO = vao;\n\n            // disable cache to force a re enable of array\n            if ( !vao ) this.clearVertexAttribCache();\n\n            // disable currentIndexVBO to force to bind indexArray from Geometry\n            // if there is a change of vao\n            this._currentIndexVBO = undefined;\n\n            return true;\n        }\n        return false;\n    },\n\n    setVertexAttribArray: function ( attrib, array, normalize ) {\n\n        var vertexAttribMap = this.vertexAttribMap;\n        vertexAttribMap._disable[ attrib ] = false;\n        var gl = this._graphicContext;\n        var binded = false;\n\n        if ( array.isDirty() ) {\n            array.bind( gl );\n            array.compile( gl );\n            binded = true;\n        }\n\n        var currentArray = vertexAttribMap[ attrib ];\n        if ( currentArray !== array ) {\n\n            if ( !binded ) {\n                array.bind( gl );\n            }\n\n            if ( !currentArray ) {\n                gl.enableVertexAttribArray( attrib );\n\n                // can be === false (so undefined check is important)\n                if ( currentArray === undefined )\n                    vertexAttribMap._keys.push( attrib );\n\n            }\n\n            vertexAttribMap[ attrib ] = array;\n            gl.vertexAttribPointer( attrib, array.getItemSize(), array.getType(), normalize, 0, 0 );\n        }\n    },\n\n\n    _getActiveUniformsFromProgramAttributes: function ( program, activeUniformsList ) {\n\n        var attributeMapStack = this.attributeMap;\n\n        var attributeKeys = program.getTrackAttributes().attributeKeys;\n\n        if ( attributeKeys.length > 0 ) {\n\n            for ( var i = 0, l = attributeKeys.length; i < l; i++ ) {\n\n                var key = attributeKeys[ i ];\n                var attributeStack = attributeMapStack[ key ];\n                if ( attributeStack === undefined ) {\n                    continue;\n                }\n\n                // we just need the uniform list and not the attribute itself\n                var attribute = attributeStack.globalDefault;\n                if ( attribute.getOrCreateUniforms === undefined ) {\n                    continue;\n                }\n\n                var uniformMap = attribute.getOrCreateUniforms();\n                for ( var keyUniform in uniformMap ) {\n                    activeUniformsList.push( uniformMap[ keyUniform ] );\n                }\n            }\n\n        }\n    },\n\n    _getActiveUniformsFromProgramTextureAttributes: function ( program, activeUniformsList ) {\n\n        var textureAttributeKeysList = program.getTrackAttributes().textureAttributeKeys;\n        if ( textureAttributeKeysList === undefined ) return;\n\n        for ( var unit = 0, nbUnit = textureAttributeKeysList.length; unit < nbUnit; unit++ ) {\n\n            var textureAttributeKeys = textureAttributeKeysList[ unit ];\n            if ( textureAttributeKeys === undefined ) continue;\n\n            var unitTextureAttributeList = this.textureAttributeMapList[ unit ];\n            if ( unitTextureAttributeList === undefined ) continue;\n\n            for ( var i = 0, l = textureAttributeKeys.length; i < l; i++ ) {\n                var key = textureAttributeKeys[ i ];\n\n                var attributeStack = unitTextureAttributeList[ key ];\n                if ( attributeStack === undefined ) {\n                    continue;\n                }\n                // we just need the uniform list and not the attribute itself\n                var attribute = attributeStack.globalDefault;\n                if ( attribute.getOrCreateUniforms === undefined ) {\n                    continue;\n                }\n                var uniformMap = attribute.getOrCreateUniforms();\n                for ( var keyUniform in uniformMap ) {\n                    activeUniformsList.push( uniformMap[ keyUniform ] );\n                }\n            }\n        }\n    },\n\n    _cacheUniformsForCustomProgram: function ( program, activeUniformsList ) {\n\n        this._getActiveUniformsFromProgramAttributes( program, activeUniformsList );\n\n        this._getActiveUniformsFromProgramTextureAttributes( program, activeUniformsList );\n\n        var gl = this._graphicContext;\n\n        // now we have a list on uniforms we want to track but we will filter them to use only what is needed by our program\n        // not that if you create a uniforms whith the same name of a tracked attribute, and it will override it\n        var uniformsFinal = {};\n\n        for ( var i = 0, l = activeUniformsList.length; i < l; i++ ) {\n            var u = activeUniformsList[ i ];\n            var uniformName = u.getName();\n            var loc = gl.getUniformLocation( program._program, uniformName );\n            if ( loc !== undefined && loc !== null ) {\n                uniformsFinal[ uniformName ] = u;\n            }\n        }\n        program.trackUniforms = uniformsFinal;\n\n    },\n\n    _applyCustomProgramUniforms: ( function () {\n\n        var activeUniformsList = [];\n\n        return function ( program ) {\n\n            // custom program so we will iterate on uniform from the program and apply them\n            // but in order to be able to use Attribute in the state graph we will check if\n            // our program want them. It must be defined by the user\n\n            // first time we see attributes key, so we will keep a list of uniforms from attributes\n            activeUniformsList.length = 0;\n\n            // fill the program with cached active uniforms map from attributes and texture attributes\n            if ( program.getTrackAttributes() !== undefined && program.trackUniforms === undefined ) {\n                this._cacheUniformsForCustomProgram( program, activeUniformsList );\n            }\n\n            var programUniformMap = program.getUniformsCache();\n            var uniformMapStackContent = this.uniforms;\n\n            var programTrackUniformMap;\n            if ( program.trackUniforms )\n                programTrackUniformMap = program.trackUniforms;\n\n            var uniform;\n            for ( var uniformKey in programUniformMap ) {\n                var location = programUniformMap[ uniformKey ];\n                var uniformStack = uniformMapStackContent[ uniformKey ];\n\n                if ( uniformStack === undefined ) {\n\n                    if ( programTrackUniformMap !== undefined ) {\n                        uniform = programTrackUniformMap[ uniformKey ];\n                        if ( uniform !== undefined ) {\n                            uniform.apply( this._graphicContext, location );\n                        }\n                    }\n\n                } else {\n\n                    if ( uniformStack.values().length === 0 ) {\n                        uniform = uniformStack.globalDefault;\n                    } else {\n                        uniform = uniformStack.back().object;\n                    }\n                    uniform.apply( this._graphicContext, location );\n\n                }\n            }\n        };\n    } )(),\n\n\n    // apply a generated program if necessary\n    // It build a Shader from the shader generator\n    // it apply for the following condition\n    // the user has not put a Pogram in the stack or if he has he added one with OFF\n    _generateAndApplyProgram: function () {\n\n        var attributeMap = this.attributeMap;\n        if ( attributeMap.Program !== undefined && attributeMap.Program.values().length !== 0 && attributeMap.Program.back().value !== StateAttribute.OFF )\n            return undefined;\n\n        // no custom program look into the stack of ShaderGenerator name\n        // what we should use to generate a program\n\n        var last = this._shaderGeneratorNames.back();\n        var shaderGenerator = this._shaderGeneratorProxy.getShaderGenerator( last ? last.object : undefined );\n\n        var program = shaderGenerator.getOrCreateProgram( this );\n        this.applyAttribute( program );\n        return program;\n    },\n\n    _computeForeignUniforms: function ( programUniformMap, activeUniformMap ) {\n\n        var uniformMap = programUniformMap;\n\n        var foreignUniforms = [];\n        for ( var keyUniform in programUniformMap ) {\n            var location = uniformMap[ keyUniform ];\n\n            if ( location !== undefined && activeUniformMap[ keyUniform ] === undefined ) {\n\n                // filter 'standard' uniform matrix that will be applied for all shader\n                if ( keyUniform !== this.modelViewMatrix.getName() &&\n                    keyUniform !== this.modelMatrix.getName() &&\n                    keyUniform !== this.viewMatrix.getName() &&\n                    keyUniform !== this.projectionMatrix.getName() &&\n                    keyUniform !== this.modelViewNormalMatrix.getName() &&\n                    keyUniform !== this.modelNormalMatrix.getName() &&\n                    keyUniform !== 'uArrayColorEnabled' ) {\n                    foreignUniforms.push( keyUniform );\n                }\n            }\n\n        }\n\n        return foreignUniforms;\n    },\n\n    _removeUniformsNotRequiredByProgram: function ( activeUniformMap, programUniformMap ) {\n\n        for ( var keyUniform in activeUniformMap ) {\n            var location = programUniformMap[ keyUniform ];\n            if ( location === undefined || location === null ) {\n                delete activeUniformMap[ keyUniform ];\n            }\n        }\n    },\n\n\n    _cacheUniformsForGeneratedProgram: function ( program ) {\n\n        var foreignUniforms = this._computeForeignUniforms( program.getUniformsCache(), program.getActiveUniforms() );\n        program.setForeignUniforms( foreignUniforms );\n\n\n        // remove uniforms listed by attributes (getActiveUniforms) but not required by the program\n        this._removeUniformsNotRequiredByProgram( program.getActiveUniforms(), program.getUniformsCache() );\n\n    },\n\n    _copyUniformEntry: function ( uniform ) {\n\n        var internalArray = uniform.getInternalArray();\n        var cacheData;\n        if ( internalArray.length < 16 )\n            cacheData = new internalArray.constructor( internalArray.length );\n\n        return cacheData;\n    },\n\n    _initUniformCache: function ( program ) {\n\n        var activeUniformMap = program.getActiveUniforms();\n\n        var foreignUniformKeys = program.getForeignUniforms();\n        var uniformMapStack = this.uniforms;\n\n        var cacheForeignUniforms = [];\n        var cacheActiveUniforms = [];\n\n        var i, l, cache, name, cacheData, uniform;\n\n        program._cacheUniformId = this._cacheUniformId++;\n        this._programUniformCache[ program._cacheUniformId ] = {};\n\n        if ( foreignUniformKeys.length ) {\n            cache = cacheForeignUniforms;\n            for ( i = 0, l = foreignUniformKeys.length; i < l; i++ ) {\n                name = foreignUniformKeys[ i ];\n                var uniStack = uniformMapStack[ name ];\n                if ( uniStack ) {\n                    uniform = uniStack.globalDefault;\n                    cacheData = this._copyUniformEntry( uniform );\n                    cache.push( cacheData );\n                }\n\n            }\n        }\n\n        for ( var keyUniform in activeUniformMap ) {\n            uniform = activeUniformMap[ keyUniform ];\n            cacheData = this._copyUniformEntry( uniform );\n            cacheActiveUniforms.push( cacheData );\n        }\n\n        this._programUniformCache[ program._cacheUniformId ].foreign = cacheForeignUniforms;\n        this._programUniformCache[ program._cacheUniformId ].active = cacheActiveUniforms;\n\n    },\n\n    _checkCacheAndApplyUniform: function ( uniform, cacheArray, i, programUniformMap, nameUniform ) {\n        var isCached;\n        var internalArray = uniform.getInternalArray();\n        var uniformArrayLength = internalArray.length;\n        if ( uniformArrayLength <= 4 ) {\n            var uniformCache = cacheArray[ i ];\n            isCached = checkUniformCache[ uniformArrayLength ]( internalArray, uniformCache );\n        } else {\n            isCached = false;\n        }\n\n        if ( !isCached ) {\n            var location = programUniformMap[ nameUniform ];\n            uniform.apply( this._graphicContext, location );\n        }\n    },\n\n    // note that about TextureAttribute that need uniform on unit we would need to improve\n    // the current uniformList ...\n\n    // when we apply the shader for the first time, we want to compute the active uniforms for this shader and the list of uniforms not extracted from attributes called foreignUniforms\n    _applyGeneratedProgramUniforms: function ( program ) {\n\n        var foreignUniformKeys = program.getForeignUniforms();\n        if ( !foreignUniformKeys ) {\n            this._cacheUniformsForGeneratedProgram( program );\n            foreignUniformKeys = program.getForeignUniforms();\n\n            this._initUniformCache( program );\n        }\n\n        var programUniformMap = program.getUniformsCache();\n        var activeUniformMap = program.getActiveUniforms();\n\n        var cacheUniformsActive = this._programUniformCache[ program._cacheUniformId ].active;\n        var cacheUniformsForeign = this._programUniformCache[ program._cacheUniformId ].foreign;\n\n        // apply active uniforms\n        // caching uniforms from attribtues make it impossible to overwrite uniform with a custom uniform instance not used in the attributes\n        var l, uniform, keyUniform;\n        var i = 0;\n        for ( keyUniform in activeUniformMap ) {\n            uniform = activeUniformMap[ keyUniform ];\n            this._checkCacheAndApplyUniform( uniform, cacheUniformsActive, i, programUniformMap, keyUniform );\n            i++; // TODO not good, for in ordered consistency, etc...\n        }\n\n        var uniformMapStack = this.uniforms;\n\n        // apply now foreign uniforms, it's uniforms needed by the program but not contains in attributes used to generate this program\n        for ( i = 0, l = foreignUniformKeys.length; i < l; i++ ) {\n            keyUniform = foreignUniformKeys[ i ];\n            var uniformStack = uniformMapStack[ keyUniform ];\n            if ( uniformStack !== undefined ) {\n                if ( uniformStack.values().length === 0 ) {\n                    uniform = uniformStack.globalDefault;\n                    Notify.warn( 'Uniform Default Not attached to a StateSet in Scene Hierarchy: ' + uniformStack.globalDefault.getName() );\n                } else {\n                    uniform = uniformStack.back().object;\n                }\n            }\n\n            this._checkCacheAndApplyUniform( uniform, cacheUniformsForeign, i, programUniformMap, keyUniform );\n\n        }\n    },\n\n    // Use to detect changes in RenderLeaf between call to avoid to applyStateSet\n    _setStateSetsDrawID: function ( id ) {\n        var values = this.stateSets.values();\n        for ( var i = 0, nbStateSets = values.length; i < nbStateSets; i++ ) {\n            values[ i ].setDrawID( id );\n        }\n    },\n\n    _stateSetStackChanged: function ( id, nbLast ) {\n        var values = this.stateSets.values();\n        var nbStateSets = values.length;\n        if ( nbLast !== nbStateSets )\n            return true;\n\n        for ( var i = 0; i < nbStateSets; i++ ) {\n            if ( id !== values[ i ].getDrawID() )\n                return true;\n        }\n\n        return false;\n    }\n\n\n} ), 'osg', 'State' );\n\nmodule.exports = State;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/State.js\n// module id = 124\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Image = require( 'osg/Image' );\nvar Notify = require( 'osg/notify' );\nvar Texture = require( 'osg/Texture' );\n\n\n/**\n * TextureCubeMap\n * @class TextureCubeMap\n * @inherits Texture\n */\nvar TextureCubeMap = function () {\n\n    Texture.call( this );\n    this._images = {};\n\n    // pre allocated all textures faces slots\n    for ( var i = 0; i < 6; i++ ) {\n        this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X + i ] = new Image();\n    }\n\n};\n\n/** @lends TextureCubeMap.prototype */\nTextureCubeMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Texture.prototype, {\n\n    setDefaultParameters: function () {\n        Texture.prototype.setDefaultParameters.call( this );\n        this._textureTarget = Texture.TEXTURE_CUBE_MAP;\n\n        this._flipY = false;\n    },\n\n    cloneType: function () {\n        return new TextureCubeMap();\n    },\n\n    setImage: function ( imageFace, img, imageFormat ) {\n\n        var face = imageFace;\n\n        if ( typeof face === 'string' )\n            face = Texture[ face ];\n\n        this._images[ face ].setImage( img, imageFormat );\n\n        this.setImageFormat( imageFormat );\n        this.setTextureSize( this._images[ face ].getWidth(), this._images[ face ].getHeight() );\n\n        this._textureNull = false;\n        this.dirty();\n    },\n\n    getImage: function ( face ) {\n        return this._images[ face ].getImage();\n    },\n\n    initCubemapContent: function ( gl ) {\n\n        var internalFormat = this._internalFormat;\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );\n\n        return true;\n    },\n\n    // handle mipmap logic, if images for mipmap are provided or not\n    generateMipmap: function ( gl, target ) {\n\n        if ( !this.hasMipmapFilter() ) return;\n\n        // manual mipmap provided\n        if ( this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X ].hasMipmap() ) {\n\n            for ( var face = 0; face < 6; face++ ) {\n                var faceImage = this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X + face ];\n                if ( !faceImage.hasMipmap() ) {\n                    Notify.error( 'mipmap not set correctly for TextureCubemap' );\n                }\n\n                var internalFormat = this._internalFormat;\n                for ( var level = 1; level < faceImage.getMipmap().length; level++ ) {\n                    var size = faceImage.getMipmap()[ level ].getWidth();\n\n                    this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, level, internalFormat, size, size, 0, internalFormat, this._type, faceImage.getMipmap()[ level ].getImage() );\n                }\n            }\n\n        } else {\n\n            // automatic mipmap\n            gl.generateMipmap( target );\n        }\n\n        this._dirtyMipmap = false;\n    },\n\n    applyImageTarget: function ( gl, internalFormat, target ) {\n\n        var faceImage = this._images[ target ];\n\n        if ( !faceImage.getImage() ) return 0;\n\n        if ( !faceImage.isReady() ) return 0;\n\n        if ( !faceImage.isDirty() ) return 1;\n\n        this.setTextureSize( faceImage.getWidth(), faceImage.getHeight() );\n\n        faceImage.setDirty( false );\n\n        if ( faceImage.isTypedArray() ) {\n            this.applyTexImage2D( gl,\n                target,\n                0,\n                internalFormat,\n                this._textureWidth,\n                this._textureHeight,\n                0,\n                internalFormat,\n                this._type,\n                faceImage.getImage() );\n        } else {\n            this.applyTexImage2D( gl,\n                target,\n                0,\n                internalFormat,\n                internalFormat,\n                this._type,\n                faceImage.getImage() );\n        }\n\n        // release here only if no mipmap\n        if ( this._unrefImageDataAfterApply &&\n            !( this.hasMipmap() && faceImage.hasMipmap() ) ) {\n\n            faceImage.release();\n        }\n\n        return 1;\n    },\n\n    initCubemapContentImage: function ( gl ) {\n\n        var internalFormat = this._internalFormat;\n        var valid = 0;\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_X );\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_X );\n\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Y );\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y );\n\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Z );\n        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z );\n\n        if ( valid === 6 )\n            return true;\n\n        return false;\n    },\n\n    apply: function ( state ) {\n\n        var gl = state.getGraphicContext();\n        // if need to release the texture\n        if ( this._dirtyTextureObject )\n            this.releaseGLObjects();\n\n        if ( this._textureObject !== undefined && !this.isDirty() ) {\n            this._textureObject.bind( gl );\n\n            // If we have modified the texture via Rtt or texSubImage2D and _need_ updated mipmaps,\n            // then we must regenerate the mipmaps explicitely.\n            // In all other cases, don't set this flag because it can be costly\n            if ( this.isDirtyMipmap() ) {\n                this.generateMipmap( gl, this._textureTarget );\n            }\n\n        } else if ( this._textureNull ) {\n\n            gl.bindTexture( this._textureTarget, null );\n\n        } else {\n\n            if ( !this._textureObject ) {\n\n                // must be called before init\n                this.computeTextureFormat();\n\n                this.init( state );\n            }\n            this._textureObject.bind( gl );\n\n            var valid;\n\n            // no images it's must be a cubemap filled from rtt\n            if ( !this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X ].getImage() ) {\n\n                valid = this.initCubemapContent( gl );\n\n            } else {\n\n                valid = this.initCubemapContentImage( gl );\n\n            }\n\n            if ( valid ) {\n                this._dirty = false;\n                this.applyFilterParameter( gl, this._textureTarget );\n                this.generateMipmap( gl, this._textureTarget );\n            }\n        } // render to cubemap not yet implemented\n    }\n\n} ), 'osg', 'TextureCubeMap' );\n\nMACROUTILS.setTypeID( TextureCubeMap );\n\nmodule.exports = TextureCubeMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/TextureCubeMap.js\n// module id = 125\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\n\n\nvar UpdateVisitor = function () {\n    NodeVisitor.call( this );\n    this.visitorType = NodeVisitor.UPDATE_VISITOR;\n    this._numUpdateCallback = 0;\n};\n\nUpdateVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    resetStats: function () {\n        this._numUpdateCallback = 0;\n    },\n\n    apply: function ( node ) {\n\n        // a way to avoid extra call is to implement getNumChildrenRequiringUpdateTraversal\n        // and stateset.requiresUpdateTraversal()\n\n\n        // handle callback in stateset\n        var stateSet = node.getStateSet();\n        if ( stateSet && stateSet.requiresUpdateTraversal() ) {\n            var updateCallbackList = stateSet.getUpdateCallbackList();\n\n            var numStateSetUpdateCallback = updateCallbackList.length;\n            if ( numStateSetUpdateCallback ) {\n                this._numUpdateCallback += numStateSetUpdateCallback;\n                for ( var i = 0, l = numStateSetUpdateCallback; i < l; i++ )\n                    updateCallbackList[ i ].update( stateSet, this );\n            }\n        }\n\n        // handle callback in nodes\n        var ncs = node.getUpdateCallbackList();\n        var numUpdateCallback = ncs.length;\n        for ( var j = 0; j < numUpdateCallback; j++ ) {\n            this._numUpdateCallback++;\n            if ( !ncs[ j ].update( node, this ) ) {\n                return;\n            }\n        }\n\n        if ( node.getNumChildrenRequiringUpdateTraversal() > 0 )\n            this.traverse( node );\n    }\n} );\n\nmodule.exports = UpdateVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/UpdateVisitor.js\n// module id = 126\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\nvar Viewport = function ( x, y, w, h ) {\n    StateAttribute.call( this );\n\n    this._x = x !== undefined ? x : 0;\n    this._y = y !== undefined ? y : 0;\n    this._width = w !== undefined ? w : 800;\n    this._height = h !== undefined ? h : 600;\n};\n\nViewport.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Viewport',\n\n    cloneType: function () {\n        return new Viewport();\n    },\n\n    apply: function ( state ) {\n        var gl = state.getGraphicContext();\n        gl.viewport( this._x, this._y, this._width, this._height );\n    },\n\n    setViewport: function ( x, y, width, height ) {\n        this._x = x;\n        this._y = y;\n        this._width = width;\n        this._height = height;\n    },\n\n    x: function () {\n        return this._x;\n    },\n\n    y: function () {\n        return this._y;\n    },\n\n    width: function () {\n        return this._width;\n    },\n\n    height: function () {\n        return this._height;\n    },\n\n    computeWindowMatrix: ( function () {\n        var translate = mat4.create();\n        var scale = mat4.create();\n        var tmpVec = vec3.create();\n\n        return function ( destination ) {\n            // res = Matrix offset * Matrix scale * Matrix translate\n            mat4.fromTranslation( translate, vec3.ONE );\n            mat4.fromScaling( scale, [ 0.5 * this._width, 0.5 * this._height, 0.5 ] );\n            var offset = mat4.fromTranslation( destination, vec3.set( tmpVec, this._x, this._y, 0.0 ) );\n\n            return mat4.mul( offset, offset, mat4.mul( scale, scale, translate ) );\n\n        };\n    } )()\n\n} ), 'osg', 'Viewport' );\n\nmodule.exports = Viewport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Viewport.js\n// module id = 127\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\nvar Scissor = function ( x, y, w, h ) {\n\n    StateAttribute.call( this );\n\n    this._x = x !== undefined ? x : -1;\n    this._y = y !== undefined ? y : -1;\n    this._width = w !== undefined ? w : -1;\n\n    this._height = h !== undefined ? h : -1;\n};\n\nScissor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'Scissor',\n\n    cloneType: function () {\n        return new Scissor();\n    },\n\n    apply: function ( state ) {\n\n        var gl = state.getGraphicContext();\n        if ( this._x !== -1 ) {\n\n            gl.enable( gl.SCISSOR_TEST );\n            gl.scissor( this._x, this._y, this._width, this._height );\n\n        } else {\n\n            gl.disable( gl.SCISSOR_TEST );\n\n        }\n    },\n\n    setScissor: function ( x, y, width, height ) {\n\n        this._x = x;\n        this._y = y;\n        this._width = width;\n        this._height = height;\n\n    },\n\n    x: function () {\n        return this._x;\n    },\n\n    y: function () {\n        return this._y;\n    },\n\n    width: function () {\n        return this._width;\n    },\n\n    height: function () {\n        return this._height;\n    }\n\n\n} ), 'osg', 'Scissor' );\n\nmodule.exports = Scissor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/Scissor.js\n// module id = 128\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\n\n/*\nuse EXT_disjoint_timer_queryto time webgl calls GPU side average over multiple frames\n\nIf timestamp feature is not supported, we virtualize the query by splitting and adding \ndummy queries, that way it should handle both nested and interleaved queries.\n\nAlso, if you time the same queryID multiple time in the same frame, it will sum the different \nqueries, that way you can track a particular of gl command for examples\n\n*/\n\nvar TimerGPU = function ( gl ) {\n\n    this._enabled = false;\n\n    if ( gl ) {\n\n        var ext = WebGLCaps.instance( gl ).getDisjointTimerQuery();\n        if ( !ext ) return this;\n\n        // webgl1 to webgl2\n        if ( !gl.getQueryParameter ) gl.getQueryParameter = ext.getQueryObjectEXT.bind( ext );\n\n        // https://github.com/KhronosGroup/WebGL/blob/master/sdk/tests/conformance/extensions/ext-disjoint-timer-query.html#L102\n        // run the page if strange results\n        // to validate you gpu/browser has correct gpu queries support\n        this._hasTimeElapsed = gl.getQuery( ext.TIME_ELAPSED_EXT, ext.QUERY_COUNTER_BITS_EXT ) >= 30;\n        this._hasTimeStamp = gl.getQuery( ext.TIMESTAMP_EXT, ext.QUERY_COUNTER_BITS_EXT ) >= 30;\n\n        if ( !this._hasTimeElapsed && !this._hasTimeStamp ) {\n            return this;\n        }\n\n        // no timestamp means not start/end absolute time\n        // which means each start must be followed by a end\n        // BEFORE any other start (of other queryID)\n        if ( !this._hasTimeStamp ) Notify.debug( 'Warning: do not use interleaved GPU query' );\n\n        this._ext = ext;\n        this._gl = gl;\n        this._enabled = true;\n\n    }\n\n    this._frameAverageCount = 10;\n\n    this._glQueries = [];\n    this._queriesByID = {};\n    this._userQueries = []; // for timestamp, it's the same as _glQueries\n\n    // stuffs used to virtualize query (no timestamp)\n    this._queryCount = 0;\n    this._nbOpened = 0;\n};\n\nTimerGPU.FRAME_COUNT = 0;\n\nTimerGPU.instance = function ( gl ) {\n\n    if ( !TimerGPU._instance ) {\n        TimerGPU._instance = new TimerGPU( gl );\n    } else if ( gl && TimerGPU._instance.getContext() !== gl ) {\n        TimerGPU._instance.setContext( gl );\n    }\n    return TimerGPU._instance;\n\n};\n\nTimerGPU.prototype = {\n\n    getContext: function () {\n        return this._gl;\n    },\n    setContext: function ( gl ) {\n        this._gl = gl;\n    },\n    setFrameAverageCount: function ( val ) {\n        this._frameAverageCount = val;\n    },\n\n    clearQueries: function () {\n        var glQueries = this._glQueries;\n        for ( var i = 0, nbQueries = glQueries.length; i < nbQueries; ++i ) {\n            var query = glQueries[ i ];\n            this._gl.deleteQuery( query._pollingStartQuery );\n            if ( query._pollingEndQuery ) this._gl.deleteQuery( query );\n        }\n\n        this._userQueries.length = 0;\n        this._glQueries.length = 0;\n        this._queriesByID = {};\n    },\n\n    supportTimeStamp: function () {\n        return this._hasTimeStamp;\n    },\n\n    // many browser doesn't yet have\n    // the marvellous gpu timers\n    enable: function () {\n        // enable only if we have the extension\n        this._enabled = !!this._ext;\n    },\n\n    disable: function () {\n        this._enabled = false;\n    },\n    isEnabled: function () {\n        return this._enabled;\n    },\n\n    setCallback: function ( cb ) {\n        this._callback = cb;\n    },\n\n    createUserQuery: function ( queryID ) {\n        var query;\n        if ( this._hasTimeStamp ) {\n            query = this.createGLQuery();\n        } else {\n            query = {\n                _startIndex: 0,\n                _endIndex: 0\n            };\n        }\n\n        query._id = queryID;\n        query._frame = TimerGPU.FRAME_COUNT;\n        query._isOpened = true;\n        query._siblings = []; // if the query is called multiple time in the same frame\n\n        return query;\n    },\n\n    createGLQuery: function () {\n        var query = {};\n        query._isWaiting = false; // wait typically 1 or 2 frames\n        query._pollingStartQuery = undefined; // gl query object\n        query._pollingEndQuery = undefined; // gl query object (timestamp only)\n        query._averageTimer = 0.0; // cumulative average time\n        query._resultCount = 0; // cumulative average count\n\n        if ( this._hasTimeStamp ) query._pollingEndQuery = this._gl.createQuery();\n        query._pollingStartQuery = this._gl.createQuery();\n\n        this._glQueries.push( query );\n\n        return query;\n    },\n\n    getOrCreateLastGLQuery: function () {\n        var query = this._glQueries[ this._queryCount - 1 ];\n        if ( query ) return query;\n\n        query = this._glQueries[ this._queryCount - 1 ] = this.createGLQuery();\n\n        return query;\n    },\n\n    beginCurrentQuery: function () {\n        if ( this._nbOpened === 0 ) return;\n\n        this._queryCount++;\n\n        var query = this.getOrCreateLastGLQuery();\n        if ( !query._isWaiting ) {\n            this._gl.beginQuery( this._ext.TIME_ELAPSED_EXT, query._pollingStartQuery );\n        }\n    },\n\n    endCurrentQuery: function () {\n        if ( this._nbOpened === 0 ) return;\n\n        if ( !this.getOrCreateLastGLQuery()._isWaiting ) {\n            this._gl.endQuery( this._ext.TIME_ELAPSED_EXT );\n        }\n    },\n\n    getAvailableQueryByID: function ( queryID ) {\n        var query = this._queriesByID[ queryID ];\n        if ( !query ) {\n            query = this._queriesByID[ queryID ] = this.createUserQuery( queryID );\n            this._userQueries.push( query );\n            return query;\n        }\n\n        if ( query._frame === TimerGPU.FRAME_COUNT ) {\n\n            if ( query._isOpened ) return query;\n\n            var siblings = query._siblings;\n            for ( var i = 0, nbSiblings = siblings.length; i < nbSiblings; ++i ) {\n                var qsib = siblings[ i ];\n                if ( qsib._frame !== TimerGPU.FRAME_COUNT || qsib._isOpened ) {\n                    qsib._frame = TimerGPU.FRAME_COUNT;\n                    return qsib;\n                }\n            }\n\n            var newQuery = this.createUserQuery();\n            siblings.push( newQuery );\n            return newQuery;\n        }\n\n        query._frame = TimerGPU.FRAME_COUNT;\n\n        return query;\n    },\n\n    // start recording time if query already exist, don't recreate\n    start: function ( queryID ) {\n\n        // If timing currently disabled or glTimer does not exist, exit early.\n        if ( !this._enabled ) {\n            return undefined;\n        }\n\n        var query = this.getAvailableQueryByID( queryID );\n        query._isOpened = true;\n\n        if ( this._hasTimeStamp ) {\n\n            if ( !query._isWaiting ) this._ext.queryCounterEXT( query._pollingStartQuery, this._ext.TIMESTAMP_EXT );\n\n        } else {\n\n            this.endCurrentQuery();\n\n            this._nbOpened++;\n            query._startIndex = this._queryCount;\n\n            this.beginCurrentQuery();\n\n        }\n\n    },\n\n    // stop query recording (if running) polls for results\n    end: function ( queryID ) {\n\n        if ( !this._enabled ) {\n            return;\n        }\n\n        var query = this.getAvailableQueryByID( queryID );\n        query._isOpened = false;\n\n        if ( this._hasTimeStamp ) {\n\n            if ( !query._isWaiting ) this._ext.queryCounterEXT( query._pollingEndQuery, this._ext.TIMESTAMP_EXT );\n\n        } else {\n\n            this.endCurrentQuery();\n\n            query._endIndex = this._queryCount;\n            this._nbOpened--;\n\n            this.beginCurrentQuery();\n\n        }\n\n    },\n\n    computeQueryAverageTime: function ( query ) {\n        var average = 0;\n        var glQueries = this._glQueries;\n\n        for ( var i = query._startIndex; i < query._endIndex; ++i ) {\n            var glAvg = glQueries[ i ]._averageTimer;\n            if ( glAvg < 0 ) return -1;\n            average += glAvg;\n        }\n\n        return average;\n    },\n\n    computeFullAverageTime: function ( query ) {\n        var average = this.computeQueryAverageTime( query );\n\n        if ( average < 0 ) return -1;\n\n        var siblings = query._siblings;\n        for ( var i = 0, nbSiblings = siblings.length; i < nbSiblings; ++i ) {\n            var qsib = siblings[ i ];\n            if ( qsib._frame !== TimerGPU.FRAME_COUNT - 1 )\n                continue;\n\n            var sibAvg = this.computeQueryAverageTime( qsib );\n            if ( sibAvg < 0 ) return -1;\n            average += sibAvg;\n        }\n\n        return average;\n    },\n\n    pollQueries: function () {\n\n        TimerGPU.FRAME_COUNT++;\n        this._queryCount = 0;\n        this._nbOpened = 0;\n\n        if ( !this._enabled || !this._callback ) {\n            return;\n        }\n\n        var glQueries = this._glQueries;\n        var nbGlQueries = glQueries.length;\n        var i;\n\n        // all timer are corrupted, clear the queries\n        var disjoint = this._gl.getParameter( this._ext.GPU_DISJOINT_EXT );\n        if ( disjoint ) {\n            for ( i = 0; i < nbGlQueries; ++i ) {\n                glQueries[ i ]._isWaiting = false;\n            }\n            return;\n        }\n\n\n        // update average time for each queries\n        for ( i = 0; i < nbGlQueries; ++i ) {\n            this.pollQuery( glQueries[ i ] );\n        }\n\n        var userQueries = this._userQueries;\n        var nbUserQueries = userQueries.length;\n\n        for ( i = 0; i < nbUserQueries; ++i ) {\n            var query = userQueries[ i ];\n            var average = this.computeFullAverageTime( query );\n            if ( average > 0 ) {\n                this._callback( average, query._id );\n            }\n        }\n    },\n\n    pollQuery: function ( query ) {\n        query._isWaiting = false;\n\n        // last to be queried\n        var lastQuery = this._hasTimeStamp ? query._pollingEndQuery : query._pollingStartQuery;\n\n        // wait till results are ready\n        var available = this._gl.getQueryParameter( lastQuery, this._gl.QUERY_RESULT_AVAILABLE );\n        if ( !available ) {\n            query._isWaiting = true;\n            return 0;\n        }\n\n        var timeElapsed;\n\n        if ( this._hasTimeStamp ) {\n\n            var startTime = this._gl.getQueryParameter( query._pollingStartQuery, this._gl.QUERY_RESULT );\n            var endTime = this._gl.getQueryParameter( lastQuery, this._gl.QUERY_RESULT );\n            timeElapsed = endTime - startTime;\n\n        } else {\n\n            timeElapsed = this._gl.getQueryParameter( lastQuery, this._gl.QUERY_RESULT );\n\n        }\n\n        query._resultCount++;\n\n        // restart cumulative average every frameAveragecount frames\n        if ( query._resultCount > this._frameAverageCount ) {\n            query._averageTimer = 0.0;\n            query._resultCount = 1;\n        }\n\n        // https://en.wikipedia.org/wiki/Moving_average#Cumulative_moving_average\n        query._averageTimer = query._averageTimer + ( ( timeElapsed - query._averageTimer ) / ( query._resultCount ) );\n\n        return query._averageTimer;\n    }\n\n};\n\nmodule.exports = TimerGPU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osg/TimerGPU.js\n// module id = 129\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Animation = require( 'osgAnimation/animation' );\nvar SkinningAttribute = require( 'osgAnimation/SkinningAttribute' );\nvar AnimationUpdateCallback = require( 'osgAnimation/AnimationUpdateCallback' );\nvar BasicAnimationManager = require( 'osgAnimation/BasicAnimationManager' );\nvar Bone = require( 'osgAnimation/Bone' );\nvar Channel = require( 'osgAnimation/channel' );\nvar CollectAnimationUpdateCallbackVisitor = require( 'osgAnimation/CollectAnimationUpdateCallbackVisitor' );\nvar Easing = require( 'osgAnimation/easing' );\nvar Interpolator = require( 'osgAnimation/interpolator' );\nvar MorphAttribute = require( 'osgAnimation/MorphAttribute' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar Skeleton = require( 'osgAnimation/Skeleton' );\nvar StackedMatrix = require( 'osgAnimation/StackedMatrix' );\nvar StackedQuaternion = require( 'osgAnimation/StackedQuaternion' );\nvar StackedRotateAxis = require( 'osgAnimation/StackedRotateAxis' );\nvar StackedScale = require( 'osgAnimation/StackedScale' );\nvar StackedTranslate = require( 'osgAnimation/StackedTranslate' );\nvar UpdateBone = require( 'osgAnimation/UpdateBone' );\nvar UpdateMatrixTransform = require( 'osgAnimation/UpdateMatrixTransform' );\nvar UpdateMorph = require( 'osgAnimation/UpdateMorph' );\nvar UpdateSkeleton = require( 'osgAnimation/UpdateSkeleton' );\n\n\nvar osgAnimation = {};\n\nMACROUTILS.objectMix( osgAnimation, Easing );\nMACROUTILS.objectMix( osgAnimation, Interpolator );\nosgAnimation.Animation = Animation;\nosgAnimation.SkinningAttribute = SkinningAttribute;\nosgAnimation.AnimationUpdateCallback = AnimationUpdateCallback;\nosgAnimation.BasicAnimationManager = BasicAnimationManager;\nosgAnimation.Bone = Bone;\nosgAnimation.Channel = Channel;\nosgAnimation.CollectAnimationUpdateCallbackVisitor = CollectAnimationUpdateCallbackVisitor;\nosgAnimation.MorphAttribute = MorphAttribute;\nosgAnimation.MorphGeometry = MorphGeometry;\nosgAnimation.RigGeometry = RigGeometry;\nosgAnimation.Skeleton = Skeleton;\nosgAnimation.StackedMatrix = StackedMatrix;\nosgAnimation.StackedQuaternion = StackedQuaternion;\nosgAnimation.StackedRotateAxis = StackedRotateAxis;\nosgAnimation.StackedScale = StackedScale;\nosgAnimation.StackedTranslate = StackedTranslate;\nosgAnimation.UpdateBone = UpdateBone;\nosgAnimation.UpdateMatrixTransform = UpdateMatrixTransform;\nosgAnimation.UpdateMorph = UpdateMorph;\nosgAnimation.UpdateSkeleton = UpdateSkeleton;\n\nmodule.exports = osgAnimation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/osgAnimation.js\n// module id = 130\n// module chunks = 0 1 2","'use strict';\nvar Channel = require( 'osgAnimation/channel' );\n\n\n// create Animation data\n// Animation {\n//     channels: [],\n//     duration: 0.0;\n//     name: string\n// },\n\nvar animationCount = 0;\n\n// assume that iniChannel has been called\n// on each channel\nvar createAnimation = function ( channels, name ) {\n\n    var min = Infinity;\n    var max = -Infinity;\n    for ( var i = 0; i < channels.length; i++ ) {\n        min = Math.min( min, channels[ i ].start );\n        max = Math.max( max, channels[ i ].end );\n    }\n\n    var duration = max - min;\n    var animationName = name || ( 'animation' + animationCount.toString() );\n    animationCount++;\n    return {\n        channels: channels,\n        duration: duration,\n        name: animationName,\n        start: min\n    };\n};\n\n// create instance Animation data. An instance animation\n// contains instance channels instead of original channels\n// Animation {\n//     channels: [],\n//     duration: 0.0;\n//     start: 0.0, // used to know when an animation has been started\n//     name: string\n// },\nvar createInstanceAnimation = function ( animation ) {\n\n    var channels = [];\n    for ( var i = 0; i < animation.channels.length; i++ ) {\n        var channel = Channel.createInstanceChannel( animation.channels[ i ] );\n        channels.push( channel );\n    }\n\n    return {\n        channels: channels,\n        duration: animation.duration,\n        start: 0.0,\n        name: animation.name,\n        firstKeyTime: animation.start\n    };\n};\n\n\nvar Animation = function () {};\n\nAnimation.createAnimation = createAnimation;\nAnimation.createInstanceAnimation = createInstanceAnimation;\n\nmodule.exports = Animation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/animation.js\n// module id = 131\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\n\nvar Target = require( 'osgAnimation/target' );\nvar channelType = require( 'osgAnimation/channelType' );\n\n\nvar Channel = {};\n\n// channel {\n//     keys: [],\n//     times: [],\n//     type: enum,\n//     target: targetName\n// }\n// init a channel with extra field\n// start, end, duration\nvar initChannel = function ( type, keys, times, targetName, channelName, channel ) {\n    var start = times[ 0 ];\n    var end = times[ times.length - 1 ];\n    channel.start = start;\n    channel.keys = keys;\n    channel.end = end;\n    channel.times = times;\n    channel.type = type;\n    channel.duration = end - start;\n    channel.target = targetName;\n    channel.name = channelName;\n    return channel;\n};\n\nvar createVec3Channel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.Vec3, keys, times, targetName, channelName, chan || {} );\n};\n\nvar createFloatChannel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.Float, keys, times, targetName, channelName, chan || {} );\n};\n\nvar createQuatChannel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.Quat, keys, times, targetName, channelName, chan || {} );\n};\n\nvar createQuatSlerpChannel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.QuatSlerp, keys, times, targetName, channelName, chan || {} );\n};\n\nvar createFloatCubicBezierChannel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.FloatCubicBezier, keys, times, targetName, channelName, chan || {} );\n};\n\nvar createVec3CubicBezierChannel = function ( keys, times, targetName, channelName, chan ) {\n    return initChannel( channelType.Vec3CubicBezier, keys, times, targetName, channelName, chan || {} );\n};\n\n\n// channel contains {\n//     keys: [],\n//     times: [],\n//     start: 0.0,\n//     end: 1.0,\n// }\n// return {\n//     channel: channel,\n//     value: vec3.create(),\n//     targetID: int,\n//     key: 0,\n//     t: 0, //global start time\n// }\n\nvar Float = {\n    create: function () {\n        return 0;\n    }\n};\nvar Vec3 = {\n    create: function () {\n        return vec3.create32();\n    }\n};\nvar Quat = {\n    create: function () {\n        return quat.create32();\n    }\n};\n\n\nvar createInstanceChannelType = function ( operator, channel ) {\n    return {\n        channel: channel,\n        value: operator.create(),\n        targetID: Target.InvalidTargetID,\n        weight: 1.0,\n        key: 0,\n        start: 0.0,\n        end: 0.0\n    };\n};\n\nvar createInstanceVec3Channel = function ( channel ) {\n    return createInstanceChannelType( Vec3, channel );\n};\n\nvar createInstanceQuatChannel = function ( channel ) {\n    return createInstanceChannelType( Quat, channel );\n};\n\nvar createInstanceFloatChannel = function ( channel ) {\n    return createInstanceChannelType( Float, channel );\n};\n\nvar createInstanceFloatCubicBezierChannel = function ( channel ) {\n    return createInstanceChannelType( Float, channel );\n};\n\nvar createInstanceVec3CubicBezierChannel = function ( channel ) {\n    return createInstanceChannelType( Vec3, channel );\n};\n\n\n// create an instance channel from type\nvar createInstanceChannel = function ( channel ) {\n    return Channel[ channel.type ]( channel );\n};\n\n// animations instances\n/*\n\n |-----------------| anim0 (channel0_0, channel0_1 )\n           |--------------| anim1 (channel1_0, channel1_1, channel1_2 )\n\n // si triage a cause de la priorité\n // iterate on priority\n // and for animations of the same priority\n\n\n // init d'une animation\n\n // init du manager\n //   createInstanceAnimation pour chaque animations\n //      createInstanceChannels pour chaque animation\n\n //   initChannelTargetID pour toute les animations du manager\n //      id -> targetName\n\n\n // get target for an animation to push on target list ( to blend )\n var targets = {};\n for ( var i = 0 ; i < channels.length; i++ ) {\n    var target = channels[i].target;\n    targets[target].push( channels[i] );\n }\n\n\n // pour l'instant on ignore les pb d'organisation de priorité\n //\n // target X : [\n //      ChannelAnima0_0\n //      ChannelAnima1_0\n // ]\n\n // target Y : [\n //      ChannelAnima0_1\n //      ChannelAnima1_1\n // ]\n\n\n */\n\n\n// for a target compute each channel contribution\n// channel0, value0, w, priority0\n// channel1, value1, w, priority0\n// channel2, value2, w, priority0\n\n\n// channel0, value0, w, priority1\n// channel1, value1, w, priority1\n// channel2, value2, w, priority1\n\n/*\n\n var value;\n Copy( channels[0].value, value );\n var weight = 0.0;\n var priority = channels[0].priority;\n var priorityWeight = channels[0].weight;\n\n for ( var i = 1; i < channels.length; i++ ) {\n\n     if ( priority !== channels[i].priority ) {\n          weight += priorityWeight * ( 1.0 - weight );\n          priorityWeight = 0.0;\n          priority = channels[i].priority;\n     }\n\n     priorityWeight += weight;\n     t = ( 1.0 - weight ) * channels[i].weight / priorityWeight;\n     lerp( t, value, channels[i].value );\n }\n\n\n // second version\n\n var value;\n Copy( channels[0].value, value );\n var weight = 0; //channels[0].weight;\n //var priority = channels[0].priority;\n var priorityWeight = 0;\n\n for ( var i = 0; i < channels.length; i++ ) {\n\n     if ( priority !== channels[i].priority ) {\n          weight += priorityWeight * ( 1.0 - weight );\n          priorityWeight = 0.0;\n          priority = channels[i].priority;\n     }\n\n     priorityWeight += weight;\n     t = ( 1.0 - weight ) * channels[i].weight / priorityWeight;\n     lerp( t, value, channels[i].value );\n }\n\n\n */\n\nChannel.createInstanceChannel = createInstanceChannel;\nChannel.createInstanceVec3Channel = createInstanceVec3Channel;\nChannel.createInstanceQuatChannel = createInstanceQuatChannel;\nChannel.createInstanceQuatSlerpChannel = createInstanceQuatChannel;\nChannel.createInstanceFloatChannel = createInstanceFloatChannel;\nChannel.createInstanceFloatCubicBezierChannel = createInstanceFloatCubicBezierChannel;\nChannel.createInstanceVec3CubicBezierChannel = createInstanceVec3CubicBezierChannel;\n\nChannel.createVec3Channel = createVec3Channel;\nChannel.createQuatChannel = createQuatChannel;\nChannel.createQuatSlerpChannel = createQuatSlerpChannel;\nChannel.createFloatChannel = createFloatChannel;\nChannel.createFloatCubicBezierChannel = createFloatCubicBezierChannel;\nChannel.createVec3CubicBezierChannel = createVec3CubicBezierChannel;\n\nChannel[ channelType.Vec3 ] = createInstanceVec3Channel;\nChannel[ channelType.Quat ] = createInstanceQuatChannel;\nChannel[ channelType.QuatSlerp ] = createInstanceQuatChannel;\nChannel[ channelType.Float ] = createInstanceFloatChannel;\nChannel[ channelType.FloatCubicBezier ] = createInstanceFloatCubicBezierChannel;\nChannel[ channelType.Vec3CubicBezier ] = createInstanceVec3CubicBezierChannel;\n\nChannel.ChannelType = channelType;\n\n\nmodule.exports = Channel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/channel.js\n// module id = 132\n// module chunks = 0 1 2","'use strict';\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar channelType = require( 'osgAnimation/channelType' );\n\n\nvar target = {};\ntarget.InvalidTargetID = -1;\n\n// defaultValue is used when no channels affect the value\nvar createTarget = function ( type, value, defaultValue ) {\n    return {\n        type: type,\n        id: target.InvalidTargetID, // -1 means no id assigned yet\n        channels: [],\n        value: value,\n        defaultValue: defaultValue\n    };\n};\n\nvar createQuatTarget = function ( defaultValue ) {\n    return createTarget( channelType.Quat,\n        quat.copy( quat.create(), defaultValue ),\n        quat.copy( quat.create(), defaultValue ) );\n};\n\nvar createMatrixTarget = function ( defaultValue ) {\n    return createTarget( channelType.Matrix,\n        mat4.copy( mat4.create(), defaultValue ),\n        mat4.copy( mat4.create(), defaultValue ) );\n};\n\nvar createVec3Target = function ( defaultValue ) {\n    return createTarget( channelType.Vec3,\n        vec3.copy( vec3.create(), defaultValue ),\n        vec3.copy( vec3.create(), defaultValue ) );\n};\n\nvar createFloatTarget = function ( defaultValue ) {\n    return createTarget( channelType.Float,\n        defaultValue,\n        defaultValue );\n};\n\ntarget.createQuatTarget = createQuatTarget;\ntarget.createVec3Target = createVec3Target;\ntarget.createFloatTarget = createFloatTarget;\ntarget.createMatrixTarget = createMatrixTarget;\n\nmodule.exports = target;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/target.js\n// module id = 133\n// module chunks = 0 1 2","'use strict';\n\n// must be sync wiht Interpolator Type\nmodule.exports = {\n    Vec3: 0,\n    Quat: 1,\n    Float: 2,\n    FloatCubicBezier: 3,\n    Vec3CubicBezier: 4,\n    QuatSlerp: 5,\n    Matrix: 6,\n    Count: 7\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/channelType.js\n// module id = 134\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar BaseObject = require( 'osg/Object' );\nvar quat = require( 'osg/glMatrix' ).quat;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Channel = require( 'osgAnimation/channel' );\nvar Animation = require( 'osgAnimation/animation' );\nvar Interpolator = require( 'osgAnimation/interpolator' );\nvar CollectAnimationUpdateCallbackVisitor = require( 'osgAnimation/CollectAnimationUpdateCallbackVisitor' );\nvar Target = require( 'osgAnimation/target' );\nvar UpdateMorph = require( 'osgAnimation/UpdateMorph' );\n\n\nvar Float = {\n    lerp: function ( a, b, t ) {\n        return a + ( b - a ) * t;\n    },\n    init: function () {\n        return 0.0;\n    },\n    copy: function ( src ) {\n        return src;\n    },\n    create: function () {\n        return 0.0;\n    }\n};\n\nvar TypeToSize = [];\nTypeToSize[ Channel.ChannelType.Float ] = 1;\nTypeToSize[ Channel.ChannelType.FloatCubicBezier ] = 1;\nTypeToSize[ Channel.ChannelType.Vec3 ] = 3;\nTypeToSize[ Channel.ChannelType.Vec3CubicBezier ] = 3;\nTypeToSize[ Channel.ChannelType.Quat ] = 4;\nTypeToSize[ Channel.ChannelType.QuatSlerp ] = 4;\nTypeToSize[ Channel.ChannelType.Matrix ] = 16;\n\n\nvar ResultType = [];\nResultType.length = Channel.ChannelType.Count;\nResultType[ Channel.ChannelType.Vec3 ] = vec3;\nResultType[ Channel.ChannelType.Quat ] = quat;\nResultType[ Channel.ChannelType.QuatSlerp ] = quat;\nResultType[ Channel.ChannelType.Float ] = Float;\nResultType[ Channel.ChannelType.FloatCubicBezier ] = Float;\nResultType[ Channel.ChannelType.Vec3CubicBezier ] = vec3;\nResultType[ Channel.ChannelType.Matrix ] = mat4;\n\n/**\n *  BasicAnimationManager\n *  @class BasicAnimationManager\n */\nvar BasicAnimationManager = function () {\n    BaseObject.call( this );\n\n    this._simulationTime = 0.0;\n    this._pauseTime = 0.0;\n    this._timeFactor = 1.0;\n    this._startTime = 0.0;\n\n    // contains a map with instance animations\n    this._instanceAnimations = {};\n\n    // animations to start\n    this._startAnimations = {};\n\n    // target contains an array of all target for this manager\n    // index in the array is used as ID\n    // see Animation.createTarget\n    // [\n    //     { id: 0,\n    //       channels: [],\n    //       value: 0.0,\n    //       defaultValue: 0.0,\n    //       type\n    //     },\n    //     ...\n    // ];\n    this._targets = [];\n    this._targetsMap = {};\n\n    // target id with active lists\n    // [\n    //   vec3: [ targetID0, targetID1 ]\n    //   Quat: [ targetID2, targetID3,  ... ]\n    //   Float: [ ... ]\n    // ]\n    this._targetsByTypes = [];\n    this._targetsByTypes.length = Channel.ChannelType.Count;\n    for ( var i = 0, ni = this._targetsByTypes.length; i < ni; i++ ) {\n        this._targetsByTypes[ i ] = [];\n    }\n\n    // current playing animations\n    this._activeAnimations = {};\n    this._activeAnimationList = [];\n\n    // current actives channels by types\n    //   [ chanel0, channel1, ... ] // vec3 type\n    //   [ chanel2, channel3, ... ] // Quat type\n    //   [ chanel5, channel6, ... ] // Float type\n    this._activeChannelsByTypes = [];\n    this._activeChannelsByTypes.length = Channel.ChannelType.Count;\n    for ( var j = 0, nj = this._activeChannelsByTypes.length; j < nj; j++ ) {\n        this._activeChannelsByTypes[ j ] = [];\n    }\n\n    // assign all target/channel in animationCallback\n    // then they can read it directly\n    // animation callback to update\n    this._animationsUpdateCallback = {};\n    this._animationsUpdateCallbackArray = [];\n\n    // queue of animations to register\n    this._animationsToRegister = [];\n\n    //Pause status (true / false)\n    this._pause = false;\n\n    this._dirty = false;\n\n    this._seekTime = -1;\n};\n\nBasicAnimationManager.prototype = MACROUTILS.objectInherit( BaseObject.prototype, {\n\n    init: function ( animations ) {\n\n        // reset all\n        this._simulationTime = 0.0;\n        this._pauseTime = 0.0;\n        this._timeFactor = 1.0;\n        this._startTime = 0.0;\n\n        // contains a map with instance animations\n        this._instanceAnimations = {};\n\n        // animations to start\n        this._startAnimations = {};\n\n        this._resetTargets();\n\n        this._activeAnimations = {};\n        this._activeAnimationList.length = 0;\n\n        for ( var i = 0, ni = this._activeChannelsByTypes.length; i < ni; i++ )\n            this._activeChannelsByTypes[ i ].length = 0;\n\n        this._animationsUpdateCallback = {};\n        this._animationsUpdateCallbackArray.length = 0;\n\n        this._pause = false;\n        this._seekTime = -1;\n\n        // add animations\n        this.addAnimations( animations );\n    },\n\n\n    // push all animations into the queue\n    addAnimations: function ( animations ) {\n\n        var instanceAnimationList = this._addAnimation( animations );\n\n        // qeue them to assign target\n        Array.prototype.push.apply( this._animationsToRegister, instanceAnimationList );\n        this._dirty = true;\n        this._registerAnimations();\n    },\n\n\n    update: function ( node, nv ) {\n\n        if ( this._dirty ) {\n            this._findAnimationUpdateCallback( node );\n            this._registerTargetFoundInAnimationCallback();\n            this._registerAnimations();\n        }\n\n        var t = nv.getFrameStamp().getSimulationTime();\n\n        if ( this._seekTime !== -1 )\n            this._pauseTime = -this._seekTime + this._startTime + t;\n        this._seekTime = -1;\n\n        if ( !this._pause ) { // Not in pause\n            this._simulationTime = this._startTime + ( t - this._pauseTime );\n        } else {\n            this._pauseTime = ( t - this._simulationTime + this._startTime );\n        }\n\n        this.updateManager( this._simulationTime * this._timeFactor );\n        return true;\n    },\n\n    updateManager: function ( t ) {\n\n\n        // adds active animations / channels requested\n        //\n        this._processStartAnimation( t );\n\n        var l = Channel.ChannelType.Count;\n        // update all actives channels by type\n        //\n        for ( var i = 0; i < l; i++ ) {\n            var activeChannelType = this._activeChannelsByTypes[ i ];\n            this._updateChannelsType( t, activeChannelType, Interpolator[ i ] );\n        }\n\n        // update targets\n        //\n        for ( var j = 0; j < l; j++ ) {\n            var targetType = this._targetsByTypes[ j ];\n            this._updateTargetType( targetType, ResultType[ j ] );\n        }\n\n\n        // update all animation callback\n        // expect to have UpdateMatrixTransform\n        for ( var k = 0, nk = this._animationsUpdateCallbackArray.length; k < nk; k++ ) {\n            var animCallback = this._animationsUpdateCallbackArray[ k ];\n            animCallback.computeChannels();\n        }\n\n        // check animation finished\n        this._removeFinishedAnimation( t );\n    },\n\n    togglePause: function () { //Pause the manager's time\n        this._pause = !this._pause;\n        // if we resume an animation we don't want to move forward the animation\n        if ( !this._pause )\n            this._seekTime = this._simulationTime;\n    },\n\n    getSimulationTime: function () {\n        return this._simulationTime;\n    },\n\n    setSimulationTime: function ( t ) {\n        this._simulationTime = t;\n    },\n\n    setSeekTime: function ( t ) {\n        this._simulationTime = t;\n        this._seekTime = t;\n    },\n\n    stopAnimation: function ( name ) {\n        var activeAnimationList = this._activeAnimationList;\n        for ( var i = 0, nbAnim = activeAnimationList.length; i < nbAnim; ++i ) {\n            if ( activeAnimationList[ i ].name === name ) {\n                this._removeActiveChannels( this._instanceAnimations[ name ] );\n                this._activeAnimations[ name ] = undefined;\n                activeAnimationList.splice( i, 1 );\n                return;\n            }\n        }\n    },\n\n    stopAllAnimation: function () {\n        var activeAnimationList = this._activeAnimationList;\n        for ( var i = 0, nbAnim = activeAnimationList.length; i < nbAnim; ++i ) {\n            var name = activeAnimationList[ i ].name;\n            this._removeActiveChannels( this._instanceAnimations[ name ] );\n            this._activeAnimations[ name ] = undefined;\n        }\n        activeAnimationList.length = 0;\n    },\n\n    setTimeFactor: function ( timeFactor ) {\n        var tf = timeFactor / this._timeFactor;\n        this._startTime += ( this._simulationTime - this._simulationTime * tf ) / tf;\n\n        this._timeFactor = timeFactor;\n\n        if ( this._pause )\n            this._simulationTime += ( this._simulationTime - this._simulationTime * tf ) / tf;\n    },\n\n    getTimeFactor: function () {\n        return this._timeFactor;\n    },\n\n    isPlaying: function ( name ) {\n        if ( this._activeAnimations[ name ] ) return true;\n        return false;\n    },\n\n    // play animation using object as config\n    // {\n    //     name: string,\n    //     priority: 0,\n    //     weight: 1.0,\n    //     loop: true / false\n    // }\n    playAnimationObject: function ( obj ) {\n\n        var anim = this._instanceAnimations[ obj.name ];\n        if ( !anim ) {\n            Notify.info( 'no animation ' + obj.name + ' found' );\n            return;\n        }\n\n        if ( this.isPlaying( obj.name ) ) return;\n\n        anim.priority = ( obj.priority === undefined ) ? 0 : obj.priority;\n        anim.weight = ( obj.weight === undefined ) ? 1.0 : obj.weight;\n        anim.loop = ( obj.loop === undefined ) ? true : obj.loop;\n\n        this._startAnimations[ anim.name ] = anim;\n    },\n\n    // if first argument is an object\n    // playAnimationObject is called instead\n    playAnimation: function ( name, loop, priority, weight ) {\n\n        var animationObject;\n        if ( typeof name === 'object' )\n            animationObject = name;\n        else {\n            animationObject = {\n                name: name,\n                priority: priority,\n                weight: weight,\n                loop: loop\n            };\n        }\n\n        return this.playAnimationObject( animationObject );\n    },\n\n    getAnimations: function () {\n        return this._instanceAnimations;\n    },\n\n\n    _registerAnimations: function () {\n\n        if ( !this._targets.length ) return;\n\n        for ( var i = 0, ni = this._animationsToRegister.length; i < ni; i++ ) {\n            var instanceAnimation = this._animationsToRegister[ i ];\n            this._registerInstanceAnimation( instanceAnimation );\n        }\n\n        this._animationsToRegister.length = 0;\n        this._dirty = false;\n    },\n\n    // Register animation\n    //\n    // Register animation list all target from channel in the animations and associate\n    // target found in the scenegraph. If no target are registered animation cant be\n    // registered. In this case animation will be pending and resolved after a visitor\n    // extract target.\n    _registerInstanceAnimation: function ( instanceAnimation ) {\n\n        var instanceChannels = instanceAnimation.channels;\n        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {\n            var instanceChannel = instanceChannels[ i ];\n            var targetName = instanceChannel.channel.target;\n            var name = instanceChannel.channel.name;\n            var uniqueTargetName = targetName + '.' + name;\n\n            // disply a warning if animation has a channel but not target found in the\n            // scene graph. We could probably optimize and removes those channels, but\n            // it must be a user decision in case the user plugin different scene\n            // graph together and target would appear later in the scenegraph\n            if ( !this._targetMap[ uniqueTargetName ] ) {\n                Notify.warn( 'registerInstanceAnimation did not find targetName (' + uniqueTargetName + ') in the scene graph' );\n                continue;\n            }\n\n            instanceChannel.targetID = this._targetMap[ uniqueTargetName ].id;\n        }\n        return true;\n    },\n\n    _findAnimationUpdateCallback: function ( node ) {\n        var collector = new CollectAnimationUpdateCallbackVisitor();\n        node.accept( collector );\n        this._animationsUpdateCallback = collector.getAnimationUpdateCallbackMap();\n    },\n\n    // assignTargetToAnimationCallback\n    //\n    // check all animationUpdateCallback collected and try to\n    // assign the channel instance registered in the manager. If a\n    // animationUpdateCallback contains channels not known by the\n    // manager we skip it.  It means that it should be called\n    // after the animations has been registered into the animation\n    // manager\n    _registerTargetFoundInAnimationCallback: function () {\n\n        this._resetTargets();\n\n        var targetID = 0;\n        var targetMap = this._targetMap;\n        var targets = this._targets;\n\n        var registerTarget = function ( uniqueTargetName, target, name ) {\n            if ( !targetMap[ uniqueTargetName ] ) {\n                targetMap[ uniqueTargetName ] = target;\n                // assign an id that will be an index into a array\n                target.id = targetID++;\n                targets.push( target );\n\n                var type = target.type; // split by type\n                this._targetsByTypes[ type ].push( target );\n            } else {\n                // detect differents target instance with same\n                // unique target name. It's a problem\n                if ( target !== targetMap[ uniqueTargetName ] )\n                    Notify.warn( 'detected differents target instance with the same name (' + name + ')' );\n            }\n        }.bind( this );\n\n\n        var target;\n        var name;\n        var uniqueTargetName;\n\n        for ( var keyAnimation in this._animationsUpdateCallback ) {\n            var animationCallback = this._animationsUpdateCallback[ keyAnimation ];\n\n            // handle UpdateBone and UpdateMatrixTransform but not stateSet\n            if ( animationCallback.getStackedTransforms && animationCallback.getStackedTransforms().length ) {\n                this._animationsUpdateCallbackArray.push( animationCallback );\n\n                var stackedTransforms = animationCallback.getStackedTransforms();\n                for ( var j = 0, nj = stackedTransforms.length; j < nj; j++ ) {\n                    var stackedTransform = stackedTransforms[ j ];\n                    target = stackedTransform.getTarget();\n                    name = stackedTransform.getName();\n                    uniqueTargetName = animationCallback.getName() + '.' + name;\n\n                    registerTarget( uniqueTargetName, target, name );\n                }\n            } else if ( animationCallback instanceof UpdateMorph ) {\n                for ( var t = 0, numTarget = animationCallback.getNumTarget(); t < numTarget; t++ ) {\n                    name = animationCallback.getTargetName( t );\n                    uniqueTargetName = name + '.' + t;\n                    target = animationCallback.getTarget( t );\n\n                    registerTarget( uniqueTargetName, target, name );\n                }\n            }\n        }\n    },\n\n    _addAnimation: function ( animations ) {\n\n        var instanceAnimationList = [];\n        for ( var i = 0, ni = animations.length; i < ni; i++ ) {\n\n            var animation = animations[ i ];\n            var animationName = animation.name;\n\n            if ( this._instanceAnimations[ animationName ] )\n                continue;\n\n            var instanceAnimation = Animation.createInstanceAnimation( animation );\n            this._instanceAnimations[ animationName ] = instanceAnimation;\n            instanceAnimationList.push( instanceAnimation );\n        }\n\n        return instanceAnimationList;\n    },\n\n    // add channels from instance animation to the active channels list\n    _addActiveChannels: function ( t, instanceAnimation ) {\n\n        var instanceChannels = instanceAnimation.channels;\n        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {\n            var instanceChannel = instanceChannels[ i ];\n            var type = instanceChannel.channel.type;\n            instanceChannel.t = t; // reset time\n            instanceChannel.instanceAnimation = instanceAnimation; // link with parent animation\n            var targetID = instanceChannel.targetID;\n\n            if ( targetID === Target.InvalidTargetID ) continue;\n\n            this._activeChannelsByTypes[ type ].push( instanceChannel );\n            this._targets[ targetID ].channels.push( instanceChannel );\n        }\n\n    },\n\n    _removeActiveChannels: function ( instanceAnimation ) {\n\n        var instanceChannels = instanceAnimation.channels;\n        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {\n            var instanceChannel = instanceChannels[ i ];\n            var type = instanceChannel.channel.type;\n            var targetID = instanceChannel.targetID;\n\n            if ( targetID === Target.InvalidTargetID ) continue;\n\n            // remove channel instance from targetID channel list\n            var targetChannelsList = this._targets[ targetID ].channels;\n            var index = targetChannelsList.indexOf( instanceChannel );\n            targetChannelsList.splice( index, 1 );\n\n            // remove channel from active channels\n            var channelTypeList = this._activeChannelsByTypes[ type ];\n            var channelIndex = channelTypeList.indexOf( instanceChannel );\n            channelTypeList.splice( channelIndex, 1 );\n        }\n\n    },\n\n    // blend value from each channels for each target\n    // or copy default value if not updated by an active animation\n    _updateTargetType: function ( targetList, operatorType ) {\n\n        for ( var i = 0, ni = targetList.length; i < ni; i++ ) {\n\n            var target = targetList[ i ];\n            var affectedChannels = target.channels;\n            var nbChannels = affectedChannels.length;\n            // note operatorType operations doesn't always operate on arrays (float)\n            // so we can't simply assume that target.value is an array so we need\n            // to write \"target.value = ...\"\n\n            if ( nbChannels === 0 ) { // no blending ?\n                target.value = operatorType.copy( target.defaultValue, target.value );\n\n            } else if ( nbChannels === 1 ) {\n                target.value = operatorType.copy( affectedChannels[ 0 ].value, target.value );\n\n            } else {\n\n                // blend between multiple channels\n                target.value = operatorType.init( target.value );\n                var accumulatedWeight = 0.0;\n\n                // it's the same as targetOut = (v0 * w0 + v1 * w1 + ...) / (w0 + w1 + ...)\n                for ( var j = 0, nj = affectedChannels.length; j < nj; j++ ) {\n\n                    var achannel = affectedChannels[ j ];\n                    var weight = achannel.weight;\n                    accumulatedWeight += weight;\n                    // avoid divide by zero and useless lerp\n                    if ( accumulatedWeight === 0.0 || weight === 0.0 )\n                        continue;\n\n                    var ratio = weight / accumulatedWeight;\n                    target.value = operatorType.lerp( target.value, target.value, achannel.value, ratio );\n                }\n            }\n        }\n    },\n\n    _updateChannelsType: function ( t, channels, interpolator ) {\n\n        for ( var i = 0, ni = channels.length; i < ni; i++ ) {\n            var channel = channels[ i ];\n            var instanceAnimation = channel.instanceAnimation;\n            var loop = instanceAnimation.loop;\n\n            var tLocal = t - channel.t;\n\n            // handle loop, careful in case animation is one frame\n            if ( loop && instanceAnimation.duration > 0.0 ) tLocal = tLocal % instanceAnimation.duration;\n\n            interpolator( tLocal + instanceAnimation.firstKeyTime, channel );\n        }\n    },\n\n    _removeFinishedAnimation: function ( t ) {\n\n        var activeAnimationList = this._activeAnimationList;\n\n        var i = 0;\n        while ( i < activeAnimationList.length ) {\n            var instanceAnimation = activeAnimationList[ i ];\n            var name = instanceAnimation.name;\n\n            if ( t > instanceAnimation.end && instanceAnimation.loop === false ) {\n                this._removeActiveChannels( instanceAnimation );\n                this._activeAnimations[ name ] = undefined;\n                activeAnimationList.splice( i, 1 );\n            } else {\n                i++;\n            }\n        }\n    },\n\n    _addActiveAnimation: function ( t, cmd ) {\n\n        this._activeAnimations[ cmd.name ] = cmd; // set animation in the list of active one\n\n        var instanceAnimation = this._instanceAnimations[ cmd.name ];\n        instanceAnimation.start = t;\n        instanceAnimation.end = t + instanceAnimation.duration;\n        this._addActiveChannels( t, instanceAnimation );\n\n        // keep track of instance animation active in a list\n        this._activeAnimationList.push( instanceAnimation );\n    },\n\n    // execute start animations events\n    // during the updateManager\n    _processStartAnimation: function ( t ) {\n\n        // dont really start animation if we dont have yet targets\n        if ( !this._targets.length ) return;\n\n        var keyAnimation;\n        for ( keyAnimation in this._startAnimations ) {\n            var cmd = this._startAnimations[ keyAnimation ];\n            var name = cmd.name;\n\n            if ( this.isPlaying( name ) )\n                continue;\n\n            this._addActiveAnimation( t, cmd );\n        }\n\n        if ( keyAnimation !== undefined ) this._startAnimations = {};\n    },\n\n    _resetTargets: function () {\n\n        this._targetMap = {};\n        this._targets.length = 0;\n\n        for ( var i = 0, ni = this._targetsByTypes.length; i < ni; i++ ) {\n            this._targetsByTypes[ i ].length = 0;\n        }\n\n    },\n\n    resetAllStackedTransforms: function () {\n        var anims = this._animationsUpdateCallbackArray;\n        for ( var i = 0, nbAnims = anims.length; i < nbAnims; i++ ) {\n            var stacked = anims[ i ].getStackedTransforms();\n            for ( var j = 0, nbStacked = stacked.length; j < nbStacked; j++ ) {\n                stacked[ j ].resetToDefaultValue();\n            }\n\n            // computeChannels is not mandatory here as the following frame will call\n            // this function anyway\n            anims[ i ].computeChannels();\n        }\n    },\n\n    setAnimationLerpEndStart: function ( anim, lerpDuration ) {\n        var channels = anim.channels;\n        if ( anim.originalDuration === undefined )\n            anim.originalDuration = anim.duration;\n\n        anim.duration = anim.originalDuration + lerpDuration;\n\n        var firstKey = anim.firstKeyTime;\n        var animDuration = anim.originalDuration;\n\n        for ( var i = 0, nbChannels = channels.length; i < nbChannels; ++i ) {\n            var ch = channels[ i ].channel;\n\n            // compare first and last key and detect if we can loop the channel or not\n            // it uses an arbitrary epsilon\n            if ( Math.abs( ch.start - firstKey ) > 0.01 || Math.abs( ch.duration - animDuration ) > 0.01 )\n                continue;\n\n            // update channel end time\n            if ( ch.originalEnd === undefined )\n                ch.originalEnd = ch.end;\n\n            ch.end = ch.originalEnd + lerpDuration;\n\n            // add or remove additonal key and time\n\n            var sizeElt = TypeToSize[ ch.type ];\n            var size = ch.times.buffer.byteLength / 4;\n\n            // no lerp between end and start\n            if ( lerpDuration === 0.0 ) {\n\n                ch.keys = new Float32Array( ch.keys.buffer, 0, ( size - 1 ) * sizeElt );\n                ch.times = new Float32Array( ch.times.buffer, 0, size - 1 );\n\n            } else {\n\n                // take full size of buffer (with additional keys)\n                ch.keys = new Float32Array( ch.keys.buffer, 0, size * sizeElt );\n                // copy first key\n                var idLast = ( size - 1 ) * sizeElt;\n                for ( var j = 0; j < sizeElt; ++j )\n                    ch.keys[ idLast + j ] = ch.keys[ j ];\n\n                ch.times = new Float32Array( ch.times.buffer, 0, size );\n                ch.times[ size - 1 ] = ch.times[ size - 2 ] + lerpDuration;\n            }\n        }\n    }\n\n} );\n\nBasicAnimationManager.TypeToSize = TypeToSize;\n\nmodule.exports = BasicAnimationManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/BasicAnimationManager.js\n// module id = 135\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar Channel = require( 'osgAnimation/channel' );\n\n\nvar vec3CopyKeyFrame = function ( i, keys, result ) {\n    result[ 0 ] = keys[ i++ ];\n    result[ 1 ] = keys[ i++ ];\n    result[ 2 ] = keys[ i++ ];\n};\n\nvar Vec4CopyKeyFrame = function ( i, keys, result ) {\n    result[ 0 ] = keys[ i++ ];\n    result[ 1 ] = keys[ i++ ];\n    result[ 2 ] = keys[ i++ ];\n    result[ 3 ] = keys[ i++ ];\n};\n\nvar Vec3LerpInterpolator = function ( t, channelInstance ) {\n\n    var channel = channelInstance.channel;\n    var value = channelInstance.value;\n    var start = channel.start;\n    var end = channel.end;\n    var keys = channel.keys;\n    var times = channel.times;\n\n    if ( t >= end ) {\n        channelInstance.key = 0;\n        vec3CopyKeyFrame( keys.length - 3, keys, value );\n        return;\n\n    } else if ( t <= start ) {\n        channelInstance.key = 0;\n        vec3CopyKeyFrame( 0, keys, value );\n        return;\n    }\n\n    var i1 = channelInstance.key;\n    if ( t > times[ i1 ] )\n        while ( times[ i1 + 1 ] < t ) i1++;\n    else if ( t < times[ i1 ] )\n        while ( times[ i1 ] > t ) i1--;\n\n    var t1 = times[ i1 ];\n    var t2 = times[ i1 + 1 ];\n\n    var index = i1 * 3;\n    var x1 = keys[ index++ ];\n    var y1 = keys[ index++ ];\n    var z1 = keys[ index++ ];\n\n    var x2 = keys[ index++ ];\n    var y2 = keys[ index++ ];\n    var z2 = keys[ index++ ];\n\n    var r = ( t - t1 ) / ( t2 - t1 );\n\n    value[ 0 ] = x1 + ( x2 - x1 ) * r;\n    value[ 1 ] = y1 + ( y2 - y1 ) * r;\n    value[ 2 ] = z1 + ( z2 - z1 ) * r;\n    channelInstance.key = i1;\n};\n\n\nvar QuatLerpInterpolator = ( function () {\n\n    var q0 = quat.create32();\n    var q1 = quat.create32();\n\n    return function ( t, channelInstance ) {\n\n        var channel = channelInstance.channel;\n        var value = channelInstance.value;\n        var start = channel.start;\n        var end = channel.end;\n        var keys = channel.keys;\n        var times = channel.times;\n\n        if ( t >= end ) {\n            channelInstance.key = 0;\n            Vec4CopyKeyFrame( keys.length - 4, keys, value );\n            return;\n\n        } else if ( t <= start ) {\n            channelInstance.key = 0;\n            Vec4CopyKeyFrame( 0, keys, value );\n            return;\n        }\n\n        var i1 = channelInstance.key;\n        if ( t > times[ i1 ] )\n            while ( times[ i1 + 1 ] < t ) i1++;\n        else if ( t < times[ i1 ] )\n            while ( times[ i1 ] > t ) i1--;\n\n        var t1 = times[ i1 ];\n        var t2 = times[ i1 + 1 ];\n\n        var index = i1 * 4;\n        q0[ 0 ] = keys[ index++ ];\n        q0[ 1 ] = keys[ index++ ];\n        q0[ 2 ] = keys[ index++ ];\n        q0[ 3 ] = keys[ index++ ];\n\n        q1[ 0 ] = keys[ index++ ];\n        q1[ 1 ] = keys[ index++ ];\n        q1[ 2 ] = keys[ index++ ];\n        q1[ 3 ] = keys[ index++ ];\n\n        var r = ( t - t1 ) / ( t2 - t1 );\n\n        quat.nlerp( value, q0, q1, r );\n        channelInstance.key = i1;\n    };\n\n} )();\n\nvar QuatSlerpInterpolator = ( function () {\n\n    var q0 = quat.create32();\n    var q1 = quat.create32();\n\n    return function ( t, channelInstance ) {\n\n        var channel = channelInstance.channel;\n        var value = channelInstance.value;\n        var start = channel.start;\n        var end = channel.end;\n        var keys = channel.keys;\n        var times = channel.times;\n\n        if ( t >= end ) {\n            channelInstance.key = 0;\n            Vec4CopyKeyFrame( keys.length - 4, keys, value );\n            return;\n\n        } else if ( t <= start ) {\n            channelInstance.key = 0;\n            Vec4CopyKeyFrame( 0, keys, value );\n            return;\n        }\n\n        var i1 = channelInstance.key;\n        if ( t > times[ i1 ] )\n            while ( times[ i1 + 1 ] < t ) i1++;\n        else if ( t < times[ i1 ] )\n            while ( times[ i1 ] > t ) i1--;\n\n        var t1 = times[ i1 ];\n        var t2 = times[ i1 + 1 ];\n\n        var index = i1 * 4;\n        q0[ 0 ] = keys[ index++ ];\n        q0[ 1 ] = keys[ index++ ];\n        q0[ 2 ] = keys[ index++ ];\n        q0[ 3 ] = keys[ index++ ];\n\n        q1[ 0 ] = keys[ index++ ];\n        q1[ 1 ] = keys[ index++ ];\n        q1[ 2 ] = keys[ index++ ];\n        q1[ 3 ] = keys[ index++ ];\n\n        var r = ( t - t1 ) / ( t2 - t1 );\n\n        quat.slerp( value, q0, q1, r );\n\n        channelInstance.key = i1;\n    };\n} )();\n\n\nvar FloatLerpInterpolator = function ( t, channelInstance ) {\n\n    var channel = channelInstance.channel;\n    var value = channelInstance.value;\n    var start = channel.start;\n    var end = channel.end;\n    var keys = channel.keys;\n    var times = channel.times;\n\n    if ( t >= end ) {\n        channelInstance.key = 0;\n        channelInstance.value = keys[ keys.length - 1 ];\n        return;\n\n    } else if ( t <= start ) {\n        channelInstance.key = 0;\n        channelInstance.value = keys[ 0 ];\n        return;\n    }\n\n    var i1 = channelInstance.key;\n    if ( t > times[ i1 ] )\n        while ( times[ i1 + 1 ] < t ) i1++;\n    else if ( t < times[ i1 ] )\n        while ( times[ i1 ] > t ) i1--;\n\n\n    var t1 = times[ i1 ];\n    var t2 = times[ i1 + 1 ];\n\n    var index = i1;\n    var x1 = keys[ index++ ];\n    var x2 = keys[ index++ ];\n\n    var r = ( t - t1 ) / ( t2 - t1 );\n\n    value = x1 + ( x2 - x1 ) * r;\n    channelInstance.key = i1;\n    channelInstance.value = value;\n};\n\nvar FloatCubicBezierInterpolator = function ( t, channelInstance ) {\n    var channel = channelInstance.channel;\n    var value = channelInstance.value;\n    var start = channel.start;\n    var end = channel.end;\n    var keys = channel.keys;\n    var times = channel.times;\n\n    if ( t >= end ) {\n        channelInstance.key = 0;\n        channelInstance.value = keys[ keys.length - 3 ];\n        return;\n\n    } else if ( t <= start ) {\n        channelInstance.key = 0;\n        channelInstance.value = keys[ 0 ];\n        return;\n    }\n\n    var i = channelInstance.key;\n    if ( t > times[ i ] )\n        while ( times[ i + 1 ] < t ) i++;\n    else if ( t < times[ i ] )\n        while ( times[ i ] > t ) i--;\n\n    var tt = ( t - times[ i ] ) / ( times[ i + 1 ] - times[ i ] );\n    var oneMinusT = 1.0 - tt;\n    var oneMinusT2 = oneMinusT * oneMinusT;\n    var oneMinusT3 = oneMinusT2 * oneMinusT;\n    var t2 = tt * tt;\n\n    var id = i * 3;\n    var v0 = keys[ id ] * oneMinusT3;\n    var v1 = keys[ id + 1 ] * ( 3.0 * tt * oneMinusT2 );\n    var v2 = keys[ id + 2 ] * ( 3.0 * t2 * oneMinusT );\n    var v3 = keys[ id + 3 ] * ( t2 * tt );\n\n    value = v0 + v1 + v2 + v3;\n    channelInstance.key = i;\n    channelInstance.value = value;\n};\n\nvar Vec3CubicBezierInterpolator = ( function () {\n    var v0 = vec3.create();\n    var v1 = vec3.create();\n    var v2 = vec3.create();\n    var v3 = vec3.create();\n\n    return function ( t, channelInstance ) {\n        var channel = channelInstance.channel;\n        var value = channelInstance.value;\n        var start = channel.start;\n        var end = channel.end;\n        var keys = channel.keys;\n        var times = channel.times;\n\n        if ( t >= end ) {\n            channelInstance.key = 0;\n            vec3CopyKeyFrame( keys.length - 9, keys, value );\n            return;\n\n        } else if ( t <= start ) {\n            channelInstance.key = 0;\n            vec3CopyKeyFrame( 0, keys, value );\n            return;\n        }\n\n        var i = channelInstance.key;\n        if ( t > times[ i ] )\n            while ( times[ i + 1 ] < t ) i++;\n        else if ( t < times[ i ] )\n            while ( times[ i ] > t ) i--;\n\n        var tt = ( t - times[ i ] ) / ( times[ i + 1 ] - times[ i ] );\n        var oneMinusT = 1.0 - tt;\n        var oneMinusT2 = oneMinusT * oneMinusT;\n        var oneMinusT3 = oneMinusT2 * oneMinusT;\n        var t2 = tt * tt;\n\n        var id = i * 9;\n        vec3.scale( v0, vec3.set( v0, keys[ id++ ], keys[ id++ ], keys[ id++ ] ), oneMinusT3 );\n        vec3.scale( v1, vec3.set( v1, keys[ id++ ], keys[ id++ ], keys[ id++ ] ), ( 3.0 * tt * oneMinusT2 ) );\n        vec3.scale( v2, vec3.set( v2, keys[ id++ ], keys[ id++ ], keys[ id++ ] ), ( 3.0 * t2 * oneMinusT ) );\n        vec3.scale( v3, vec3.set( v3, keys[ id++ ], keys[ id++ ], keys[ id++ ] ), ( t2 * tt ) );\n\n        value[ 0 ] = v0[ 0 ] + v1[ 0 ] + v2[ 0 ] + v3[ 0 ];\n        value[ 1 ] = v0[ 1 ] + v1[ 1 ] + v2[ 1 ] + v3[ 1 ];\n        value[ 2 ] = v0[ 2 ] + v1[ 2 ] + v2[ 2 ] + v3[ 2 ];\n        channelInstance.key = i;\n    };\n\n} )();\n\n// must be sync wiht Interpolator Type\nvar ChannelType = Channel.ChannelType;\n\nvar moduleInterpolator = {};\n\n// refrence interpolator by channe enum id\nmoduleInterpolator[ ChannelType.Vec3 ] = Vec3LerpInterpolator;\nmoduleInterpolator[ ChannelType.Quat ] = QuatLerpInterpolator;\nmoduleInterpolator[ ChannelType.QuatSlerp ] = QuatSlerpInterpolator;\nmoduleInterpolator[ ChannelType.Float ] = FloatLerpInterpolator;\nmoduleInterpolator[ ChannelType.FloatCubicBezier ] = FloatCubicBezierInterpolator;\nmoduleInterpolator[ ChannelType.Vec3CubicBezier ] = Vec3CubicBezierInterpolator;\n\nmoduleInterpolator.Vec3LerpInterpolator = Vec3LerpInterpolator;\nmoduleInterpolator.QuatLerpInterpolator = QuatLerpInterpolator;\nmoduleInterpolator.QuatSlerpInterpolator = QuatSlerpInterpolator;\nmoduleInterpolator.FloatLerpInterpolator = FloatLerpInterpolator;\nmoduleInterpolator.FloatCubicBezierInterpolator = FloatCubicBezierInterpolator;\nmoduleInterpolator.Vec3CubicBezierInterpolator = Vec3CubicBezierInterpolator;\n\nmodule.exports = moduleInterpolator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/interpolator.js\n// module id = 136\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar AnimationUpdateCallback = require( 'osgAnimation/AnimationUpdateCallback' );\n\n\n// search into a subgraph all target\nvar CollectAnimationUpdateCallbackVisitor = function () {\n    NodeVisitor.call( this );\n    this._animationUpdateCallback = {};\n};\n\n\nCollectAnimationUpdateCallbackVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    getAnimationUpdateCallbackMap: function () {\n        return this._animationUpdateCallback;\n    },\n\n    apply: function ( node ) {\n        var cbs = node.getUpdateCallbackList();\n\n        // collect and remove animation update callback\n        for ( var i = 0, cbsLength = cbs.length; i < cbsLength; i++ ) {\n            var cb = cbs[ i ];\n            if ( cb instanceof AnimationUpdateCallback ) {\n                this._animationUpdateCallback[ cb.getInstanceID() ] = cb;\n                //node.removeUpdateCallback( cb );\n            }\n        }\n        this.traverse( node );\n    }\n\n} );\n\nmodule.exports = CollectAnimationUpdateCallbackVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/CollectAnimationUpdateCallbackVisitor.js\n// module id = 137\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar AnimationUpdateCallback = require( 'osgAnimation/AnimationUpdateCallback' );\nvar Target = require( 'osgAnimation/target' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\n\nvar UpdateMorph = function () {\n    AnimationUpdateCallback.call( this );\n\n    this._targets = []; // float target\n    this._targetNames = []; // names of targets\n    this._morphs = []; // the update morph can update several morphs\n\n    this._weights = new Float32Array( MorphGeometry.MAX_MORPH_GPU );\n    // stuffs to handles > max morph gpu targets\n    this._indexMap = new Uint32Array( MorphGeometry.MAX_MORPH_GPU ); // we map VA to the last gpu morphed VA targets\n    this._gpuMorphed = []; // size of this._targets, for each target a bool states if it's gpu morphed or not\n\n    this._maxMorphGPU = -1;\n};\n\nvar EFFECTIVE_EPS = MorphGeometry.EFFECTIVE_EPS; // in case we have more than 4 morphs, we can skip low effective weights\n\n// for sorting\nvar funcWeights = function ( a, b ) {\n    return Math.abs( b.value ) - Math.abs( a.value );\n};\n\nUpdateMorph.prototype = MACROUTILS.objectInherit( AnimationUpdateCallback.prototype, {\n\n    init: function ( node ) {\n        this._maxMorphGPU = MorphGeometry.MAX_MORPH_GPU;\n        this._morphs.length = 0;\n\n        //Find the morph geometry & init it\n        var children = node.getChildren();\n        for ( var i = 0, l = children.length; i < l; i++ ) {\n\n            var geom = children[ i ];\n            var morph;\n            if ( geom instanceof MorphGeometry ) {\n                morph = geom;\n            } else if ( geom instanceof RigGeometry && geom.getSourceGeometry() instanceof MorphGeometry ) {\n                morph = geom.getSourceGeometry();\n            }\n\n            if ( !morph ) continue;\n\n            if ( morph.getName() === this.getName() ) {\n                if ( !morph.isInitialized() )\n                    morph.init();\n\n                this._morphs.push( morph );\n                this._maxMorphGPU = Math.min( this._maxMorphGPU, morph.getMaximumPossibleMorphGPU() );\n            }\n        }\n    },\n\n    isInitialized: function () {\n        var morphs = this._morphs;\n        var nbMorphs = morphs.length;\n        if ( !nbMorphs ) return false;\n\n        for ( var i = 0; i < nbMorphs; ++i ) {\n            if ( !morphs[ i ].isInitialized() ) return false;\n        }\n\n        return true;\n    },\n\n    getNumTarget: function () {\n        return this._targets.length;\n    },\n\n    getTarget: function ( index ) {\n        return this._targets[ index ];\n    },\n\n    getTargetName: function ( index ) {\n        return this._targetNames[ index ];\n    },\n\n    addTarget: function ( name, index ) {\n        this._targets[ index ] = Target.createFloatTarget( 0 );\n        this._targetNames[ index ] = name;\n    },\n\n    _remapBufferArrays: function () {\n\n        // basically, this function remaps all the active morphed VA to the 4th first morphTargets VA\n        var indexMap = this._indexMap;\n        var morphs = this._morphs;\n        for ( var i = 0; i < this._maxMorphGPU; ++i ) {\n            var index = indexMap[ i ];\n            var strI = '_' + i;\n            var strIndex = '_' + index;\n\n            for ( var j = 0, nbMorphs = morphs.length; j < nbMorphs; ++j ) {\n\n                var morph = morphs[ j ];\n                var vAttrs = morph.getVertexAttributeList();\n                var morphNames = morph.getMorphTargetNames();\n                for ( var k = 0, nbNames = morphNames.length; k < nbNames; ++k ) {\n\n                    var attName = morphNames[ k ];\n                    vAttrs[ attName + strI ].setBufferArray( vAttrs[ attName + strIndex ].getInitialBufferArray() );\n\n                }\n            }\n        }\n    },\n\n    _mergeExtraMorphTarget: function ( attrs, attName, extraWeightSum ) {\n\n        var i = 0;\n        // ignore the gpu morphed\n        var gpuMorphed = this._gpuMorphed;\n        var vAttr = attrs[ attName ];\n        var vertexLen = vAttr.getElements().length;\n        var nbVertex = vertexLen / vAttr.getItemSize();\n        var itemSize = vAttr.getItemSize();\n\n        vAttr._cpuMorph = vAttr._cpuMorph || new BufferArray( BufferArray.ARRAY_BUFFER, new Float32Array( vertexLen ), itemSize );\n        var morphExtraTargets = vAttr._cpuMorph.getElements();\n        for ( i = 0; i < vertexLen; ++i ) {\n            morphExtraTargets[ i ] = 0.0;\n        }\n\n        var targets = this._targets;\n        for ( var j = 0, nb = targets.length; j < nb; ++j ) {\n\n            // ignore gpu morphed targets\n            if ( gpuMorphed[ j ] === true )\n                continue;\n\n            var weight = targets[ j ].value;\n            if ( Math.abs( weight ) < EFFECTIVE_EPS )\n                continue;\n\n            weight /= extraWeightSum;\n\n            var morphElts = attrs[ attName + '_' + j ].getInitialBufferArray().getElements();\n            for ( i = 0; i < nbVertex; ++i ) {\n\n                var k = i * itemSize;\n                morphExtraTargets[ k ] += weight * morphElts[ k ];\n                morphExtraTargets[ k + 1 ] += weight * morphElts[ k + 1 ];\n                morphExtraTargets[ k + 2 ] += weight * morphElts[ k + 2 ];\n                // don't morph tangent w component\n            }\n        }\n\n        // map on last index target\n        attrs[ attName + '_' + ( this._maxMorphGPU - 1 ) ].setBufferArray( vAttr._cpuMorph );\n        vAttr._cpuMorph.dirty();\n    },\n\n    _computeExtraWeightsSum: function () {\n        var gpuMorphed = this._gpuMorphed;\n        var sum = 0.0;\n        var targets = this._targets;\n        for ( var i = 0, nb = targets.length; i < nb; ++i ) {\n\n            // ignore gpu morphed targets\n            if ( gpuMorphed[ i ] === true )\n                continue;\n\n            var weight = targets[ i ].value;\n            if ( Math.abs( weight ) < EFFECTIVE_EPS )\n                continue;\n\n            sum += weight;\n        }\n        // check comment in _morphBufferArrayCPU (avoid near zero value)\n        var eps = 1e-5;\n        if ( Math.abs( sum ) > eps ) return sum;\n        return sum < 0.0 ? -eps : eps;\n    },\n\n    _morphBufferArrayCPU: function () {\n\n        // the idea is... we have :\n        // v' = v * (1-w1-w2-w3) + t1*w1 + t2*w2 + t3*w3\n        // we want\n        // v' = v * (1-w1-w4) + t1*w1 + t4*w4\n        // so basically we have to compute\n        // w4 = w2+w3 // (check if ~0 !)\n        // t4 = (t2*w2+t3*w3)/w4\n        // (w4 is extraWeightSum and t4 will be computed in _mergeExtraMorphTarget)\n\n        // compute new weights for the 4th target (all the extra target will be merged inside this one)\n        var extraWeightSum = this._weights[ this._maxMorphGPU - 1 ] = this._computeExtraWeightsSum();\n\n        var processed = {}; // handles referenced buffer array (avoid useless double morph computation the same buffer)\n        var morphs = this._morphs;\n        for ( var i = 0, nbMorphs = morphs.length; i < nbMorphs; ++i ) {\n\n            var morph = morphs[ i ];\n            var vAttrs = morph.getVertexAttributeList();\n            var morphNames = morph.getMorphTargetNames();\n\n            for ( var j = 0, nbNames = morphNames.length; j < nbNames; ++j ) {\n\n                var name = morphNames[ j ];\n                var attr = vAttrs[ name ];\n                // skip if the bufferArray is shared in another morphGeometry and has already been cpu morphed\n                if ( !attr || processed[ attr.getInstanceID() ] ) continue;\n                processed[ attr.getInstanceID() ] = true;\n\n                this._mergeExtraMorphTarget( vAttrs, name, extraWeightSum );\n            }\n        }\n    },\n\n    updateWeights: function () {\n\n        if ( this._maxMorphGPU === 0 )\n            return;\n\n        var i = 0;\n        var targets = this._targets;\n        var nbTargets = targets.length;\n        // reset weights\n        var weights = this._weights;\n        weights[ 0 ] = weights[ 1 ] = weights[ 2 ] = weights[ 3 ] = 0.0;\n\n        // no need to swap VA or to use CPU morph\n        if ( nbTargets <= this._maxMorphGPU ) {\n            for ( i = 0; i < nbTargets; ++i ) {\n                weights[ i ] = targets[ i ].value;\n            }\n            return;\n        }\n\n        // reset indexMap\n        var indexMap = this._indexMap;\n        indexMap[ 0 ] = indexMap[ 1 ] = indexMap[ 2 ] = indexMap[ 3 ] = 0;\n\n        // reset gpu morphed array\n        var gpuMorphed = this._gpuMorphed;\n        gpuMorphed.length = nbTargets;\n        for ( i = 0; i < nbTargets; ++i ) gpuMorphed[ i ] = false;\n\n        var sortedTargets = targets.slice( 0 ).sort( funcWeights );\n\n        for ( i = 0; i < this._maxMorphGPU; ++i ) {\n            var ti = targets.indexOf( sortedTargets[ i ] );\n            gpuMorphed[ ti ] = true;\n            indexMap[ i ] = ti;\n            weights[ i ] = sortedTargets[ i ].value;\n        }\n\n        // check more than 4 targets, we compute all the extra targets influence and merge in the last 4th morphs targets\n        var extraMorphCPU = Math.abs( sortedTargets[ this._maxMorphGPU ].value ) >= EFFECTIVE_EPS;\n        gpuMorphed[ indexMap[ this._maxMorphGPU - 1 ] ] = !extraMorphCPU;\n\n        this._remapBufferArrays();\n        if ( extraMorphCPU ) {\n            this._morphBufferArrayCPU();\n        }\n    },\n\n    update: function ( node /*, nv*/ ) {\n        if ( !this.isInitialized() )\n            this.init( node );\n\n        this.updateWeights();\n\n        var weights = this._weights;\n        var nbTargets = Math.min( this._maxMorphGPU, this._targets.length );\n        var morphs = this._morphs;\n        for ( var i = 0, nbMorphs = morphs.length; i < nbMorphs; ++i ) {\n\n            var array = morphs[ i ].getTargetsWeight();\n            for ( var j = 0; j < nbTargets; j++ ) {\n                array[ j ] = weights[ j ];\n            }\n        }\n\n        return true;\n    }\n} );\n\nmodule.exports = UpdateMorph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/UpdateMorph.js\n// module id = 138\n// module chunks = 0 1 2","'use strict';\n\nvar easeOutQuad = function ( t ) {\n    return -( t * ( t - 2.0 ) );\n};\nvar easeInQuad = function ( t ) {\n    return ( t * t );\n};\nvar easeOutCubic = function ( t ) {\n    t = t - 1.0;\n    return ( t * t * t + 1 );\n};\nvar easeInCubic = function ( t ) {\n    return ( t * t * t );\n};\nvar easeOutQuart = function ( t ) {\n    t = t - 1;\n    return -( t * t * t * t - 1 );\n};\nvar easeInQuart = function ( t ) {\n    return ( t * t * t * t );\n};\nvar easeOutElastic = function ( t ) {\n    return Math.pow( 2.0, -10.0 * t ) * Math.sin( ( t - 0.3 / 4.0 ) * ( 2.0 * Math.PI ) / 0.3 ) + 1.0;\n};\n//osgAnimation.EaseInElastic = function(t) { return ; };\nvar easeOutBounce = function ( t ) {\n    if ( t < ( 1 / 2.75 ) ) {\n        return ( 7.5625 * t * t );\n    } else if ( t < ( 2 / 2.75 ) ) {\n        return ( 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + 0.75 );\n    } else if ( t < ( 2.5 / 2.75 ) ) {\n        return ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375 );\n    } else {\n        return ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375 );\n    }\n};\n\nmodule.exports = {\n    easeOutQuad: easeOutQuad,\n    easeInQuad: easeInQuad,\n    easeOutCubic: easeOutCubic,\n    easeInCubic: easeInCubic,\n    easeOutQuart: easeOutQuart,\n    easeInQuart: easeInQuart,\n    easeOutElastic: easeOutElastic,\n    easeOutBounce: easeOutBounce,\n    EaseOutQuad: easeOutQuad,\n    EaseInQuad: easeInQuad,\n    EaseOutCubic: easeOutCubic,\n    EaseInCubic: easeInCubic,\n    EaseOutQuart: easeOutQuart,\n    EaseInQuart: easeInQuart,\n    EaseOutElastic: easeOutElastic,\n    EaseOutBounce: easeOutBounce\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/easing.js\n// module id = 139\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Target = require( 'osgAnimation/target' );\n\n\nvar StackedMatrix = function ( name, matrix ) {\n    Object.call( this );\n    this._target = Target.createMatrixTarget( matrix || mat4.IDENTITY );\n    if ( name ) this.setName( name );\n};\n\nStackedMatrix.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( matrix ) {\n        this.setMatrix( matrix );\n        mat4.copy( this._target.defaultValue, matrix );\n    },\n\n    getTarget: function () {\n        return this._target;\n    },\n\n    getMatrix: function () {\n        return this._target.value;\n    },\n\n    setMatrix: function ( m ) {\n        mat4.copy( this._target.value, m );\n    },\n\n    resetToDefaultValue: function () {\n        this.setMatrix( this._target.defaultValue );\n    },\n\n    applyToMatrix: function ( m ) {\n        mat4.mul( m, m, this._target.value );\n    }\n\n} );\n\nmodule.exports = StackedMatrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/StackedMatrix.js\n// module id = 140\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar Target = require( 'osgAnimation/target' );\n\nvar qIdentity = quat.create();\n\nvar StackedQuaternion = function ( name, q ) {\n    Object.call( this );\n    this._target = Target.createQuatTarget( q || qIdentity );\n    if ( name ) this.setName( name );\n};\n\nStackedQuaternion.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( q ) {\n        this.setQuaternion( q );\n        quat.copy( this._target.defaultValue, q );\n    },\n\n    setQuaternion: function ( q ) {\n        quat.copy( this._target.value, q );\n    },\n\n    getTarget: function () {\n        return this._target;\n    },\n\n    resetToDefaultValue: function () {\n        this.setQuaternion( this._target.defaultValue );\n    },\n\n    applyToMatrix: ( function () {\n        var matrixTmp = mat4.create();\n\n        return function applyToMatrix( m ) {\n            var mtmp = matrixTmp;\n            mat4.fromQuat( mtmp, this._target.value );\n            mat4.mul( m, m, mtmp );\n        };\n    } )()\n\n} );\n\nmodule.exports = StackedQuaternion;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/StackedQuaternion.js\n// module id = 141\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar Target = require( 'osgAnimation/target' );\n\n\nvar StackedRotateAxis = function ( name, axis, angle ) {\n    Object.call( this );\n    this._axis = vec3.fromValues( 0, 0, 1 );\n    if ( axis ) vec3.copy( this._axis, axis );\n    this._target = Target.createFloatTarget( typeof angle === 'number' ? angle : 0.0 );\n    if ( name ) this.setName( name );\n};\n\nStackedRotateAxis.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( axis, angle ) {\n        this.setAxis( axis );\n        this.setAngle( angle );\n        this._target.defaultValue = angle;\n    },\n\n    setAxis: function ( axis ) {\n        vec3.copy( this._axis, axis );\n    },\n\n    setAngle: function ( angle ) {\n        this._target.value = angle;\n    },\n\n    getTarget: function () {\n        return this._target;\n    },\n\n    resetToDefaultValue: function () {\n        this.setAngle( this._target.defaultValue );\n    },\n\n    applyToMatrix: ( function () {\n        var matrixTmp = mat4.create();\n        var quatTmp = quat.create();\n\n        return function ( m ) {\n            var axis = this._axis;\n            var qtmp = quatTmp;\n            var mtmp = matrixTmp;\n            var angle = this._target.value;\n\n            quat.setAxisAngle( qtmp, axis, angle );\n            mat4.fromQuat( mtmp, qtmp );\n            mat4.mul( m, m, mtmp );\n        };\n    } )()\n\n} );\n\nmodule.exports = StackedRotateAxis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/StackedRotateAxis.js\n// module id = 142\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Target = require( 'osgAnimation/target' );\n\n\nvar StackedScale = function ( name, scale ) {\n    Object.call( this );\n    this._target = Target.createVec3Target( scale || vec3.ONE );\n    if ( name ) this.setName( name );\n};\n\n\nStackedScale.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( scale ) {\n        this.setScale( scale );\n        vec3.copy( this._target.defaultValue, scale );\n    },\n\n    setScale: function ( scale ) {\n        vec3.copy( this._target.value, scale );\n    },\n\n    getTarget: function () {\n        return this._target;\n    },\n\n    resetToDefaultValue: function () {\n        this.setScale( this._target.defaultValue );\n    },\n\n    // must be optimized\n    applyToMatrix: function ( m ) {\n\n        var scale = this._target.value;\n        mat4.scale( m, m, scale );\n\n    }\n\n} );\n\nmodule.exports = StackedScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/StackedScale.js\n// module id = 143\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Target = require( 'osgAnimation/target' );\n\n\n/**\n *  StackedTranslate\n */\nvar StackedTranslate = function ( name, translate ) {\n    Object.call( this );\n    this._target = Target.createVec3Target( translate || vec3.ZERO );\n    if ( name ) this.setName( name );\n};\n\n\nStackedTranslate.prototype = MACROUTILS.objectInherit( Object.prototype, {\n\n    init: function ( translate ) {\n        this.setTranslate( translate );\n        vec3.copy( this._target.defaultValue, translate );\n    },\n\n    setTranslate: function ( translate ) {\n        vec3.copy( this._target.value, translate );\n    },\n\n    getTarget: function () {\n        return this._target;\n    },\n\n    resetToDefaultValue: function () {\n        this.setTranslate( this._target.defaultValue );\n    },\n\n    applyToMatrix: function ( m ) {\n        mat4.translate( m, m, this._target.value );\n    }\n} );\n\nmodule.exports = StackedTranslate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgAnimation/StackedTranslate.js\n// module id = 144\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Input = require( 'osgDB/Input' );\nvar ReaderParser = require( 'osgDB/readerParser' );\nvar DatabasePager = require( 'osgDB/DatabasePager' );\nvar osgWrappers = require( 'osgWrappers/serializers/osg' );\nvar osgAnimationWrappers = require( 'osgWrappers/serializers/osgAnimation' );\nvar osgTextWrappers = require( 'osgWrappers/serializers/osgText' );\nvar Registry = require( 'osgDB/Registry' );\nvar FileHelper = require( 'osgDB/FileHelper' );\n\nvar osgDB = {};\nosgDB.Input = Input;\nMACROUTILS.objectMix( osgDB, ReaderParser );\nosgDB.DatabasePager = DatabasePager;\nosgDB.ObjectWrapper.serializers.osg = osgWrappers;\nosgDB.ObjectWrapper.serializers.osgAnimation = osgAnimationWrappers;\nosgDB.ObjectWrapper.serializers.osgText = osgTextWrappers;\nosgDB.Registry = Registry;\nosgDB.FileHelper = FileHelper;\nosgDB.requestFile = require( 'osgDB/requestFile' );\n\nvar zlib = require( 'osgDB/zlib' );\nMACROUTILS.objectMix( osgDB, zlib );\n\nmodule.exports = osgDB;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/osgDB.js\n// module id = 145\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar osgNameSpace = require( 'osgNameSpace' );\nvar _requestFile = require( 'osgDB/requestFile' );\nvar Options = require( 'osgDB/options' );\nvar zlib = require( 'osgDB/zlib' );\nvar Notify = require( 'osg/notify' );\nvar Image = require( 'osg/Image' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar DrawArrayLengths = require( 'osg/DrawArrayLengths' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\n\n\nvar Input = function ( json, identifier ) {\n    this._json = json;\n    var map = identifier;\n    if ( map === undefined ) {\n        map = {};\n    }\n    this._identifierMap = map;\n    this._objectRegistry = {};\n\n    this._cacheReadObject = {}; //wrappers\n\n    // this._progressXHRCallback = undefined;\n    // this._prefixURL = '';\n    // this.setImageLoadingOptions( {\n    //     promise: true,\n    //     onload: undefined\n    // } );\n\n    this.setOptions( MACROUTILS.objectMix( {}, Options ) );\n\n    // {\n    //     prefixURL: '',\n    //     progressXHRCallback: undefined,\n    //     readImageURL: undefined,\n    //     imageLoadingUsePromise: undefined,\n    //     imageOnload: undefined,\n    // };\n};\n\n\n// keep one instance of image fallback\nif ( !Input.imageFallback ) {\n    Input.imageFallback = ( function () {\n        var fallback = new window.Image();\n        fallback.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2P8DwQACgAD/il4QJ8AAAAASUVORK5CYII=';\n        return fallback;\n    } )();\n}\n\nInput.prototype = {\n\n    clone: function () {\n        var input = new Input();\n        input._objectRegistry = this._objectRegistry;\n        input._cacheReadObject = this._cacheReadObject;\n        return input;\n    },\n\n    setOptions: function ( options ) {\n        this._defaultOptions = options;\n    },\n    getOptions: function () {\n        return this._defaultOptions;\n    },\n    setProgressXHRCallback: function ( func ) {\n        this._defaultOptions.progressXHRCallback = func;\n    },\n    setReadNodeURLCallback: function ( func ) {\n        this._defaultOptions.readNodeURL = func;\n    },\n    // used to override the type from pathname\n    // typically if you want to create proxy object\n    registerObject: function ( fullyQualifiedObjectname, constructor ) {\n        this._objectRegistry[ fullyQualifiedObjectname ] = constructor;\n    },\n\n    getJSON: function () {\n        return this._json;\n    },\n\n    setJSON: function ( json ) {\n        this._json = json;\n        return this;\n    },\n\n    setPrefixURL: function ( prefix ) {\n        this._defaultOptions.prefixURL = prefix;\n    },\n\n    getPrefixURL: function () {\n        return this._defaultOptions.prefixURL;\n    },\n\n    setDatabasePath: function ( path ) {\n        this._defaultOptions.databasePath = path;\n    },\n\n    getDatabasePath: function () {\n        return this._defaultOptions.databasePath;\n    },\n\n    computeURL: function ( url ) {\n\n        if ( typeof this._defaultOptions.prefixURL === 'string' &&\n            this._defaultOptions.prefixURL.length > 0 ) {\n\n            return this._defaultOptions.prefixURL + url;\n        }\n\n        return url;\n    },\n\n\n    requestFile: function ( url, options ) {\n        return _requestFile( url, options );\n    },\n\n    getObjectWrapper: function ( path ) {\n        if ( this._objectRegistry[ path ] ) {\n            return new( this._objectRegistry[ path ] )();\n        }\n\n        var scope = osgNameSpace;\n        var splittedPath = path.split( '.' );\n        for ( var i = 0, l = splittedPath.length; i < l; i++ ) {\n            var obj = scope[ splittedPath[ i ] ];\n            if ( obj === undefined ) {\n                return undefined;\n            }\n            scope = obj;\n        }\n        this._objectRegistry[ path ] = scope;\n        // create the new obj\n        return new( scope )();\n    },\n\n    fetchImage: function ( image, url, options, defer ) {\n        var checkInlineImage = 'data:image/';\n        // crossOrigin does not work for inline data image\n        var isInlineImage = ( url.substring( 0, checkInlineImage.length ) === checkInlineImage );\n        var img = new window.Image();\n        img.onerror = function () {\n            Notify.warn( 'warning use white texture as fallback instead of ' + url );\n            image.setImage( Input.imageFallback );\n            if ( defer ) {\n                defer.resolve( image );\n            }\n        };\n\n        if ( !isInlineImage && options.imageCrossOrigin ) {\n            img.crossOrigin = options.imageCrossOrigin;\n        }\n\n        img.onload = function () {\n\n            if ( defer ) {\n                if ( options.imageOnload ) options.imageOnload.call( image );\n                defer.resolve( image );\n            } else if ( options.imageOnload )\n                options.imageOnload.call( image );\n\n        };\n\n        image.setURL( url );\n        image.setImage( img );\n\n        img.src = url;\n        return image;\n    },\n\n    readImageURL: function ( url, options ) {\n\n        if ( options === undefined ) {\n            options = this._defaultOptions;\n        }\n\n        // hook reader\n        if ( options.readImageURL ) {\n            // be carefull if you plan to call hook the call and after\n            // call the original readImageURL, you will need to remove\n            // from options the readImageURL if you dont want an infinte\n            // recursion call\n            return options.readImageURL.call( this, url, options );\n        }\n\n        // if image is on inline image skip url computation\n        if ( url.substr( 0, 10 ) !== 'data:image' ) {\n            url = this.computeURL( url );\n        }\n\n\n        var image = new Image();\n        if ( options.imageLoadingUsePromise !== true ) {\n            return this.fetchImage( image, url, options );\n        }\n\n        var defer = P.defer();\n        this.fetchImage( image, url, options, defer );\n\n        return defer.promise;\n    },\n\n\n    readNodeURL: function ( url, opt ) {\n\n        var options = opt;\n        if ( options === undefined ) {\n            options = this._defaultOptions;\n        }\n\n        // hook reader\n        if ( options.readNodeURL ) {\n            // be carefull if you plan to call hook the call and after\n            // call the original readNodeURL, you will need to remove\n            // from options the readNodeURL if you dont want an infinte\n            // recursion call\n            return options.readNodeURL.call( this, url, options );\n        }\n\n        url = this.computeURL( url );\n\n        var defer = P.defer();\n\n        // copy because we are going to modify it to have relative prefix to load assets\n        options = MACROUTILS.objectMix( {}, options );\n\n        // automatic prefix if non specfied\n        if ( !!!options.prefixURL ) {\n            var prefix = this.getPrefixURL();\n            var index = url.lastIndexOf( '/' );\n            if ( index !== -1 ) {\n                prefix = url.substring( 0, index + 1 );\n            }\n            options.prefixURL = prefix;\n        }\n\n        var self = this;\n\n        var ReaderParser = require( 'osgDB/readerParser' );\n\n        var readSceneGraph = function ( data ) {\n\n            ReaderParser.parseSceneGraph( data, options ).then( function ( child ) {\n                defer.resolve( child );\n                Notify.log( 'loaded ' + url );\n            } ).catch( defer.reject.bind( defer ) );\n        };\n\n        var ungzipFile = function ( arrayBuffer ) {\n\n            function pad( n ) {\n                return n.length < 2 ? '0' + n : n;\n            }\n\n            function uintToString( uintArray ) {\n                var str = '';\n                for ( var i = 0, len = uintArray.length; i < len; ++i ) {\n                    str += ( '%' + pad( uintArray[ i ].toString( 16 ) ) );\n                }\n                str = decodeURIComponent( str );\n                return str;\n            }\n\n\n            var unpacked = arrayBuffer;\n            if ( zlib.isGunzipBuffer( arrayBuffer ) ) {\n                unpacked = zlib.gunzip( arrayBuffer );\n            }\n\n            var typedArray = new Uint8Array( unpacked );\n            var str = uintToString( typedArray );\n            return str;\n        };\n\n\n        // try to get the file as responseText to parse JSON\n        var fileTextPromise = self.requestFile( url );\n        fileTextPromise.then( function ( str ) {\n\n            var data;\n            try {\n\n                data = JSON.parse( str );\n\n            } catch ( error ) { // can't parse try with ungzip code path\n\n                Notify.error( 'cant parse url ' + url + ' try to gunzip' );\n\n            }\n\n            // we have the json, read it\n            if ( data )\n                return readSceneGraph( data );\n\n\n            // no data try with gunzip\n            var fileGzipPromise = self.requestFile( url, {\n                responseType: 'arraybuffer'\n            } );\n            fileGzipPromise.then( function ( file ) {\n\n                var str = ungzipFile( file );\n                data = JSON.parse( str );\n                readSceneGraph( data );\n\n            } ).catch( function ( status ) {\n\n                Notify.error( 'cant read file ' + url + ' status ' + status );\n                defer.reject();\n\n            } ).done();\n\n            return true;\n\n        } ).catch( function ( status ) {\n\n            Notify.error( 'cant get file ' + url + ' status ' + status );\n            defer.reject();\n\n        } ).done();\n\n        return defer.promise;\n    },\n\n    _unzipTypedArray: function ( binary ) {\n\n        var typedArray = new Uint8Array( binary );\n\n        // check magic number 1f8b\n        if ( typedArray[ 0 ] === 0x1f && typedArray[ 1 ] === 0x8b ) {\n            var zlib = require( 'zlib' );\n\n            if ( !zlib ) {\n                Notify.error( 'osg failed to use a gunzip.min.js to uncompress a gz file.\\n You can add this vendors to enable this feature or adds the good header in your gzip file served by your server' );\n            }\n\n            var zdec = new zlib.Gunzip( typedArray );\n            var result = zdec.decompress();\n            return result.buffer;\n        }\n\n        return binary;\n    },\n\n    readBinaryArrayURL: function ( url, options ) {\n\n        if ( options === undefined ) {\n            options = this._defaultOptions;\n        }\n\n        if ( options.readBinaryArrayURL ) {\n            return options.readBinaryArrayURL.call( this, url, options );\n        }\n\n        url = this.computeURL( url );\n\n\n        if ( this._identifierMap[ url ] !== undefined ) {\n            return this._identifierMap[ url ];\n        }\n        var defer = P.defer();\n\n        var filePromise = this.requestFile( url, {\n            responseType: 'arraybuffer',\n            progress: this._defaultOptions.progressXHRCallback\n        } );\n\n        this._identifierMap[ url ] = defer.promise;\n        filePromise.then( function ( file ) {\n            defer.resolve( this._unzipTypedArray( file ) );\n        }.bind( this ) );\n\n        return defer.promise;\n    },\n\n    initializeBufferArray: function ( vb, type, buf, options ) {\n        if ( options === undefined )\n            options = this.getOptions();\n        if ( options.initializeBufferArray )\n            return options.initializeBufferArray.call( this, vb, type, buf );\n\n        var url = vb.File;\n        var defer = P.defer();\n        this.readBinaryArrayURL( url ).then( function ( array ) {\n\n            var typedArray;\n            // manage endianness\n            var bigEndian;\n            ( function () {\n                var a = new Uint8Array( [ 0x12, 0x34 ] );\n                var b = new Uint16Array( a.buffer );\n                bigEndian = ( ( b[ 0 ] ).toString( 16 ) === '1234' );\n            } )();\n\n            var offset = 0;\n            if ( vb.Offset !== undefined ) {\n                offset = vb.Offset;\n            }\n\n            var bytesPerElement = MACROUTILS[ type ].BYTES_PER_ELEMENT;\n            var nbItems = vb.Size;\n            var nbCoords = buf.getItemSize();\n            var totalSizeInBytes = nbItems * bytesPerElement * nbCoords;\n\n            if ( bigEndian ) {\n                Notify.log( 'big endian detected' );\n                var TypedArray = MACROUTILS[ type ];\n                var tmpArray = new TypedArray( nbItems * nbCoords );\n                var data = new DataView( array, offset, totalSizeInBytes );\n                var i = 0,\n                    l = tmpArray.length;\n                if ( type === 'Uint16Array' ) {\n                    for ( ; i < l; i++ ) {\n                        tmpArray[ i ] = data.getUint16( i * bytesPerElement, true );\n                    }\n                } else if ( type === 'Float32Array' ) {\n                    for ( ; i < l; i++ ) {\n                        tmpArray[ i ] = data.getFloat32( i * bytesPerElement, true );\n                    }\n                }\n                typedArray = tmpArray;\n                data = null;\n            } else {\n                typedArray = new MACROUTILS[ type ]( array, offset, nbCoords * nbItems );\n            }\n\n            buf.setElements( typedArray );\n            defer.resolve( buf );\n        } ).catch( function () {\n            Notify.warn( 'Can\\'t read binary array URL' );\n        } );\n        return defer.promise;\n    },\n\n    readBufferArray: function ( options ) {\n        var jsonObj = this.getJSON();\n\n        var uniqueID = jsonObj.UniqueID;\n        var osgjsObject;\n        if ( uniqueID !== undefined ) {\n            osgjsObject = this._identifierMap[ uniqueID ];\n            if ( osgjsObject !== undefined ) {\n                return osgjsObject;\n            }\n        }\n\n        if ( options === undefined )\n            options = this.getOptions();\n        if ( options.readBufferArray )\n            return options.readBufferArray.call( this );\n\n        if ( ( !jsonObj.Elements && !jsonObj.Array ) || !jsonObj.ItemSize || !jsonObj.Type )\n            return P.reject();\n\n        var promise;\n\n        // inline array\n        if ( jsonObj.Elements ) {\n            promise = P.resolve( new BufferArray( BufferArray[ jsonObj.Type ], jsonObj.Elements, jsonObj.ItemSize ) );\n\n        } else if ( jsonObj.Array ) {\n\n            var buf = new BufferArray( BufferArray[ jsonObj.Type ] );\n            buf.setItemSize( jsonObj.ItemSize );\n\n            var vb, type;\n            if ( jsonObj.Array.Float32Array ) {\n                vb = jsonObj.Array.Float32Array;\n                type = 'Float32Array';\n            } else if ( jsonObj.Array.Uint16Array ) {\n                vb = jsonObj.Array.Uint16Array;\n                type = 'Uint16Array';\n            } else if ( jsonObj.Array.Uint8Array ) {\n                vb = jsonObj.Array.Uint8Array;\n                type = 'Uint8Array';\n            }\n\n            if ( vb === undefined ) {\n                Notify.warn( 'Typed Array ' + window.Object.keys( jsonObj.Array )[ 0 ] );\n                return P.reject();\n            }\n\n            if ( vb.File ) {\n                promise = this.initializeBufferArray( vb, type, buf );\n            } else if ( vb.Elements ) {\n                buf.setElements( new MACROUTILS[ type ]( vb.Elements ) );\n                promise = P.resolve( buf );\n            }\n        }\n\n        if ( uniqueID !== undefined ) {\n            this._identifierMap[ uniqueID ] = promise;\n        }\n        return promise;\n    },\n\n    readUserDataContainer: function () {\n        var jsonObj = this.getJSON();\n        var osgjsObject;\n        var uniqueID = jsonObj.UniqueID;\n        if ( uniqueID !== undefined ) {\n            osgjsObject = this._identifierMap[ uniqueID ];\n            if ( osgjsObject !== undefined ) {\n                return osgjsObject.Values;\n            }\n        }\n\n        this._identifierMap[ uniqueID ] = jsonObj;\n        return jsonObj.Values;\n    },\n\n    readPrimitiveSet: function () {\n        var jsonObj = this.getJSON();\n        var uniqueID;\n        var osgjsObject;\n\n        var defer = P.defer();\n        var obj, mode, first, count;\n        var drawElementPrimitive = jsonObj.DrawElementUShort || jsonObj.DrawElementUByte || jsonObj.DrawElementUInt || jsonObj.DrawElementsUShort || jsonObj.DrawElementsUByte || jsonObj.DrawElementsUInt || undefined;\n        if ( drawElementPrimitive ) {\n\n            uniqueID = drawElementPrimitive.UniqueID;\n            if ( uniqueID !== undefined ) {\n                osgjsObject = this._identifierMap[ uniqueID ];\n                if ( osgjsObject !== undefined ) {\n                    return osgjsObject;\n                }\n            }\n\n            var jsonArray = drawElementPrimitive.Indices;\n            var prevJson = jsonObj;\n\n            mode = drawElementPrimitive.Mode;\n            if ( !mode ) {\n                mode = PrimitiveSet.TRIANGLES;\n            } else {\n                mode = PrimitiveSet[ mode ];\n            }\n            obj = new DrawElements( mode );\n\n            this.setJSON( jsonArray );\n            this.readBufferArray().then( function ( array ) {\n                obj.setIndices( array );\n                defer.resolve( obj );\n            } ).catch( function () {\n                Notify.warn( 'Error buffer array' );\n            } );\n            this.setJSON( prevJson );\n        }\n\n        var drawArrayPrimitive = jsonObj.DrawArray || jsonObj.DrawArrays;\n        if ( drawArrayPrimitive ) {\n\n            uniqueID = drawArrayPrimitive.UniqueID;\n            if ( uniqueID !== undefined ) {\n                osgjsObject = this._identifierMap[ uniqueID ];\n                if ( osgjsObject !== undefined ) {\n                    return osgjsObject;\n                }\n            }\n\n            mode = drawArrayPrimitive.Mode || drawArrayPrimitive.mode;\n            first = drawArrayPrimitive.First !== undefined ? drawArrayPrimitive.First : drawArrayPrimitive.first;\n            count = drawArrayPrimitive.Count !== undefined ? drawArrayPrimitive.Count : drawArrayPrimitive.count;\n            var drawArray = new DrawArrays( PrimitiveSet[ mode ], first, count );\n            defer.resolve( drawArray );\n        }\n\n        var drawArrayLengthsPrimitive = jsonObj.DrawArrayLengths || undefined;\n        if ( drawArrayLengthsPrimitive ) {\n\n            uniqueID = drawArrayLengthsPrimitive.UniqueID;\n            if ( uniqueID !== undefined ) {\n                osgjsObject = this._identifierMap[ uniqueID ];\n                if ( osgjsObject !== undefined ) {\n                    return osgjsObject;\n                }\n            }\n\n            mode = drawArrayLengthsPrimitive.Mode;\n            first = drawArrayLengthsPrimitive.First;\n            var array = drawArrayLengthsPrimitive.ArrayLengths;\n            var drawArrayLengths = new DrawArrayLengths( PrimitiveSet[ mode ], first, array );\n            defer.resolve( drawArrayLengths );\n        }\n\n        if ( uniqueID !== undefined ) {\n            this._identifierMap[ uniqueID ] = defer.promise;\n        }\n\n        return defer.promise;\n    },\n\n\n    readObject: function () {\n\n        var jsonObj = this.getJSON();\n        var prop = window.Object.keys( jsonObj )[ 0 ];\n        if ( !prop ) {\n            Notify.warn( 'can\\'t find property for object ' + jsonObj );\n            return P.reject();\n        }\n\n        var uniqueID = jsonObj[ prop ].UniqueID;\n        var osgjsObject;\n        if ( uniqueID !== undefined ) {\n            osgjsObject = this._identifierMap[ uniqueID ];\n            if ( osgjsObject !== undefined ) {\n                return osgjsObject;\n            }\n        }\n\n        var obj = this.getObjectWrapper( prop );\n\n        if ( !obj ) {\n            Notify.warn( 'can\\'t instanciate object ' + prop );\n            return P.reject();\n        }\n\n        var ReaderParser = require( 'osgDB/readerParser' );\n        var scope = ReaderParser.ObjectWrapper.serializers;\n\n        if ( this._cacheReadObject[ prop ] ) {\n            scope = this._cacheReadObject[ prop ];\n        } else {\n\n            var splittedPath = prop.split( '.' );\n            for ( var i = 0, l = splittedPath.length; i < l; i++ ) {\n                var reader = scope[ splittedPath[ i ] ];\n                if ( reader === undefined ) {\n                    Notify.warn( 'can\\'t find function to read object ' + prop + ' - undefined' );\n                    return P.reject();\n                }\n                scope = reader;\n            }\n            this._cacheReadObject[ prop ] = scope;\n        }\n\n        var promise = scope( this.setJSON( jsonObj[ prop ] ), obj );\n\n        if ( uniqueID !== undefined ) {\n            this._identifierMap[ uniqueID ] = promise;\n            obj._uniqueID = uniqueID;\n        }\n\n        return promise;\n    }\n};\n\nmodule.exports = Input;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/Input.js\n// module id = 146\n// module chunks = 0 1 2","var P = require( 'bluebird' );\n\nvar requestFileFromURL = function ( url, options ) {\n\n    var defer = P.defer();\n\n    var req = new XMLHttpRequest();\n    req.open( 'GET', url, true );\n\n    // handle responseType\n    if ( options && options.responseType )\n        req.responseType = options.responseType;\n\n    if ( options && options.progress ) {\n        req.addEventListener( 'progress', options.progress, false );\n    }\n\n    req.addEventListener( 'error', function () {\n        defer.reject();\n    }, false );\n\n    req.addEventListener( 'load', function () {\n\n        if ( req.responseType === 'arraybuffer' || req.responseType === 'blob' )\n            defer.resolve( req.response );\n        else\n            defer.resolve( req.responseText );\n\n    } );\n\n    req.send( null );\n    return defer.promise;\n};\n\nvar requestFileFromReader = function ( file, options ) {\n    var defer = Promise.defer();\n    var reader = new window.FileReader();\n    reader.onload = function ( data ) {\n        if ( options.responseType === 'blob' ) {\n            var img = new window.Image();\n            img.src = data.target.result;\n            defer.resolve( img );\n        } else {\n            defer.resolve( data.target.result );\n        }\n    };\n    // handle responseType\n    if ( options && options.responseType ) {\n        if ( options.responseType === 'arraybuffer' )\n            reader.readAsArrayBuffer( file );\n        else if ( options.responseType === 'string' )\n            reader.readAsText( file );\n        else\n            reader.readAsDataURL( file );\n    } else {\n        reader.readAsText( file );\n    }\n    return defer.promise;\n};\n\nvar requestFile = function ( urlOrFile, options ) {\n    if ( typeof ( urlOrFile ) === 'string' ) {\n        return requestFileFromURL( urlOrFile, options );\n    } else {\n        return requestFileFromReader( urlOrFile, options );\n    }\n};\n\nmodule.exports = requestFile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/requestFile.js\n// module id = 147\n// module chunks = 0 1 2","'use strict';\nvar defaultOptions = {\n\n    // prefix to built url to load resource\n    prefixURL: '',\n\n    // database URL for PagedLOD structures\n    databasePath: '',\n\n    // callback used when loading data\n    progressXHRCallback: undefined,\n\n    // replacement of readImageURL to use your own code to load Nodes\n    // the function will be execute in the context of Input, see Input:readNodeURL\n    readNodeURL: undefined,\n\n    // replacement of readImageURL to use your own code to load osg.Image\n    // the function will be execute in the context of Input, see Input:readImageURL\n    readImageURL: undefined,\n\n    // replacement of readBinaryArrayURL to use your own code to load binary array\n    // the function will be execute in the context of Input, see Input:readBinaryArrayURL\n    readBinaryArrayURL: undefined,\n\n    imageLoadingUsePromise: true, // use promise to load image instead of returning Image\n    imageOnload: undefined, // use callback when loading an image\n    imageCrossOrigin: undefined // use callback when loading an image\n};\n\nmodule.exports = defaultOptions;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/options.js\n// module id = 148\n// module chunks = 0 1 2","var notify = require( 'osg/notify' );\n\nvar isBufferGZIP = function ( arrayBuffer ) {\n    var typedArray = new Uint8Array( arrayBuffer );\n    return ( typedArray[ 0 ] === 0x1f && typedArray[ 1 ] === 0x8b );\n};\n\nvar gunzip = function ( arrayBuffer ) {\n\n    var typedArray = new Uint8Array( arrayBuffer );\n    var zlib = require( 'zlib' );\n\n    if ( !zlib ) {\n        notify.error( 'osg failed to use a gunzip.min.js to uncompress a gz file.\\n You can add this vendors to enable this feature or get it at https://github.com/imaya/zlib.js/blob/master/bin/gunzip.min.js' );\n    }\n\n    var zdec = new zlib.Gunzip( typedArray );\n    var result = zdec.decompress();\n    return result.buffer;\n\n};\n\nmodule.exports = {\n    isGunzipBuffer: isBufferGZIP,\n    gunzip: gunzip\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/zlib.js\n// module id = 149\n// module chunks = 0 1 2","module.exports = __WEBPACK_EXTERNAL_MODULE_150__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Zlib\",\"commonjs2\":\"zlib\",\"commonjs\":\"zlib\",\"amd\":\"zlib\"}\n// module id = 150\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Uniform = require( 'osg/Uniform' );\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar Geometry = require( 'osg/Geometry' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar StateSet = require( 'osg/StateSet' );\nvar Node = require( 'osg/Node' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Projection = require( 'osg/Projection' );\nvar Registry = require( 'osgDB/Registry' );\n\nvar ReaderParser = {};\n\nReaderParser.ObjectWrapper = {};\nReaderParser.ObjectWrapper.serializers = {};\n\nReaderParser.readImage = function ( url, options ) {\n    return ReaderParser.registry().readImageURL( url, options );\n};\nReaderParser.readImageURL = ReaderParser.readImage; // alias\n\nReaderParser.readBinaryArrayURL = function ( url, options ) {\n    return ReaderParser.registry().readBinaryArrayURL( url, options );\n};\n\nReaderParser.readNodeURL = function ( url, options ) {\n    var extension = url.substr( url.lastIndexOf( '.' ) + 1 );\n    var readerWriter = Registry.instance().getReaderWriterForExtension( extension );\n    if ( readerWriter !== undefined )\n        return readerWriter.readNodeURL( url, options );\n    // If we don't have a registered plugin go through the osgjs\n    // FIXME: we should have osgjs also as a plugin in the future\n    return ReaderParser.registry().readNodeURL( url, options );\n};\n\nReaderParser.registry = function () {\n    var Input = require( 'osgDB/Input' );\n    if ( ReaderParser.registry._input === undefined ) {\n        ReaderParser.registry._input = new Input();\n    }\n    return ReaderParser.registry._input;\n};\n\nReaderParser.parseSceneGraph = function ( node, options ) {\n    if ( node.Version !== undefined && node.Version > 0 ) {\n        MACROUTILS.time( 'osgjs.metric:ReaderParser.parseSceneGraph' );\n\n        var key;\n        for ( var prop in node ) {\n            if ( prop !== 'Generator' && prop !== 'Version' ) {\n                key = prop;\n                break;\n            }\n        }\n\n        if ( key ) {\n            var obj = {};\n            obj[ key ] = node[ key ];\n            var input = ReaderParser.registry().clone();\n            input.setJSON( obj );\n\n            // copy global options and override with user options\n            var opt = MACROUTILS.objectMix( MACROUTILS.objectMix( {}, ReaderParser.registry().getOptions() ), options || {} );\n            input.setOptions( opt );\n            var object = input.readObject();\n            MACROUTILS.timeEnd( 'osgjs.metric:ReaderParser.parseSceneGraph' );\n            return object;\n        } else {\n            Notify.log( 'can\\'t parse scenegraph ' + node );\n        }\n    } else {\n        MACROUTILS.time( 'osgjs.metric:ReaderParser.parseSceneGraphDeprecated' );\n        var nodeOld = ReaderParser.parseSceneGraphDeprecated( node );\n        MACROUTILS.timeEnd( 'osgjs.metric:ReaderParser.parseSceneGraphDeprecated' );\n        return nodeOld;\n    }\n    return undefined;\n};\n\nReaderParser.parseSceneGraphDeprecated = function ( node ) {\n    var getFieldBackwardCompatible = function ( field, json ) {\n        var value = json[ field ];\n        if ( value === undefined ) {\n            value = json[ field.toLowerCase() ];\n        }\n        return value;\n    };\n    var setName = function ( osgjs, json ) {\n        var name = getFieldBackwardCompatible( 'Name', json );\n        if ( name && osgjs.setName !== undefined ) {\n            osgjs.setName( name );\n        }\n    };\n\n    var setMaterial = function ( osgjs, json ) {\n        setName( osgjs, json );\n        osgjs.setAmbient( getFieldBackwardCompatible( 'Ambient', json ) );\n        osgjs.setDiffuse( getFieldBackwardCompatible( 'Diffuse', json ) );\n        osgjs.setEmission( getFieldBackwardCompatible( 'Emission', json ) );\n        osgjs.setSpecular( getFieldBackwardCompatible( 'Specular', json ) );\n        osgjs.setShininess( getFieldBackwardCompatible( 'Shininess', json ) );\n    };\n\n    var setBlendFunc = function ( osgjs, json ) {\n        setName( osgjs, json );\n        osgjs.setSourceRGB( json.SourceRGB );\n        osgjs.setSourceAlpha( json.SourceAlpha );\n        osgjs.setDestinationRGB( json.DestinationRGB );\n        osgjs.setDestinationAlpha( json.DestinationAlpha );\n    };\n\n    var setTexture = function ( osgjs, json ) {\n        var magFilter = json.MagFilter || json[ 'mag_filter' ] || undefined;\n        if ( magFilter ) {\n            osgjs.setMagFilter( magFilter );\n        }\n        var minFilter = json.MinFilter || json[ 'min_filter' ] || undefined;\n        if ( minFilter ) {\n            osgjs.setMinFilter( minFilter );\n        }\n        var wrapT = json.WrapT || json[ 'wrap_t' ] || undefined;\n        if ( wrapT ) {\n            osgjs.setWrapT( wrapT );\n        }\n        var wrapS = json.WrapS || json[ 'wrap_s' ] || undefined;\n        if ( wrapS ) {\n            osgjs.setWrapS( wrapS );\n        }\n        var file = getFieldBackwardCompatible( 'File', json );\n        ReaderParser.readImage( file ).then( function ( img ) {\n            osgjs.setImage( img );\n        } ).catch( function () {\n            Notify.log( 'Can\\'t read image' );\n        } );\n    };\n\n    var setStateSet = function ( osgjs, json ) {\n        setName( osgjs, json );\n        var textures = getFieldBackwardCompatible( 'Textures', json ) || getFieldBackwardCompatible( 'TextureAttributeList', json ) || undefined;\n        if ( textures ) {\n            for ( var t = 0, tl = textures.length; t < tl; t++ ) {\n                var file = getFieldBackwardCompatible( 'File', textures[ t ] );\n                if ( !file ) {\n                    Notify.log( 'no texture on unit ' + t + ' skip it' );\n                    continue;\n                }\n                var Texture = require( 'osg/Texture' );\n                var tex = new Texture();\n                setTexture( tex, textures[ t ] );\n\n                osgjs.setTextureAttributeAndModes( t, tex );\n                osgjs.addUniform( Uniform.createInt1( t, 'Texture' + t ) );\n            }\n        }\n\n        var blendfunc = getFieldBackwardCompatible( 'BlendFunc', json );\n        if ( blendfunc ) {\n            var newblendfunc = new BlendFunc();\n            setBlendFunc( newblendfunc, blendfunc );\n            osgjs.setAttributeAndModes( newblendfunc );\n        }\n\n        var material = getFieldBackwardCompatible( 'Material', json );\n        if ( material ) {\n            var Material = require( 'osg/Material' );\n            var newmaterial = new Material();\n            setMaterial( newmaterial, material );\n            osgjs.setAttributeAndModes( newmaterial );\n        }\n    };\n\n\n    var newnode;\n    var children = node.children;\n    var primitives = node._primitives || node.primitives || node.Primitives || undefined;\n    var attributes = node._attributes || node.attributes || node.Attributes || undefined;\n    if ( primitives || attributes ) {\n\n        var geom = new Geometry();\n        setName( geom, node );\n        geom.stateset = node.stateset;\n        node = geom;\n\n        for ( var p = 0, lp = primitives.length; p < lp; p++ ) {\n            var mode = primitives[ p ].mode;\n            if ( primitives[ p ].indices ) {\n                var array = primitives[ p ].indices;\n                array = new BufferArray( BufferArray[ array.type ], array.elements, array.itemSize );\n                if ( !mode ) {\n                    mode = 'TRIANGLES';\n                } else {\n                    mode = PrimitiveSet[ mode ];\n                }\n                geom.getPrimitiveSetList().push( new DrawElements( mode, array ) );\n            } else {\n                mode = PrimitiveSet[ mode ];\n                var first = primitives[ p ].first;\n                var count = primitives[ p ].count;\n\n                geom.getPrimitiveSetList().push( new DrawArrays( mode, first, count ) );\n            }\n        }\n\n        for ( var attr in attributes ) {\n            var attributeArray = attributes[ attr ];\n            geom.getVertexAttributeList()[ attr ] = new BufferArray( attributeArray.type, attributeArray.elements, attributeArray.itemSize );\n        }\n\n    }\n\n    var stateset = getFieldBackwardCompatible( 'StateSet', node );\n    if ( stateset ) {\n        var newstateset = new StateSet();\n        setStateSet( newstateset, stateset );\n        node.stateset = newstateset;\n    }\n\n    var matrix = node.matrix || node.Matrix || undefined;\n    if ( matrix ) {\n        newnode = new MatrixTransform();\n        setName( newnode, node );\n\n        MACROUTILS.extend( newnode, node );\n        mat4.copy( newnode.getMatrix(), matrix );\n        node = newnode;\n    }\n\n    var projection = node.projection || node.Projection || undefined;\n    if ( projection ) {\n        newnode = new Projection();\n        setName( newnode, node );\n        MACROUTILS.extend( newnode, node );\n        mat4.copy( newnode.setProjectionMatrix(), projection );\n        node = newnode;\n    }\n\n    // default type\n    if ( node.typeID === undefined ) {\n        newnode = new Node();\n        setName( newnode, node );\n        MACROUTILS.extend( newnode, node );\n        node = newnode;\n    }\n\n\n    if ( children ) {\n        // disable children, it will be processed in the end\n        node.children = [];\n\n        for ( var child = 0, childLength = children.length; child < childLength; child++ ) {\n            node.addChild( ReaderParser.parseSceneGraphDeprecated( children[ child ] ) );\n        }\n    }\n\n    return node;\n};\n\nmodule.exports = ReaderParser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/readerParser.js\n// module id = 151\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\n\n/**\n * This is a very simplistic version of the OSG registry, we could\n * expand/improve it in the future\n */\n\nvar Registry = {\n\n    instance: function () {\n        if ( !Registry._instance ) {\n            Registry._instance = Registry;\n            Registry._instance.plugins = new window.Map();\n        }\n        return Registry._instance;\n    },\n\n    // We register directly a plugin for a extension.\n    addReaderWriter: function ( extension, plugin ) {\n        if ( Registry.instance().plugins.get( extension ) !== undefined )\n            Notify.warn( 'the \\'' + extension + '\\' plugin already exists' );\n        Registry.instance().plugins.set( extension, plugin );\n    },\n\n    getReaderWriterForExtension: function ( name ) {\n        return Registry.instance().plugins.get( name );\n    }\n};\n\n\nmodule.exports = Registry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/Registry.js\n// module id = 152\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar PagedLOD = require( 'osg/PagedLOD' );\nvar Timer = require( 'osg/Timer' );\n\n/**\n * Database paging class which manages the loading of files\n * and synchronizing of loaded models with the main scene graph.\n *  @class DatabasePager\n */\nvar DatabasePager = function () {\n    this._pendingRequests = [];\n    this._pendingNodes = [];\n    this._loading = false;\n    this._progressCallback = undefined;\n    this._lastCB = true;\n    this._activePagedLODList = new Set();\n    this._childrenToRemoveList = new Set();\n    this._downloadingRequestsNumber = 0;\n    this._maxRequestsPerFrame = 10;\n    this._acceptNewRequests = true;\n    // In OSG the targetMaximumNumberOfPagedLOD is 300 by default\n    // here we set 75 as we need to be more strict with memory in a browser\n    // This value can be setted using setTargetMaximumNumberOfPageLOD method.\n    this._targetMaximumNumberOfPagedLOD = 75;\n};\n\nvar DatabaseRequest = function () {\n    this._loadedModel = undefined;\n    this._group = undefined;\n    this._url = undefined;\n    this._function = undefined;\n    this._timeStamp = 0.0;\n    this._groupExpired = false;\n    this._priority = 0.0;\n};\n\nvar FindPagedLODsVisitor = function ( pagedLODList, frameNumber ) {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n    this._activePagedLODList = pagedLODList;\n    this._frameNumber = frameNumber;\n};\nFindPagedLODsVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    apply: function ( node ) {\n        if ( node.getTypeID() === PagedLOD.getTypeID() ) {\n            node.setFrameNumberOfLastTraversal( this._frameNumber );\n            this._activePagedLODList.add( node );\n        }\n        this.traverse( node );\n    }\n} );\n\nvar ReleaseVisitor = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n};\nReleaseVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    apply: function ( node ) {\n        // mark GLResources in nodes to be released\n        node.releaseGLObjects();\n        this.traverse( node );\n    }\n} );\n\nvar ExpirePagedLODVisitor = function () {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n    this._childrenList = [];\n};\n\nExpirePagedLODVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    apply: function ( node ) {\n        if ( node.getTypeID() === PagedLOD.getTypeID() ) {\n            this._childrenList.push( node );\n            this._markRequestsExpired( node );\n        }\n        this.traverse( node );\n    },\n\n    removeExpiredChildrenAndFindPagedLODs: function ( plod, expiryTime, expiryFrame, removedChildren ) {\n        if ( !plod.children.length ) return false;\n\n        var sizeBefore = removedChildren.length;\n        plod.removeExpiredChildren( expiryTime, expiryFrame, removedChildren );\n        for ( var i = sizeBefore; i < removedChildren.length; i++ ) {\n            removedChildren[ i ].accept( this );\n        }\n        return sizeBefore !== removedChildren.length;\n    },\n\n    _markRequestsExpired: function ( plod ) {\n        var numRanges = plod._perRangeDataList.length;\n        var request;\n        for ( var i = 0; i < numRanges; i++ ) {\n            request = plod.getDatabaseRequest( i );\n            if ( request !== undefined ) {\n                request._groupExpired = true;\n                request._loadedModel = null;\n            }\n        }\n    }\n} );\n\nDatabasePager.prototype = MACROUTILS.objectLibraryClass( {\n\n    setTargetMaximumNumberOfPageLOD: function ( target ) {\n        this._targetMaximumNumberOfPagedLOD = target;\n    },\n\n    getTargetMaximumNumberOfPageLOD: function () {\n        return this._targetMaximumNumberOfPagedLOD;\n    },\n\n    setAcceptNewDatabaseRequests: function ( acceptNewRequests ) {\n        this._acceptNewRequests = acceptNewRequests;\n    },\n    getAcceptNewDatabaseRequests: function () {\n        return this._acceptNewRequests;\n    },\n    reset: function () {\n        this._pendingRequests = [];\n        this._pendingNodes = [];\n        this._loading = false;\n        this._lastCB = true;\n        this._activePagedLODList.clear();\n        this._childrenToRemoveList.clear();\n        this._downloadingRequestsNumber = 0;\n        this._maxRequestsPerFrame = 10;\n        this._acceptNewRequests = true;\n        this._targetMaximumNumberOfPagedLOD = 75;\n    },\n\n    updateSceneGraph: function ( frameStamp ) {\n        // Progress callback\n        if ( this._progressCallback !== undefined ) {\n            // Maybe we should encapsulate this in a promise.\n            this.executeProgressCallback();\n        }\n        // We need to control the time spent in DatabasePager tasks to\n        // avoid making the rendering slow.\n        // Probably we can have a time parameter to manage all the tasks.\n        // Now it is fixed to 0.0025 ms to remove expired childs\n        // and 0.005 ms  to add to the scene the loaded requests.\n\n        // Remove expired nodes\n        this.removeExpiredSubgraphs( frameStamp, 0.0025 );\n        // Time to do the requests.\n        this.takeRequests();\n        // Add the loaded data to the graph\n        this.addLoadedDataToSceneGraph( frameStamp, 0.005 );\n    },\n\n\n    executeProgressCallback: function () {\n        if ( this._pendingRequests.length > 0 || this._pendingNodes.length > 0 ) {\n            this._progressCallback( this._pendingRequests.length + this._downloadingRequestsNumber, this._pendingNodes.length );\n            this._lastCB = false;\n        } else {\n            if ( !this._lastCB ) {\n                this._progressCallback( this._pendingRequests.length + this._downloadingRequestsNumber, this._pendingNodes.length );\n                this._lastCB = true;\n            }\n        }\n    },\n\n    setMaxRequestsPerFrame: function ( numRequests ) {\n        this._maxRequestsPerFrame = numRequests;\n    },\n\n    getMaxRequestsPerFrame: function () {\n        return this._maxRequestsPerFrame;\n    },\n\n    getRequestListSize: function () {\n        return this._pendingRequests.length + this._downloadingRequestsNumber;\n    },\n\n    setProgressCallback: function ( cb ) {\n        this._progressCallback = cb;\n    },\n\n    addLoadedDataToSceneGraph: function ( frameStamp, availableTime ) {\n\n        if ( availableTime <= 0.0 ) return 0.0;\n\n        // Prune the list of database requests.\n        var elapsedTime = 0.0;\n        var beginTime = Timer.instance().tick();\n        this._pendingNodes.sort( function ( r1, r2 ) {\n            return r2._timeStamp - r1._timeStamp;\n        } );\n\n        for ( var i = 0; i < this._pendingNodes.length; i++ ) {\n            if ( elapsedTime > availableTime ) return 0.0;\n\n            var request = this._pendingNodes.shift();\n            var frameNumber = frameStamp.getFrameNumber();\n            var timeStamp = frameStamp.getSimulationTime();\n\n            // If the request is not expired, then add/register new childs\n            if ( request._groupExpired === false ) {\n\n                var plod = request._group;\n                plod.setTimeStamp( plod.children.length, timeStamp );\n                plod.setFrameNumber( plod.children.length, frameNumber );\n                plod.addChildNode( request._loadedModel );\n\n                // Register PagedLODs.\n                if ( !this._activePagedLODList.has( plod ) ) {\n                    this.registerPagedLODs( plod, frameNumber );\n                } else {\n                    this.registerPagedLODs( request._loadedModel, frameNumber );\n                }\n\n            } else {\n\n                // Clean the request\n                request._loadedModel = undefined;\n                request = undefined;\n\n            }\n            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n        }\n        availableTime -= elapsedTime;\n        return availableTime;\n    },\n\n    isLoading: function () {\n        return this._loading;\n    },\n\n    registerPagedLODs: function ( subgraph, frameNumber ) {\n        if ( !subgraph ) return;\n        subgraph.accept( new FindPagedLODsVisitor( this._activePagedLODList, frameNumber ) );\n    },\n\n    requestNodeFile: function ( func, url, node, timestamp, priority ) {\n        // Check if we are currently accepting requests.\n        if ( !this._acceptNewRequests ) return undefined;\n        // We don't need to determine if the dbrequest is in the queue\n        // That is already done in the PagedLOD, so we just create the request\n        var dbrequest = new DatabaseRequest();\n        dbrequest._group = node;\n        dbrequest._function = func;\n        dbrequest._url = url;\n        dbrequest._timeStamp = timestamp;\n        dbrequest._priority = priority;\n        this._pendingRequests.push( dbrequest );\n        return dbrequest;\n    },\n\n    takeRequests: function () {\n        if ( this._pendingRequests.length ) {\n            var numRequests = Math.min( this._maxRequestsPerFrame, this._pendingRequests.length );\n            this._pendingRequests.sort( function ( r1, r2 ) {\n                // Ask for newer requests first.\n                var value = r1._timeStamp - r2._timeStamp;\n                // Ask for the greater priority if the timestamp is the same.\n                if ( value === 0 ) {\n                    value = r1._priority - r2._priority;\n                }\n                return value;\n\n            } );\n            for ( var i = 0; i < numRequests; i++ ) {\n                this._downloadingRequestsNumber++;\n                this.processRequest( this._pendingRequests.shift() );\n            }\n        }\n    },\n\n    processRequest: function ( dbrequest ) {\n\n        this._loading = true;\n        var that = this;\n        // Check if the request is valid;\n        if ( dbrequest._groupExpired ) {\n            //Notify.log( 'DatabasePager::processRequest() Request expired.' );\n            that._downloadingRequestsNumber--;\n            this._loading = false;\n            return;\n        }\n\n        // Load from function\n        if ( dbrequest._function !== undefined ) {\n            this.loadNodeFromFunction( dbrequest._function, dbrequest._group ).then( function ( child ) {\n                that._downloadingRequestsNumber--;\n                dbrequest._loadedModel = child;\n                that._pendingNodes.push( dbrequest );\n                that._loading = false;\n            } );\n\n        } else if ( dbrequest._url !== '' ) { // Load from URL\n            this.loadNodeFromURL( dbrequest._url ).then( function ( child ) {\n                that._downloadingRequestsNumber--;\n                dbrequest._loadedModel = child;\n                that._pendingNodes.push( dbrequest );\n                that._loading = false;\n            } );\n        }\n    },\n\n    loadNodeFromFunction: function ( func, plod ) {\n        // Need to call with pagedLOD as parent, to be able to have multiresolution structures.\n        var promise = ( func )( plod );\n        // should func always return a promise ?\n        if ( !promise ) return P.reject();\n        if ( promise && promise.then ) return promise;\n        return P.resolve( promise );\n    },\n\n    loadNodeFromURL: function ( url ) {\n        var ReaderParser = require( 'osgDB/readerParser' );\n        // Call to ReaderParser just in case there is a custom readNodeURL Callback\n        // See osgDB/options.js and/or osgDB/Input.js\n        // TODO: We should study if performance can be improved if separating the XHTTP request from\n        // the parsing. This way several/many request could be done at the same time.\n        // Also we should be able to cancel requests, so there is a need to have access\n        // to the HTTPRequest Object\n        return ReaderParser.readNodeURL( url );\n    },\n\n    releaseGLExpiredSubgraphs: function ( availableTime ) {\n\n        if ( availableTime <= 0.0 ) return 0.0;\n        // We need to test if we have time to flush\n        var elapsedTime = 0.0;\n        var beginTime = Timer.instance().tick();\n        var that = this;\n\n        this._childrenToRemoveList.forEach( function ( node ) {\n            // If we don't have more time, break the loop.\n            if ( elapsedTime > availableTime ) return;\n            that._childrenToRemoveList.delete( node );\n            node.accept( new ReleaseVisitor() );\n            node.removeChildren();\n            node = null;\n            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n        } );\n\n        availableTime -= elapsedTime;\n        return availableTime;\n    },\n\n    removeExpiredSubgraphs: function ( frameStamp, availableTime ) {\n\n        if ( frameStamp.getFrameNumber() === 0 ) return 0.0;\n\n        var numToPrune = this._activePagedLODList.size - this._targetMaximumNumberOfPagedLOD;\n        var expiryTime = frameStamp.getSimulationTime() - 0.1;\n        var expiryFrame = frameStamp.getFrameNumber() - 1;\n        // First traverse and remove inactive PagedLODs, as their children will\n        // certainly have expired.\n        // TODO: Then traverse active nodes if we still need to prune.\n        if ( numToPrune > 0 ) {\n            availableTime = this.removeExpiredChildren( numToPrune, expiryTime, expiryFrame, availableTime );\n        }\n        return availableTime;\n    },\n\n    removeExpiredChildren: function ( numToPrune, expiryTime, expiryFrame, availableTime ) {\n        // Iterate over the activePagedLODList to remove expired children\n        // We need to control the time spent in remove childs.\n        var elapsedTime = 0.0;\n        var beginTime = Timer.instance().tick();\n        var that = this;\n        var removedChildren = [];\n        var expiredPagedLODVisitor = new ExpirePagedLODVisitor();\n\n        this._activePagedLODList.forEach( function ( plod ) {\n            // Check if we have time, else return 0\n            if ( elapsedTime > availableTime ) return 0.0;\n            if ( numToPrune < 0 ) return availableTime;\n            // See if plod is still active, so we don't have to prune\n            if ( expiryFrame < plod.getFrameNumberOfLastTraversal() ) return availableTime;\n            expiredPagedLODVisitor.removeExpiredChildrenAndFindPagedLODs( plod, expiryTime, expiryFrame, removedChildren );\n            for ( var i = 0; i < expiredPagedLODVisitor._childrenList.length; i++ ) {\n                that._activePagedLODList.delete( expiredPagedLODVisitor._childrenList[ i ] );\n                numToPrune--;\n            }\n            // Add to the remove list all the childs deleted\n            for ( i = 0; i < removedChildren.length; i++ ) {\n                that._childrenToRemoveList.add( removedChildren[ i ] );\n            }\n            expiredPagedLODVisitor._childrenList.length = 0;\n            removedChildren.length = 0;\n            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );\n        } );\n        availableTime -= elapsedTime;\n        return availableTime;\n    }\n}, 'osgDB', 'DatabasePager' );\n\nmodule.exports = DatabasePager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/DatabasePager.js\n// module id = 153\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar TransformEnums = require( 'osg/transformEnums' );\n\nvar osgWrapper = {};\n\nosgWrapper.Object = function ( input, obj ) {\n    var jsonObj = input.getJSON();\n\n    if ( jsonObj.Name ) obj.setName( jsonObj.Name );\n\n    if ( jsonObj.UserDataContainer ) {\n        var userdata = input.setJSON( jsonObj.UserDataContainer ).readUserDataContainer();\n        if ( userdata !== undefined ) {\n            obj.setUserData( userdata );\n        }\n    }\n\n    return obj;\n};\n/* jshint newcap: false */\nosgWrapper.Node = function ( input, node ) {\n    var jsonObj = input.getJSON();\n\n    osgWrapper.Object( input, node );\n\n    var promiseArray = [];\n\n    if ( jsonObj.UpdateCallbacks ) {\n        var cbAddCallback = node.addUpdateCallback.bind( node );\n        for ( var j = 0, l = jsonObj.UpdateCallbacks.length; j < l; j++ ) {\n            var promise = input.setJSON( jsonObj.UpdateCallbacks[ j ] ).readObject();\n            promiseArray.push( promise );\n            promise.then( cbAddCallback );\n        }\n    }\n\n    if ( jsonObj.StateSet ) {\n        var pp = input.setJSON( jsonObj.StateSet ).readObject();\n        promiseArray.push( pp );\n        pp.then( node.setStateSet.bind( node ) );\n    }\n\n    var queue = [];\n    // For each url, create a function call and add it to the queue\n    if ( jsonObj.Children ) {\n        for ( var i = 0, k = jsonObj.Children.length; i < k; i++ ) {\n            queue.push( input.setJSON( jsonObj.Children[ i ] ).readObject() );\n        }\n    }\n    // Resolve first updateCallbacks and stateset.\n    return P.all( promiseArray ).then( function () {\n        // Need to wait until the stateset and the all the callbacks are resolved\n        return P.all( queue ).then( function ( queueNodes ) {\n            // All the results from P.all are on the argument as an array\n            // Now insert children in the right order\n            var len = queueNodes.length;\n            for ( var i = 0; i < len; i++ )\n                node.addChild( queueNodes[ i ] );\n            return node;\n        } );\n    } );\n};\n\nosgWrapper.StateSet = function ( input, stateSet ) {\n    var jsonObj = input.getJSON();\n\n    osgWrapper.Object( input, stateSet );\n\n    if ( jsonObj.RenderingHint !== undefined ) {\n        stateSet.setRenderingHint( jsonObj.RenderingHint );\n    }\n\n    var promiseArray = [];\n\n    var createAttribute = function ( jsonAttribute ) {\n        var promise = input.setJSON( jsonAttribute ).readObject();\n        if ( promise.isRejected() ) // sometimes we have some empty objects\n            return;\n        promiseArray.push( promise );\n        promise.then( stateSet.setAttributeAndModes.bind( stateSet ) );\n    };\n\n    if ( jsonObj.AttributeList !== undefined ) {\n        for ( var i = 0, l = jsonObj.AttributeList.length; i < l; i++ ) {\n            createAttribute( jsonObj.AttributeList[ i ] );\n        }\n    }\n\n    var createTextureAttribute = function ( unit, textureAttribute ) {\n        var promise = input.setJSON( textureAttribute ).readObject();\n        if ( promise.isRejected() ) // sometimes we have some empty objects\n            return;\n        promiseArray.push( promise );\n        promise.then( stateSet.setTextureAttributeAndModes.bind( stateSet, unit ) );\n    };\n\n    if ( jsonObj.TextureAttributeList ) {\n        var textures = jsonObj.TextureAttributeList;\n        for ( var t = 0, lt = textures.length; t < lt; t++ ) {\n            var textureAttributes = textures[ t ];\n            for ( var a = 0, al = textureAttributes.length; a < al; a++ ) {\n                createTextureAttribute( t, textureAttributes[ a ] );\n            }\n        }\n    }\n\n    return P.all( promiseArray ).then( function () {\n        return stateSet;\n    } );\n};\n\nosgWrapper.Material = function ( input, material ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Diffuse || !jsonObj.Emission || !jsonObj.Specular || jsonObj.Shininess === undefined )\n        return P.reject();\n\n    osgWrapper.Object( input, material );\n\n    material.setAmbient( jsonObj.Ambient );\n    material.setDiffuse( jsonObj.Diffuse );\n    material.setEmission( jsonObj.Emission );\n    material.setSpecular( jsonObj.Specular );\n    material.setShininess( jsonObj.Shininess );\n    return P.resolve( material );\n};\n\nosgWrapper.BlendFunc = function ( input, blend ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.SourceRGB || !jsonObj.SourceAlpha || !jsonObj.DestinationRGB || !jsonObj.DestinationAlpha )\n        return P.reject();\n\n    osgWrapper.Object( input, blend );\n\n    blend.setSourceRGB( jsonObj.SourceRGB );\n    blend.setSourceAlpha( jsonObj.SourceAlpha );\n    blend.setDestinationRGB( jsonObj.DestinationRGB );\n    blend.setDestinationAlpha( jsonObj.DestinationAlpha );\n    return P.resolve( blend );\n};\n\nosgWrapper.CullFace = function ( input, attr ) {\n    var jsonObj = input.getJSON();\n    if ( jsonObj.Mode === undefined )\n        return P.reject();\n\n    osgWrapper.Object( input, attr );\n    attr.setMode( jsonObj.Mode );\n    return P.resolve( attr );\n};\n\nosgWrapper.BlendColor = function ( input, attr ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.ConstantColor )\n        return P.reject();\n\n    osgWrapper.Object( input, attr );\n    attr.setConstantColor( jsonObj.ConstantColor );\n    return P.resolve( attr );\n};\n\nosgWrapper.Light = function ( input, light ) {\n    var jsonObj = input.getJSON();\n\n    if ( !jsonObj.Ambient ||\n        !jsonObj.Diffuse ||\n        !jsonObj.Direction ||\n        !jsonObj.Position ||\n        !jsonObj.Specular ||\n        jsonObj.LightNum === undefined ||\n        jsonObj.SpotCutoff === undefined ||\n        jsonObj.LinearAttenuation === undefined ||\n        jsonObj.ConstantAttenuation === undefined ||\n        jsonObj.QuadraticAttenuation === undefined )\n        return P.reject();\n\n    osgWrapper.Object( input, light );\n    light.setAmbient( jsonObj.Ambient );\n    light.setConstantAttenuation( jsonObj.ConstantAttenuation );\n    light.setDiffuse( jsonObj.Diffuse );\n    light.setDirection( jsonObj.Direction );\n    light.setLightNumber( jsonObj.LightNum );\n    light.setLinearAttenuation( jsonObj.LinearAttenuation );\n    light.setPosition( jsonObj.Position );\n    light.setQuadraticAttenuation( jsonObj.QuadraticAttenuation );\n    light.setSpecular( jsonObj.Specular );\n    light.setSpotCutoff( jsonObj.SpotCutoff );\n    light.setSpotBlend( 0.01 );\n    if ( jsonObj.SpotExponent !== undefined ) {\n        light.setSpotBlend( jsonObj.SpotExponent / 128.0 );\n    }\n    return P.resolve( light );\n};\n\nosgWrapper.Texture = function ( input, texture ) {\n    var jsonObj = input.getJSON();\n\n    osgWrapper.Object( input, texture );\n\n    if ( jsonObj.MinFilter ) texture.setMinFilter( jsonObj.MinFilter );\n    if ( jsonObj.MagFilter ) texture.setMagFilter( jsonObj.MagFilter );\n    if ( jsonObj.WrapT ) texture.setWrapT( jsonObj.WrapT );\n    if ( jsonObj.WrapS ) texture.setWrapS( jsonObj.WrapS );\n\n    // no file return dummy texture\n    var file = jsonObj.File;\n    if ( file === undefined ) {\n        file = 'no-image-provided';\n    }\n\n    return input.readImageURL( file ).then( function ( img ) {\n        texture.setImage( img );\n        return texture;\n    } );\n};\n\nosgWrapper.Projection = function ( input, node ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Matrix )\n        return P.reject();\n\n    var promise = osgWrapper.Node( input, node );\n    node.setMatrix( jsonObj.Matrix );\n    return promise;\n};\n\nosgWrapper.MatrixTransform = function ( input, node ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Matrix )\n        return P.reject();\n\n    var promise = osgWrapper.Node( input, node );\n    node.setMatrix( jsonObj.Matrix );\n    return promise;\n};\n\nosgWrapper.LightSource = function ( input, node ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Light )\n        return P.reject();\n\n    var promise = osgWrapper.Node( input, node );\n    return P.all( [ input.setJSON( jsonObj.Light ).readObject(), promise ] ).then( function ( args ) {\n        var light = args[ 0 ];\n        //var lightsource = args[ 1 ];\n        node.setLight( light );\n        if ( jsonObj.ReferenceFrame === 'ABSOLUTE_RF' )\n            node.setReferenceFrame( TransformEnums.ABSOLUTE_RF );\n        return node;\n    } );\n};\n\n// not robust, but we probably don't want to complexify the function for now\nosgWrapper.functionSortAttributes = function ( a, b ) {\n    if ( a.indexOf( 'TexCoord' ) !== -1 && b.indexOf( 'TexCoord' ) !== -1 ) {\n        return parseInt( a.substr( 8 ), 10 ) - parseInt( b.substr( 8 ), 10 );\n    }\n\n    if ( a < b ) return -1;\n    if ( a > b ) return 1;\n    return 0;\n};\n\nosgWrapper.Geometry = function ( input, node ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.VertexAttributeList )\n        return P.reject();\n\n    jsonObj.PrimitiveSetList = jsonObj.PrimitiveSetList || [];\n\n    var arraysPromise = [];\n    arraysPromise.push( osgWrapper.Node( input, node ) );\n\n    var prims = node.getPrimitives();\n    var cbAddPrimitives = prims.push.bind( prims );\n    var i = 0;\n    var l = jsonObj.PrimitiveSetList.length;\n    for ( i = 0; i < l; i++ ) {\n        var promisePrimitive = input.setJSON( jsonObj.PrimitiveSetList[ i ] ).readPrimitiveSet();\n        arraysPromise.push( promisePrimitive );\n        promisePrimitive.then( cbAddPrimitives );\n    }\n\n    var cbSetBuffer = function ( name, buffer ) {\n        this.getVertexAttributeList()[ name ] = buffer;\n    };\n\n    var vList = jsonObj.VertexAttributeList;\n    var keys = window.Object.keys( vList );\n\n    // TexCoord10 should be sorted after TexCoord5 (in case of referenced attributes)\n    // alternative is to resolve the referenced keys (2 passes method for example)\n    keys.sort( osgWrapper.functionSortAttributes );\n\n    l = keys.length;\n    for ( i = 0; i < l; i++ ) {\n        var name = keys[ i ];\n        var promiseBuffer = input.setJSON( vList[ name ] ).readBufferArray();\n        arraysPromise.push( promiseBuffer );\n        promiseBuffer.then( cbSetBuffer.bind( node, name ) );\n    }\n\n    return P.all( arraysPromise ).then( function () {\n        return node;\n    } );\n};\n\nosgWrapper.PagedLOD = function ( input, plod ) {\n    var jsonObj = input.getJSON();\n\n    osgWrapper.Object( input, plod );\n    // Parse center Mode\n    if ( jsonObj.CenterMode === 'USE_BOUNDING_SPHERE_CENTER' )\n        plod.setCenterMode( 0 );\n    else if ( jsonObj.CenterMode === 'UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED' )\n        plod.setCenterMode( 2 );\n\n    // Parse center and radius\n    plod.setCenter( [ jsonObj.UserCenter[ 0 ], jsonObj.UserCenter[ 1 ], jsonObj.UserCenter[ 2 ] ] );\n    plod.setRadius( jsonObj.UserCenter[ 3 ] );\n\n    // Parse RangeMode\n    if ( jsonObj.RangeMode === 'PIXEL_SIZE_ON_SCREEN' )\n        plod.setRangeMode( 1 );\n\n    var str;\n\n    // Parse Ranges\n    var o = jsonObj.RangeList;\n\n    for ( var i = 0; i < window.Object.keys( o ).length; i++ ) {\n        str = 'Range ' + i;\n        var v = o[ str ];\n        plod.setRange( i, v[ 0 ], v[ 1 ] );\n    }\n    // Parse Files\n    o = jsonObj.RangeDataList;\n    for ( i = 0; i < window.Object.keys( o ).length; i++ ) {\n        str = 'File ' + i;\n        plod.setFileName( i, o[ str ] );\n    }\n    // Set database path from options\n    // TODO: Check also if we have a path from json\n    plod.setDatabasePath( input.getDatabasePath() );\n\n    var queue = [];\n    // For each url, create a function call and add it to the queue\n    if ( jsonObj.Children ) {\n        for ( var j = 0, k = jsonObj.Children.length; j < k; j++ ) {\n            queue.push( input.setJSON( jsonObj.Children[ j ] ).readObject() );\n        }\n    }\n\n    return P.all( queue ).then( function ( queueNodes ) {\n        // All the results from P.all are on the argument as an array\n        var len = queueNodes.length;\n        for ( i = 0; i < len; i++ )\n            plod.addChildNode( queueNodes[ i ] );\n        return plod;\n    } );\n};\nmodule.exports = osgWrapper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgWrappers/serializers/osg.js\n// module id = 154\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar Notify = require( 'osg/notify' );\nvar osgWrapper = require( 'osgWrappers/serializers/osg' );\nvar Channel = require( 'osgAnimation/channel' );\nvar Animation = require( 'osgAnimation/animation' );\nvar ReaderParser = require( 'osgDB/readerParser' );\nvar StackedMatrix = require( 'osgAnimation/StackedMatrix' );\nvar StackedScale = require( 'osgAnimation/StackedScale' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\nvar Geometry = require( 'osg/Geometry' );\n\n\n/*eslint new-cap: [2, {\"capIsNewExceptions\": [\"Geometry\", \"MatrixTransform\", \"StandardVec3Channel\", \"StandardQuatChannel\", \"StandardFloatChannel\", \"MorphGeometry\"]}]*/\n\nvar osgAnimationWrapper = {};\n\nvar channelCtor = function () {};\n\nvar registry = ReaderParser.registry();\nregistry.registerObject( 'osgAnimation.Vec3LerpChannel', channelCtor );\nregistry.registerObject( 'osgAnimation.FloatLerpChannel', channelCtor );\nregistry.registerObject( 'osgAnimation.QuatSlerpChannel', channelCtor );\nregistry.registerObject( 'osgAnimation.QuatLerpChannel', channelCtor );\nregistry.registerObject( 'osgAnimation.FloatCubicBezierChannel', channelCtor );\nregistry.registerObject( 'osgAnimation.Vec3CubicBezierChannel', channelCtor );\n// needs to be cleaned in c++\nregistry.registerObject( 'osgAnimation.StackedMatrixElement', StackedMatrix );\nregistry.registerObject( 'osgAnimation.StackedScaleElement', StackedScale );\n\nosgAnimationWrapper.Animation = function ( input ) {\n    var jsonObj = input.getJSON();\n    if ( jsonObj.Name === undefined || !jsonObj.Channels || jsonObj.Channels.length === 0 )\n        return P.reject();\n\n    var arrayChannelsPromise = [];\n\n    // channels\n    for ( var i = 0, l = jsonObj.Channels.length; i < l; i++ ) {\n        var promise = input.setJSON( jsonObj.Channels[ i ] ).readObject();\n        arrayChannelsPromise.push( promise );\n    }\n\n    return P.all( arrayChannelsPromise ).then( function ( channels ) {\n        return Animation.createAnimation( channels, jsonObj.Name );\n    } );\n};\n\nosgAnimationWrapper.StandardVec3Channel = function ( input, channel, creator ) {\n    var jsonObj = input.getJSON();\n    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key || jsonObj.KeyFrames.Key.length !== 3 )\n        return P.reject();\n\n    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();\n    var jsKeyX = input.setJSON( jsonObj.KeyFrames.Key[ 0 ] ).readBufferArray();\n    var jsKeyY = input.setJSON( jsonObj.KeyFrames.Key[ 1 ] ).readBufferArray();\n    var jsKeyZ = input.setJSON( jsonObj.KeyFrames.Key[ 2 ] ).readBufferArray();\n\n    return P.all( [ jsTime, jsKeyX, jsKeyY, jsKeyZ ] ).then( function ( pArray ) {\n        var eTime = pArray[ 0 ].getElements();\n        var eKeyX = pArray[ 1 ].getElements();\n        var eKeyY = pArray[ 2 ].getElements();\n        var eKeyZ = pArray[ 3 ].getElements();\n\n        // the keys and time array are always create with a slightly biffer array buffer\n        // (one additional element) in case we want to lerp between end and start\n        var size = eTime.length;\n        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 3 ), 0, size * 3 );\n        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n\n        for ( var i = 0; i < size; i++ ) {\n            var id = i * 3;\n            times[ i ] = eTime[ i ];\n            keys[ id++ ] = eKeyX[ i ];\n            keys[ id++ ] = eKeyY[ i ];\n            keys[ id ] = eKeyZ[ i ];\n        }\n\n        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );\n        return channel;\n    } );\n};\n\nosgAnimationWrapper.StandardQuatChannel = function ( input, channel, creator ) {\n    var jsonObj = input.getJSON();\n    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key || jsonObj.KeyFrames.Key.length !== 4 )\n        return P.reject();\n\n    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();\n    var jsKeyX = input.setJSON( jsonObj.KeyFrames.Key[ 0 ] ).readBufferArray();\n    var jsKeyY = input.setJSON( jsonObj.KeyFrames.Key[ 1 ] ).readBufferArray();\n    var jsKeyZ = input.setJSON( jsonObj.KeyFrames.Key[ 2 ] ).readBufferArray();\n    var jsKeyW = input.setJSON( jsonObj.KeyFrames.Key[ 3 ] ).readBufferArray();\n\n    return P.all( [ jsTime, jsKeyX, jsKeyY, jsKeyZ, jsKeyW ] ).then( function ( pArray ) {\n        var eTime = pArray[ 0 ].getElements();\n        var eKeyX = pArray[ 1 ].getElements();\n        var eKeyY = pArray[ 2 ].getElements();\n        var eKeyZ = pArray[ 3 ].getElements();\n        var eKeyW = pArray[ 4 ].getElements();\n\n        var size = eTime.length;\n        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 4 ), 0, size * 4 );\n        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n\n        for ( var i = 0; i < size; i++ ) {\n            var id = i * 4;\n            times[ i ] = eTime[ i ];\n            keys[ id++ ] = eKeyX[ i ];\n            keys[ id++ ] = eKeyY[ i ];\n            keys[ id++ ] = eKeyZ[ i ];\n            keys[ id ] = eKeyW[ i ];\n        }\n        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );\n        return channel;\n    } );\n};\n\nosgAnimationWrapper.StandardFloatChannel = function ( input, channel, creator ) {\n    var jsonObj = input.getJSON();\n    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key )\n        return P.reject();\n\n    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();\n    var jsKey = input.setJSON( jsonObj.KeyFrames.Key ).readBufferArray();\n\n    return P.all( [ jsTime, jsKey ] ).then( function ( pArray ) {\n        var eTime = pArray[ 0 ].getElements();\n        var eKey = pArray[ 1 ].getElements();\n\n        var size = eTime.length;\n        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n\n        for ( var i = 0; i < size; i++ ) {\n            times[ i ] = eTime[ i ];\n            keys[ i ] = eKey[ i ];\n        }\n\n        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );\n        return channel;\n    } );\n};\n\nosgAnimationWrapper.Vec3LerpChannel = function ( input, channel ) {\n    return osgAnimationWrapper.StandardVec3Channel( input, channel, Channel.createVec3Channel );\n};\n\nosgAnimationWrapper.QuatLerpChannel = function ( input, channel ) {\n    return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatChannel );\n};\n\nosgAnimationWrapper.QuatSlerpChannel = function ( input, channel ) {\n    // nlerp is less expensive than slerp\n    return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatChannel );\n    // return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatSlerpChannel );\n};\n\nosgAnimationWrapper.FloatLerpChannel = function ( input, channel ) {\n    return osgAnimationWrapper.StandardFloatChannel( input, channel, Channel.createFloatChannel );\n};\n\nosgAnimationWrapper.FloatCubicBezierChannel = function ( input, channel ) {\n    var jsonObj = input.getJSON();\n\n    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name ||\n        !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Position ||\n        !jsonObj.KeyFrames.ControlPointOut || !jsonObj.KeyFrames.ControlPointIn )\n        return P.reject();\n\n    var arrayPromise = [];\n    var keyFrames = window.Object.keys( jsonObj.KeyFrames );\n    for ( var i = 0; i < keyFrames.length; i++ )\n        arrayPromise.push( input.setJSON( jsonObj.KeyFrames[ keyFrames[ i ] ] ).readBufferArray() );\n\n    return P.all( arrayPromise ).then( function ( pArray ) {\n        var controlPointIn = pArray[ 0 ].getElements();\n        var controlPointOut = pArray[ 1 ].getElements();\n        var position = pArray[ 2 ].getElements();\n        var time = pArray[ 3 ].getElements();\n\n        var size = time.length;\n        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 3 ), 0, size * 3 );\n        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n\n        for ( var i = 0; i < size; i++ ) {\n            var id = i * 3;\n\n            times[ i ] = time[ i ];\n            keys[ id++ ] = position[ i ];\n            keys[ id++ ] = controlPointIn[ i ];\n            keys[ id ] = controlPointOut[ i ];\n        }\n        Channel.createFloatCubicBezierChannel( keys, times, jsonObj.TargetName, jsonObj.Name, channel );\n        return channel;\n    } );\n};\n\nosgAnimationWrapper.Vec3CubicBezierChannel = function ( input, channel ) {\n    var jsonObj = input.getJSON();\n\n    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Position || !jsonObj.KeyFrames.ControlPointOut || !jsonObj.KeyFrames.ControlPointIn || jsonObj.KeyFrames.Position.length !== 3 || jsonObj.KeyFrames.ControlPointIn.length !== 3 || jsonObj.KeyFrames.ControlPointOut.length !== 3 )\n        return P.reject();\n\n    var arrayPromise = [];\n\n    //Reads all keyframes\n    var keyFrames = window.Object.keys( jsonObj.KeyFrames );\n    for ( var i = 0; i < keyFrames.length; i++ ) {\n        var key = keyFrames[ i ];\n        var jsonAttribute = jsonObj.KeyFrames[ key ];\n        if ( key !== 'Time' ) {\n            arrayPromise.push( input.setJSON( jsonAttribute[ 0 ] ).readBufferArray() );\n            arrayPromise.push( input.setJSON( jsonAttribute[ 1 ] ).readBufferArray() );\n            arrayPromise.push( input.setJSON( jsonAttribute[ 2 ] ).readBufferArray() );\n        } else\n            arrayPromise.push( input.setJSON( jsonAttribute ).readBufferArray() );\n    }\n\n    return P.all( arrayPromise ).then( function ( pArray ) {\n        var cpi0 = pArray[ 0 ].getElements();\n        var cpi1 = pArray[ 1 ].getElements();\n        var cpi2 = pArray[ 2 ].getElements();\n        var cpo0 = pArray[ 3 ].getElements();\n        var cpo1 = pArray[ 4 ].getElements();\n        var cpo2 = pArray[ 5 ].getElements();\n        var p0 = pArray[ 6 ].getElements();\n        var p1 = pArray[ 7 ].getElements();\n        var p2 = pArray[ 8 ].getElements();\n        var time = pArray[ 9 ].getElements();\n\n        var size = time.length;\n        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 9 ), 0, size * 9 );\n        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );\n\n        for ( var i = 0; i < size; i++ ) {\n            var id = i * 9;\n\n            times[ i ] = time[ i ];\n            keys[ id++ ] = p0[ i ];\n            keys[ id++ ] = p1[ i ];\n            keys[ id++ ] = p2[ i ];\n\n            keys[ id++ ] = cpi0[ i ];\n            keys[ id++ ] = cpi1[ i ];\n            keys[ id++ ] = cpi2[ i ];\n\n            keys[ id++ ] = cpo0[ i ];\n            keys[ id++ ] = cpo1[ i ];\n            keys[ id ] = cpo2[ i ];\n        }\n        Channel.createVec3CubicBezierChannel( keys, times, jsonObj.TargetName, jsonObj.Name, channel );\n        return channel;\n    } );\n};\n\nosgAnimationWrapper.BasicAnimationManager = function ( input, manager ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Animations )\n        return P.reject();\n\n    osgWrapper.Object( input, manager );\n\n    var animPromises = [];\n\n    for ( var i = 0, l = jsonObj.Animations.length; i < l; i++ ) {\n        var prim = input.setJSON( jsonObj.Animations[ i ] ).readObject();\n        if ( prim.isRejected() ) {\n            Notify.warn( 'An Animation failed on the parsing!' );\n            continue;\n        }\n        animPromises.push( prim );\n    }\n\n    return P.all( animPromises ).then( function ( animations ) {\n        manager.init( animations );\n        return manager;\n    } );\n};\n\nosgAnimationWrapper.UpdateMatrixTransform = function ( input, umt ) {\n    var jsonObj = input.getJSON();\n    //  some stackedTransform on bones has no name but the transform is usefull\n    if ( /*!jsonObj.Name ||*/ !jsonObj.StackedTransforms )\n        return P.reject();\n\n    osgWrapper.Object( input, umt );\n\n    var promiseArray = [];\n    for ( var i = 0, l = jsonObj.StackedTransforms.length; i < l; i++ ) {\n        promiseArray.push( input.setJSON( jsonObj.StackedTransforms[ i ] ).readObject() );\n    }\n\n    // when UpdateMatrixTransform is ready\n    // compute the default value data\n    return P.all( promiseArray ).then( function ( array ) {\n        var stack = umt.getStackedTransforms();\n        for ( var i = 0, l = array.length; i < l; i++ ) stack.push( array[ i ] );\n        umt.computeChannels();\n        return umt;\n    } );\n};\n\nosgAnimationWrapper.StackedTranslate = function ( input, st ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Name || !jsonObj.Translate )\n        return P.reject();\n\n    osgWrapper.Object( input, st );\n\n    st.init( jsonObj.Translate );\n\n    return P.resolve( st );\n};\n\nosgAnimationWrapper.StackedQuaternion = function ( input, st ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Name || !jsonObj.Quaternion )\n        return P.reject();\n\n    osgWrapper.Object( input, st );\n\n    st.init( jsonObj.Quaternion );\n\n    return P.resolve( st );\n};\n\nosgAnimationWrapper.StackedRotateAxis = function ( input, st ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Axis || jsonObj.Angle === undefined )\n        return P.reject();\n\n    osgWrapper.Object( input, st );\n\n    st.init( jsonObj.Axis, jsonObj.Angle );\n\n    return P.resolve( st );\n};\n\nosgAnimationWrapper.StackedMatrix = function ( input, sme ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Name || !jsonObj.Matrix )\n        return P.reject();\n\n    osgWrapper.Object( input, sme );\n\n    sme.init( jsonObj.Matrix );\n\n    return P.resolve( sme );\n};\n\nosgAnimationWrapper.StackedScale = function ( input, stc ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Name || !jsonObj.Scale )\n        return P.reject();\n\n    osgWrapper.Object( input, stc );\n\n    stc.init( jsonObj.Scale );\n\n    return P.resolve( stc );\n};\n\nosgAnimationWrapper.Bone = function ( input, bone ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.InvBindMatrixInSkeletonSpace )\n        return P.reject();\n\n    var promise = osgWrapper.MatrixTransform( input, bone );\n\n    bone.setInvBindMatrixInSkeletonSpace( jsonObj.InvBindMatrixInSkeletonSpace );\n\n    if ( jsonObj.BoundingBox ) {\n        // It is mandatory because we need it for shadows and culling\n        var bbox = bone.getBoneBoundingBox();\n        bbox.setMax( jsonObj.BoundingBox.max );\n        bbox.setMin( jsonObj.BoundingBox.min );\n    }\n\n    return promise;\n};\n\nosgAnimationWrapper.UpdateBone = osgAnimationWrapper.UpdateMatrixTransform;\n\nosgAnimationWrapper.UpdateSkeleton = function ( input, upSkl ) {\n    osgWrapper.Object( input, upSkl );\n    return P.resolve( upSkl );\n};\n\nosgAnimationWrapper.Skeleton = osgWrapper.MatrixTransform;\n\nosgAnimationWrapper.RigGeometry = function ( input, rigGeom ) {\n    var jsonObj = input.getJSON();\n\n    if ( !jsonObj.SourceGeometry ) // check boneMap\n        return P.reject();\n\n    if ( !jsonObj.BoneMap )\n        Notify.warn( 'No boneMap found in a RigGeometry !' );\n\n    //Import rigGeometry as Geometry + BoneMap\n    var rigPromise = osgWrapper.Geometry( input, rigGeom );\n    rigGeom._boneNameID = jsonObj.BoneMap;\n\n    //Import source geometry and merge it with the rigGeometry\n    var sourceGeometry = jsonObj.SourceGeometry[ 'osg.Geometry' ];\n    var geomPromise;\n    if ( sourceGeometry ) {\n        input.setJSON( sourceGeometry );\n        rigGeom.setSourceGeometry( new Geometry() );\n        geomPromise = osgWrapper.Geometry( input, rigGeom.getSourceGeometry() );\n    } else {\n        sourceGeometry = jsonObj.SourceGeometry[ 'osgAnimation.MorphGeometry' ];\n        if ( sourceGeometry ) {\n            input.setJSON( sourceGeometry );\n            rigGeom.setSourceGeometry( new MorphGeometry() );\n            geomPromise = osgAnimationWrapper.MorphGeometry( input, rigGeom.getSourceGeometry() );\n        } else {\n            Notify.warn( 'SourceGeometry type no recognized' );\n        }\n    }\n\n    // not sure if it's normal but rig geometry don't have UniqueID\n    if ( rigGeom._uniqueID === undefined )\n        rigGeom._uniqueID = sourceGeometry.UniqueID;\n\n    return P.all( [ rigPromise, geomPromise ] ).then( function () {\n\n        rigGeom.mergeChildrenData();\n        return rigGeom;\n\n    } );\n\n};\n\nosgAnimationWrapper.MorphGeometry = function ( input, morphGeometry ) {\n\n    var jsonObj = input.getJSON();\n\n    if ( !jsonObj.MorphTargets )\n        return P.reject();\n\n    var morphTargets = jsonObj.MorphTargets;\n    var arrayPromise = [];\n\n    // arrayPromise[0] is the morphGeometry\n    arrayPromise.push( osgWrapper.Geometry( input, morphGeometry ) );\n\n    for ( var i = 0, l = morphTargets.length; i < l; i++ )\n        arrayPromise.push( input.setJSON( morphTargets[ i ] ).readObject() );\n\n    return P.all( arrayPromise ).then( function ( promiseResultArray ) {\n\n        var morphGeometryResolved = promiseResultArray[ 0 ];\n\n        var targets = morphGeometryResolved.getMorphTargets();\n        for ( var j = 1, jn = promiseResultArray.length; j < jn; j++ )\n            targets.push( promiseResultArray[ j ] );\n\n        morphGeometryResolved.mergeChildrenVertexAttributeList();\n        return morphGeometryResolved;\n\n    } );\n};\n\nosgAnimationWrapper.UpdateMorph = function ( input, updateMorph ) {\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.TargetMap )\n        return P.reject();\n\n    osgWrapper.Object( input, updateMorph );\n\n    var keys = window.Object.keys( jsonObj.TargetMap );\n    for ( var i = 0, l = keys.length; i < l; i++ ) {\n        var key = keys[ i ];\n        updateMorph.addTarget( jsonObj.TargetMap[ key ], parseInt( key, 10 ) );\n    }\n\n    return P.resolve( updateMorph );\n};\n\nosgAnimationWrapper.StackedMatrixElement = osgAnimationWrapper.StackedMatrix;\nosgAnimationWrapper.StackedScaleElement = osgAnimationWrapper.StackedScale;\n\nmodule.exports = osgAnimationWrapper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgWrappers/serializers/osgAnimation.js\n// module id = 155\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar osgWrapper = require( 'osgWrappers/serializers/osg' );\nvar Notify = require( 'osg/notify' );\nvar Text = require( 'osgText/Text' );\n\nvar osgTextWrapper = {};\n\nosgTextWrapper.Text = function ( input, node ) {\n\n    var jsonObj = input.getJSON();\n    if ( !jsonObj.Text )\n        return P.reject();\n\n    var promise = osgWrapper.Node( input, node );\n    node.setColor( jsonObj.Color );\n    node.setText( jsonObj.Text );\n    node.setAutoRotateToScreen( jsonObj.AutoRotateToScreen );\n    node.setPosition( jsonObj.Position );\n    node.setCharacterSize( jsonObj.CharacterSize );\n\n    if ( jsonObj.Layout === 'VERTICAL' ) {\n        Notify.error( 'Vertical Alignment not supported' );\n        return P.reject();\n    }\n    var alignment = jsonObj.Alignment;\n    if ( jsonObj.Alignment.indexOf( 'BASE_LINE' ) > -1 ) {\n        if ( jsonObj.Alignment === 'LEFT_BASE_LINE' ) {\n            alignment = Text.LEFT_CENTER;\n        } else if ( jsonObj.Alignment === 'CENTER_BASE_LINE' ) {\n            alignment = Text.CENTER_CENTER;\n        } else if ( jsonObj.Alignment === 'RIGHT_BASE_LINE' ) {\n            alignment = Text.RIGHT_CENTER;\n        } else if ( jsonObj.Alignment === 'LEFT_BOTTOM_BASE_LINE' ) {\n            alignment = Text.LEFT_BOTTOM;\n        } else if ( jsonObj.Alignment === 'CENTER_BOTTOM_BASE_LINE' ) {\n            alignment = Text.CENTER_BOTTOM;\n        } else if ( jsonObj.Alignment === 'RIGHT_BOTTOM_BASE_LINE' ) {\n            alignment = Text.RIGHT_BOTTOM;\n        }\n    }\n    node.setAlignment( alignment );\n    node.setLayout( jsonObj.Layout );\n\n    return promise;\n};\n\n\nmodule.exports = osgTextWrapper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgWrappers/serializers/osgText.js\n// module id = 156\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar AutoTransform = require( 'osg/AutoTransform' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Shape = require( 'osg/shape' );\nvar Texture = require( 'osg/Texture' );\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar quat = require( 'osg/glMatrix' ).quat;\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Node = require( 'osg/Node' );\n/**\n *  @class Text: Text 2D using a Canvas2D as a texture for a textured quad.\n *  Notes: The OSGjs Text has been implemented like OSG osgText::Text as much as possible. However there are some\n *  things that should be noted:\n *  - This Text is far more simple than OSG ones, it only supports basic functionality.\n *  - In contrast to OSG, Text inherits from AutoTransform in osgjs.\n *  - Supported fonts are not the same in HTML than in OSG/C++.\n *  - Vertical layout is not supported right now.\n *  - BaseLine alignments are not supported, instead they are converted to supported ones if parsing a osgjs file.\n *  - Set the color in the range [ 0 - 1 ], as if you were working with OSG.\n *  - Texts are generated as a canvas 2D texture sticked in a quad. The size of the texture is the next power of two of the current size of the\n *    text so the bigger is your characterSize, the more memory it will consume.\n */\nvar Text = function ( text ) {\n    AutoTransform.call( this );\n    // create a canvas element\n    this._canvas = document.createElement( 'canvas' );\n    this._context = this._canvas.getContext( '2d' );\n    this._matrixTransform = new MatrixTransform();\n    this.addChild( this._matrixTransform );\n    this._text = '';\n    if ( text !== undefined ) this._text = text;\n    this._font = 'monospace';\n    // Vec4 value to load/return\n    this._color = vec4.fromValues( 0.0, 0.0, 0.0, 1.0 );\n    // This determines the text color, it can take a hex value or rgba value (e.g. rgba(255,0,0,0.5))\n    this._fillStyle = 'rgba( 0, 0, 0, 1 )';\n    // This determines the alignment of text, e.g. left, center, right\n    this._context.textAlign = 'center';\n    this._textX = undefined;\n    // This determines the baseline of the text, e.g. top, middle, bottom\n    this._context.baseLine = 'middle';\n    this._textY = undefined;\n    // Size of the textured quad in meters.\n    this._characterSize = 1;\n    this._characterSizeMode = Text.OBJECT_COORDS;\n    // Font resolution\n    this._fontSize = 32;\n    this._geometry = undefined;\n    this._autoRotateToScreen = false;\n    this._position = vec3.create();\n    this._layout = Text.LEFT_TO_RIGHT;\n    this._alignment = Text.CENTER_CENTER;\n    // NPOT textures\n    this._forcePowerOfTwo = false;\n    // Lazy initialization\n    this._texture = new Texture();\n    this.drawText();\n    this._dirty = false;\n\n    // We need to keep track of modelView Matrix\n    this._previousModelView = mat4.create();\n};\n\n// CharacterSizeMode\nText.OBJECT_COORDS = 0;\nText.SCREEN_COORDS = 1;\nText.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT = 2;\n\n// Layout enum\nText.LEFT_TO_RIGHT = 'ltr';\nText.RIGHT_TO_LEFT = 'rtl';\n\n// Alignment enum\nText.LEFT_TOP = 0;\nText.LEFT_CENTER = 1;\nText.LEFT_BOTTOM = 2;\n\nText.CENTER_TOP = 3;\nText.CENTER_CENTER = 4;\nText.CENTER_BOTTOM = 5;\n\nText.RIGHT_TOP = 6;\nText.RIGHT_CENTER = 7;\nText.RIGHT_BOTTOM = 8;\n\n/** @lends Text.prototype */\nText.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( AutoTransform.prototype, {\n\n    drawText: function () {\n        if ( this._geometry !== undefined ) {\n            this._matrixTransform.removeChild( this._geometry );\n            // The text could be dynamic, so we need to remove GL objects\n            this._geometry.releaseGLObjects();\n        }\n        if ( !this._text ) return;\n        this.setTextProperties();\n        this._canvas.width = this._context.measureText( this._text ).width;\n        this._canvas.height = this._fontSize * 2;\n        // For devices not supporting NPOT textures\n        if ( this._forcePowerOfTwo ) {\n            this._canvas.width = this._nextPowerOfTwo( this._canvas.width );\n            this._canvas.height = this._nextPowerOfTwo( this._canvas.height );\n        }\n        // We need to set the text properties again, as the canvas size cold change.\n        this.setTextProperties();\n        this._context.clearRect( 0, 0, this._canvas.width, this._canvas.height );\n        this._context.fillText( this._text, this._textX, this._textY );\n        // Right now we set the pivot point to center, to assure the bounding box is correct when rendering billboards.\n        // TODO: Possibility to set different pivot point so we can have missing alignments.\n        var aspectRatio = this._canvas.width / this._canvas.height;\n        var quadWidth = this._characterSize * aspectRatio;\n        this._geometry = Shape.createTexturedQuadGeometry( -quadWidth / 2, -this._characterSize / 2, 0, quadWidth, 0, 0, 0, this._characterSize, 0 );\n        // create a texture to attach the canvas2D\n        this._texture.setTextureSize( this._canvas.width, this._canvas.height );\n        this._texture.setMinFilter( 'LINEAR' );\n        this._texture.setMagFilter( 'LINEAR' );\n        this._texture.setImage( this._canvas );\n        // Transparency stuff\n        var stateset = this._geometry.getOrCreateStateSet();\n        stateset.setTextureAttributeAndModes( 0, this._texture );\n        stateset.setRenderingHint( 'TRANSPARENT_BIN' );\n        stateset.setAttributeAndModes( new BlendFunc( BlendFunc.ONE, BlendFunc.ONE_MINUS_SRC_ALPHA ) );\n        this._matrixTransform.addChild( this._geometry );\n        this.dirtyBound();\n    },\n\n    setText: function ( text ) {\n        this._text = text;\n        // Canvas size could change so we need to make it dirty.\n        this._dirty = true;\n    },\n\n    getText: function () {\n        return this._text;\n    },\n\n    setFont: function ( font ) {\n        this._font = font;\n        this._dirty = true;\n    },\n\n    setColor: function ( color ) {\n        this._color = color;\n        // Convert color to html range\n        this._fillStyle = 'rgba(' + Math.round( color[ 0 ] * 255 ) + ',' + Math.round( color[ 1 ] * 255 ) + ',' + Math.round( color[ 2 ] * 255 ) + ',' + color[ 3 ] + ')';\n        this._context.fillStyle = this._fillStyle;\n        // Canvas size does not change so we don't need to redo the quad.\n        this._context.fillText( this._text, this._textX, this._textY );\n    },\n\n    getColor: function () {\n        return this._color;\n    },\n\n    setCharacterSize: function ( size ) {\n        this._characterSize = size;\n        if ( this._characterSizeMode !== Text.OBJECT_COORDS ) {\n            mat4.fromScaling( this._matrixTransform.getMatrix(), [ this._characterSize, this._characterSize, this._characterSize ] );\n            if ( this._characterSizeMode === Text.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT )\n                this.setMaximumScale( this._characterSize );\n        }\n        this._dirty = true;\n    },\n\n    getCharacterSize: function () {\n        return this._characterSize;\n    },\n\n    setCharacterSizeMode: function ( mode ) {\n        this._characterSizeMode = mode;\n        if ( this._characterSizeMode !== Text.OBJECT_COORDS ) {\n            mat4.fromScaling( this._matrixTransform.getMatrix(), [ this._characterSize, this._characterSize, this._characterSize ] );\n            this.setAutoScaleToScreen( true );\n            this.setMaximumScale( Number.MAX_VALUE );\n            if ( this._characterSizeMode === Text.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT )\n                this.setMaximumScale( this._characterSize );\n        } else {\n            this._matrixTransform.setMatrix( mat4.create() );\n            this.setAutoScaleToScreen( false );\n        }\n        this._dirty = true;\n    },\n\n    getCharacterSizeMode: function () {\n        return this._characterSizeMode;\n    },\n\n    setFontResolution: function ( resolution ) {\n        this._fontSize = resolution;\n        this._dirty = true;\n    },\n\n    getFontResolution: function () {\n        return this._fontSize;\n    },\n\n    setPosition: function ( position ) {\n        this._position = position;\n        mat4.fromTranslation( this.getMatrix(), position );\n    },\n\n    getPosition: function () {\n        return this._position;\n    },\n\n    setTextProperties: function () {\n        this._context.fillStyle = this._fillStyle;\n        this._setAlignmentValues( this._alignment );\n        this._context.font = this._fontSize + 'px ' + this._font;\n        this._context.direction = this._layout;\n    },\n\n    setAutoRotateToScreen: function ( value ) {\n        AutoTransform.prototype.setAutoRotateToScreen.call( this, value );\n        this._dirty = true;\n    },\n\n    getAutoRotateToScreen: function () {\n        return this._autoRotateToScreen;\n    },\n\n    setLayout: function ( layout ) {\n        if ( typeof layout === 'string' ) {\n            this._layout = Text[ layout ];\n        } else {\n            this._layout = layout;\n        }\n        this._dirty = true;\n    },\n    getLayout: function () {\n        return this._layout;\n    },\n    setAlignment: function ( alignment ) {\n        if ( typeof alignment === 'string' ) {\n            this._alignment = Text[ alignment ];\n        } else {\n            this._alignment = alignment;\n        }\n        this._dirty = true;\n    },\n    getAlignment: function () {\n        return this._alignment;\n    },\n\n    accept: ( function () {\n\n        return function ( visitor ) {\n            if ( this._dirty ) {\n                this.drawText();\n                this._dirty = false;\n            }\n            if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {\n\n                var width = visitor.getViewport().width();\n                var height = visitor.getViewport().height();\n                var projMat = visitor.getCurrentProjectionMatrix();\n                var modelViewMat = visitor.getCurrentModelViewMatrix();\n                var position = this._position;\n                var doUpdate = this._firstTimeToInitEyePoint;\n\n                if ( !this._firstTimeToInitEyePoint ) {\n                    if ( !mat4.exactEquals( modelViewMat, this._previousModelView ) ) {\n                        doUpdate = true;\n                    } else if ( width !== this._previousWidth || height !== this._previousHeight ) {\n                        doUpdate = true;\n                    } else if ( !mat4.exactEquals( projMat, this._previousProjection ) ) {\n                        doUpdate = true;\n                    } else if ( !vec3.exactEquals( position, this._previousPosition ) ) {\n                        doUpdate = true;\n                    }\n                }\n                this._firstTimeToInitEyePoint = false;\n                if ( doUpdate ) {\n                    if ( this._autoScaleToScreen ) {\n                        var viewport = visitor.getViewport();\n                        var psvector = this.computePixelSizeVector( viewport, projMat, modelViewMat );\n                        var v = vec4.fromValues( this._position[ 0 ], this._position[ 1 ], this._position[ 2 ], 1.0 );\n                        var pixelSize = vec4.dot( v, psvector );\n                        pixelSize = 0.48 / pixelSize;\n                        var size = 1.0 / pixelSize;\n                        if ( this._autoScaleTransitionWidthRatio > 0.0 ) {\n                            var c, b, a;\n                            if ( this._minimumScale > 0.0 ) {\n                                var j = this._minimumScale;\n                                var i = ( this._maximumScale < Number.MAX_VALUE ) ?\n                                    this._minimumScale + ( this._maximumScale - this._minimumScale ) * this._autoScaleTransitionWidthRatio :\n                                    this._minimumScale * ( 1.0 + this._autoScaleTransitionWidthRatio );\n                                c = 1.0 / ( 4.0 * ( i - j ) );\n                                b = 1.0 - 2.0 * c * i;\n                                a = j + b * b / ( 4.0 * c );\n                                var k = -b / ( 2.0 * c );\n                                if ( size < k ) size = this._minimumScale;\n                                else if ( size < i ) size = a + b * size + c * ( size * size );\n                            }\n                            if ( this._maximumScale < Number.MAX_VALUE ) {\n                                var n = this._maximumScale;\n                                var m = ( this._minimumScale > 0.0 ) ?\n                                    this._maximumScale + ( this._minimumScale - this._maximumScale ) * this._autoScaleTransitionWidthRatio :\n                                    this._maximumScale * ( 1.0 - this._autoScaleTransitionWidthRatio );\n                                c = 1.0 / ( 4.0 * ( m - n ) );\n                                b = 1.0 - 2.0 * c * m;\n                                a = n + b * b / ( 4.0 * c );\n                                var p = -b / ( 2.0 * c );\n\n                                if ( size > p ) size = this._maximumScale;\n                                else if ( size > m ) size = a + b * size + c * ( size * size );\n                            }\n                        }\n                        this.setScale( size );\n                    }\n                    if ( this._autoRotateToScreen ) {\n                        var rotation = quat.create();\n                        var modelView = visitor.getCurrentModelViewMatrix();\n                        mat4.getRotation( rotation, modelView );\n                        this.setRotation( quat.invert( rotation, rotation ) );\n                    }\n                    this._previousWidth = width;\n                    this._previousHeight = height;\n                    vec3.copy( this._previousPosition, position );\n                    mat4.copy( this._previousProjection, projMat );\n                    mat4.copy( this._previousModelView, modelViewMat );\n                }\n            }\n\n            Node.prototype.accept.call( this, visitor );\n        };\n    } )(),\n    _setAlignmentValues: function ( alignment ) {\n        // Convert the OSG Api to js API\n        switch ( alignment ) {\n        case Text.LEFT_TOP:\n            this._context.textAlign = 'left';\n            this._textX = 0;\n            this._context.textBaseline = 'top';\n            this._textY = 0;\n            break;\n        case Text.LEFT_CENTER:\n            this._context.textAlign = 'left';\n            this._textX = 0;\n            this._context.textBaseline = 'middle';\n            this._textY = this._canvas.height / 2;\n            break;\n        case Text.LEFT_BOTTOM:\n            this._context.textAlign = 'left';\n            this._textX = 0;\n            this._context.textBaseline = 'bottom';\n            this._textY = this._canvas.height;\n            break;\n        case Text.CENTER_TOP:\n            this._context.textAlign = 'center';\n            this._textX = this._canvas.width / 2;\n            this._context.textBaseline = 'top';\n            this._textY = 0;\n            break;\n        case Text.CENTER_CENTER:\n            this._context.textAlign = 'center';\n            this._textX = this._canvas.width / 2;\n            this._context.textBaseline = 'middle';\n            this._textY = this._canvas.height / 2;\n            break;\n        case Text.CENTER_BOTTOM:\n            this._context.textAlign = 'center';\n            this._textX = this._canvas.width / 2;\n            this._context.textBaseline = 'bottom';\n            this._textY = this._canvas.height;\n            break;\n        case Text.RIGHT_TOP:\n            this._context.textAlign = 'right';\n            this._textX = this._canvas.width;\n            this._context.textBaseline = 'top';\n            this._textY = 0;\n            break;\n        case Text.RIGHT_CENTER:\n            this._context.textAlign = 'right';\n            this._textX = this._canvas.width;\n            this._context.textBaseline = 'middle';\n            this._textY = this._canvas.height / 2;\n            break;\n        case Text.RIGHT_BOTTOM:\n            this._context.textAlign = 'right';\n            this._textX = this._canvas.width;\n            this._context.textBaseline = 'bottom';\n            this._textY = this._canvas.height;\n            break;\n        }\n    },\n    setForcePowerOfTwo: function ( value ) {\n        this._forcePowerOfTwo = value;\n    },\n    getForcePowerOfTwo: function () {\n        return this._forcePowerOfTwo;\n    },\n    _nextPowerOfTwo: function ( value ) {\n        var v = value;\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n} ), 'osgText', 'Text' );\n\nmodule.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgText/Text.js\n// module id = 157\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\n\nvar ReaderParser = require( 'osgDB/readerParser' );\nvar Registry = require( 'osgDB/Registry' );\nvar requestFile = require( 'osgDB/requestFile.js' );\nvar Notify = require( 'osg/notify' );\n\n// Drag'n Drop file helper\n// it also holds a list of basic types per extension to do requests.\nvar FileHelper = {\n\n    readFileList: function ( fileList ) {\n        var fileName;\n        var filesMap = new window.Map();\n        var promiseArray = [];\n        var i;\n\n        for ( i = 0; i < fileList.length; ++i ) {\n            var ext = fileList[ i ].name.substr( fileList[ i ].name.lastIndexOf( '.' ) + 1 );\n            var readerWriter = Registry.instance().getReaderWriterForExtension( ext );\n            // We need a hack for osgjs til it is converted to a readerwriter\n            if ( readerWriter !== undefined || ext === 'osgjs' ) {\n                // So this is the main file to read\n                fileName = fileList[ i ].name;\n            }\n\n            var type = FileHelper.getTypeForExtension( ext );\n            promiseArray.push( requestFile( fileList[ i ], {\n                responseType: type\n            } ) );\n        }\n\n        return P.all( promiseArray ).then( function ( files ) {\n\n            for ( i = 0; i < files.length; ++i ) {\n                filesMap.set( fileList[ i ].name, files[ i ] );\n            }\n\n            return ReaderParser.readNodeURL( fileName, {\n                filesMap: filesMap\n            } );\n\n        } );\n    },\n\n    // Adds basic types\n    init: function () {\n        FileHelper._typesMap = new window.Map();\n        // Binary\n        FileHelper._typesMap.set( 'bin', 'arraybuffer' );\n        FileHelper._typesMap.set( 'b3dm', 'arraybuffer' );\n        FileHelper._typesMap.set( 'glb', 'arraybuffer' );\n        FileHelper._typesMap.set( 'zip', 'arraybuffer' );\n        // Image\n        FileHelper._typesMap.set( 'png', 'blob' );\n        FileHelper._typesMap.set( 'jpg', 'blob' );\n        FileHelper._typesMap.set( 'jpeg', 'blob' );\n        FileHelper._typesMap.set( 'gif', 'blob' );\n        // Text\n        FileHelper._typesMap.set( 'json', 'string' );\n        FileHelper._typesMap.set( 'gltf', 'string' );\n        FileHelper._typesMap.set( 'osgjs', 'string' );\n    },\n\n    // To add user defined types\n    addTypeForExtension: function ( type, extension ) {\n        if ( !FileHelper._typesMap ) FileHelper.init();\n        if ( FileHelper._typesMap.get( extension ) !== undefined ) {\n            Notify.warn( 'the \\'' + extension + '\\' already has a type' );\n        }\n        FileHelper._typesMap.set( extension, type );\n    },\n\n    getTypeForExtension: function ( extension ) {\n        if ( !FileHelper._typesMap ) {\n            FileHelper.init();\n        }\n        return this._typesMap.get( extension );\n    }\n};\n\nmodule.exports = FileHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgDB/FileHelper.js\n// module id = 158\n// module chunks = 0 1 2","'use strict';\nvar Hammer = require( 'hammer' );\nvar CADManipulator = require( 'osgGA/CADManipulator' );\nvar CADManipulatorStandardMouseKeyboardController = require( 'osgGA/CADManipulatorStandardMouseKeyboardController' );\nvar CADManipulatorHammerController = require( 'osgGA/CADManipulatorHammerController' );\nvar FirstPersonManipulator = require( 'osgGA/FirstPersonManipulator' );\nvar FirstPersonManipulatorDeviceOrientationController = require( 'osgGA/FirstPersonManipulatorDeviceOrientationController' );\nvar FirstPersonManipulatorHammerController = require( 'osgGA/FirstPersonManipulatorHammerController' );\nvar FirstPersonManipulatorStandardMouseKeyboardController = require( 'osgGA/FirstPersonManipulatorStandardMouseKeyboardController' );\nvar FirstPersonManipulatorWebVRController = require( 'osgGA/FirstPersonManipulatorWebVRController' );\nvar Manipulator = require( 'osgGA/Manipulator' );\nvar OrbitManipulator = require( 'osgGA/OrbitManipulator' );\nvar OrbitManipulatorDeviceOrientationController = require( 'osgGA/OrbitManipulatorDeviceOrientationController' );\nvar OrbitManipulatorGamePadController = require( 'osgGA/OrbitManipulatorGamePadController' );\nvar OrbitManipulatorHammerController = require( 'osgGA/OrbitManipulatorHammerController' );\nvar OrbitManipulatorLeapMotionController = require( 'osgGA/OrbitManipulatorLeapMotionController' );\nvar OrbitManipulatorStandardMouseKeyboardController = require( 'osgGA/OrbitManipulatorStandardMouseKeyboardController' );\nvar OrbitManipulatorWebVRController = require( 'osgGA/OrbitManipulatorWebVRController' );\nvar SwitchManipulator = require( 'osgGA/SwitchManipulator' );\nvar OrbitManipulatorEnums = require( 'osgGA/orbitManipulatorEnums' );\n\n\nvar osgGA = {};\n\nHammer.NO_MOUSEEVENTS = true; // disable hammer js mouse events\n\nosgGA.CADManipulator = CADManipulator;\nosgGA.getCADManipulatorStandardMouseKeyboardController = function () {\n    return CADManipulatorStandardMouseKeyboardController;\n};\nosgGA.getCADManipulatorHammerController = function () {\n    return CADManipulatorHammerController;\n};\nosgGA.FirstPersonManipulator = FirstPersonManipulator;\nosgGA.getFirstPersonDeviceOrientationController = function () {\n    return FirstPersonManipulatorDeviceOrientationController;\n};\nosgGA.getFirstPersonManipulatorHammerController = function () {\n    return FirstPersonManipulatorHammerController;\n};\nosgGA.getFirstPersonStandardMouseKeyboardControllerClass = function () {\n    return FirstPersonManipulatorStandardMouseKeyboardController;\n};\nosgGA.getFirstPersonWebVRControllerClass = function () {\n    return FirstPersonManipulatorWebVRController;\n};\nosgGA.Manipulator = Manipulator;\nosgGA.OrbitManipulator = OrbitManipulator;\nosgGA.getOrbitManipulatorDeviceOrientationController = function () {\n    return OrbitManipulatorDeviceOrientationController;\n};\nosgGA.getOrbitManipulatorGamePadController = function () {\n    return OrbitManipulatorGamePadController;\n};\nosgGA.getOrbitManipulatorHammerController = function () {\n    return OrbitManipulatorHammerController;\n};\nosgGA.getOrbitManipulatorLeapMotionController = function () {\n    return OrbitManipulatorLeapMotionController;\n};\nosgGA.getOrbitManipulatorStandardMouseKeyboardController = function () {\n    return OrbitManipulatorStandardMouseKeyboardController;\n};\nosgGA.getOrbitManipulatorWebVRController = function () {\n    return OrbitManipulatorWebVRController;\n};\n\nosgGA.SwitchManipulator = SwitchManipulator;\n\nosgGA.OrbitManipulator.Rotate = OrbitManipulatorEnums.ROTATE;\nosgGA.OrbitManipulator.Pan = OrbitManipulatorEnums.PAN;\nosgGA.OrbitManipulator.Zoom = OrbitManipulatorEnums.ZOOM;\n\nmodule.exports = osgGA;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/osgGA.js\n// module id = 159\n// module chunks = 0 1 2","module.exports = __WEBPACK_EXTERNAL_MODULE_160__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammer\"}\n// module id = 160\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Manipulator = require( 'osgGA/Manipulator' );\nvar IntersectionVisitor = require( 'osgUtil/IntersectionVisitor' );\nvar LineSegmentIntersector = require( 'osgUtil/LineSegmentIntersector' );\nvar PolytopeIntersector = require( 'osgUtil/PolytopeIntersector' );\nvar ComputeMatrixFromNodePath = require( 'osg/computeMatrixFromNodePath' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar CADManipulatorStandardMouseKeyboardController = require( 'osgGA/CADManipulatorStandardMouseKeyboardController' );\nvar CADManipulatorHammerController = require( 'osgGA/CADManipulatorHammerController' );\nvar DelayInterpolator = require( 'osgUtil/DelayInterpolator' );\n\n/**\n *  CADManipulator\n *  @class Provides a manipulator with rotation and zoom capacities around a pivot point.\n *  The pivot point is computed through intersections. If no intersection is computed\n *  the manipulator uses the last computed pivot point.\n *  - Mousewheel/Pinch zooms in and out on the pivot point.\n *  - Double click/tap zooms in on the pivot point.\n *  - Left click/pan rotates around the pivot point.\n *  - Center/Right click or two-finger drag moves the view.\n *  - Spacebar resets the view.\n */\n\nvar CADManipulator = function () {\n    Manipulator.call( this );\n    this._tmpHomePosition = vec3.create();\n    this._intersectionVisitor = new IntersectionVisitor();\n    this._lineSegmentIntersector = new LineSegmentIntersector();\n    this._polytopeIntersector = undefined;\n    this._usePolytopeIntersector = false;\n    this._dimensionMask = ( 1 << 2 );\n    this.init();\n};\n\nCADManipulator.Interpolator = function () {\n    this._current = vec2.create();\n    this._target = vec2.create();\n    this._delta = vec2.create();\n    this._reset = false;\n    this.reset();\n    this._width = undefined;\n    this._height = undefined;\n};\n\nCADManipulator.Interpolator.prototype = {\n    setWidth: function ( width ) {\n        this._width = width;\n    },\n    setHeight: function ( height ) {\n        this._height = height;\n    },\n    reset: function () {\n        for ( var i = 0, l = this._current.length; i < l; i++ ) {\n            this._current[ i ] = this._target[ i ] = 0;\n        }\n        this._reset = true;\n    },\n    update: function () {\n        var d0;\n        var d1;\n        if ( this._width === undefined ) d0 = 0;\n        else d0 = ( this._target[ 0 ] - this._current[ 0 ] ) / this._width;\n        this._delta[ 0 ] = d0;\n        this._current[ 0 ] = this._target[ 0 ];\n        if ( this._height === undefined ) d1 = 0;\n        else d1 = ( this._target[ 1 ] - this._current[ 1 ] ) / this._height;\n        this._delta[ 1 ] = d1;\n        this._current[ 1 ] = this._target[ 1 ];\n        return this._delta;\n    },\n    set: function () {\n        for ( var i = 0, l = this._current.length; i < l; i++ ) {\n            this._current[ i ] = this._target[ i ] = arguments[ i ];\n        }\n        this._reset = false;\n    },\n    isReset: function () {\n        return this._reset;\n    },\n    getCurrent: function () {\n        return this._current;\n    },\n    setTarget: function () {\n        for ( var i = 0, l = this._target.length; i < l; i++ ) {\n            if ( this._reset ) {\n                this._target[ i ] = this._current[ i ] = arguments[ i ];\n            } else {\n                this._target[ i ] = arguments[ i ];\n            }\n        }\n        this._reset = false;\n    },\n    addTarget: function () {\n        for ( var i = 0; i < arguments.length; i++ ) {\n            this._target[ i ] += arguments[ i ];\n        }\n    },\n    getTarget: function () {\n        return this._target;\n    },\n    getDelta: function () {\n        return this._delta;\n    }\n};\n\nCADManipulator.AvailableControllerList = [ 'StandardMouseKeyboard', 'Hammer' ];\nCADManipulator.ControllerList = [ 'StandardMouseKeyboard', 'Hammer' ];\n\n/** @lends CADManipulator.prototype */\nCADManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {\n    init: function () {\n        this._distance = 25.0;\n        this._target = vec3.create();\n        this._upz = vec3.fromValues( 0.0, 0.0, 1.0 );\n        this._right = vec3.fromValues( 1.0, 0.0, 0.0 );\n\n        vec3.init( this._target );\n\n        var rot1 = mat4.fromRotation( mat4.create(), -Math.PI, this._upz );\n        var rot2 = mat4.fromRotation( mat4.create(), Math.PI / 10.0, this._right );\n        this._rotation = mat4.create();\n        mat4.mul( this._rotation, rot1, rot2 );\n        this._time = 0.0;\n\n        this._rotate = new CADManipulator.Interpolator();\n        this._pan = new CADManipulator.Interpolator();\n        this._zoom = new DelayInterpolator( 1 );\n\n        this._panFactor = 1.5;\n        this._rotateFactor = 1;\n        this._zoomFactor = 1;\n\n        this._inverseMatrix = mat4.create();\n\n        this._homeEye = undefined;\n        this._homeCenter = undefined;\n        this._homeUp = vec3.fromValues( 0.0, 0.0, 1.0 );\n\n        this._orientation = quat.create();\n        this._pivotPoint = vec3.create();\n\n        this._eye = undefined;\n\n\n        this._zoomDir = vec3.create();\n\n        // instance of controller\n        var self = this;\n\n        CADManipulator.ControllerList.forEach( function ( value ) {\n            if ( CADManipulator[ value ] !== undefined ) {\n                self._controllerList[ value ] = new CADManipulator[ value ]( self );\n            }\n        } );\n    },\n\n    setViewer: function ( viewer ) {\n        this._viewer = viewer;\n    },\n\n    reset: function () {\n        this.init();\n    },\n\n    setNode: function ( node ) {\n        this._node = node;\n    },\n\n    setPivotPoint: function ( pivotPoint ) {\n        // First calculate offset\n        vec3.copy( this._pivotPoint, pivotPoint );\n    },\n\n    setTarget: ( function () {\n        var eyePos = vec3.create();\n        return function ( target ) {\n            vec3.copy( this._target, target );\n            this.getEyePosition( eyePos );\n            this._distance = vec3.distance( target, eyePos );\n        };\n    } )(),\n\n    setEyePosition: function ( eye ) {\n        vec3.copy( this._eye, eye );\n        this._distance = vec3.distance( this._target, eye );\n    },\n\n    setHomePosition: function ( eye, center, up ) {\n        this._homeEye = eye;\n        this._homeCenter = center;\n        this._homeUp = up;\n    },\n\n    computeHomePosition: ( function () {\n        var f = vec3.create();\n        var s = vec3.create();\n        var u = vec3.create();\n        var result = mat4.create();\n        return function ( boundStrategy ) {\n\n            var bs = this.getHomeBound( boundStrategy );\n            if ( !bs ) return;\n            this.setDistance( this.getHomeDistance( bs ) );\n            this.setTarget( bs.center() );\n            this.setPivotPoint( bs.center() );\n\n            if ( this._homeEye === undefined ) {\n                this._homeEye = vec3.create();\n                this.getEyePosition( this._homeEye );\n            }\n\n            if ( this._homeCenter === undefined ) {\n                this._homeCenter = vec3.create();\n                vec3.copy( this._homeCenter, bs.center() );\n            }\n\n            if ( this._eye === undefined ) {\n                this._eye = vec3.create();\n            }\n\n            vec3.copy( this._eye, this._homeEye );\n            vec3.copy( this._target, this._homeCenter );\n            vec3.copy( this._upz, this._homeUp );\n\n            mat4.copy( result, this._rotation );\n            var center = this._target;\n            var eye = this._eye;\n\n            vec3.sub( f, center, eye );\n            vec3.normalize( f, f );\n\n            vec3.cross( s, f, this._upz );\n            vec3.normalize( s, s );\n\n            vec3.cross( u, s, f );\n            vec3.normalize( u, u );\n\n            // s[0], f[0], u[0], 0.0,\n            // s[1], f[1], u[1], 0.0,\n            // s[2], f[2], u[2], 0.0,\n            // 0,    0,    0,     1.0\n            result[ 0 ] = s[ 0 ];\n            result[ 1 ] = u[ 0 ];\n            result[ 2 ] = -f[ 0 ];\n            result[ 3 ] = 0.0;\n            result[ 4 ] = s[ 1 ];\n            result[ 5 ] = u[ 1 ];\n            result[ 6 ] = -f[ 1 ];\n            result[ 7 ] = 0.0;\n            result[ 8 ] = s[ 2 ];\n            result[ 9 ] = u[ 2 ];\n            result[ 10 ] = -f[ 2 ];\n            result[ 11 ] = 0.0;\n            result[ 12 ] = 0;\n            result[ 13 ] = 0;\n            result[ 14 ] = 0;\n            result[ 15 ] = 1.0;\n\n            mat4.getRotation( this._orientation, result );\n            quat.invert( this._orientation, this._orientation );\n        };\n    } )(),\n\n    setZoomFactor: function ( f ) {\n        this._zoomFactor = f;\n    },\n\n    setRotateFactor: function ( f ) {\n        this._rotateFactor = f;\n    },\n\n    setPanFactor: function ( f ) {\n        this._panFactor = f;\n    },\n\n    setDistance: function ( d ) {\n        this._distance = d;\n    },\n\n    // If set to true, intersections are computed against points and lines\n    setUsePolytopeIntersector: function ( upi ) {\n        this._usePolytopeIntersector = upi;\n    },\n\n    getUsePolytopeIntersector: function () {\n        return this._usePolytopeIntersector;\n    },\n\n    getDistance: function () {\n        return this._distance;\n    },\n\n    zoom: function ( ratio ) {\n        this._distance = ratio;\n    },\n\n    getRotateInterpolator: function () {\n        return this._rotate;\n    },\n\n    getPanInterpolator: function () {\n        return this._pan;\n    },\n\n    getZoomInterpolator: function () {\n        return this._zoom;\n    },\n\n    getIntersectionVisitor: function () {\n        return this._intersectionVisitor;\n    },\n\n    getLineSegmentIntersector: function () {\n        return this._lineSegmentIntersector;\n    },\n\n    getOrCreatePolytopeIntersector: function () {\n        if ( this._polytopeIntersector === undefined ) {\n            this._polytopeIntersector = new PolytopeIntersector();\n            this._polytopeIntersector.setIntersectionLimit( PolytopeIntersector.LIMIT_ONE_PER_DRAWABLE );\n            this._polytopeIntersector.setDimensionMask( PolytopeIntersector.DimZero | PolytopeIntersector.DimOne );\n        }\n        return this._polytopeIntersector;\n    },\n\n    getTarget: function ( target ) {\n        vec3.copy( target, this._target );\n        return target;\n    },\n\n    getEyePosition: function ( eye ) {\n        if ( this._eye === undefined )\n            this.computeEyePosition( this._target, this._distance, eye );\n        else vec3.copy( eye, this._eye );\n    },\n\n    computeEyePosition: ( function () {\n        var tmpDist = vec3.create();\n        var tmpInverse = mat4.create();\n        return function ( target, distance, eye ) {\n            mat4.invert( tmpInverse, this._rotation );\n            tmpDist[ 1 ] = distance;\n            vec3.transformMat4( eye, tmpDist, tmpInverse );\n            vec3.add( eye, target, eye );\n        };\n    } )(),\n\n    computePan: ( function () {\n        var trans = vec3.create();\n        var rotPos = vec3.create();\n        var speedTmp = vec3.create();\n        return function ( dx, dy, rotMat ) {\n            var speed = vec3.length( vec3.sub( speedTmp, this._eye, this._pivotPoint ) ) / this._panFactor;\n            if ( speed < 10 ) speed = 10;\n            trans[ 0 ] = dx * speed / 2;\n            trans[ 1 ] = dy * speed / 2;\n            trans[ 2 ] = 0;\n            vec3.transformMat4( rotPos, trans, rotMat );\n            vec3.add( this._eye, this._eye, rotPos );\n        };\n    } )(),\n\n    computeZoom: ( function () {\n        var vectorDistance = vec3.create();\n        var speedDist = vec3.create();\n        return function ( dz ) {\n            var zoomSpeed = dz * this._zoomFactor;\n            vec3.sub( vectorDistance, this._pivotPoint, this._eye );\n            vec3.add( this._eye, this._eye, vec3.scale( speedDist, vectorDistance, zoomSpeed ) );\n        };\n    } )(),\n\n    computeRotation: ( function () {\n\n        var rightNormalized = vec3.create();\n        var right = vec3.create();\n        var dir = vec3.create();\n        var offset = vec3.create();\n        var pitchQuat = quat.create();\n        var yawQuat = quat.create();\n        var pitchyawQuat = quat.create();\n        var tmp = vec3.create();\n        var rightScalar = vec3.create();\n\n        return function ( yawDelta, pitchDelta ) {\n\n            vec3.transformQuat( right, this._right, this._orientation );\n            vec3.normalize( rightNormalized, right );\n            vec3.sub( dir, this._eye, this._pivotPoint );\n            var scalar = vec3.dot( rightNormalized, dir );\n            vec3.sub( offset, dir, vec3.scale( rightScalar, rightNormalized, scalar ) );\n            var xy = vec3.fromValues( -offset[ 0 ], -offset[ 1 ], 0 );\n\n            var positionPitch = Math.atan2( -offset[ 2 ], vec3.length( xy ) );\n            pitchDelta = Math.max( -Math.PI / 2 + 0.01, Math.min( Math.PI / 2 - 0.01, ( positionPitch + pitchDelta ) ) ) - positionPitch;\n\n            quat.setAxisAngle( pitchQuat, right, pitchDelta * this._rotateFactor );\n            quat.setAxisAngle( yawQuat, this._upz, yawDelta * this._rotateFactor );\n\n            quat.mul( pitchyawQuat, yawQuat, pitchQuat );\n            vec3.transformQuat( tmp, dir, pitchyawQuat );\n            vec3.add( this._eye, tmp, this._pivotPoint );\n\n            // Find rotation offset and target\n            quat.mul( this._orientation, yawQuat, this._orientation );\n\n            vec3.transformQuat( right, this._right, this._orientation );\n            quat.setAxisAngle( pitchQuat, right, pitchDelta * this._rotateFactor );\n            quat.mul( this._orientation, pitchQuat, this._orientation );\n        };\n    } )(),\n\n\n    update: ( function () {\n        var rotMat = mat4.create();\n        var transMat = mat4.create();\n        return function ( nv ) {\n\n            var dt = nv.getFrameStamp().getDeltaTime();\n\n            var mouseFactor = 10;\n            //Note inverted y\n            var delta = this._rotate.update();\n            this.computeRotation( -delta[ 0 ] * mouseFactor, delta[ 1 ] * mouseFactor );\n            mat4.fromQuat( rotMat, this._orientation );\n\n            var deltapan = this._pan.update();\n            this.computePan( -deltapan[ 0 ] * mouseFactor, -deltapan[ 1 ] * mouseFactor, rotMat );\n\n            delta = this._zoom.update( dt );\n            this.computeZoom( -delta[ 0 ] / 10.0 );\n\n            mat4.fromTranslation( transMat, this._eye );\n            mat4.mul( this._inverseMatrix, transMat, rotMat );\n            mat4.invert( this._inverseMatrix, this._inverseMatrix );\n        };\n    } )(),\n    getInverseMatrix: function () {\n        return this._inverseMatrix;\n    },\n\n    computeIntersections: ( function () {\n        var hits = [];\n        var pTrans = vec3.create();\n        return function ( pos ) {\n            var viewer = this._camera.getView();\n\n            var cam = this._camera;\n            var width = cam.getViewport().width();\n            var height = cam.getViewport().height();\n            this._rotate.setWidth( width );\n            this._rotate.setHeight( height );\n            this._pan.setWidth( width );\n            this._pan.setHeight( height );\n\n            var point, matrix;\n            if ( ( this._dimensionMask & ( 1 << 2 ) ) !== 0 ) {\n                hits = viewer.computeIntersections( pos[ 0 ], pos[ 1 ] );\n\n                if ( hits.length > 0 ) {\n                    point = hits[ 0 ].point;\n                    hits[ 0 ].nodepath.shift();\n                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( hits[ 0 ].nodepath );\n                    vec3.transformMat4( pTrans, point, matrix );\n                    this.setPivotPoint( pTrans );\n                }\n            }\n\n            if ( hits.length === 0 && this._usePolytopeIntersector ) {\n                var pi = this.getOrCreatePolytopeIntersector();\n                pi.reset();\n                pi.setPolytopeFromWindowCoordinates( pos[ 0 ] - 5, pos[ 1 ] - 5, pos[ 0 ] + 5, pos[ 1 ] + 5 );\n                var iv = this._intersectionVisitor;\n                iv.setIntersector( pi );\n                viewer.getCamera().accept( iv );\n                hits = pi.getIntersections();\n                hits.sort( function ( a, b ) {\n                    return a._distance - b._distance;\n                } );\n                if ( hits.length > 0 ) {\n                    point = hits[ 0 ]._center;\n                    hits[ 0 ].nodePath.shift();\n                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( hits[ 0 ].nodePath );\n                    vec3.transformMat4( pTrans, point, matrix );\n                    this.setPivotPoint( pTrans );\n                }\n            }\n        };\n    } )(),\n\n    getPositionRelativeToCanvas: ( function () {\n        var offset = vec2.create();\n        var pos = vec2.create();\n        return function ( x, y ) {\n            var canvas = this._camera._graphicContext.canvas;\n            this.getOffsetRect( canvas, offset );\n            var ratioX = canvas.width / canvas.clientWidth;\n            var ratioY = canvas.height / canvas.clientHeight;\n            pos[ 0 ] = ( x - offset[ 1 ] ) * ratioX;\n            pos[ 1 ] = ( canvas.clientHeight - ( y - offset[ 0 ] ) ) * ratioY;\n            return pos;\n        };\n    } )(),\n\n    getCanvasCenter: ( function () {\n        var offset = vec2.create();\n        var pos = vec2.create();\n        return function () {\n            var canvas = this._camera.getGraphicContext().canvas;\n            this.getOffsetRect( canvas, offset );\n            var ratioX = canvas.width / canvas.clientWidth;\n            var ratioY = canvas.height / canvas.clientHeight;\n            pos[ 0 ] = ( canvas.clientWidth / 2 ) * ratioX;\n            pos[ 1 ] = ( canvas.clientHeight / 2 ) * ratioY;\n            return pos;\n        };\n    } )(),\n\n    getOffsetRect: function ( elem, offset ) {\n        var box = elem.getBoundingClientRect();\n        var body = document.body;\n        var docElem = document.documentElement;\n        var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;\n        var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;\n        var clientTop = docElem.clientTop || body.clientTop || 0;\n        var clientLeft = docElem.clientLeft || body.clientLeft || 0;\n        var top = box.top + scrollTop - clientTop;\n        var left = box.left + scrollLeft - clientLeft;\n        offset[ 0 ] = Math.round( top );\n        offset[ 1 ] = Math.round( left );\n        return offset;\n    }\n\n} );\n\nCADManipulator.StandardMouseKeyboard = CADManipulatorStandardMouseKeyboardController;\nCADManipulator.Hammer = CADManipulatorHammerController;\n\nmodule.exports = CADManipulator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/CADManipulator.js\n// module id = 161\n// module chunks = 0 1 2","'use strict';\nvar BoundingSphere = require( 'osg/BoundingSphere' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\n// Base class for Camera / User manipulator\nvar Manipulator = function ( boundStrategy ) {\n    this._boundStrategy = boundStrategy;\n    if ( this._boundStrategy === undefined )\n        this._boundStrategy = Manipulator.COMPUTE_HOME_USING_SPHERE;\n\n    this._controllerList = {};\n    this._inverseMatrix = mat4.create();\n    this._camera = undefined;\n    this._node = undefined;\n    this._frustum = {};\n    this._computeBoundNodeMaskOverride = ~0x0;\n};\n\nManipulator.prototype = {\n    setCamera: function ( c ) {\n        this._camera = c;\n    },\n    getCamera: function () {\n        return this._camera;\n    },\n    setNode: function ( node ) {\n        this._node = node;\n    },\n    setComputeBoundNodeMaskOverride: function ( mask ) {\n        this._computeBoundNodeMaskOverride = mask;\n    },\n    getComputeBoundNodeMaskOverride: function () {\n        return this._computeBoundNodeMaskOverride;\n    },\n\n    // overrideStrat should be a bounding volume calculation strategy\n    getHomeBound: function ( overrideStrat ) {\n        var node = this._node;\n        if ( !node )\n            return;\n\n        var type = overrideStrat !== undefined ? overrideStrat : this._boundStrategy;\n\n        if ( type & Manipulator.COMPUTE_HOME_USING_BBOX ) {\n            var bs = new BoundingSphere();\n\n            var bb = null;\n            if ( this._computeBoundNodeMaskOverride === ~0x0 ) {\n                bb = node.getBoundingBox();\n            } else {\n                var ComputeBoundsVisitor = require( 'osg/ComputeBoundsVisitor' );\n                var cbv = new ComputeBoundsVisitor();\n                cbv.setNodeMaskOverride( this._computeBoundNodeMaskOverride );\n                cbv.reset();\n\n                cbv.apply( node );\n                bb = cbv.getBoundingBox();\n            }\n\n            if ( bb.valid() )\n                bs.expandByBoundingBox( bb );\n\n            // minimum between sphere and box\n            if ( type & Manipulator.COMPUTE_HOME_USING_SPHERE ) {\n                var boundSphere = node.getBound();\n                if ( boundSphere.radius() < bs.radius() )\n                    return boundSphere;\n            }\n\n            return bs;\n        }\n\n        return node.getBound();\n    },\n    getHomeDistance: function ( bs ) {\n        var frustum = this._frustum;\n        var dist = bs.radius();\n        if ( this._camera && mat4.getFrustum( frustum, this._camera.getProjectionMatrix() ) ) {\n            var vertical2 = Math.abs( frustum.right - frustum.left ) / frustum.zNear / 2;\n            var horizontal2 = Math.abs( frustum.top - frustum.bottom ) / frustum.zNear / 2;\n            dist /= Math.sin( Math.atan2( horizontal2 < vertical2 ? horizontal2 : vertical2, 1 ) );\n        } else {\n            dist *= 1.5;\n        }\n        return dist;\n    },\n    // eg: var currentTime = nv.getFrameStamp().getSimulationTime();\n    update: function ( /*nv*/) {},\n\n    getInverseMatrix: function () {\n        return this._inverseMatrix;\n    },\n\n    getControllerList: function () {\n        return this._controllerList;\n    }\n};\n\n// flags\nManipulator.COMPUTE_HOME_USING_SPHERE = 1 << 0;\nManipulator.COMPUTE_HOME_USING_BBOX = 1 << 1;\n\nmodule.exports = Manipulator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/Manipulator.js\n// module id = 162\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar TransformEnums = require( 'osg/transformEnums' );\n\n\nvar IntersectionVisitor = function () {\n    NodeVisitor.call( this );\n    // We could need to use a stack of intersectors in case we want\n    // to use several intersectors. Right now we use only one.\n    this._intersector = undefined;\n    this._projectionStack = [ mat4.IDENTITY ];\n    this._modelStack = [ mat4.IDENTITY ];\n    this._viewStack = [ mat4.IDENTITY ];\n    this._windowStack = [ mat4.IDENTITY ];\n\n    this.reset();\n};\n\nIntersectionVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    reset: function () {\n        IntersectionVisitor._reservedMatrixStack.reset();\n    },\n    setIntersector: function ( intersector ) {\n        this._intersector = intersector;\n    },\n    getIntersector: function () {\n        return this._intersector;\n    },\n    // Model matrix\n    pushModelMatrix: function ( matrix ) {\n        this._modelStack.push( matrix );\n    },\n    getModelMatrix: function () {\n        return ( this._modelStack.length ) ? this._modelStack[ this._modelStack.length - 1 ] : undefined;\n\n    },\n    popModelMatrix: function () {\n        return this._modelStack.pop();\n    },\n    // View Matrix\n    pushViewMatrix: function ( matrix ) {\n        this._viewStack.push( matrix );\n\n    },\n    getViewMatrix: function () {\n        return ( this._viewStack.length ) ? this._viewStack[ this._viewStack.length - 1 ] : undefined;\n\n    },\n    popViewMatrix: function () {\n        return this._viewStack.pop();\n    },\n    // Projection Matrix\n    pushProjectionMatrix: function ( matrix ) {\n        this._projectionStack.push( matrix );\n    },\n    getProjectionMatrix: function () {\n        return ( this._projectionStack.length ) ? this._projectionStack[ this._projectionStack.length - 1 ] : undefined;\n\n    },\n    popProjectionMatrix: function () {\n        return this._projectionStack.pop();\n    },\n    // Window Matrix\n    pushWindowMatrix: function ( matrix ) {\n        this._windowStack.push( matrix );\n    },\n    pushWindowMatrixUsingViewport: function ( viewport ) {\n        this._windowStack.push( viewport.computeWindowMatrix( IntersectionVisitor._reservedMatrixStack.get() ) );\n    },\n    getWindowMatrix: function () {\n        return ( this._windowStack.length ) ? this._windowStack[ this._windowStack.length - 1 ] : undefined;\n    },\n    popWindowMatrix: function () {\n        return this._windowStack.pop();\n    },\n    getTransformation: ( function () {\n        // We should move this to the intersector when we need to use different coordinate frames\n        // Now we only support WINDOW coordinate frame\n\n        // /!\\ 64 bit precision because the picking is jittery otherwise\n        // It's probably caused by one of the camera matrix that has too big/small values\n        // but currently it's the ony fix we have\n        var mat = mat4.create64();\n\n        return function () {\n            mat4.copy( mat, this.getWindowMatrix() || mat4.IDENTITY );\n            mat4.mul( mat, mat, this.getProjectionMatrix() || mat4.IDENTITY );\n            mat4.mul( mat, mat, this.getViewMatrix() || mat4.IDENTITY );\n            mat4.mul( mat, mat, this.getModelMatrix() || mat4.IDENTITY );\n\n            return mat;\n        };\n    } )(),\n\n    enter: function ( node ) {\n        // Call to each intersector\n        return this._intersector.enter( node );\n    },\n\n    apply: function ( node ) {\n        // Here we need to decide which apply method to use\n        if ( node.getViewMatrix ) {\n            // It's a Camera\n            this.applyCamera( node );\n        } else {\n            if ( node.getMatrix ) {\n                // It's a Transform Node\n                this.applyTransform( node );\n            } else {\n                // It's a leaf or an intermediate node\n                this.applyNode( node );\n            }\n        }\n    },\n\n    applyCamera: function ( camera ) {\n        // We use an absolute reference frame for simplicity\n        var vp = camera.getViewport();\n        if ( vp !== undefined ) {\n            this.pushWindowMatrixUsingViewport( vp );\n        }\n\n        var projection, view, model;\n        if ( camera.getReferenceFrame() === TransformEnums.RELATIVE_RF && this.getViewMatrix() && this.getProjectionMatrix() ) {\n            // relative\n            projection = mat4.mul( IntersectionVisitor._reservedMatrixStack.get(), this.getProjectionMatrix(), camera.getProjectionMatrix() );\n            view = this.getViewMatrix();\n            model = mat4.mul( IntersectionVisitor._reservedMatrixStack.get(), this.getModelMatrix(), camera.getViewMatrix() );\n        } else {\n            // absolute\n            projection = camera.getProjectionMatrix();\n            view = camera.getViewMatrix();\n            model = mat4.identity( IntersectionVisitor._reservedMatrixStack.get() );\n        }\n\n        this.pushProjectionMatrix( projection );\n        this.pushViewMatrix( view );\n        this.pushModelMatrix( model );\n\n        // TODO maybe we should do something like OSG for the transformation given\n        // to the intersector (having a stack)\n        this._intersector.setCurrentTransformation( this.getTransformation() );\n        this.traverse( camera );\n\n        this.popModelMatrix();\n        this.popViewMatrix();\n        this.popProjectionMatrix();\n        if ( vp !== undefined ) {\n            this.popWindowMatrix();\n        }\n        this._intersector.setCurrentTransformation( this.getTransformation() );\n    },\n\n    applyNode: function ( node ) {\n        if ( !this.enter( node ) ) return;\n        // As this part of the code is potentially executed a lot of times we don't use instanceof\n        // https://jsperf.com/instanceof-performance/25\n        if ( node.getPrimitiveSetList ) {\n            this._intersector.intersect( this, node );\n            // If it is a leaf (it has primitives) we can safely return\n            return;\n        }\n        if ( node.traverse ) {\n            this.traverse( node );\n        }\n    },\n\n    applyTransform: function ( node ) {\n        // Now only use PROJECTION coordinate frame\n        if ( !this.enter( node ) ) return;\n        // Accumulate Transform\n        if ( node.getReferenceFrame() === TransformEnums.ABSOLUTE_RF ) {\n            var matrix = IntersectionVisitor._reservedMatrixStack.get();\n            this.pushViewMatrix( mat4.identity( matrix ) );\n            this.pushModelMatrix( node.getMatrix() );\n        } else if ( this._modelStack.length > 0 ) {\n            var m = mat4.copy( IntersectionVisitor._reservedMatrixStack.get(), this.getModelMatrix() );\n            mat4.mul( m, m, node.getMatrix() );\n            this.pushModelMatrix( m );\n        } else {\n            this.pushModelMatrix( node.getMatrix() );\n        }\n\n        // TODO see above\n        this._intersector.setCurrentTransformation( this.getTransformation() );\n        this.traverse( node );\n\n        this.popModelMatrix();\n        if ( node.getReferenceFrame() === TransformEnums.ABSOLUTE_RF )\n            this.popViewMatrix();\n        this._intersector.setCurrentTransformation( this.getTransformation() );\n    }\n} );\n\nIntersectionVisitor._reservedMatrixStack = new MatrixMemoryPool();\n\nmodule.exports = IntersectionVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/IntersectionVisitor.js\n// module id = 163\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar TriangleLineSegmentIntersector = require( 'osgUtil/TriangleLineSegmentIntersector' );\n\n\nvar LineSegmentIntersector = function () {\n    this._start = vec3.create();\n    this._end = vec3.create();\n    this._iStart = vec3.create();\n    this._iEnd = vec3.create();\n    this._intersections = [];\n};\n\nLineSegmentIntersector.prototype = {\n    set: function ( start, end ) {\n        vec3.copy( this._start, start );\n        vec3.copy( this._iStart, start );\n        vec3.copy( this._end, end );\n        vec3.copy( this._iEnd, end );\n    },\n    setStart: function ( start ) {\n        vec3.copy( this._start, start );\n        vec3.copy( this._iStart, start );\n    },\n    setEnd: function ( end ) {\n        vec3.copy( this._end, end );\n        vec3.copy( this._iEnd, end );\n    },\n    reset: function () {\n        // Clear the intersections vector\n        this._intersections.length = 0;\n    },\n    enter: function ( node ) {\n        // Not working if culling disabled ??\n        return !node.isCullingActive() || this.intersects( node.getBound() );\n    },\n    // Intersection Segment/Sphere\n    intersects: ( function () {\n        var sm = vec3.create();\n        var se = vec3.create();\n        return function ( bsphere ) {\n            // test for _start inside the bounding sphere\n            if ( !bsphere.valid() ) return false;\n            vec3.sub( sm, this._iStart, bsphere.center() );\n            var c = vec3.sqrLen( sm ) - bsphere.radius2();\n            if ( c <= 0.0 ) {\n                return true;\n            }\n            // solve quadratic equation\n            vec3.sub( se, this._iEnd, this._iStart );\n            var a = vec3.sqrLen( se );\n            var b = vec3.dot( sm, se ) * 2.0;\n            var d = b * b - 4.0 * a * c;\n            // no intersections if d<0\n            if ( d < 0.0 ) {\n                return false;\n            }\n            // compute two solutions of quadratic equation\n            d = Math.sqrt( d );\n            var div = 0.5 / a;\n            var r1 = ( -b - d ) * div;\n            var r2 = ( -b + d ) * div;\n\n            // return false if both intersections are before the ray start\n            if ( r1 <= 0.0 && r2 <= 0.0 ) {\n                return false;\n            }\n\n            if ( r1 > 1.0 && r2 > 1.0 ) {\n                return false;\n            }\n            return true;\n        };\n    } )(),\n\n    intersect: ( function () {\n\n        var ti = new TriangleLineSegmentIntersector();\n\n        return function ( iv, node ) {\n\n            var kdtree = node.getShape();\n            if ( kdtree )\n                return kdtree.intersectRay( this._iStart, this._iEnd, this._intersections, iv.nodePath );\n\n            ti.reset();\n            ti.setNodePath( iv.nodePath );\n            ti.set( this._iStart, this._iEnd );\n\n            // handle rig transformed vertices\n            if ( node.computeTransformedVertices ) {\n                var vList = node.getVertexAttributeList();\n                var originVerts = vList.Vertex.getElements();\n\n                // temporarily hook vertex buffer for the tri intersections\n                // don't call setElements as it dirty some stuffs because of gl buffer\n                vList.Vertex._elements = node.computeTransformedVertices();\n                ti.apply( node );\n                vList.Vertex._elements = originVerts;\n            } else {\n                ti.apply( node );\n            }\n\n            var trianglesIntersections = ti._intersections;\n            var intersections = this._intersections;\n            var l = trianglesIntersections.length;\n            for ( var i = 0; i < l; i++ ) {\n                intersections.push( trianglesIntersections[ i ] );\n            }\n\n            return l > 0;\n        };\n    } )(),\n\n    getIntersections: function () {\n        return this._intersections;\n    },\n    setCurrentTransformation: function ( matrix ) {\n        mat4.invert( matrix, matrix );\n        vec3.transformMat4( this._iStart, this._start, matrix );\n        vec3.transformMat4( this._iEnd, this._end, matrix );\n    }\n};\n\nmodule.exports = LineSegmentIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/LineSegmentIntersector.js\n// module id = 164\n// module chunks = 0 1 2","'use strict';\nvar PolytopePrimitiveIntersector = require( 'osgUtil/PolytopePrimitiveIntersector' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Plane = require( 'osg/Plane' );\n\n/** Concrete class for implementing polytope intersections with the scene graph.\n * To be used in conjunction with IntersectionVisitor. */\nvar PolytopeIntersector = function () {\n    this._intersections = [];\n    this._index = 0;\n    this._polytope = [];\n    this._iPolytope = [];\n    this._referencePlane = vec4.create();\n    this._iReferencePlane = vec4.create();\n    this._intersectionLimit = PolytopeIntersector.NO_LIMIT;\n    this._dimensionMask = PolytopeIntersector.AllDims;\n};\n\n\nPolytopeIntersector.NO_LIMIT = 0;\nPolytopeIntersector.LIMIT_ONE_PER_DRAWABLE = 1;\nPolytopeIntersector.LIMIT_ONE = 2;\n\n\nPolytopeIntersector.DimZero = ( 1 << 0 );\nPolytopeIntersector.DimOne = ( 1 << 1 );\nPolytopeIntersector.DimTwo = ( 1 << 2 );\nPolytopeIntersector.AllDims = ( PolytopeIntersector.DimZero | PolytopeIntersector.DimOne | PolytopeIntersector.DimTwo );\n\n\nvar transformVec4PostMult = function ( out, p, m ) {\n    var x = p[ 0 ];\n    var y = p[ 1 ];\n    var z = p[ 2 ];\n    var w = p[ 3 ];\n\n    out[ 0 ] = m[ 0 ] * x + m[ 1 ] * y + m[ 2 ] * z + m[ 3 ] * w;\n    out[ 1 ] = m[ 4 ] * x + m[ 5 ] * y + m[ 6 ] * z + m[ 7 ] * w;\n    out[ 2 ] = m[ 8 ] * x + m[ 9 ] * y + m[ 10 ] * z + m[ 11 ] * w;\n    out[ 3 ] = m[ 12 ] * x + m[ 13 ] * y + m[ 14 ] * z + m[ 15 ] * w;\n};\n\nPolytopeIntersector.prototype = {\n\n    setPolytope: function ( polytope ) {\n        var nbPlanes = polytope.length;\n        this._polytope.length = polytope.length = nbPlanes;\n        for ( var i = 0; i < nbPlanes; ++i ) {\n            var plane = polytope[ i ];\n            this._polytope[ i ] = vec4.copy( this._polytope[ i ] || Plane.create(), plane );\n            this._iPolytope[ i ] = vec4.copy( this._iPolytope[ i ] || Plane.create(), plane );\n        }\n\n        vec4.copy( this._referencePlane, polytope[ nbPlanes - 1 ] );\n        vec4.copy( this._iReferencePlane, this._referencePlane );\n    },\n\n    setPolytopeFromWindowCoordinates: function ( xMin, yMin, xMax, yMax ) {\n        // Note: last polytope value depends on the Coordinate frame\n        // Now we are only supporting WINDOW coordinate frame, so must change this if we decide to support\n        // other types of Coordinate Frame\n        this.setPolytope( [\n            vec4.fromValues( 1.0, 0.0, 0.0, -xMin ),\n            vec4.fromValues( -1.0, 0.0, 0.0, xMax ),\n            vec4.fromValues( 0.0, 1.0, 0.0, -yMin ),\n            vec4.fromValues( 0.0, -1.0, 0.0, yMax ),\n            vec4.fromValues( 0.0, 0.0, 1.0, 0.0 )\n        ] );\n    },\n\n    /** Set the dimension mask.\n     * As polytope-triangle and polytope-quad intersections are expensive to compute\n     * it is possible to turn them off by calling setDimensionMask( DimZero | DimOne )\n     */\n    setDimensionMask: function ( mask ) {\n        this._dimensionMask = mask;\n    },\n\n    reset: function () {\n        // Clear the intersections vector\n        this._intersections.length = 0;\n    },\n\n    enter: function ( node ) {\n        if ( this.reachedLimit() ) return false;\n        return !node.isCullingActive() || this.intersects( node.getBound() );\n    },\n\n    reachedLimit: function () {\n        return this._intersectionLimit === PolytopeIntersector.LIMIT_ONE && this._intersections.length > 0;\n    },\n\n    // Intersection Polytope/Sphere\n    intersects: function ( bsphere ) {\n        if ( !bsphere.valid() ) return false;\n\n        var pos = bsphere.center();\n        var radius = -bsphere.radius();\n        for ( var i = 0, j = this._iPolytope.length; i < j; i++ ) {\n            if ( Plane.distanceToPlane( this._iPolytope, pos ) <= radius ) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    // Intersection Polytope/Geometry\n    intersect: function ( iv, node ) {\n        if ( this.reachedLimit() ) return false;\n        var ppi = new PolytopePrimitiveIntersector();\n        ppi.setNodePath( iv.nodePath );\n        ppi.set( this._iPolytope, this._iReferencePlane );\n        ppi.setLimitOneIntersection( this._intersectionLimit === PolytopeIntersector.LIMIT_ONE_PER_DRAWABLE || this._intersectionLimit === PolytopeIntersector.LIMIT_ONE );\n        ppi.setDimensionMask( this._dimensionMask );\n        ppi.apply( node );\n        var l = ppi._intersections.length;\n        if ( l > 0 ) {\n            // Intersection/s exists\n            for ( var i = 0; i < l; i++ ) {\n                this._intersections.push( ppi._intersections[ i ] );\n            }\n            return true;\n        }\n        // No intersection found\n        return false;\n    },\n\n    getIntersections: function () {\n        return this._intersections;\n    },\n\n    setIntersectionLimit: function ( limit ) {\n        this._intersectionLimit = limit;\n    },\n\n    setCurrentTransformation: function ( matrix ) {\n        // Transform the polytope and the referencePlane to the current Model local coordinate frame\n        for ( var i = 0, j = this._polytope.length; i < j; i++ ) {\n            var iplane = this._iPolytope[ i ] = this._iPolytope[ i ] || vec4.create();\n            // PostMult\n            transformVec4PostMult( iplane, this._polytope[ i ], matrix );\n            // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.\n            vec4.scale( iplane, iplane, 1.0 / vec3.len( iplane ) );\n        }\n\n        //Post Mult\n        transformVec4PostMult( this._iReferencePlane, this._referencePlane, matrix );\n\n        // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.\n        vec4.scale( this._iReferencePlane, this._iReferencePlane, 1.0 / vec3.len( this._iReferencePlane ) );\n    }\n};\n\nmodule.exports = PolytopeIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/PolytopeIntersector.js\n// module id = 165\n// module chunks = 0 1 2","'use strict';\nvar osgMath = require( 'osg/math' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar PrimitiveFunctor = require( 'osg/PrimitiveFunctor' );\nvar Plane = require( 'osg/Plane' );\n\n\nvar PolytopeIntersection = function ( index, candidates, candidatesMasks, referencePlane, nodePath ) {\n    this._index = index - 1; ///< primitive index\n    this._distance = 0; ///< distance from reference plane\n    this._maxDistance = -1; ///< maximum distance of intersection points from reference plane\n    this._numPoints = 0;\n    this._points = [];\n    this._maxNumIntersections = 6;\n    this._center = vec3.create();\n    for ( var i = 0, j = candidates.length; i < j; i++ ) {\n        if ( candidatesMasks[ i ] === 0 ) continue;\n\n        this._points[ this._numPoints++ ] = vec3.clone( candidates[ i ] );\n        vec3.add( this._center, this._center, candidates[ i ] );\n\n        var distance = Plane.distanceToPlane( referencePlane, candidates[ i ] );\n        if ( distance > this._maxDistance ) this._maxDistance = distance;\n        if ( this._numPoints === this._maxNumIntesections ) break;\n    }\n\n    vec3.scale( this._center, this._center, 1 / this._numPoints );\n    this._distance = Plane.distanceToPlane( referencePlane, this._center );\n    this.nodePath = nodePath;\n};\n\nvar PlanesLine = function ( planeMask, pos, dir ) {\n    this._planeMask = planeMask;\n    this._pos = pos;\n    this._dir = dir;\n};\nvar PolytopePrimitiveIntersector = function () {\n    this._intersections = [];\n    this._nodePath = [];\n    this._index = 0;\n    this._referencePlane = [];\n    this._planes = []; ///< active planes extracted from polytope\n    this._lines = []; ///< all intersection lines of two polytope planes\n    this._candidates = [];\n    this._candidatesMasks = [];\n    this._lines = [];\n    this._planesMask = 0;\n    this._limitOneIntersection = false;\n    this._dimensionMask = undefined;\n};\n\nPolytopePrimitiveIntersector.prototype = {\n\n    setNodePath: function ( np ) {\n        this._nodePath = np;\n    },\n\n    set: function ( polytope, referencePlane ) {\n        this._planes = polytope;\n        this._referencePlane = referencePlane;\n        this._planesMask = 0;\n        this._lines.length = 0;\n        for ( var i = 0; i < this._planes.length; i++ ) {\n            this._planesMask = ( this._planesMask << 1 ) | 1;\n        }\n    },\n\n    setDimensionMask: function ( mask ) {\n        this._dimensionMask = mask;\n    },\n\n    apply: function ( node ) {\n        if ( !node.getAttributes().Vertex ) {\n            return;\n        }\n        var vertices = node.getAttributes().Vertex.getElements();\n        var self = this;\n        // The callback must be defined as a closure\n        /* jshint asi: true */\n        var cb = function () {\n            return {\n                operatorPoint: function ( v ) {\n                    self.intersectPoint( v );\n                },\n                operatorLine: function ( v1, v2 ) {\n                    self.intersectLine( v1, v2 );\n                },\n                operatorTriangle: function ( v1, v2, v3 ) {\n                    self.intersectTriangle( v1, v2, v3 );\n                }\n            }\n        };\n        var pf = new PrimitiveFunctor( node, cb, vertices );\n        pf.apply();\n    },\n\n\n    checkCandidatePoints: function ( insideMask ) {\n        var selectorMask = 0x1;\n        var numCands = this._candidates.length;\n        for ( var i = 0, j = this._planes.length; i < j && numCands > 0; ++i, selectorMask <<= 1 ) {\n            if ( insideMask & selectorMask ) continue;\n            for ( var c = 0; c < this._candidates.length; ++c ) {\n                if ( this._candidatesMasks[ c ] === 0 ) continue;\n                if ( selectorMask & this._candidatesMasks[ c ] ) continue;\n                if ( this.distance( this._planes[ i ], this._candidates[ c ] ) < 0.0 ) {\n                    this._candidatesMasks[ c ] = 0;\n                    --numCands;\n                    if ( numCands === 0 ) return 0;\n                }\n            }\n        }\n        return numCands;\n    },\n\n    intersectPoint: ( function () {\n        var hit = vec3.create();\n        return function ( v ) {\n            this._index++;\n            if ( ( this._dimensionMask & ( 1 << 0 ) ) === 0 ) return;\n            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;\n            var d;\n\n            for ( var i = 0, j = this._planes.length; i < j; ++i ) {\n                d = this.distance( this._planes[ i ], v );\n                if ( d < 0.0 ) {\n                    // point is outside the polytope\n                    return;\n                }\n            }\n            this._candidates = [];\n            this._candidatesMasks = [];\n            // Intersection found: Copy the value and push it\n            vec3.copy( hit, v );\n            this._candidates.push( hit );\n            this._candidatesMasks.push( this._planesMask );\n            this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n        };\n    } )(),\n\n\n    intersectLine: ( function () {\n\n        var hit = vec3.create();\n        return function ( v1, v2 ) {\n            this._index++;\n            if ( ( this._dimensionMask & ( 1 << 1 ) ) === 0 ) return;\n            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;\n            var v1Inside = true;\n            var v2Inside = true;\n            var selectorMask = 0x1;\n            var insideMask = 0x0;\n            this._candidates = [];\n            this._candidatesMasks = [];\n            var d1, d2, d1IsNegative, d2IsNegative;\n            for ( var i = 0, j = this._planes.length; i < j; ++i, selectorMask <<= 1 ) {\n                d1 = this.distance( this._planes[ i ], v1 );\n                d2 = this.distance( this._planes[ i ], v2 );\n                d1IsNegative = ( d1 < 0.0 );\n                d2IsNegative = ( d2 < 0.0 );\n                if ( d1IsNegative && d2IsNegative ) return; // line outside\n                if ( !d1IsNegative && !d2IsNegative ) {\n                    // completly inside this plane\n                    insideMask |= selectorMask;\n                    continue;\n                }\n                if ( d1IsNegative ) v1Inside = false;\n                if ( d2IsNegative ) v2Inside = false;\n                if ( d1 === 0.0 ) {\n                    vec3.copy( hit, v1 );\n                    this._candidates.push( hit );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( d2 === 0.0 ) {\n                    vec3.copy( hit, v2 );\n                    this._candidates.push( hit );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( d1IsNegative && !d2IsNegative ) {\n                    //v1-(v2-v1)*(d1/(-d1+d2))) )\n                    vec3.sub( hit, v2, v1 );\n                    vec3.scale( hit, hit, d1 / ( -d1 + d2 ) );\n                    vec3.sub( hit, v1, hit );\n                    this._candidates.push( hit );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( !d1IsNegative && d2IsNegative ) {\n                    //(v1+(v2-v1)*(d1/(d1-d2)))\n                    vec3.sub( hit, v2, v1 );\n\n                    vec3.scaleAndAdd( hit, v1, hit, d1 / ( d1 - d2 ) );\n\n                    this._candidates.push( hit );\n                    this._candidatesMasks.push( selectorMask );\n                }\n            }\n\n            if ( insideMask === this._planesMask ) {\n                this._candidates.push( vec3.clone( v1 ) );\n                this._candidatesMasks.push( this._planesMask );\n                this._candidates.push( vec3.clone( v2 ) );\n                this._candidatesMasks.push( this._planesMask );\n                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n                return;\n            }\n\n            var numCands = this.checkCandidatePoints( insideMask );\n            if ( numCands > 0 ) {\n                if ( v1Inside ) {\n                    this._candidatesMasks.push( this._planesMask );\n                    this._candidates.push( vec3.clone( v1 ) );\n                }\n                if ( v2Inside ) {\n                    this._candidatesMasks.push( this._planesMask );\n                    this._candidates.push( vec3.clone( v2 ) );\n                }\n                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n            }\n        };\n    } )(),\n\n    intersectTriangle: ( function () {\n\n        var tmpHit = vec3.create();\n        // Only needed for special case, should we move it to a new function?\n        var e1 = vec3.create();\n        var e2 = vec3.create();\n        var point = vec3.create();\n        var p = vec3.create();\n        var s = vec3.create();\n        var q = vec3.create();\n        return function ( v1, v2, v3 ) {\n            this._index++;\n            if ( ( this._dimensionMask & ( 1 << 2 ) ) === 0 ) return;\n            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;\n            var selectorMask = 0x1;\n            var insideMask = 0x0;\n            this._candidates = [];\n            this._candidatesMasks = [];\n            var d1, d2, d3, d1IsNegative, d2IsNegative, d3IsNegative;\n            for ( var i = 0, j = this._planes.length; i < j; ++i, selectorMask <<= 1 ) {\n                d1 = this.distance( this._planes[ i ], v1 );\n                d2 = this.distance( this._planes[ i ], v2 );\n                d3 = this.distance( this._planes[ i ], v3 );\n                d1IsNegative = ( d1 < 0.0 );\n                d2IsNegative = ( d2 < 0.0 );\n                d3IsNegative = ( d3 < 0.0 );\n\n                if ( d1IsNegative && d2IsNegative && d3IsNegative ) return; // Triangle outside\n                if ( !d1IsNegative && !d2IsNegative && !d3IsNegative ) {\n                    // completly inside this plane\n                    insideMask |= selectorMask;\n                    continue;\n                }\n                // edge v1-v2 intersects\n                if ( d1 === 0.0 ) {\n                    vec3.copy( tmpHit, v1 );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( d2 === 0.0 ) {\n                    vec3.copy( tmpHit, v2 );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( d1IsNegative && !d2IsNegative ) {\n                    //v1-(v2-v1)*(d1/(-d1+d2))) )\n                    vec3.sub( tmpHit, v2, v1 );\n                    vec3.scale( tmpHit, tmpHit, d1 / ( -d1 + d2 ) );\n                    vec3.sub( tmpHit, v1, tmpHit );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( !d1IsNegative && d2IsNegative ) {\n                    //(v1+(v2-v1)*(d1/(d1-d2)))\n                    vec3.sub( tmpHit, v2, v1 );\n\n                    vec3.scaleAndAdd( tmpHit, v1, tmpHit, d1 / ( d1 - d2 ) );\n\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                }\n                // edge v1-v3 intersects\n                if ( d3 === 0.0 ) {\n                    vec3.copy( tmpHit, v3 );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( d1IsNegative && !d3IsNegative ) {\n                    // v1-(v3-v1)*(d1/(-d1+d3))\n                    vec3.sub( tmpHit, v3, v1 );\n                    vec3.scale( tmpHit, tmpHit, d1 / ( -d1 + d3 ) );\n                    vec3.sub( tmpHit, v1, tmpHit );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( !d1IsNegative && d3IsNegative ) {\n                    // v1+(v3-v1)*(d1/(d1-d3))\n                    vec3.sub( tmpHit, v3, v1 );\n\n                    vec3.scaleAndAdd( tmpHit, v1, tmpHit, d1 / ( d1 - d3 ) );\n\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                }\n                // edge v2-v3 intersects\n                if ( d2IsNegative && !d3IsNegative ) {\n                    // v2-(v3-v2)*(d2/(-d2+d3))\n                    vec3.sub( tmpHit, v3, v2 );\n                    vec3.scale( tmpHit, tmpHit, d2 / ( -d2 + d3 ) );\n                    vec3.sub( tmpHit, v2, tmpHit );\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                } else if ( !d2IsNegative && d3IsNegative ) {\n                    //v2+(v3-v2)*(d2/(d2-d3))\n                    vec3.sub( tmpHit, v3, v2 );\n\n                    vec3.scaleAndAdd( tmpHit, v2, tmpHit, d2 / ( d2 - d3 ) );\n\n                    this._candidates.push( vec3.clone( tmpHit ) );\n                    this._candidatesMasks.push( selectorMask );\n                }\n            }\n            if ( insideMask === this._planesMask ) {\n                // triangle lies inside of all planes\n                this._candidates.push( vec3.clone( v1 ) );\n                this._candidatesMasks.push( this._planesMask );\n                this._candidates.push( vec3.clone( v2 ) );\n                this._candidatesMasks.push( this._planesMask );\n                this._candidates.push( vec3.clone( v3 ) );\n                this._candidatesMasks.push( this._planesMask );\n                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n                return;\n            }\n            var numCands = this.checkCandidatePoints( insideMask );\n            if ( numCands > 0 ) {\n                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n                return;\n            }\n            // handle case where the polytope goes through the triangle\n            // without containing any point of it\n            // Probably it can be moved to other function and do the relevant closures.\n\n            var lines = this.getPolytopeLines();\n            this._candidates = [];\n            this._candidatesMasks = [];\n            // check all polytope lines against the triangle\n            // use algorithm from \"Real-time rendering\" (second edition) pp.580\n            //var e1= vec3.create();\n            //var e2= vec3.create();\n\n            vec3.sub( e1, v2, v1 );\n            vec3.sub( e2, v3, v1 );\n            for ( i = 0; i < lines.length; ++i ) {\n                //var point = vec3.create();\n                //var p = vec3.create();\n                vec3.cross( p, lines[ i ]._dir, e2 );\n                var a = vec3.dot( e1, p );\n                if ( Math.abs( a ) < 1E-6 ) continue;\n                var f = 1.0 / a;\n                //var s = vec3.create();\n                vec3.sub( s, lines[ i ]._pos, v1 );\n                var u = f * ( vec3.dot( s, p ) );\n                if ( u < 0.0 || u > 1.0 ) continue;\n                //var q = vec3.create();\n                vec3.cross( q, s, e1 );\n                var v = f * ( vec3.dot( lines[ i ]._dir, q ) );\n                if ( v < 0.0 || u + v > 1.0 ) continue;\n                var t = f * ( vec3.dot( e2, q ) );\n\n                vec3.scaleAndAdd( point, lines[ i ]._pos, lines[ i ]._dir, t );\n\n                this._candidates.push( vec3.copy( vec3.create(), point ) );\n                this._candidatesMasks.push( lines[ i ]._planeMask );\n            }\n            numCands = this.checkCandidatePoints( insideMask );\n            if ( numCands > 0 ) {\n                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );\n                return;\n            }\n        };\n    } )(),\n\n    getPolytopeLines: ( function () {\n        var lineDirection = vec3.create();\n        var searchDirection = vec3.create();\n        var normal1 = vec3.create();\n        var point1 = vec3.create();\n        var normal2 = vec3.create();\n        var linePoint = vec3.create();\n        var epsilon = 1E-6;\n        return function () {\n            if ( this._lines.length > 0 ) return this._lines; // Polytope lines already calculated\n            var selectorMask = 0x1;\n            for ( var i = 0, j = this._planes.length; i < j; i++, selectorMask <<= 1 ) {\n                vec3.copy( normal1, this._planes[ i ] );\n                vec3.scale( point1, normal1, -this._planes[ i ][ 3 ] ); // canonical point on plane[ i ]\n                var subSelectorMask = ( selectorMask << 1 );\n                for ( var jt = i + 1, k = this._planes.length; jt < k; ++jt, subSelectorMask <<= 1 ) {\n                    vec3.copy( normal2, this._planes[ jt ] );\n                    if ( Math.abs( vec3.dot( normal1, normal2 ) ) > ( 1.0 - epsilon ) ) continue;\n                    vec3.cross( lineDirection, normal1, normal2 );\n                    vec3.cross( searchDirection, lineDirection, normal1 );\n                    //-plane2.distance(point1)/(searchDirection*normal2);\n                    var searchDist = -this.distance( this._planes[ jt ], point1 ) / vec3.dot( searchDirection, normal2 );\n                    if ( osgMath.isNaN( searchDist ) ) continue;\n\n                    vec3.scaleAndAdd( linePoint, point1, searchDirection, searchDist );\n\n                    this._lines.push( new PlanesLine( selectorMask | subSelectorMask, vec3.clone( linePoint ), vec3.clone( lineDirection ) ) );\n                }\n            }\n            return this._lines;\n        };\n    } )(),\n\n    setLimitOneIntersection: function ( limit ) {\n        this._limitOneIntersection = limit;\n    },\n\n    distance: function ( plane, v ) {\n        return vec3.dot( plane, v ) + plane[ 3 ];\n    }\n\n};\n\nmodule.exports = PolytopePrimitiveIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/PolytopePrimitiveIntersector.js\n// module id = 166\n// module chunks = 0 1 2","'use strict';\nvar OrbitManipulator = require( 'osgGA/OrbitManipulator' );\n\nvar CADManipulatorStandardMouseKeyboardController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this._timer = false;\n    this.init();\n};\n\nCADManipulatorStandardMouseKeyboardController.prototype = {\n    init: function () {\n        this.releaseButton();\n        this._rotateKey = 65; // a\n        this._zoomKey = 83; // s\n        this._panKey = 68; // d\n        this._mode = undefined;\n    },\n    getMode: function () {\n        return this._mode;\n    },\n    setMode: function ( mode ) {\n        this._mode = mode;\n    },\n    setEventProxy: function ( proxy ) {\n        this._eventProxy = proxy;\n    },\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n    },\n    setDimensionMask: function ( dimMask ) {\n        this._dimensionMask = dimMask;\n    },\n\n    mousemove: function ( ev ) {\n        if ( this._buttonup === true ) {\n            return;\n        }\n\n        var manipulator = this._manipulator;\n        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );\n\n        if ( isNaN( pos[ 0 ] ) === false && isNaN( pos[ 1 ] ) === false ) {\n\n            var mode = this.getMode();\n            if ( mode === OrbitManipulator.Rotate ) {\n                manipulator.getRotateInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\n\n            } else if ( mode === OrbitManipulator.Pan ) {\n                manipulator.getPanInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\n\n            } else if ( mode === OrbitManipulator.Zoom ) {\n                var zoom = manipulator.getZoomInterpolator();\n                manipulator.computeIntersections( pos );\n\n                if ( zoom.isReset() ) {\n                    zoom.setStart( pos[ 1 ] );\n                    zoom.set( 0.0 );\n                }\n                var dy = pos[ 1 ] - zoom.getStart();\n                zoom.setStart( pos[ 1 ] );\n                var v = zoom.getTarget()[ 0 ];\n                zoom.setTarget( v - dy / 20.0 );\n            }\n        }\n\n        ev.preventDefault();\n    },\n    mousedown: function ( ev ) {\n        var manipulator = this._manipulator;\n        var mode = this.getMode();\n        if ( mode === undefined ) {\n            if ( ev.button === 0 ) {\n                if ( ev.shiftKey ) {\n                    this.setMode( OrbitManipulator.Pan );\n                } else if ( ev.ctrlKey ) {\n                    this.setMode( OrbitManipulator.Zoom );\n                } else {\n                    this.setMode( OrbitManipulator.Rotate );\n                }\n            } else {\n                this.setMode( OrbitManipulator.Pan );\n            }\n        }\n\n        this.pushButton();\n\n        //var pos = this.getPositionRelativeToCanvas( ev );\n        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );\n        manipulator.computeIntersections( pos );\n\n        mode = this.getMode();\n        if ( mode === OrbitManipulator.Rotate ) {\n            manipulator.getRotateInterpolator().reset();\n            manipulator.getRotateInterpolator().set( pos[ 0 ], pos[ 1 ] );\n        } else if ( mode === OrbitManipulator.Pan ) {\n            manipulator.getPanInterpolator().reset();\n            manipulator.getPanInterpolator().set( pos[ 0 ], pos[ 1 ] );\n        } else if ( mode === OrbitManipulator.Zoom ) {\n            manipulator.getZoomInterpolator().setStart( pos[ 1 ] );\n            manipulator.getZoomInterpolator().set( 0.0 );\n        }\n    },\n    mouseup: function ( /*ev */) {\n        this.releaseButton();\n        this.setMode( undefined );\n    },\n    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {\n        var manipulator = this._manipulator;\n        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - intDelta;\n        manipulator.getZoomInterpolator().setTarget( zoomTarget );\n        var timer;\n        if ( this._timer === false ) {\n            this._timer = true;\n            var that = this;\n            clearTimeout( timer );\n            timer = setTimeout( function () {\n                that._timer = false;\n            }, 200 );\n            //var pos = this.getPositionRelativeToCanvas( ev );\n            var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );\n            manipulator.computeIntersections( pos );\n        }\n    },\n\n    dblclick: function ( ev ) {\n        var manipulator = this._manipulator;\n        ev.preventDefault();\n\n        manipulator.getZoomInterpolator().set( 0.0 );\n        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - 10; // Default interval 10\n        manipulator.getZoomInterpolator().setTarget( zoomTarget );\n        //var pos = this.getPositionRelativeToCanvas( ev );\n        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );\n        manipulator.computeIntersections( pos );\n    },\n\n    pushButton: function () {\n        this._buttonup = false;\n    },\n    releaseButton: function () {\n        this._buttonup = true;\n    },\n\n    keydown: function ( ev ) {\n        if ( ev.keyCode === 32 ) {\n            this._manipulator.computeHomePosition();\n            ev.preventDefault();\n\n        } else if ( ev.keyCode === this._panKey &&\n            this.getMode() !== OrbitManipulator.Pan ) {\n            this.setMode( OrbitManipulator.Pan );\n            this._manipulator.getPanInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        } else if ( ev.keyCode === this._zoomKey &&\n            this.getMode() !== OrbitManipulator.Zoom ) {\n            this.setMode( OrbitManipulator.Zoom );\n            this._manipulator.getZoomInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        } else if ( ev.keyCode === this._rotateKey &&\n            this.getMode() !== OrbitManipulator.Rotate ) {\n            this.setMode( OrbitManipulator.Rotate );\n            this._manipulator.getRotateInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        }\n\n    },\n\n    keyup: function ( ev ) {\n        if ( ev.keyCode === this._panKey ) {\n            this.mouseup( ev );\n        } else if ( ev.keyCode === this._rotateKey ) {\n            this.mouseup( ev );\n        } else if ( ev.keyCode === this._rotateKey ) {\n            this.mouseup( ev );\n        }\n        this.setMode( undefined );\n    },\n\n};\n\nmodule.exports = CADManipulatorStandardMouseKeyboardController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/CADManipulatorStandardMouseKeyboardController.js\n// module id = 167\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Manipulator = require( 'osgGA/Manipulator' );\nvar OrbitManipulatorDeviceOrientationController = require( 'osgGA/OrbitManipulatorDeviceOrientationController' );\nvar OrbitManipulatorGamePadController = require( 'osgGA/OrbitManipulatorGamePadController' );\nvar OrbitManipulatorHammerController = require( 'osgGA/OrbitManipulatorHammerController' );\nvar OrbitManipulatorLeapMotionController = require( 'osgGA/OrbitManipulatorLeapMotionController' );\nvar OrbitManipulatorStandardMouseKeyboardController = require( 'osgGA/OrbitManipulatorStandardMouseKeyboardController' );\nvar OrbitManipulatorWebVRController = require( 'osgGA/OrbitManipulatorWebVRController' );\nvar DelayInterpolator = require( 'osgUtil/DelayInterpolator' );\n\n\n/**\n *  OrbitManipulator\n *  @class\n */\nvar OrbitManipulator = function ( boundStrategy ) {\n    Manipulator.call( this, boundStrategy );\n    this._homePosition = vec3.create();\n    this._frustum = {};\n    this.init();\n};\n\nOrbitManipulator.AvailableControllerList = [ 'StandardMouseKeyboard',\n    'LeapMotion',\n    'GamePad',\n    'Hammer',\n    'DeviceOrientation',\n    'WebVR'\n];\n\nOrbitManipulator.ControllerList = [ 'StandardMouseKeyboard',\n    'LeapMotion',\n    'GamePad',\n    'Hammer',\n    'DeviceOrientation',\n    'WebVR'\n];\n\nvar TWO_PI = 2 * Math.PI;\n\n/** @lends OrbitManipulator.prototype */\nOrbitManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {\n    init: function () {\n        this._distance = 25.0;\n        this._target = vec3.create();\n        this._upz = vec3.fromValues( 0.0, 0.0, 1.0 );\n        vec3.init( this._target );\n\n        var rot1 = mat4.fromRotation( mat4.create(), -Math.PI, this._upz );\n        var rot2 = mat4.fromRotation( mat4.create(), Math.PI / 10.0, vec3.fromValues( 1.0, 0.0, 0.0 ) );\n        this._rotation = mat4.create();\n        mat4.mul( this._rotation, rot1, rot2 );\n        this._time = 0.0;\n\n        this._vrMatrix = mat4.create();\n\n        this._rotate = new DelayInterpolator( 2 );\n        this._pan = new DelayInterpolator( 2 );\n        this._zoom = new DelayInterpolator( 1 );\n\n        this._minSpeed = 1e-4; // set a limit to pan/zoom speed\n        this._scaleMouseMotion = 1.0;\n\n        this._inverseMatrix = mat4.create();\n\n        // distance at which we start pushing the target (so that we can still zoom)\n        // with a very low _limitZoomIn, it's like a fps manipulator as long as you don't unzoom\n        this._autoPushTarget = true;\n\n        // pitch range [-PI/2, PI/2]\n        this._limitPitchUp = Math.PI * 0.5 * 0.9;\n        this._limitPitchDown = -this._limitPitchUp;\n\n        // yaw range [-PI, PI]\n        this._limitYawLeft = -Math.PI;\n        this._limitYawRight = -this._limitYawLeft;\n\n        this._limitZoomIn = 1e-4;\n        this._limitZoomOut = Infinity;\n\n        // instance of controller\n        var self = this;\n\n        OrbitManipulator.ControllerList.forEach( function ( value ) {\n            if ( OrbitManipulator[ value ] !== undefined ) {\n                self._controllerList[ value ] = new OrbitManipulator[ value ]( self );\n            }\n        } );\n    },\n    setLimitPitchUp: function ( up ) {\n        this._limitPitchUp = up;\n    },\n    setLimitPitchDown: function ( down ) {\n        this._limitPitchDown = down;\n    },\n    setLimitYawLeft: function ( left ) {\n        this._limitYawLeft = left;\n    },\n    setLimitYawRight: function ( right ) {\n        this._limitYawRight = right;\n    },\n    setLimitZoomOut: function ( zoomOut ) {\n        this._limitZoomOut = zoomOut;\n    },\n    setLimitZoomIn: function ( zoomIn ) {\n        this._limitZoomIn = zoomIn;\n    },\n    setDelay: function ( dt ) {\n        this._rotate.setDelay( dt );\n        this._pan.setDelay( dt );\n        this._zoom.setDelay( dt );\n    },\n    reset: function () {\n        this.init();\n    },\n    setTarget: function ( target ) {\n        vec3.copy( this._target, target );\n        var eyePos = vec3.create();\n        this.getEyePosition( eyePos );\n        this._distance = vec3.distance( target, eyePos );\n    },\n    setEyePosition: ( function () {\n        var f = vec3.create();\n        var s = vec3.create();\n        var u = vec3.create();\n        return function ( eye ) {\n            var result = this._rotation;\n            var center = this._target;\n\n            vec3.sub( f, eye, center );\n            vec3.normalize( f, f );\n\n            vec3.cross( s, f, this._upz );\n            vec3.normalize( s, s );\n\n            vec3.cross( u, s, f );\n            vec3.normalize( u, u );\n\n            // s[0], f[0], u[0], 0.0,\n            // s[1], f[1], u[1], 0.0,\n            // s[2], f[2], u[2], 0.0,\n            // 0,    0,    0,     1.0\n            result[ 0 ] = s[ 0 ];\n            result[ 1 ] = f[ 0 ];\n            result[ 2 ] = u[ 0 ];\n            result[ 3 ] = 0.0;\n            result[ 4 ] = s[ 1 ];\n            result[ 5 ] = f[ 1 ];\n            result[ 6 ] = u[ 1 ];\n            result[ 7 ] = 0.0;\n            result[ 8 ] = s[ 2 ];\n            result[ 9 ] = f[ 2 ];\n            result[ 10 ] = u[ 2 ];\n            result[ 11 ] = 0.0;\n            result[ 12 ] = 0;\n            result[ 13 ] = 0;\n            result[ 14 ] = 0;\n            result[ 15 ] = 1.0;\n\n            this._distance = vec3.distance( center, eye );\n        };\n    } )(),\n\n    computeHomePosition: function ( boundStrategy ) {\n\n        var bs = this.getHomeBound( boundStrategy );\n        if ( !bs || !bs.valid() ) return;\n\n        this.setDistance( this.getHomeDistance( bs ) );\n        this.setTarget( bs.center() );\n\n    },\n\n    getHomePosition: function () {\n\n        if ( this._node !== undefined ) {\n\n            var target = this._target;\n            var distance = this.getDistance();\n\n            this.computeEyePosition( target, distance, this._homePosition );\n        }\n        return this._homePosition;\n    },\n\n    setMinSpeed: function ( s ) {\n        this._minSpeed = s;\n    },\n    getMinSpeed: function () {\n        return this._minSpeed;\n    },\n\n    setDistance: function ( d ) {\n        this._distance = d;\n    },\n    getDistance: function () {\n        return this._distance;\n    },\n\n    getSpeedFactor: function () {\n        return Math.max( this._distance, this._minSpeed );\n    },\n    computePan: ( function () {\n        var inv = mat4.create();\n        var x = vec3.create();\n        var y = vec3.create();\n        return function ( dx, dy ) {\n            var proj = this._camera.getProjectionMatrix();\n            // modulate panning speed with verticalFov value\n            // if it's an orthographic we don't change the panning speed\n            // TODO : manipulators in osgjs don't support well true orthographic camera anyway because they\n            // manage the view matrix (and you need to edit the projection matrix to 'zoom' for true ortho camera)\n            var vFov = proj[ 15 ] === 1 ? 1.0 : 2.00 / proj[ 5 ];\n            var speed = this.getSpeedFactor() * vFov;\n            dy *= speed;\n            dx *= speed;\n\n            mat4.invert( inv, this._rotation );\n            x[ 0 ] = inv[ 0 ];\n            x[ 1 ] = inv[ 1 ];\n            x[ 2 ] = inv[ 2 ];\n            vec3.normalize( x, x );\n\n            y[ 0 ] = inv[ 8 ];\n            y[ 1 ] = inv[ 9 ];\n            y[ 2 ] = inv[ 10 ];\n            vec3.normalize( y, y );\n\n            vec3.scale( x, x, -dx );\n            vec3.scale( y, y, dy );\n            vec3.add( this._target, this._target, x );\n            vec3.add( this._target, this._target, y );\n        };\n    } )(),\n    computeRotation: ( function () {\n        var rightDir = vec3.fromValues( 1.0, 0.0, 0.0 );\n\n        return function ( dx, dy ) {\n            var pitch = Math.atan( -this._rotation[ 6 ] / this._rotation[ 5 ] ) + dy / 10.0;\n            pitch = Math.min( Math.max( pitch, this._limitPitchDown ), this._limitPitchUp );\n\n            var deltaYaw = dx / 10.0;\n            var previousYaw = Math.atan2( this._rotation[ 4 ], this._rotation[ 0 ] );\n            var yaw = this._computeYaw( previousYaw, deltaYaw, this._limitYawLeft, this._limitYawRight );\n            mat4.fromRotation( this._rotation, -pitch, rightDir );\n            mat4.rotate( this._rotation, this._rotation, -yaw, this._upz );\n        };\n    } )(),\n\n    _computeYaw: function ( previousYaw, deltaYaw, left, right ) {\n        var yaw = previousYaw + deltaYaw;\n\n        if ( right !== Math.PI || left !== -Math.PI ) {\n            if ( right < left ) {\n                if ( yaw > Math.PI ) {\n                    previousYaw -= TWO_PI;\n                    yaw -= TWO_PI;\n                }\n                if ( yaw < -Math.PI ) {\n                    previousYaw += TWO_PI;\n                    yaw += TWO_PI;\n                }\n            }\n\n            if ( deltaYaw === 0 ) {\n                var isOutsideLimit = false;\n                if ( left > right ) isOutsideLimit = ( yaw < left && yaw > right );\n                else isOutsideLimit = yaw < left || yaw > right;\n                if ( isOutsideLimit ) yaw = Math.abs( yaw - left ) > Math.abs( yaw - right ) ? right : left;\n            }\n\n            if ( deltaYaw > 0.0 && previousYaw <= right && yaw > right ) {\n                yaw = right;\n            } else if ( deltaYaw < 0.0 && previousYaw >= left && yaw < left ) {\n                yaw = left;\n            }\n        }\n        return yaw;\n    },\n\n    computeZoom: function ( dz ) {\n        this.zoom( dz );\n    },\n\n    setAutoPushTarget: function ( bool ) {\n        this._autoPushTarget = bool;\n    },\n\n    zoom: ( function () {\n        var dir = vec3.create();\n        return function ( ratio ) {\n            var newValue = this._distance + this.getSpeedFactor() * ( ratio - 1.0 );\n\n            if ( this._autoPushTarget && newValue < this._limitZoomIn ) {\n                // push the target instead of zooming on it\n                vec3.sub( dir, this._target, this.getEyePosition( dir ) );\n                vec3.normalize( dir, dir );\n                vec3.scale( dir, dir, this._limitZoomIn - newValue );\n                vec3.add( this._target, this._target, dir );\n            }\n\n            this._distance = Math.max( this._limitZoomIn, Math.min( this._limitZoomOut, newValue ) );\n        };\n    } )(),\n\n    getRotateInterpolator: function () {\n        return this._rotate;\n    },\n    getPanInterpolator: function () {\n        return this._pan;\n    },\n    getZoomInterpolator: function () {\n        return this._zoom;\n    },\n    getTarget: function ( target ) {\n        return vec3.copy( target, this._target );\n    },\n    getEyePosition: function ( eye ) {\n        this.computeEyePosition( this._target, this._distance, eye );\n        return eye;\n    },\n\n    computeEyePosition: ( function () {\n        var tmpDist = vec3.create();\n        var tmpInverse = mat4.create();\n        return function ( target, distance, eye ) {\n            mat4.invert( tmpInverse, this._rotation );\n            tmpDist[ 1 ] = distance;\n            vec3.transformMat4( eye, tmpDist, tmpInverse );\n            vec3.add( eye, target, eye );\n        };\n    } )(),\n\n    update: ( function () {\n        var eye = vec3.create();\n        return function ( nv ) {\n            var dt = nv.getFrameStamp().getDeltaTime();\n\n            var delta;\n            var mouseFactor = 0.1;\n            delta = this._rotate.update( dt );\n            this.computeRotation( -delta[ 0 ] * mouseFactor * this._scaleMouseMotion, -delta[ 1 ] * mouseFactor * this._scaleMouseMotion );\n\n            var panFactor = 0.002;\n            delta = this._pan.update( dt );\n            this.computePan( -delta[ 0 ] * panFactor, -delta[ 1 ] * panFactor );\n\n\n            delta = this._zoom.update( dt );\n            this.computeZoom( 1.0 + delta[ 0 ] / 10.0 );\n\n            var target = this._target;\n            var distance = this._distance;\n\n            /* 1. Works but bypass other manipulators */\n            // mat4.copy( this._inverseMatrix , this._vrMatrix );\n\n            /* 2. Works but gets broken by other manipulators */\n            mat4.invert( this._inverseMatrix, this._rotation );\n            mat4.mul( this._inverseMatrix, this._vrMatrix, this._inverseMatrix );\n\n            /* 3. Doesnt' work */\n            // mat4.mul( this._vrMatrix,  this._vrMatrix, this._rotation );\n            // mat4.invert( this._inverseMatrix, this._vrMatrix );\n\n            vec3.set( eye, 0.0, distance, 0.0 );\n            vec3.transformMat4( eye, eye, this._inverseMatrix );\n\n            mat4.lookAt( this._inverseMatrix, vec3.add( eye, target, eye ), target, this._upz );\n\n        };\n    } )(),\n\n    setPoseVR: function ( q /*, pos*/ ) {\n        mat4.fromQuat( this._vrMatrix, q );\n        // this._vrMatrix[ 12 ] = pos[ 0 ];\n        // this._vrMatrix[ 13 ] = pos[ 1 ];\n        // this._vrMatrix[ 14 ] = pos[ 2 ];\n    }\n} );\n\nOrbitManipulator.DeviceOrientation = OrbitManipulatorDeviceOrientationController;\nOrbitManipulator.GamePad = OrbitManipulatorGamePadController;\nOrbitManipulator.Hammer = OrbitManipulatorHammerController;\nOrbitManipulator.LeapMotion = OrbitManipulatorLeapMotionController;\nOrbitManipulator.WebVR = OrbitManipulatorWebVRController;\nOrbitManipulator.StandardMouseKeyboard = OrbitManipulatorStandardMouseKeyboardController;\n\nmodule.exports = OrbitManipulator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulator.js\n// module id = 168\n// module chunks = 0 1 2","'use strict';\nvar quat = require( 'osg/glMatrix' ).quat;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\nvar FirstPersonDeviceOrientation = require( 'osgGA/FirstPersonManipulatorDeviceOrientationController' );\n\n\nvar OrbitManipulatorDeviceOrientationController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nOrbitManipulatorDeviceOrientationController.prototype = {\n\n    init: function () {\n        this._stepFactor = 1.0; // meaning radius*stepFactor to move\n        this._quat = quat.create();\n        this._pos = vec3.create();\n    },\n\n    update: function ( deviceOrientation, screenOrientation ) {\n\n        // for now we use the same code in first person and orbit to compute rotation\n        FirstPersonDeviceOrientation.computeQuaternion( this._quat, deviceOrientation, screenOrientation );\n        this._manipulator.setPoseVR( this._quat, this._pos );\n    }\n\n};\n\nmodule.exports = OrbitManipulatorDeviceOrientationController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorDeviceOrientationController.js\n// module id = 169\n// module chunks = 0 1 2","'use strict';\nvar quat = require( 'osg/glMatrix' ).quat;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\nvar degtorad = Math.PI / 180.0; // Degree-to-Radian conversion\n\nvar makeRotateFromEuler = function ( q, x, y, z, order ) {\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    // content/SpinCalc.m\n\n    var c1 = Math.cos( x / 2 );\n    var c2 = Math.cos( y / 2 );\n    var c3 = Math.cos( z / 2 );\n    var s1 = Math.sin( x / 2 );\n    var s2 = Math.sin( y / 2 );\n    var s3 = Math.sin( z / 2 );\n\n    if ( order === 'XYZ' ) {\n\n        q[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'YXZ' ) {\n\n        q[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'ZXY' ) {\n\n        q[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'ZYX' ) {\n\n        q[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'YZX' ) {\n\n        q[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'XZY' ) {\n\n        q[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;\n        q[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;\n        q[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;\n        q[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;\n\n    }\n    return q;\n};\n\n\nvar FirstPersonManipulatorDeviceOrientationController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nFirstPersonManipulatorDeviceOrientationController.computeQuaternion = ( function () {\n\n    var screenTransform = quat.create();\n    var worldTransform = quat.fromValues( -Math.sqrt( 0.5 ), 0.0, 0.0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\n\n    // but on ios alpha is relative to the first question:\n    //\n    // http://www.html5rocks.com/en/tutorials/device/orientation/\n    // For most browsers, alpha returns the compass heading, so when the device is pointed\n    // north, alpha is zero. With Mobile Safari, alpha is based on the direction the\n    // device was pointing when device orientation was first requested. The compass\n    // heading is available in the webkitCompassHeading parameter.\n\n    return function ( q, deviceOrientation, screenOrientation ) {\n\n        var alpha = deviceOrientation.alpha * degtorad;\n        var beta = deviceOrientation.beta * degtorad;\n        var gamma = deviceOrientation.gamma * degtorad;\n\n        // If the user goes in landscape mode, he rotates his device with a certain angle\n        // around the Z axis counterclockwise and the DeviceOrientation contains this\n        // rotation To compensate this, we apply a rotation of the same angle in the\n        // opposite way\n\n        var screenAngle = screenOrientation * degtorad;\n\n        // alpha is heading -> X\n        // beta             -> Z Up\n        // Gamma            -> Y view direction\n        makeRotateFromEuler( q, beta, alpha, -gamma, 'YXZ' );\n        // equivalent to\n        // var rotateX = mat4.fromRotation( mat4.create(), beta,[ 1,0,0 ] );\n        // var rotateY = mat4.fromRotation( mat4.create(), alpha,[ 0,1,0 ] );\n        // var rotateZ = mat4.fromRotation( mat4.create(), -gamma,[ 0,0,1 ] );\n        // var result = mat4.create();\n        // mat4.mul( result, rotateY, rotateX );\n        // mat4.mul( result, result, rotateZ );\n        // mat4.getRotation( q, result );\n\n        var minusHalfAngle = -screenAngle / 2.0;\n        screenTransform[ 1 ] = Math.sin( minusHalfAngle );\n        screenTransform[ 3 ] = Math.cos( minusHalfAngle );\n\n        quat.mul( q, q, screenTransform );\n        quat.mul( q, q, worldTransform );\n\n        var yTemp = q[ 1 ];\n        q[ 1 ] = -q[ 2 ];\n        q[ 2 ] = yTemp;\n\n        return q;\n    };\n\n} )();\n\nFirstPersonManipulatorDeviceOrientationController.prototype = {\n\n    init: function () {\n        this._stepFactor = 1.0; // meaning radius*stepFactor to move\n        this._quat = quat.create();\n        this._pos = vec3.create();\n    },\n\n    update: function ( deviceOrientation, screenOrientation ) {\n\n        FirstPersonManipulatorDeviceOrientationController.computeQuaternion( this._quat, deviceOrientation, screenOrientation );\n        this._manipulator.setPoseVR( this._quat, this._pos );\n    }\n\n};\n\nmodule.exports = FirstPersonManipulatorDeviceOrientationController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/FirstPersonManipulatorDeviceOrientationController.js\n// module id = 170\n// module chunks = 0 1 2","'use strict';\nvar vec2 = require( 'osg/glMatrix' ).vec2;\n\n\nvar OrbitManipulatorGamePadController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nOrbitManipulatorGamePadController.prototype = {\n    init: function () {\n        this._delay = 0.15;\n        this._threshold = 0.08;\n        this._mode = 0;\n        this._padFactor = 10.0;\n        this._zoomFactor = 0.5;\n        this._rotateFactor = 5.0;\n    },\n\n\n    addPan: function ( pan, x, y ) {\n        pan.setDelay( this._delay );\n        pan.addTarget( x * this._padFactor, y * this._padFactor );\n    },\n\n    addZoom: function ( zoom, z ) {\n        zoom.setDelay( this._delay );\n        zoom.addTarget( z * this._zoomFactor );\n    },\n\n    addRotate: function ( rotate, x, y ) {\n        rotate.setDelay( this._delay );\n        //var rotateTarget = rotate.getTarget();\n        rotate.addTarget( x * this._rotateFactor, y * this._rotateFactor );\n    },\n\n    gamepadaxes: function ( axes ) {\n\n        // Block badly balanced controllers\n        var AXIS_THRESHOLD = 0.005;\n\n        //var rotateTarget, panTarget;\n        var rotate = this._manipulator.getRotateInterpolator();\n        var zoom = this._manipulator.getZoomInterpolator();\n        var pan = this._manipulator.getPanInterpolator();\n        // Regular gamepads\n        if ( axes.length === 4 ) {\n\n            if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {\n                this.addRotate( rotate, -axes[ 0 ], axes[ 1 ] );\n            }\n            if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD ) {\n                this.addZoom( zoom, -axes[ 3 ] );\n            }\n\n            //SpaceNavigator & 6-axis controllers\n        } else if ( axes.length >= 5 ) {\n            //Notify.log(axes);\n            if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {\n                this.addPan( pan, -axes[ 0 ], axes[ 1 ] );\n            }\n\n            if ( Math.abs( axes[ 2 ] ) > AXIS_THRESHOLD ) {\n                this.addZoom( zoom, -axes[ 2 ] );\n            }\n\n            if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 4 ] ) > AXIS_THRESHOLD ) {\n                this.addRotate( rotate, axes[ 4 ], axes[ 3 ] );\n            }\n        }\n\n    },\n\n    gamepadbuttondown: function ( event /*, pressed */ ) {\n        // Buttons 12 to 15 are the d-pad.\n        if ( event.button >= 12 && event.button <= 15 ) {\n            var pan = this._manipulator.getPanInterpolator();\n            var panTarget = pan.getTarget();\n            var delta = {\n                12: vec2.fromValues( 0, -1 ),\n                13: vec2.fromValues( 0, 1 ),\n                14: vec2.fromValues( -1, 0 ),\n                15: vec2.fromValues( 1, 0 )\n            }[ event.button ];\n            pan.setDelay( this._delay );\n            pan.setTarget( panTarget[ 0 ] - delta[ 0 ] * 10, panTarget[ 1 ] + delta[ 1 ] * 10 );\n        }\n    },\n\n    update: function ( gm ) {\n        if ( !gm ) {\n            return;\n        }\n\n        var axis = gm.axes;\n        var buttons = gm.buttons;\n\n        this.gamepadaxes( axis );\n\n        // Dummy event wrapper\n        var emptyFunc = function () {};\n        for ( var i = 0; i < buttons.length; i++ ) {\n            if ( buttons[ i ] ) {\n                this.gamepadbuttondown( {\n                    preventDefault: emptyFunc,\n                    gamepad: gm,\n                    button: i\n                }, !!buttons[ i ] );\n            }\n        }\n    }\n};\nmodule.exports = OrbitManipulatorGamePadController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorGamePadController.js\n// module id = 171\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\nvar osgMath = require( 'osg/math' );\n\nvar OrbitManipulatorHammerController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nOrbitManipulatorHammerController.prototype = {\n    init: function () {\n        this._panFactorX = 1.0;\n        this._panFactorY = -this._panFactorX;\n\n        this._rotateFactorX = 0.6;\n        this._rotateFactorY = -this._rotateFactorX;\n        this._zoomFactor = 5.0;\n\n        this._lastScale = 0;\n        this._nbPointerLast = 0; // to check if we the number of pointers has changed\n        this._delay = 0.15;\n\n        this._transformStarted = false;\n        this._dragStarted = false;\n    },\n    setEventProxy: function ( proxy ) {\n        if ( proxy === undefined || ( proxy !== undefined && proxy === this._eventProxy ) ) {\n            return;\n        }\n        this._eventProxy = proxy;\n        var self = this;\n        var hammer = proxy;\n        var computeTouches = function ( event ) {\n            if ( event.pointers !== undefined )\n                return event.pointers.length;\n            return 1; // mouse\n        };\n\n        var dragCB = function ( ev ) {\n            return 'touches ' + computeTouches( ev ) + ' distance ' + ev.distance + ' x ' + ev.deltaX + ' y ' + ev.deltaY;\n        };\n        // Set a minimal thresold on pinch event, to be detected after pan\n        hammer.get( 'pinch' ).set( {\n            threshold: 0.1\n        } );\n        // Let the pan be detected with two fingers.\n        hammer.get( 'pan' ).set( {\n            threshold: 0,\n            pointers: 0\n        } );\n        hammer.get( 'pinch' ).recognizeWith( hammer.get( 'pan' ) );\n\n        this._cbPanStart = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || self._transformStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n\n            self._dragStarted = true;\n            self._nbPointerLast = computeTouches( event );\n\n            if ( self._nbPointerLast === 2 ) {\n                manipulator.getPanInterpolator().reset();\n                manipulator.getPanInterpolator().set( event.center.x * self._panFactorX, event.center.y * self._panFactorY );\n            } else {\n                manipulator.getRotateInterpolator().reset();\n                manipulator.getRotateInterpolator().set( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );\n            }\n            Notify.debug( 'drag start, ' + dragCB( event ) );\n        };\n\n        this._cbPanMove = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n\n            var nbPointers = computeTouches( event );\n            // prevent sudden big changes in the event.center variables\n            if ( self._nbPointerLast !== nbPointers ) {\n                if ( nbPointers === 2 ) manipulator.getPanInterpolator().reset();\n                else manipulator.getRotateInterpolator().reset();\n                self._nbPointerLast = nbPointers;\n            }\n\n            if ( nbPointers === 2 ) {\n                manipulator.getPanInterpolator().setTarget( event.center.x * self._panFactorX, event.center.y * self._panFactorY );\n                Notify.debug( 'pan, ' + dragCB( event ) );\n            } else {\n                manipulator.getRotateInterpolator().setDelay( self._delay );\n                manipulator.getRotateInterpolator().setTarget( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );\n                Notify.debug( 'rotate, ' + dragCB( event ) );\n            }\n        };\n\n        this._cbPanEnd = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._dragStarted = false;\n            Notify.debug( 'drag end, ' + dragCB( event ) );\n        };\n\n        this._cbPinchStart = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._transformStarted = true;\n\n            self._lastScale = event.scale;\n            manipulator.getZoomInterpolator().reset();\n            manipulator.getZoomInterpolator().set( self._lastScale );\n            event.preventDefault();\n            Notify.debug( 'zoom start, ' + dragCB( event ) );\n        };\n\n        this._cbPinchEnd = function ( event ) {\n            if ( event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._transformStarted = false;\n            Notify.debug( 'zoom end, ' + dragCB( event ) );\n        };\n\n\n        this._cbPinchInOut = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._transformStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n\n            // make the dezoom faster (because the manipulator dezoom/dezoom distance speed is adaptive)\n            var zoomFactor = event.scale > self._lastScale ? self._zoomFactor : self._zoomFactor * 3.0;\n            // also detect pan (velocity) to reduce zoom force\n            var minDezoom = 0.0;\n            var maxDezoom = 0.5;\n            zoomFactor *= osgMath.smoothStep( minDezoom, maxDezoom, -Math.abs( event.velocity ) + ( minDezoom + maxDezoom ) );\n\n            var scale = ( event.scale - self._lastScale ) * zoomFactor;\n            self._lastScale = event.scale;\n\n            manipulator.getZoomInterpolator().setTarget( manipulator.getZoomInterpolator().getTarget()[ 0 ] - scale );\n            Notify.debug( 'zoom, ' + dragCB( event ) );\n        };\n\n        hammer.on( 'panstart ', this._cbPanStart );\n        hammer.on( 'panmove', this._cbPanMove );\n        hammer.on( 'panend', this._cbPanEnd );\n        hammer.on( 'pinchstart', this._cbPinchStart );\n        hammer.on( 'pinchend', this._cbPinchEnd );\n        hammer.on( 'pinchin pinchout', this._cbPinchInOut );\n    },\n    removeEventProxy: function ( proxy ) {\n        if ( !proxy || !this._eventProxy )\n            return;\n        proxy.off( 'panstart ', this._cbPanStart );\n        proxy.off( 'panmove', this._cbPanMove );\n        proxy.off( 'panend', this._cbPanEnd );\n        proxy.off( 'pinchstart', this._cbPinchStart );\n        proxy.off( 'pinchend', this._cbPinchEnd );\n        proxy.off( 'pinchin pinchout', this._cbPinchInOut );\n    },\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n    }\n};\nmodule.exports = OrbitManipulatorHammerController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorHammerController.js\n// module id = 172\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec2 = require( 'osg/glMatrix' ).vec2;\n\n\nvar OrbitManipulatorLeapMotionController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nvar ModeConfig = {\n    'rotate': {\n        dtx: -1.2 * 1.2,\n        dty: -0.9 * 1.2,\n        dtz: -0.1,\n        delay: 0.05,\n        method: 'getRotateInterpolator'\n    },\n    'pan': {\n        dtx: -1.2 * 1.2,\n        dty: -0.9 * 1.2,\n        delay: 0.05,\n        method: 'getPanInterpolator'\n    },\n    'zoom': {\n        dtx: 0.0,\n        dty: -0.5,\n        delay: 0.05,\n        method: 'getZoomInterpolator'\n    },\n    'zoom-twohands': {\n        dtx: -0.05,\n        dty: 0.0,\n        delay: 0.05,\n        method: 'getZoomInterpolator'\n    }\n};\n\nOrbitManipulatorLeapMotionController.prototype = {\n    init: function () {\n        this._virtualCursor = vec2.fromValues( 0.0, 0.0 );\n        this._targetPosition = vec2.fromValues( 0.0, 0.0 );\n        this._previousFrame = undefined;\n        this._displacement = vec2.fromValues( 0.0, 0.0 );\n        this._top = vec2.fromValues( 0.0, 1.0 );\n        this._motion = vec2.fromValues( 0.0, 0.0 );\n        this._delay = 0.05;\n        this._threshold = 0.08;\n        this._directionDotThreshold = 0.5;\n        this._mode = 'rotate';\n    },\n\n    update: function ( frame ) {\n        if ( !this._previousFrame ) {\n            this._previousFrame = frame;\n        }\n\n        // no fingers ? return\n        if ( frame.fingers.length === 0 ) {\n            return;\n        }\n\n        var deltaFrame = this._previousFrame.translation( frame );\n\n        this._previousFrame = frame;\n\n        if ( frame.hands.length === 0 ) {\n            return;\n        }\n\n        // filter noise\n        if ( Math.abs( deltaFrame[ 0 ] ) < this._threshold &&\n            Math.abs( deltaFrame[ 1 ] ) < this._threshold ) {\n            return;\n        }\n\n        var mode = this._mode;\n        var dist = 0;\n\n        // scale is when there two hands with but with two hand with more than 1 fingers\n        if ( frame.gestures.length > 0 ) {\n            for ( var i = 0; i < frame.gestures.length; i++ ) {\n                var gesture = frame.gestures[ i ];\n                if ( gesture.type === 'circle' ) {\n                    this._manipulator.computeHomePosition();\n                    return;\n                }\n            }\n        }\n\n        if ( frame.hands.length === 1 ) {\n            if ( frame.hands[ 0 ].fingers.length >= 3 ) {\n                mode = 'zoom';\n                dist = frame.hands[ 0 ].palmPosition[ 1 ] / 10.0;\n                dist = Math.max( dist - 4, 0.01 );\n\n            } else if ( frame.hands[ 0 ].fingers.length > 1 ) {\n                mode = 'pan';\n            } else {\n                // by default onw hand moving means rotation\n                mode = 'rotate';\n            }\n        } else if ( frame.hands.length === 2 ) {\n            var d0 = Math.abs( vec3.dot( frame.hands[ 0 ].palmNormal, this._top ) ),\n                d1 = Math.abs( vec3.dot( frame.hands[ 1 ].palmNormal, this._top ) );\n\n            // two hands : zoom\n            if ( d0 < this._directionDotThreshold && d1 < this._directionDotThreshold ) {\n                mode = 'zoom-twohands';\n            } else {\n                // if hands flat do nothing\n                mode = undefined;\n                this._handsDistanceOld = undefined;\n            }\n        }\n        var zoom = this._manipulator.getZoomInterpolator();\n\n        if ( mode === undefined ) {\n            return;\n        }\n        // change mode reset counter and skip this frame\n        if ( mode !== this._mode ) {\n            Notify.info( 'Switch to mode ' + mode );\n\n            this._motion[ 0 ] = 0;\n            this._motion[ 1 ] = 0;\n            this._mode = mode;\n\n            if ( mode === 'zoom' || mode === 'zoom-twohands' ) {\n                if ( zoom.isReset() ) {\n                    zoom.setStart( 1.0 );\n                    zoom.set( 0.0 );\n                }\n            }\n            return;\n        }\n\n        var dtx, dty, dtz;\n        dtx = ModeConfig[ mode ].dtx;\n        dty = ModeConfig[ mode ].dty;\n        dtz = ModeConfig[ mode ].dtz;\n\n        this._motion[ 0 ] += deltaFrame[ 0 ] * dtx;\n        this._motion[ 1 ] += deltaFrame[ 1 ] * dty;\n\n        var delay = ModeConfig[ mode ].delay;\n\n        // we use the mode enum to get the good method\n        var method = ModeConfig[ mode ].method;\n        this._manipulator[ method ]().setDelay( delay );\n\n        if ( mode === 'zoom' ) {\n            Notify.log( dist );\n            zoom.setTarget( dist );\n        } else if ( mode === 'zoom-twohands' ) { // two hands zoom\n            // distance between two hands\n            var handsDistance = vec3.distance( frame.hands[ 1 ].palmPosition, frame.hands[ 0 ].palmPosition );\n\n            if ( this._handsDistanceOld !== undefined ) {\n                // compare distance with lastframe and zoom if they get nearer, unzoom if they separate\n                var vel = dtx * ( handsDistance - this._handsDistanceOld );\n\n                dist = zoom._target;\n                dist[ 0 ] += vel;\n            }\n            this._handsDistanceOld = handsDistance;\n        } else {\n            if ( mode === 'rotate' ) {\n                dist = zoom._target[ 0 ];\n                dist += deltaFrame[ 2 ] * dtz;\n                dist = Math.max( dist, 0.01 );\n                zoom.setTarget( dist );\n            }\n            this._manipulator[ method ]().addTarget( this._motion[ 0 ], this._motion[ 1 ] );\n        }\n\n        this._motion[ 1 ] = this._motion[ 0 ] = 0;\n    }\n};\nmodule.exports = OrbitManipulatorLeapMotionController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorLeapMotionController.js\n// module id = 173\n// module chunks = 0 1 2","'use strict';\nvar osgMath = require( 'osg/math' );\nvar OrbitManipulatorEnums = require( 'osgGA/orbitManipulatorEnums' );\n\n\nvar OrbitManipulatorStandardMouseKeyboardController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nOrbitManipulatorStandardMouseKeyboardController.prototype = {\n    init: function () {\n        this.releaseButton();\n        this._rotateKey = 65; // a\n        this._zoomKey = 83; // s\n        this._panKey = 68; // d\n\n        this._mode = undefined;\n        this._delay = 0.15;\n    },\n    getMode: function () {\n        return this._mode;\n    },\n    setMode: function ( mode ) {\n        this._mode = mode;\n    },\n    setEventProxy: function ( proxy ) {\n        this._eventProxy = proxy;\n    },\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n    },\n    mousemove: function ( ev ) {\n        if ( this._buttonup === true ) {\n            return;\n        }\n        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\n        var manipulator = this._manipulator;\n        if ( osgMath.isNaN( pos[ 0 ] ) === false && osgMath.isNaN( pos[ 1 ] ) === false ) {\n\n            var mode = this.getMode();\n            if ( mode === OrbitManipulatorEnums.ROTATE ) {\n                manipulator.getRotateInterpolator().setDelay( this._delay );\n                manipulator.getRotateInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\n\n            } else if ( mode === OrbitManipulatorEnums.PAN ) {\n                manipulator.getPanInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\n\n            } else if ( mode === OrbitManipulatorEnums.ZOOM ) {\n                var zoom = manipulator.getZoomInterpolator();\n                if ( zoom.isReset() ) {\n                    zoom.setStart( pos[ 1 ] );\n                    zoom.set( 0.0 );\n                }\n                var dy = pos[ 1 ] - zoom.getStart();\n                zoom.setStart( pos[ 1 ] );\n                var v = zoom.getTarget()[ 0 ];\n                zoom.setTarget( v - dy / 20.0 );\n            }\n        }\n\n        ev.preventDefault();\n    },\n    mousedown: function ( ev ) {\n        var manipulator = this._manipulator;\n        var mode = this.getMode();\n        if ( mode === undefined ) {\n            if ( ev.button === 0 ) {\n                if ( ev.shiftKey ) {\n                    this.setMode( OrbitManipulatorEnums.PAN );\n                } else if ( ev.ctrlKey ) {\n                    this.setMode( OrbitManipulatorEnums.ZOOM );\n                } else {\n                    this.setMode( OrbitManipulatorEnums.ROTATE );\n                }\n            } else {\n                // For users on Mac machines for who CTRL+LeftClick is naturally converted \n                // into a RightClick in Firefox.\n                if ( ev.button === 2 && ev.ctrlKey ) {\n                    this.setMode( OrbitManipulatorEnums.ZOOM );\n                } else {\n                    this.setMode( OrbitManipulatorEnums.PAN );\n                }\n            }\n        }\n\n        this.pushButton();\n\n        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\n        mode = this.getMode();\n        if ( mode === OrbitManipulatorEnums.ROTATE ) {\n            manipulator.getRotateInterpolator().reset();\n            manipulator.getRotateInterpolator().set( pos[ 0 ], pos[ 1 ] );\n        } else if ( mode === OrbitManipulatorEnums.PAN ) {\n            manipulator.getPanInterpolator().reset();\n            manipulator.getPanInterpolator().set( pos[ 0 ], pos[ 1 ] );\n        } else if ( mode === OrbitManipulatorEnums.ZOOM ) {\n            manipulator.getZoomInterpolator().setStart( pos[ 1 ] );\n            manipulator.getZoomInterpolator().set( 0.0 );\n        }\n    },\n    mouseup: function ( /*ev */) {\n        this.releaseButton();\n        this.setMode( undefined );\n    },\n    mouseout: function ( /*ev */) {\n        this.releaseButton();\n        this.setMode( undefined );\n    },\n    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {\n        var manipulator = this._manipulator;\n        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - intDelta;\n        manipulator.getZoomInterpolator().setTarget( zoomTarget );\n    },\n\n    pushButton: function () {\n        this._buttonup = false;\n    },\n    releaseButton: function () {\n        this._buttonup = true;\n    },\n\n    keydown: function ( ev ) {\n        if ( ev.keyCode === 32 ) {\n            this._manipulator.computeHomePosition();\n            ev.preventDefault();\n        } else if ( ev.keyCode === this._panKey &&\n            this.getMode() !== OrbitManipulatorEnums.PAN ) {\n            this.setMode( OrbitManipulatorEnums.PAN );\n            this._manipulator.getPanInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        } else if ( ev.keyCode === this._zoomKey &&\n            this.getMode() !== OrbitManipulatorEnums.ZOOM ) {\n            this.setMode( OrbitManipulatorEnums.ZOOM );\n            this._manipulator.getZoomInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        } else if ( ev.keyCode === this._rotateKey &&\n            this.getMode() !== OrbitManipulatorEnums.ROTATE ) {\n            this.setMode( OrbitManipulatorEnums.ROTATE );\n            this._manipulator.getRotateInterpolator().reset();\n            this.pushButton();\n            ev.preventDefault();\n        }\n\n    },\n\n    keyup: function ( ev ) {\n        if ( ev.keyCode === this._panKey ) {\n            this.mouseup( ev );\n        } else if ( ev.keyCode === this._rotateKey ) {\n            this.mouseup( ev );\n        } else if ( ev.keyCode === this._rotateKey ) {\n            this.mouseup( ev );\n        }\n        this.setMode( undefined );\n    }\n\n};\nmodule.exports = OrbitManipulatorStandardMouseKeyboardController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorStandardMouseKeyboardController.js\n// module id = 174\n// module chunks = 0 1 2","'use strict';\nmodule.exports = {\n    ROTATE: 0,\n    PAN: 1,\n    ZOOM: 2\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/orbitManipulatorEnums.js\n// module id = 175\n// module chunks = 0 1 2","'use strict';\n\nvar OrbitManipulatorWebVRController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nOrbitManipulatorWebVRController.prototype = {\n    init: function () {},\n    update: function ( q, position ) {\n        this._manipulator.setPoseVR( q, position );\n    }\n};\n\nmodule.exports = OrbitManipulatorWebVRController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/OrbitManipulatorWebVRController.js\n// module id = 176\n// module chunks = 0 1 2","var DelayInterpolator = function ( size, delay ) {\n    this._current = new Float32Array( size );\n    this._target = new Float32Array( size );\n    this._delta = new Float32Array( size );\n    this._delay = ( delay !== undefined ) ? delay : 0.15;\n    this._reset = false;\n    this._start = 0.0;\n    this.reset();\n};\n\nDelayInterpolator.prototype = {\n    setDelay: function ( delay ) {\n        this._delay = delay;\n    },\n    reset: function () {\n        for ( var i = 0, l = this._current.length; i < l; i++ ) {\n            this._current[ i ] = this._target[ i ] = 0.0;\n        }\n        this._reset = true;\n    },\n    update: function ( dt ) {\n        // assume 60 fps to be consistent with the old _delay values for backward compatibility\n        // (otherwise we'd have to adjust the _delay values by multiplying to 60 )\n        var dtDelay = Math.min( 1.0, this._delay * dt * 60.0 );\n        for ( var i = 0, l = this._current.length; i < l; i++ ) {\n            var d = ( this._target[ i ] - this._current[ i ] ) * dtDelay;\n            this._delta[ i ] = d;\n            this._current[ i ] += d;\n        }\n        return this._delta;\n    },\n    set: function () {\n        for ( var i = 0, l = this._current.length; i < l; i++ ) {\n            this._current[ i ] = this._target[ i ] = arguments[ i ];\n        }\n        this._reset = false;\n    },\n    isReset: function () {\n        return this._reset;\n    },\n    getCurrent: function () {\n        return this._current;\n    },\n    setTarget: function () {\n        for ( var i = 0, l = this._target.length; i < l; i++ ) {\n            if ( this._reset ) {\n                this._target[ i ] = this._current[ i ] = arguments[ i ];\n            } else {\n                this._target[ i ] = arguments[ i ];\n            }\n        }\n        this._reset = false;\n    },\n    addTarget: function () {\n        for ( var i = 0; i < arguments.length; i++ ) {\n            this._target[ i ] += arguments[ i ];\n        }\n    },\n    getTarget: function () {\n        return this._target;\n    },\n    getDelta: function () {\n        return this._delta;\n    },\n    getStart: function () {\n        return this._start;\n    },\n    setStart: function ( start ) {\n        this._start = start;\n    }\n};\n\nmodule.exports = DelayInterpolator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DelayInterpolator.js\n// module id = 177\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\n\nvar CADManipulatorHammerController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this._timer = false;\n    this.init();\n};\n\nCADManipulatorHammerController.prototype = {\n    init: function () {\n        this._panFactorX = 1.0;\n        this._panFactorY = -this._panFactorX;\n\n        this._rotateFactorX = 0.6;\n        this._rotateFactorY = -this._rotateFactorX;\n        this._zoomFactor = 5.0;\n\n        this._lastScale = 0;\n        this._nbPointerLast = 0; // to check if we the number of pointers has changed\n\n        this._lastPos = undefined; // to set the pivot for rotation\n    },\n    setEventProxy: function ( proxy ) {\n        if ( proxy === undefined || ( proxy !== undefined && proxy === this._eventProxy ) ) {\n            return;\n        }\n        this._eventProxy = proxy;\n        var self = this;\n        var hammer = proxy;\n        var computeTouches = function ( event ) {\n            if ( event.pointers !== undefined )\n                return event.pointers.length;\n            return 1; // mouse\n        };\n\n        var dragCB = function ( ev ) {\n            return 'touches ' + computeTouches( ev ) + ' distance ' + ev.distance + ' x ' + ev.deltaX + ' y ' + ev.deltaY;\n        };\n        // Set a minimal thresold on pinch event, to be detected after pan\n        hammer.get( 'pinch' ).set( {\n            threshold: 0.1\n        } );\n        // Let the pan be detected with two fingers.\n        hammer.get( 'pan' ).set( {\n            threshold: 0,\n            pointers: 0\n        } );\n        hammer.get( 'pinch' ).recognizeWith( hammer.get( 'pan' ) );\n\n        hammer.get( 'tap' ).set( {\n            taps: 2,\n            posThreshold: 300\n        } );\n\n        this._cbPanStart = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || self._transformStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n            var gesture = event;\n            self._dragStarted = true;\n            self._nbPointerLast = computeTouches( gesture );\n\n            var pos;\n            if ( self._nbPointerLast === 2 ) {\n                pos = manipulator.getPositionRelativeToCanvas( event.center.x, event.center.y );\n                self._lastPos = pos;\n            } else {\n                if ( self._lastPos === undefined ) {\n                    pos = manipulator.getCanvasCenter();\n                } else {\n                    pos = self._lastPos;\n                }\n            }\n\n            manipulator.computeIntersections( pos );\n\n            if ( self._nbPointerLast === 2 ) {\n                manipulator.getPanInterpolator().reset();\n                manipulator.getPanInterpolator().set( event.center.x * self._panFactorX, event.center.y * self._panFactorY );\n            } else {\n                manipulator.getRotateInterpolator().reset();\n            }\n            Notify.debug( 'drag start, ' + dragCB( gesture ) );\n        };\n\n        this._cbPanMove = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n            var gesture = event;\n            var nbPointers = computeTouches( gesture );\n\n            // prevent sudden big changes in the event.center variables\n            if ( self._nbPointerLast !== nbPointers ) {\n                if ( nbPointers === 2 ) manipulator.getPanInterpolator().reset();\n                else manipulator.getRotateInterpolator().reset();\n                self._nbPointerLast = nbPointers;\n            }\n\n            if ( nbPointers === 2 ) {\n                manipulator.getPanInterpolator().setTarget( event.center.x * self._panFactorX, event.center.y * self._panFactorY );\n                Notify.debug( 'pan, ' + dragCB( gesture ) );\n            } else {\n                manipulator.getRotateInterpolator().setTarget( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );\n                Notify.debug( 'rotate, ' + dragCB( gesture ) );\n            }\n        };\n\n        this._cbPanEnd = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._dragStarted = false;\n            var gesture = event;\n            Notify.debug( 'drag end, ' + dragCB( gesture ) );\n        };\n\n        this._cbPinchStart = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._transformStarted = true;\n            var gesture = event;\n\n            self._lastScale = gesture.scale;\n            manipulator.getZoomInterpolator().reset();\n            manipulator.getZoomInterpolator().set( self._lastScale );\n            event.preventDefault();\n\n            Notify.debug( 'zoom start, ' + dragCB( gesture ) );\n        };\n\n        this._cbPinchEnd = function ( event ) {\n            if ( event.pointerType === 'mouse' ) {\n                return;\n            }\n            self._transformStarted = false;\n            Notify.debug( 'zoom end, ' + dragCB( event ) );\n        };\n\n        this._cbPinchInOut = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || !self._transformStarted || event.pointerType === 'mouse' ) {\n                return;\n            }\n            var gesture = event;\n\n            // make the dezoom faster\n            var zoomFactor = gesture.scale > self._lastScale ? self._zoomFactor : self._zoomFactor * 4.0;\n            var scale = ( gesture.scale - self._lastScale ) * zoomFactor;\n            self._lastScale = gesture.scale;\n\n            manipulator.getZoomInterpolator().setTarget( manipulator.getZoomInterpolator().getTarget()[ 0 ] - scale );\n\n            Notify.debug( 'zoom, ' + dragCB( gesture ) );\n        };\n\n        this._cbDoubleTap = function ( event ) {\n            var manipulator = self._manipulator;\n            if ( !manipulator || event.pointerType === 'mouse' ) {\n                return;\n            }\n            var gesture = event;\n\n            var pos = manipulator.getPositionRelativeToCanvas( event.center.x, event.center.y );\n            self._lastPos = pos;\n\n            manipulator.getZoomInterpolator().set( 0.0 );\n            var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - 10; // Default interval 10\n            manipulator.getZoomInterpolator().setTarget( zoomTarget );\n\n            Notify.debug( 'tap, ' + dragCB( gesture ) );\n        };\n\n        hammer.on( 'panstart ', this._cbPanStart );\n        hammer.on( 'panmove', this._cbPanMove );\n        hammer.on( 'panend', this._cbPanEnd );\n        hammer.on( 'pinchstart', this._cbPinchStart );\n        hammer.on( 'pinchend', this._cbPinchEnd );\n        hammer.on( 'pinchin pinchout', this._cbPinchInOut );\n        hammer.on( 'tap', this._cbDoubleTap );\n    },\n    removeEventProxy: function ( proxy ) {\n        if ( !proxy || !this._eventProxy )\n            return;\n        proxy.off( 'panstart ', this._cbPanStart );\n        proxy.off( 'panmove', this._cbPanMove );\n        proxy.off( 'panend', this._cbPanEnd );\n        proxy.off( 'pinchstart', this._cbPinchStart );\n        proxy.off( 'pinchend', this._cbPinchEnd );\n        proxy.off( 'pinchin pinchout', this._cbPinchInOut );\n        proxy.off( 'tap', this._cbDoubleTap );\n    },\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n    }\n};\n\nmodule.exports = CADManipulatorHammerController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/CADManipulatorHammerController.js\n// module id = 178\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Manipulator = require( 'osgGA/Manipulator' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar FirstPersonManipulatorDeviceOrientationController = require( 'osgGA/FirstPersonManipulatorDeviceOrientationController' );\nvar FirstPersonManipulatorHammerController = require( 'osgGA/FirstPersonManipulatorHammerController' );\nvar FirstPersonManipulatorWebVRController = require( 'osgGA/FirstPersonManipulatorWebVRController' );\nvar FirstPersonManipulatorStandardMouseKeyboardController = require( 'osgGA/FirstPersonManipulatorStandardMouseKeyboardController' );\nvar DelayInterpolator = require( 'osgUtil/DelayInterpolator' );\n\n\n/**\n * Authors:\n *  Matt Fontaine <tehqin@gmail.com>\n *  Cedric Pinson <trigrou@gmail.com>\n */\n\n/**\n *  FirstPersonManipulator\n *  @class\n */\nvar FirstPersonManipulator = function ( boundStrategy ) {\n    Manipulator.call( this, boundStrategy );\n    this.init();\n};\n\nFirstPersonManipulator.AvailableControllerList = [ 'StandardMouseKeyboard', 'WebVR', 'DeviceOrientation', 'Hammer' ];\nFirstPersonManipulator.ControllerList = [ 'StandardMouseKeyboard', 'WebVR', 'DeviceOrientation', 'Hammer' ];\n\nFirstPersonManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {\n\n    computeHomePosition: function ( boundStrategy ) {\n        var bs = this.getHomeBound( boundStrategy );\n        if ( !bs || !bs.valid() ) return;\n\n        this._distance = this.getHomeDistance( bs );\n        var cen = bs.center();\n        vec3.scale( this._eye, this._direction, -this._distance );\n        vec3.add( this._eye, cen, this._eye );\n        this.setTarget( cen );\n    },\n\n    init: function () {\n        this._direction = vec3.fromValues( 0.0, 1.0, 0.0 );\n        this._eye = vec3.fromValues( 0.0, 25.0, 10.0 );\n        this._up = vec3.fromValues( 0.0, 0.0, 1.0 );\n        this._distance = 1.0;\n        this._forward = new DelayInterpolator( 1 );\n        this._side = new DelayInterpolator( 1 );\n        this._lookPosition = new DelayInterpolator( 2 );\n\n        // direct pan interpolator (not based on auto-move)\n        this._pan = new DelayInterpolator( 2 );\n        this._zoom = new DelayInterpolator( 1 );\n\n        this._stepFactor = 1.0; // meaning radius*stepFactor to move\n        this._angleVertical = 0.0;\n        this._angleHorizontal = 0.0;\n\n        // tmp value use for computation\n        this._tmpGetTargetDir = vec3.create();\n\n        // vr controls\n        this._vrEnable = false;\n        this._vrRot = quat.create(); // absolute orientation\n        this._vrPos = vec3.create(); // absolute position\n        this._vrTrans = vec3.create(); // delta translation since last update\n\n        var self = this;\n\n        this._controllerList = {};\n        FirstPersonManipulator.ControllerList.forEach( function ( value ) {\n            if ( FirstPersonManipulator[ value ] !== undefined ) {\n                self._controllerList[ value ] = new FirstPersonManipulator[ value ]( self );\n            }\n        } );\n\n    },\n\n    setDelay: function ( dt ) {\n        this._forward.setDelay( dt );\n        this._side.setDelay( dt );\n        this._lookPosition.setDelay( dt );\n        this._pan.setDelay( dt );\n        this._zoom.setDelay( dt );\n    },\n\n    getEyePosition: function ( eye ) {\n        eye[ 0 ] = this._eye[ 0 ];\n        eye[ 1 ] = this._eye[ 1 ];\n        eye[ 2 ] = this._eye[ 2 ];\n        return eye;\n    },\n\n    setEyePosition: function ( eye ) {\n        this._eye[ 0 ] = eye[ 0 ];\n        this._eye[ 1 ] = eye[ 1 ];\n        this._eye[ 2 ] = eye[ 2 ];\n        return this;\n    },\n\n    getTarget: function ( pos ) {\n        var dir = vec3.scale( this._tmpGetTargetDir, this._direction, this._distance );\n        vec3.add( pos, this._eye, dir );\n        return pos;\n    },\n\n    setTarget: function ( pos ) {\n        var dir = this._tmpGetTargetDir;\n        vec3.sub( dir, pos, this._eye );\n        dir[ 2 ] = 0.0;\n        vec3.normalize( dir, dir );\n        this._angleHorizontal = Math.acos( dir[ 1 ] );\n        if ( dir[ 0 ] < 0.0 ) {\n            this._angleHorizontal = -this._angleHorizontal;\n        }\n        vec3.sub( dir, pos, this._eye );\n        vec3.normalize( dir, dir );\n\n        this._angleVertical = -Math.asin( dir[ 2 ] );\n        vec3.copy( this._direction, dir );\n    },\n\n    getLookPositionInterpolator: function () {\n        return this._lookPosition;\n    },\n    getSideInterpolator: function () {\n        return this._side;\n    },\n    getForwardInterpolator: function () {\n        return this._forward;\n    },\n    getPanInterpolator: function () {\n        return this._pan;\n    },\n    getZoomInterpolator: function () {\n        return this._zoom;\n    },\n    getRotateInterpolator: function () {\n        // for compatibility with orbit hammer controllers\n        return this._lookPosition;\n    },\n\n    computeRotation: ( function () {\n        var first = mat4.create();\n        var rotMat = mat4.create();\n\n        var right = vec3.fromValues( 1.0, 0.0, 0.0 );\n        var upy = vec3.fromValues( 0.0, 1.0, 0.0 );\n        var upz = vec3.fromValues( 0.0, 0.0, 1.0 );\n        var LIMIT = Math.PI * 0.5;\n        return function ( dx, dy ) {\n            this._angleVertical += dy * 0.01;\n            this._angleHorizontal -= dx * 0.01;\n            if ( this._angleVertical > LIMIT ) this._angleVertical = LIMIT;\n            else if ( this._angleVertical < -LIMIT ) this._angleVertical = -LIMIT;\n\n            if ( this._vrEnable ) {\n                vec3.transformQuat( this._direction, upy, this._vrRot );\n                vec3.normalize( this._direction, this._direction );\n                vec3.transformQuat( this._up, upz, this._vrRot );\n\n            } else {\n                mat4.fromRotation( first, -this._angleVertical, right );\n                mat4.fromRotation( rotMat, -this._angleHorizontal, upz );\n                mat4.mul( rotMat, rotMat, first );\n\n                vec3.transformMat4( this._direction, upy, rotMat );\n                vec3.normalize( this._direction, this._direction );\n                vec3.transformMat4( this._up, upz, rotMat );\n            }\n        };\n    } )(),\n    reset: function () {\n        this.init();\n    },\n    setDistance: function ( d ) {\n        this._distance = d;\n    },\n    getDistance: function () {\n        return this._distance;\n    },\n    setStepFactor: function ( t ) {\n        this._stepFactor = t;\n    },\n\n    computePosition: ( function () {\n        var vec = vec2.create();\n\n        return function ( dt ) {\n            this._forward.update( dt );\n            this._side.update( dt );\n\n            // TDOO why check with epsilon ?\n            var factor = this._distance < 1e-3 ? 1e-3 : this._distance;\n\n            // see comment in orbitManipulator for fov modulation speed\n            var proj = this._camera.getProjectionMatrix();\n            var vFov = proj[ 15 ] === 1 ? 1.0 : 2.0 / proj[ 5 ];\n\n            // time based displacement vector\n            vec[ 0 ] = this._forward.getCurrent()[ 0 ];\n            vec[ 1 ] = this._side.getCurrent()[ 0 ];\n            var len2 = vec2.sqrLen( vec );\n            if ( len2 > 1.0 ) vec2.scale( vec, vec, 1.0 / Math.sqrt( len2 ) );\n\n            // direct displacement vectors\n            var pan = this._pan.update( dt );\n            var zoom = this._zoom.update( dt );\n\n            var timeFactor = this._stepFactor * factor * vFov * dt;\n            var directFactor = this._stepFactor * factor * vFov * 0.005;\n\n            this.moveForward( vec[ 0 ] * timeFactor - zoom[ 0 ] * directFactor * 20.0 );\n            this.strafe( vec[ 1 ] * timeFactor - pan[ 0 ] * directFactor );\n            this.strafeVertical( -pan[ 1 ] * directFactor );\n\n            if ( this._vrEnable ) {\n                vec3.add( this._eye, this._eye, this._vrTrans );\n                // in case setPoseVR skips some frame (possible if tracking is lost temporarily)\n                vec3.init( this._vrTrans );\n            }\n        };\n    } )(),\n\n\n    update: ( function () {\n        var tmpTarget = vec3.create();\n\n        return function ( nv ) {\n\n            var dt = nv.getFrameStamp().getDeltaTime();\n\n            var delta = this._lookPosition.update( dt );\n            this.computeRotation( -delta[ 0 ] * 0.5, -delta[ 1 ] * 0.5 );\n            this.computePosition( dt );\n\n            vec3.add( tmpTarget, this._eye, this._direction );\n            mat4.lookAt( this._inverseMatrix, this._eye, tmpTarget, this._up );\n\n            this._vrEnable = false; // setPoseVR is called on each frame\n        };\n    } )(),\n\n    setPoseVR: function ( q, pos ) {\n        this._vrEnable = true;\n        quat.copy( this._vrRot, q );\n        vec3.sub( this._vrTrans, pos, this._vrPos );\n        vec3.copy( this._vrPos, pos );\n    },\n\n    moveForward: ( function () {\n        var tmp = vec3.create();\n        return function ( distance ) {\n            vec3.normalize( tmp, this._direction );\n            vec3.scale( tmp, tmp, distance );\n            vec3.add( this._eye, this._eye, tmp );\n        };\n    } )(),\n\n    strafe: ( function () {\n        var tmp = vec3.create();\n        return function ( distance ) {\n            vec3.cross( tmp, this._direction, this._up );\n            vec3.normalize( tmp, tmp );\n            vec3.scale( tmp, tmp, distance );\n            vec3.add( this._eye, this._eye, tmp );\n        };\n    } )(),\n\n    strafeVertical: ( function () {\n        var tmp = vec3.create();\n        return function ( distance ) {\n            vec3.normalize( tmp, this._up );\n            vec3.scale( tmp, tmp, distance );\n            vec3.add( this._eye, this._eye, tmp );\n        };\n    } )()\n\n} );\n\nFirstPersonManipulator.DeviceOrientation = FirstPersonManipulatorDeviceOrientationController;\nFirstPersonManipulator.Hammer = FirstPersonManipulatorHammerController;\nFirstPersonManipulator.WebVR = FirstPersonManipulatorWebVRController;\nFirstPersonManipulator.StandardMouseKeyboard = FirstPersonManipulatorStandardMouseKeyboardController;\n\nmodule.exports = FirstPersonManipulator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/FirstPersonManipulator.js\n// module id = 179\n// module chunks = 0 1 2","'use strict';\nvar OrbitManipulatorHammerController = require( 'osgGA/OrbitManipulatorHammerController' );\n\n\nmodule.exports = OrbitManipulatorHammerController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/FirstPersonManipulatorHammerController.js\n// module id = 180\n// module chunks = 0 1 2","'use strict';\n\nvar FirstPersonManipulatorWebVRController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nFirstPersonManipulatorWebVRController.prototype = {\n    init: function () {},\n    update: function ( q, position ) {\n        this._manipulator.setPoseVR( q, position );\n    }\n};\n\nmodule.exports = FirstPersonManipulatorWebVRController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/FirstPersonManipulatorWebVRController.js\n// module id = 181\n// module chunks = 0 1 2","'use strict';\n\nvar FirstPersonManipulatorStandardMouseKeyboardController = function ( manipulator ) {\n    this._manipulator = manipulator;\n    this.init();\n};\n\nFirstPersonManipulatorStandardMouseKeyboardController.prototype = {\n    init: function () {\n        this.releaseButton();\n        this._delay = 0.15;\n        this._stepFactor = 1.0; // meaning radius*stepFactor to move\n    },\n    setEventProxy: function ( proxy ) {\n        this._eventProxy = proxy;\n    },\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n\n        // we always want to sync speed of controller with manipulator\n        this._manipulator.setStepFactor( this._stepFactor );\n    },\n\n    pushButton: function () {\n        this._buttonup = false;\n    },\n    releaseButton: function () {\n        this._buttonup = true;\n    },\n\n    mousedown: function ( ev ) {\n        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\n        var manipulator = this._manipulator;\n        manipulator.getLookPositionInterpolator().set( pos[ 0 ], pos[ 1 ] );\n        this.pushButton();\n    },\n    mouseup: function ( /*ev */) {\n        this.releaseButton();\n    },\n    mouseout: function ( /*ev */) {\n        this.releaseButton();\n    },\n    mousemove: function ( ev ) {\n        if ( this._buttonup === true ) {\n            return;\n        }\n\n        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\n        this._manipulator.getLookPositionInterpolator().setDelay( this._delay );\n        this._manipulator.getLookPositionInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\n\n        ev.preventDefault();\n    },\n    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {\n        this._stepFactor = Math.min( Math.max( 0.001, this._stepFactor + intDelta * 0.01 ), 4.0 );\n        this._manipulator.setStepFactor( this._stepFactor );\n    },\n\n    keydown: function ( event ) {\n        var manipulator = this._manipulator;\n        if ( event.keyCode === 32 ) {\n            manipulator.computeHomePosition();\n            event.preventDefault();\n        } else if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 ) { // w/z/up\n            manipulator.getForwardInterpolator().setDelay( this._delay );\n            manipulator.getForwardInterpolator().setTarget( 1 );\n            event.preventDefault();\n            return false;\n        } else if ( event.keyCode === 83 || event.keyCode === 40 ) { // S/down\n            manipulator.getForwardInterpolator().setDelay( this._delay );\n            manipulator.getForwardInterpolator().setTarget( -1 );\n            event.preventDefault();\n            return false;\n        } else if ( event.keyCode === 68 || event.keyCode === 39 ) { // D/right\n            manipulator.getSideInterpolator().setDelay( this._delay );\n            manipulator.getSideInterpolator().setTarget( 1 );\n            event.preventDefault();\n            return false;\n        } else if ( event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left\n            manipulator.getSideInterpolator().setDelay( this._delay );\n            manipulator.getSideInterpolator().setTarget( -1 );\n            event.preventDefault();\n            return false;\n        }\n        return undefined;\n    },\n\n    keyup: function ( event ) {\n        var manipulator = this._manipulator;\n        if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 || // w/z/up\n            event.keyCode === 83 || event.keyCode === 40 ) { // S/down\n            manipulator.getForwardInterpolator().setDelay( this._delay );\n            manipulator.getForwardInterpolator().setTarget( 0 );\n            return false;\n        } else if ( event.keyCode === 68 || event.keyCode === 39 || // D/right\n            event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left\n            manipulator.getSideInterpolator().setDelay( this._delay );\n            manipulator.getSideInterpolator().setTarget( 0 );\n            return false;\n        }\n        return undefined;\n    }\n\n};\n\nmodule.exports = FirstPersonManipulatorStandardMouseKeyboardController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/FirstPersonManipulatorStandardMouseKeyboardController.js\n// module id = 182\n// module chunks = 0 1 2","'use strict';\n\n/**\n *  OrbitManipulator\n *  @class\n */\nvar SwitchManipulator = function () {\n    this._manipulatorList = [];\n    this._currentManipulator = undefined;\n};\n\n/** @lends SwitchManipulator.prototype */\nSwitchManipulator.prototype = {\n    getCamera: function () {\n        return this.getCurrentManipulator().getCamera();\n    },\n    setCamera: function ( cam ) {\n        var cbList = this.getManipulatorList();\n        for ( var i = 0, nb = cbList.length; i < nb; ++i )\n            cbList[ i ].setCamera( cam );\n    },\n    update: function ( nv ) {\n        var manipulator = this.getCurrentManipulator();\n        if ( manipulator !== undefined ) {\n            return manipulator.update( nv );\n        }\n        return undefined;\n    },\n    getNode: function () {\n        // we should add an accessor in the osgjs manipulator\n        return this.getCurrentManipulator()._node;\n    },\n    setNode: function ( node ) {\n        var cbList = this.getManipulatorList();\n        for ( var i = 0, nb = cbList.length; i < nb; ++i )\n            cbList[ i ].setNode( node );\n    },\n    getControllerList: function () {\n        return this.getCurrentManipulator().getControllerList();\n    },\n    getNumManipulator: function () {\n        return this._manipulatorList.length;\n    },\n    addManipulator: function ( manipulator ) {\n        this._manipulatorList.push( manipulator );\n        if ( this._currentManipulator === undefined ) {\n            this.setManipulatorIndex( 0 );\n        }\n    },\n    getManipulatorList: function () {\n        return this._manipulatorList;\n    },\n    setManipulatorIndex: function ( index ) {\n        this._currentManipulator = index;\n    },\n    getCurrentManipulatorIndex: function () {\n        return this._currentManipulator;\n    },\n    getCurrentManipulator: function () {\n        return this._manipulatorList[ this._currentManipulator ];\n    },\n    reset: function () {\n        this.getCurrentManipulator().reset();\n    },\n    computeHomePosition: function ( useBoundingBox ) {\n        var manipulator = this.getCurrentManipulator();\n        if ( manipulator !== undefined ) {\n            manipulator.computeHomePosition( useBoundingBox );\n        }\n    },\n    getInverseMatrix: function () {\n        var manipulator = this.getCurrentManipulator();\n        if ( manipulator !== undefined ) {\n            return manipulator.getInverseMatrix();\n        }\n    },\n    getHomeBound: function ( boundStrategy ) {\n        return this.getCurrentManipulator().getHomeBound( boundStrategy );\n    },\n    getHomeDistance: function ( bs ) {\n        return this.getCurrentManipulator().getHomeDistance( bs );\n    }\n};\n\nmodule.exports = SwitchManipulator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgGA/SwitchManipulator.js\n// module id = 183\n// module chunks = 0 1 2","'use strict';\nvar Composer = require( 'osgUtil/Composer' );\nvar debug = require( 'osgUtil/debug' );\nvar DelayInterpolator = require( 'osgUtil/DelayInterpolator' );\nvar DisplayNormalVisitor = require( 'osgUtil/DisplayNormalVisitor' );\nvar DisplayGeometryVisitor = require( 'osgUtil/DisplayGeometryVisitor' );\nvar DisplayGraph = require( 'osgUtil/DisplayGraph' );\nvar IntersectionVisitor = require( 'osgUtil/IntersectionVisitor' );\nvar LineSegmentIntersector = require( 'osgUtil/LineSegmentIntersector' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeGizmo = require( 'osgUtil/NodeGizmo' );\nvar GizmoGeometry = require( 'osgUtil/gizmoGeometry' );\nvar PolytopeIntersector = require( 'osgUtil/PolytopeIntersector' );\nvar PolytopePrimitiveIntersector = require( 'osgUtil/PolytopePrimitiveIntersector' );\nvar SphereIntersector = require( 'osgUtil/SphereIntersector' );\nvar TangentSpaceGenerator = require( 'osgUtil/TangentSpaceGenerator' );\nvar TriangleLineSegmentIntersector = require( 'osgUtil/TriangleLineSegmentIntersector' );\nvar WebVRCustom = require( 'osgUtil/WebVRCustom' );\nvar WebVR = require( 'osgUtil/WebVR' );\n\n\nvar osgUtil = {};\n\nosgUtil.Composer = Composer;\nMACROUTILS.objectMix( osgUtil, debug );\nosgUtil.DelayInterpolator = DelayInterpolator;\nosgUtil.DisplayNormalVisitor = DisplayNormalVisitor;\nosgUtil.DisplayGeometryVisitor = DisplayGeometryVisitor;\nosgUtil.DisplayGraph = DisplayGraph;\nosgUtil.IntersectionVisitor = IntersectionVisitor;\nosgUtil.LineSegmentIntersector = LineSegmentIntersector;\nosgUtil.NodeGizmo = NodeGizmo;\nosgUtil.GizmoGeometry = GizmoGeometry;\nosgUtil.WebVRCustom = WebVRCustom;\nosgUtil.PolytopeIntersector = PolytopeIntersector;\nosgUtil.PolytopePrimitiveIntersector = PolytopePrimitiveIntersector;\nosgUtil.SphereIntersector = SphereIntersector;\nosgUtil.TangentSpaceGenerator = TangentSpaceGenerator;\nosgUtil.TriangleLineSegmentIntersector = TriangleLineSegmentIntersector;\nosgUtil.WebVR = WebVR;\n\nmodule.exports = osgUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/osgUtil.js\n// module id = 184\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osg/Node' );\nvar CullFace = require( 'osg/CullFace' );\nvar Depth = require( 'osg/Depth' );\nvar Texture = require( 'osg/Texture' );\nvar Camera = require( 'osg/Camera' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar Viewport = require( 'osg/Viewport' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Uniform = require( 'osg/Uniform' );\nvar StateSet = require( 'osg/StateSet' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar Shape = require( 'osg/shape' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n\n/*\n Composer is an helper to create post fx. The idea is to push one or more textures into a pipe of shader filter.\n\n how to use it:\n\n // example how to blur a texture and render it to screen\n var myTexture; // imagine it's your texture you want to process\n var composer = new Composer();\n composer.addPass(new Composer.Filter.InputTexture(myTexture));\n composer.addPass(new Composer.Filter.HBlur(5));\n composer.addPass(new Composer.Filter.VBlur(5));\n composer.renderToScreen(1200, 900);\n composer.build(); // if you dont build manually it will be done in the scenegraph while upading\n rootnode.addChild(composer);\n\n // now you can imagine to some process and use the result as input texture for a geometry\n var myTexture; // imagine it's your texture you want to process\n var myResultTexture = new Texture(); // imagine it's your texture you want to process\n myResultTexture.setTextureSize(1200,900);\n var composer = new Composer();\n composer.addPass(new Composer.Filter.InputTexture(myTexture));\n composer.addPass(new Composer.Filter.HBlur(5));\n composer.addPass(new Composer.Filter.VBlur(5), resultTexture);\n\n myGeometry.getStateSet().setTextureAttributeAndModes(0, resultTexture);\n rootnode.addChild(composer);\n\n */\n\nvar Composer = function () {\n    Node.call( this );\n    this._stack = [];\n    this._renderToScreen = false;\n    this._dirty = false;\n\n    this._textureRTT = [];\n    this._cameraRTT = [];\n\n    var UpdateCallback = function () {\n\n    };\n    UpdateCallback.prototype = {\n        update: function ( node /*, nv */ ) {\n            if ( node.isDirty() ) {\n                node.build();\n            }\n            return true;\n        }\n    };\n    this.addUpdateCallback( new UpdateCallback() );\n    // disable unecessarry drawing/states/check\n    this.getOrCreateStateSet().setAttributeAndModes( new Depth( 'DISABLE' ) );\n    this.getOrCreateStateSet().setAttributeAndModes( new CullFace( 'BACK' ) );\n};\n\nComposer.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    dirty: function () {\n        for ( var i = 0, l = this._stack.length; i < l; i++ ) {\n            this._stack[ i ].filter.dirty();\n        }\n    },\n\n    // addPass support different signature\n    // addPass(filter) -> the filter will be done on a texture of the same size than the previous pass\n    // addPass(filter, textureWidth, textureHeight) -> the filter will be done on a texture width and height\n    // addPass(filter, texture) -> the filter will be done on the giver texture using its width and height\n    addPass: function ( filter, arg0, arg1 ) {\n\n        var newPass = {};\n        newPass.filter = filter;\n        // when arg0 is a texture\n        // arg1 is the target, can be TEXTURE_2D ( by default ) or\n        // a cubemape's face like TEXTURE_CUBE_MAP_POSITIVE_X, ...\n        if ( arg0 instanceof Texture ) {\n            newPass.texture = arg0;\n            newPass.textureTarget = arg1 || Texture.TEXTURE_2D;\n        } else if ( arg0 !== undefined && arg1 !== undefined ) {\n            newPass.width = Math.floor( arg0 );\n            newPass.height = Math.floor( arg1 );\n        }\n\n        this._stack.push( newPass );\n        return newPass.filter;\n    },\n    renderToScreen: function ( w, h ) {\n        this._renderToScreen = true;\n        this._renderToScreenWidth = w;\n        this._renderToScreenHeight = h;\n    },\n    getResultTexture: function () {\n        return this._resultTexture;\n    },\n    isDirty: function () {\n        for ( var i = 0, l = this._stack.length; i < l; i++ ) {\n            if ( this._stack[ i ].filter.isDirty() ) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    build: function () {\n\n        var self = this;\n\n        // keep some references\n        // TODO: use for reuse/cache/invalidation\n        self._textureRTT = [];\n        self._cameraRTT = [];\n\n\n        this.removeChildren();\n        var lastTextureResult;\n\n        this._stack.forEach( function ( element, i, array ) {\n\n            // update filter internal due to user change on filter\n            if ( element.filter.isDirty() ) {\n                element.filter.build();\n            }\n\n            // this filter need a special setup that composer build cannot do\n            if ( element.filter.interConnectFilters ) {\n                lastTextureResult = element.filter.interConnectFilters( self, i, array );\n                // goto next filter directly\n                return;\n            }\n\n            var stateSet = element.filter.getStateSet();\n            var w, h;\n\n            // compute filter render texture size\n            if ( element.texture !== undefined ) {\n\n                w = element.texture.getWidth();\n                h = element.texture.getHeight();\n\n            } else if ( element.width !== undefined && element.height !== undefined ) {\n\n                w = element.width;\n                h = element.height;\n\n            } else {\n\n                // get width from Texture0\n                var inputTexture = stateSet.getTextureAttribute( 0, 'Texture' );\n                if ( inputTexture === undefined ) {\n                    Notify.warn( 'Composer can\\'t find any information to setup texture output size' );\n                } else {\n                    w = inputTexture.getWidth();\n                    h = inputTexture.getHeight();\n                }\n            }\n\n            // is it the last filter and we want to render to screen ?\n            var lastFilterRenderToScreen = ( i === array.length - 1 &&\n                self._renderToScreen === true );\n\n            // check if we have something to do\n            // else we will just translate stateset to the next filter\n            // this part exist to manage the Composer.Filter.InputTexture that setup the first texture unit\n            if ( !lastFilterRenderToScreen ) {\n                if ( stateSet.getAttribute( 'Program' ) === undefined ) {\n                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, stateSet.getTextureAttribute( 0, 'Texture' ) );\n                    return;\n                }\n            }\n\n            // build the filter into a Camera and a StateSet\n            var camera = new Camera();\n            self._cameraRTT.push( camera );\n            camera.setStateSet( stateSet );\n\n\n            var textureResult;\n            // check if we want to render on screen\n            if ( lastFilterRenderToScreen === true ) {\n                w = self._renderToScreenWidth;\n                h = self._renderToScreenHeight;\n            } else {\n                // Or in a offscreen Framebuffer\n                camera.setRenderOrder( Camera.PRE_RENDER, 0 );\n                textureResult = element.texture;\n                var textureTarget = element.textureTarget;\n                // if no user provided render target texture, create one\n                if ( textureResult === undefined ) {\n                    textureResult = new Texture();\n                    textureResult.setName( 'composer Rtt ' + element.filter.getFragmentName() );\n                    textureResult.setTextureSize( w, h );\n                    textureTarget = Texture.TEXTURE_2D;\n                    self._textureRTT.push( textureResult );\n                }\n                // Attach the render texture target as FBO\n                // Note: node depth attachment because we're in 2D\n                camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, textureResult, textureTarget );\n            }\n\n            var vp = new Viewport( 0, 0, w, h );\n            camera.setReferenceFrame( TransformEnums.ABSOLUTE_RF );\n            camera.setViewport( vp );\n\n            // FIXME: not really useful, but osgjs keep pushing projection matrix\n            // and maybe some old code still use it\n            mat4.ortho( camera.getProjectionMatrix(), 0, 1, 0, 1, -5, 5 );\n\n            var quad = Shape.createTexturedFullScreenFakeQuadGeometry();\n\n            if ( element.filter.buildGeometry )\n                quad = element.filter.buildGeometry( quad );\n\n            quad.setName( 'composer layer' );\n\n            // if rendering into texture framebuffer\n            if ( textureResult ) {\n\n\n                // assign the result texture to the next stateset\n                if ( i + 1 < array.length ) {\n                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, textureResult );\n                }\n\n            }\n            lastTextureResult = textureResult;\n\n\n            camera.addChild( quad );\n            element.filter.getStateSet().addUniform( Uniform.createFloat2( vec2.fromValues( w, h ), 'RenderSize' ) );\n\n            // Optimization, no need to clear,\n            // unless we know we'll have transparent parts\n            // which is a special case rather than the default\n            camera.setClearMask( 0 );\n\n            camera.setName( element.filter.getFragmentName() || 'Composer Pass' + i );\n            // add to composer\n            self.addChild( camera );\n        } );\n        // reference to the resulting texture\n        // undefined if rendering directly to screen\n        this._resultTexture = lastTextureResult;\n    }\n} );\n\nComposer.Filter = function () {\n    this._stateSet = new StateSet();\n    this._dirty = true;\n    // no default shader name (in case we use a compiler and it's already provided)\n    // ideally we should check the string and add a default name if there is none\n    this._fragmentName = '';\n    this._vertexName = '';\n};\n\nComposer.Filter.prototype = {\n    setFragmentName: function ( fname ) {\n        this._fragmentName = fname;\n    },\n    getFragmentName: function () {\n        return this._fragmentName;\n    },\n    setVertexName: function ( vname ) {\n        this._vertexName = vname;\n    },\n    getVertexName: function () {\n        return this._vertexName;\n    },\n    getDefineFragmentName: function () {\n        if ( !this._fragmentName ) return '';\n        return '\\n#define SHADER_NAME ' + this._fragmentName + '\\n';\n    },\n    getDefineVertexName: function () {\n        if ( !this._vertexName && !this._fragmentName ) return '';\n        return '\\n#define SHADER_NAME ' + ( this._vertexName || this._fragmentName ) + '\\n';\n    },\n    getStateSet: function () {\n        return this._stateSet;\n    },\n    getOrCreateStateSet: function () {\n        return this._stateSet;\n    },\n    dirty: function () {\n        this._dirty = true;\n    },\n    isDirty: function () {\n        return this._dirty;\n    }\n};\n\n// default means you do use the special optimized full screen triangle\n// dubbed fakeFullscreenQuad\n// no need of modelView, projection, nor texcoord\nComposer.Filter.defaultVertexShader = [\n    'attribute vec3 Vertex;',\n    'varying vec2 vTexCoord0;',\n    'void main(void) {',\n    '  gl_Position = vec4(Vertex*2.0 - 1.0,1.0);',\n    '  vTexCoord0 = Vertex.xy;',\n    '}',\n    ''\n].join( '\\n' );\nComposer.Filter.defaultFragmentShaderHeader = [\n    '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif',\n    'varying vec2 vTexCoord0;',\n    'uniform vec2 RenderSize;',\n    'uniform sampler2D Texture0;',\n    ''\n].join( '\\n' );\n\nComposer.Filter.shaderUtils = [\n    'vec4 packFloatTo4x8(in float v) {',\n    'vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;',\n    'enc = fract(enc);',\n    'enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);',\n    'return enc;',\n    '}',\n\n    ' ',\n    'vec4 pack2FloatTo4x8(in vec2 val) {',\n    ' const vec2 bitSh = vec2(256.0, 1.0);',\n    ' const vec2 bitMsk = vec2(0.0, 1.0/256.0);',\n    ' vec2 res1 = fract(val.x * bitSh);',\n    ' res1 -= res1.xx * bitMsk;',\n    ' vec2 res2 = fract(val.y * bitSh);',\n    ' res2 -= res2.xx * bitMsk;',\n    ' return vec4(res1.x,res1.y,res2.x,res2.y);',\n    '}',\n    ' ',\n    'float unpack4x8ToFloat( vec4 rgba ) {',\n    ' return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );',\n    '}',\n    ' ',\n    'vec2 unpack4x8To2Float(in vec4 val) {',\n    ' const vec2 unshift = vec2(1.0/256.0, 1.0);',\n    ' return vec2(dot(val.xy, unshift), dot(val.zw, unshift));',\n    '}',\n\n    'vec2 encodeNormal (vec3 n)',\n    '{',\n    '    float f = sqrt(8.0*n.z+8.0);',\n    '    return n.xy / f + 0.5;',\n    '}',\n\n    'vec3 decodeNormal (vec2 enc)',\n    '{',\n    '    vec2 fenc = enc*4.0-2.0;',\n    '    float f = dot(fenc,fenc);',\n    '    float g = sqrt(1.0-f/4.0);',\n    '    vec3 n;',\n    '    n.xy = fenc*g;',\n    '    n.z = 1.0-f/2.0;',\n    '    return n;',\n    '}',\n    ''\n].join( '\\n' );\n\nComposer.Filter.Helper = {\n    pascalCache: [\n        [ 1 ]\n    ],\n    getOrCreatePascalCoefficients: function ( kernelSize ) {\n        kernelSize = kernelSize === undefined ? 5 : Math.min( kernelSize, 128 );\n        var cache = Composer.Filter.Helper.pascalCache;\n        if ( cache[ kernelSize ] )\n            return cache[ kernelSize ];\n        for ( var j = cache.length - 1; j < kernelSize; j++ ) {\n            var currentRow = cache[ j ];\n            var currentRowSize = currentRow.length;\n\n            var nextRow = new Array( currentRowSize );\n            nextRow[ 0 ] = 1.0;\n            nextRow[ currentRowSize ] = 1.0;\n\n            // unnormalized pascal\n            var sum = j === cache.length - 1 ? Math.pow( 2, j ) : 1.0;\n            for ( var p = 0; p < currentRowSize - 1; p++ )\n                nextRow[ p + 1 ] = ( currentRow[ p ] + currentRow[ p + 1 ] ) * sum;\n            // normalized array\n            sum = Math.pow( 2, j + 1 );\n            for ( var k = 0; k < currentRowSize + 1; k++ )\n                nextRow[ k ] /= sum;\n            cache.push( nextRow );\n        }\n        return cache[ kernelSize ];\n    }\n};\n\nComposer.Filter.Custom = function ( fragmentShader, uniforms ) {\n    Composer.Filter.call( this );\n    this._fragmentShader = fragmentShader;\n    this._uniforms = uniforms;\n    this._vertexShader = Composer.Filter.defaultVertexShader;\n};\n\nComposer.Filter.Custom.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    getFragmentShader: function () {\n        return this._fragmentShader;\n    },\n    getVertexShader: function () {\n        return this._vertexShader;\n    },\n    setFragmentShader: function ( f ) {\n        this._fragmentShader = f;\n    },\n    setVertexShader: function ( v ) {\n        this._vertexShader = v;\n    },\n    autoBindFragmentUniformStateSet: function ( stateSet, fragmentShader, uniforms ) {\n\n        var unitIndex = 0;\n\n        // TODO: check if not a better place Utils\n        // and reuse (we already do this in shader)\n        // At least DEFINE the regexp somewhere somehow\n        var r = fragmentShader.match( /uniform\\s+\\w+\\s+\\w+/g );\n        if ( !r ) return;\n\n        for ( var i = 0, l = r.length; i < l; i++ ) {\n\n            var match = r[ i ].match( /uniform\\s+(\\w+)\\s+(\\w+)/ );\n            var uniformType = match[ 1 ];\n            var uniformName = match[ 2 ];\n            var uniform;\n\n            if ( !uniforms[ uniformName ] ) continue;\n\n            var uniformValue = uniforms[ uniformName ];\n\n            if ( uniformType.search( 'sampler' ) !== -1 ) {\n\n                // STRONG IMPLICIT LINKING HERE:\n                // Texture Unit Linked directly to declaration order in fragment Shader\n                stateSet.setTextureAttributeAndModes( unitIndex, uniformValue );\n                uniform = Uniform.createInt1( unitIndex, uniformName );\n                unitIndex++;\n                stateSet.addUniform( uniform );\n\n            } else {\n\n                if ( Uniform.isUniform( uniformValue ) ) {\n                    uniform = uniformValue;\n                } else {\n                    uniform = Uniform[ uniformType ]( uniforms[ uniformName ], uniformName );\n                }\n                stateSet.addUniform( uniform );\n\n            }\n\n        }\n    },\n    build: function () {\n\n        this._program = new Program(\n            new Shader( Shader.VERTEX_SHADER, this._vertexShader + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, this._fragmentShader + this.getDefineFragmentName() ) );\n\n        if ( this._uniforms ) {\n            this.autoBindFragmentUniformStateSet( this._stateSet, this._fragmentShader, this._uniforms );\n        }\n        this._stateSet.setAttributeAndModes( this._program );\n        this._dirty = false;\n\n    }\n} );\n\n\n// filter that switch its render target and its input at each frame\n// allowing to get input for last frame render.\nComposer.Filter.PingPong = function ( cameraRtt0, rtt0, cameraRtt1, rtt1, fragmentShader, uniforms ) {\n    Composer.Filter.Custom.apply( this, [ fragmentShader, uniforms ] );\n\n    this._cameraRtt0 = cameraRtt0;\n    this._rtt0 = rtt0;\n\n    this._cameraRtt1 = cameraRtt1;\n    this._rtt1 = rtt1;\n\n    this._fragmentName = 'PingPong';\n};\n\nComposer.Filter.PingPong.prototype = MACROUTILS.objectInherit( Composer.Filter.Custom.prototype, {\n\n    // Constraints:\n    // - Next Filter: texture unit 0 === rtt0 && texture unit 1 === rtt1\n    // - Previous Filter: the output of the previous filter if any\n    //      will be binded to texture unit 0 of both camera stateset\n    interConnectFilters: function ( composer, i, array ) {\n\n        var filterStateSet = this.getStateSet();\n\n        var st0 = this._cameraRtt0.getOrCreateStateSet();\n        var st1 = this._cameraRtt1.getOrCreateStateSet();\n\n        // copy filter program and uniforms on the 2 cameras\n        st0.setAttributeAndModes( this._program );\n        st1.setAttributeAndModes( this._program );\n\n        // PingPong filter is a peculiar Filter where user provides the Camera\n        // instead of compose::build creating them, and allowing user to provide\n        // them in the ctor\n        // To make sure we don't forget any uniform\n        // we make sure to get uniform from the filter itself and the uniform\n        // from the parameters\n        var unifKey, unif, uniforms = this.getStateSet().getUniformList();\n        if ( uniforms ) {\n            for ( unifKey in uniforms ) {\n                unif = uniforms[ unifKey ].getUniform();\n                st0.addUniform( unif );\n                st1.addUniform( unif );\n            }\n        }\n\n        uniforms = this._uniforms;\n        if ( uniforms ) {\n            for ( unifKey in uniforms ) {\n                unif = uniforms[ unifKey ];\n                st0.addUniform( unif );\n                st1.addUniform( unif );\n            }\n        }\n\n\n        var uniformTU0 = Uniform.createInt1( 0, 'Texture0' );\n        var uniformTU1 = Uniform.createInt1( 1, 'Texture1' );\n\n        st0.addUniform( uniformTU0 );\n        st0.addUniform( uniformTU1 );\n\n        st1.addUniform( uniformTU0 );\n        st1.addUniform( uniformTU1 );\n\n        // copy input on both camera\n        // Composer::Build set the last render into the current filter stateset texture unit 0\n        // we copy that into each camera as Texture unit 0\n        var inputTexture = filterStateSet.getTextureAttribute( 0, 'Texture' );\n        st0.setTextureAttributeAndModes( 0, inputTexture );\n        st1.setTextureAttributeAndModes( 0, inputTexture );\n\n        st0.setTextureAttributeAndModes( 1, this._rtt1 );\n        st1.setTextureAttributeAndModes( 1, this._rtt0 );\n\n        // if not the last filter\n        // bind both result to next filter\n        // rtt0 to texture unit 0\n        // rtt0 to texture unit 1\n        if ( i !== array.length - 1 ) {\n\n            // just translate stateset to the next filter\n            var nextSt = array[ i + 1 ].filter.getStateSet();\n\n            nextSt.setTextureAttributeAndModes( 0, this._rtt0 );\n            nextSt.setTextureAttributeAndModes( 1, this._rtt1 );\n\n            nextSt.addUniform( uniformTU0 );\n            nextSt.addUniform( uniformTU1 );\n\n        }\n\n        var quad = Shape.createTexturedFullScreenFakeQuadGeometry();\n\n        if ( this.buildGeometry )\n            quad = this.buildGeometry( quad );\n\n        quad.setName( 'composer layer' );\n\n        this._cameraRtt0.addChild( quad );\n        this._cameraRtt1.addChild( quad );\n\n        composer.addChild( this._cameraRtt0 );\n        composer.addChild( this._cameraRtt1 );\n\n        composer._textureRTT.push( this._rtt0 );\n        composer._textureRTT.push( this._rtt1 );\n\n        composer._cameraRTT.push( this._cameraRtt0 );\n        composer._cameraRTT.push( this._cameraRtt1 );\n\n        // hide one of the two pass, as we will render only one each frame\n        this._cameraRtt1.setNodeMask( 0x0 );\n\n        // last texture result, only one possible so the first will do\n        return this._rtt0;\n\n    },\n\n    // PingPong\n    switch: function () {\n\n        var nodeMask0 = this._cameraRtt0.getNodeMask();\n        var nodeMask1 = this._cameraRtt1.getNodeMask();\n\n        this._cameraRtt0.setNodeMask( nodeMask1 );\n        this._cameraRtt1.setNodeMask( nodeMask0 );\n\n    }\n\n} );\n\nComposer.Filter.AverageHBlur = function ( nbSamplesOpt, linear, unpack, pack ) {\n    Composer.Filter.call( this );\n    this._linear = linear !== false;\n    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );\n    this._unpack = unpack;\n    this._pack = pack;\n    this._pixelSize = 1.0;\n    this._fragmentName = 'AverageHBlur' + this._nbSamples;\n};\n\nComposer.Filter.AverageHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    setBlurSize: function ( nbSamples ) {\n        if ( nbSamples % 2 !== 1 ) {\n            nbSamples += 1;\n        }\n        this._nbSamples = nbSamples;\n        this.dirty();\n    },\n    setPixelSize: function ( value ) {\n        this._pixelSize = value;\n        this.dirty();\n    },\n\n    getUVOffset: function ( value ) {\n        return 'vec2(float(' + value + ')/RenderSize[0], 0.0);';\n    },\n    getShaderBlurKernel: function () {\n        var nbSamples = this._nbSamples;\n\n\n        var kernel = [];\n\n        kernel.push( ' pixel = unpack(Texture0, vTexCoord0 );' );\n        kernel.push( ' if (pixel.w == 0.0) { gl_FragColor = pixel; return; }' );\n        kernel.push( ' vec2 offset;' );\n        var i;\n        var numTexBlurStep = Math.floor( nbSamples / 2 );\n        if ( numTexBlurStep % 2 !== 0 ) {\n            nbSamples += 1;\n            numTexBlurStep = Math.floor( nbSamples / 2 );\n        }\n        var numFinalSample = numTexBlurStep * 2.0 + 1.0;\n        var weight = 1.0 / numFinalSample;\n        if ( !this._linear ) {\n            for ( i = 0; i < numTexBlurStep; i++ ) {\n                kernel.push( ' offset = ' + this.getUVOffset( ( i + 1 ) * this._pixelSize ) );\n                kernel.push( ' pixel += unpack(Texture0, vTexCoord0 + offset);' );\n                kernel.push( ' pixel += unpack(Texture0, vTexCoord0 - offset);' );\n            }\n            kernel.push( ' pixel *= float(' + weight + ');' );\n\n            //console.log( 'N: Sum = ' + ( weight + numTexBlurStep * weight * 2 ) );\n            //console.log( 'N: nbSample = ' + nbSamples + ' texBlurStep= ' + numTexBlurStep + ' finalSample= ' + numFinalSample );\n            //console.log( 'N: w = ' + weight );\n\n        } else {\n            // using bilinear HW to divide texfetch by 2\n            var offset, offsetIdx;\n            var idx = 1;\n            var weightTwo = ( 1.0 - weight ) / ( numTexBlurStep * 2.0 );\n            // first pixel not same weight as others\n            kernel.push( ' pixel *= float(' + weight + ');' );\n            kernel.push( ' vec4 pixelLin = vec4(0.0);' );\n\n            for ( i = 0; i < numTexBlurStep; i += 2 ) {\n\n                offsetIdx = idx + 0.5; //  ((i*weight + (i+1)*weight)/(weight+weight)) ===  (2i + 1) / 2 = i + 0.5\n                idx += 2;\n                offset = this.getUVOffset( offsetIdx * this._pixelSize );\n\n                kernel.push( ' offset = ' + offset );\n\n                kernel.push( ' pixelLin += unpack(Texture0, vTexCoord0 + offset);' );\n                kernel.push( ' pixelLin += unpack(Texture0, vTexCoord0 - offset);' );\n            }\n            kernel.push( ' pixel += pixelLin * float(' + weightTwo * 2 + ');' );\n\n            //console.log( 'L: Sum = ' + ( weight + numTexBlurStep * weightTwo * 2 ) );\n            //console.log( 'L: nbSample = ' + nbSamples + ' texBlurStep= ' + numTexBlurStep + ' finalSample= ' + numFinalSample );\n            //console.log( 'N: w = ' + weight + ' numTexBlurStep  ' + numTexBlurStep + ' * w2 = ' + weightTwo );\n\n        }\n        return kernel;\n    },\n    build: function () {\n\n        var tex = this._stateSet.getTextureAttribute( 0, 'Texture' );\n        if ( tex && this._linear ) {\n            tex.setMinFilter( 'LINEAR' );\n            tex.setMagFilter( 'LINEAR' );\n        } else {\n            this._linear = false;\n        }\n\n        //var nbSamples = this._nbSamples;\n        var vtx = Composer.Filter.defaultVertexShader;\n        var fgt = [\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform float width;',\n\n            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',\n            this._pack || 'vec4 pack(vec4 pix) { return pix; }',\n\n            'void main (void)',\n            '{',\n            '  vec4 pixel;',\n            this.getShaderBlurKernel().join( '\\n' ),\n            '  gl_FragColor = pack(pixel);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {\n            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );\n        }\n\n\n        this._stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\n\nComposer.Filter.AverageVBlur = function ( nbSamplesOpt, linear, unpack, pack ) {\n    Composer.Filter.AverageHBlur.call( this, nbSamplesOpt, linear, unpack, pack );\n    this._fragmentName = 'AverageVBlur' + this._nbSamples;\n};\nComposer.Filter.AverageVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.AverageHBlur.prototype, {\n    getUVOffset: function ( value ) {\n        return 'vec2(0.0, float(' + value + ')/RenderSize[1]);';\n    }\n} );\n\nComposer.Filter.BilateralHBlur = function ( options, unpack, pack ) {\n    Composer.Filter.call( this );\n\n    if ( options === undefined ) {\n        options = {};\n    }\n\n    var nbSamplesOpt = options.nbSamples;\n    var depthTexture = options.depthTexture;\n    var radius = options.radius;\n\n    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );\n    this._depthTexture = depthTexture;\n    this._radius = Uniform.createFloat( 1.0, 'radius' );\n    this._pixelSize = Uniform.createFloat( 1.0, 'pixelSize' );\n    this.setRadius( radius );\n\n    this._unpack = unpack;\n    this._pack = pack;\n    this._fragmentName = 'BilateralHBlur' + this._nbSamples;\n};\n\nComposer.Filter.BilateralHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    setBlurSize: function ( nbSamples ) {\n        if ( nbSamples % 2 !== 1 ) {\n            nbSamples += 1;\n        }\n        //Notify.log('BlurSize ' + nbSamples);\n        this._nbSamples = nbSamples;\n        this.dirty();\n    },\n    setPixelSize: function ( value ) {\n        this._pixelSize.setFloat( value );\n    },\n    setRadius: function ( radius ) {\n        this._radius.setFloat( radius ); // *2.0;\n    },\n    getUVOffset: function ( value ) {\n        return 'vec2(0.0, float(' + value + ') * pixelSize )/RenderSize[1];';\n    },\n    getShaderBlurKernel: function () {\n        var nbSamples = this._nbSamples;\n        var kernel = [];\n        kernel.push( ' pixel = unpack(Texture0, vTexCoord0 );' );\n        kernel.push( ' if (pixel.w <= 0.0001) { gl_FragColor = vec4(1.0); return; }' );\n        kernel.push( ' vec2 offset, tmpUV;' );\n        kernel.push( ' depth = getDepthValue(unpack(Texture1, vTexCoord0 ));' );\n        for ( var i = 1; i < Math.ceil( nbSamples / 2 ); i++ ) {\n            kernel.push( ' offset = ' + this.getUVOffset( i ) );\n\n            kernel.push( ' tmpUV =  vTexCoord0 + offset;' );\n            kernel.push( ' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));' );\n            kernel.push( ' if ( abs(depth-tmpDepth) < radius) {' );\n            kernel.push( '   pixel += unpack(Texture0, tmpUV);' );\n            kernel.push( '   nbHits += 1.0;' );\n            kernel.push( ' }' );\n\n            kernel.push( ' tmpUV =  vTexCoord0 - offset;' );\n            kernel.push( ' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));' );\n            kernel.push( ' if ( abs(depth-tmpDepth) < radius) {' );\n            kernel.push( '   pixel += unpack(Texture0, tmpUV);' );\n            kernel.push( '   nbHits += 1.0;' );\n            kernel.push( ' }' );\n        }\n        kernel.push( ' pixel /= nbHits;' );\n        return kernel;\n    },\n    build: function () {\n        //var nbSamples = this._nbSamples;\n        var vtx = Composer.Filter.defaultVertexShader;\n        var fgt = [\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform sampler2D Texture1;',\n            'uniform float width;',\n            'uniform mat4 projection;',\n            'uniform float radius;',\n            'uniform float pixelSize;',\n\n            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',\n            this._pack || 'vec4 pack(vec4 pix) { return pix; }',\n\n            'float znear,zfar,zrange;',\n            '',\n            Composer.Filter.shaderUtils,\n            '',\n            'float getDepthValue(vec4 v) {',\n            '  float depth = unpack4x8ToFloat(v);',\n            '  depth = depth*zrange+znear;',\n            '  return -depth;',\n            '}',\n\n            'void main (void)',\n            '{',\n            '  vec4 pixel;',\n            '  float depth, tmpDepth;',\n            '  znear = projection[3][2] / (projection[2][2]-1.0);',\n            '  zfar = projection[3][2] / (projection[2][2]+1.0);',\n            '  zrange = zfar-znear;',\n            '  float nbHits = 1.0;',\n\n            this.getShaderBlurKernel().join( '\\n' ),\n            '  gl_FragColor = pack(pixel);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {\n            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );\n        }\n        if ( this._stateSet.getUniform( 'Texture1' ) === undefined ) {\n            this._stateSet.addUniform( Uniform.createInt1( 1, 'Texture1' ) );\n        }\n        this._stateSet.addUniform( this._radius );\n        this._stateSet.addUniform( this._pixelSize );\n        this._stateSet.setTextureAttributeAndModes( 1, this._depthTexture );\n        this._stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\nComposer.Filter.BilateralVBlur = function ( options, unpack, pack ) {\n    Composer.Filter.BilateralHBlur.call( this, options, unpack, pack );\n    this._fragmentName = 'BilateralVBlur' + this._nbSamples;\n};\n\nComposer.Filter.BilateralVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.BilateralHBlur.prototype, {\n    getUVOffset: function ( value ) {\n        return 'vec2(float(' + value + ')*pixelSize/RenderSize[0],0.0);';\n    }\n} );\n\n// InputTexture is a fake filter to setup the first texture\n// in the composer pipeline\nComposer.Filter.InputTexture = function ( texture ) {\n    Composer.Filter.call( this );\n    this._stateSet.setTextureAttributeAndModes( 0, texture );\n    this._fragmentName = 'InputTexture';\n};\nComposer.Filter.InputTexture.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    build: function () {\n        this._dirty = false;\n    }\n} );\n\n// Operate a Gaussian horizontal blur\nComposer.Filter.HBlur = function ( nbSamplesOpt, linear, unpack, pack ) {\n    Composer.Filter.call( this );\n    this._linear = linear !== false;\n    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );\n    this._unpack = unpack;\n    this._pack = pack;\n    this._fragmentName = 'HBlur' + this._nbSamples;\n};\n\nComposer.Filter.HBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    setBlurSize: function ( nbSamples ) {\n        if ( nbSamples % 2 !== 0 ) {\n            nbSamples += 1;\n        }\n        this._nbSamples = nbSamples;\n        this.dirty();\n    },\n    getUVOffset: function ( value ) {\n        // TODO: could compute that in JS and remove 1 div per kernel step\n        return 'vec2(float(' + value + ')/ RenderSize[0], 0.0) ;';\n    },\n    build: function () {\n        var nbSamples = this._nbSamples;\n\n        // TODO: get rendersize from that and precompute\n        // offset when possible\n        var tex = this._stateSet.getTextureAttribute( 0, 'Texture' );\n        if ( tex && this._linear ) {\n            tex.setMinFilter( 'LINEAR' );\n            tex.setMagFilter( 'LINEAR' );\n        } else {\n            this._linear = false;\n        }\n\n        var vtx = Composer.Filter.defaultVertexShader;\n\n\n        // http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n        // outermost are near 0, so unless float buffer...\n        // at samples = 6 already it's 1/32 = 0.03\n        // so we lessen texFetch (allow higher kernel size with less texfetch)\n        var weightMin = 0.005 / nbSamples;\n        var coeffIdx = nbSamples;\n        var weights = Composer.Filter.Helper.getOrCreatePascalCoefficients( coeffIdx );\n        var start = Math.floor( coeffIdx / 2.0 );\n\n        var kernel = [];\n        kernel.push( ' pixel = float(' + weights[ start ] + ')*unpack(Texture0, vTexCoord0 ).rgb;' );\n\n        kernel.push( ' vec2 offset;' );\n        var idx, i, weight, offset, offsetIdx;\n        if ( !this._linear ) {\n            idx = 1;\n            for ( i = start + 1; i < nbSamples; i++ ) {\n                weight = weights[ i ];\n\n                if ( weight < weightMin ) break;\n\n                offsetIdx = idx++;\n                offset = this.getUVOffset( offsetIdx );\n\n                kernel.push( ' offset = ' + offset );\n                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (vTexCoord0.xy + offset.xy)).rgb;' );\n                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (vTexCoord0.xy - offset.xy)).rgb;' );\n            }\n        } else {\n\n            // using bilinear HW to divide texfetch by 2\n            // http://www.rastergrid.com/blog/wp-content/uploads/2010/09/equation.png\n            idx = 1;\n            for ( i = start + 1; i < nbSamples; i += 2 ) {\n                var weightT1 = weights[ i ];\n                var weightT2 = weights[ i + 1 ];\n\n                weight = weightT1 + weightT2;\n\n                if ( weight < weightMin ) break;\n\n                var offsetT1 = idx;\n                var offsetT2 = idx + 1;\n                idx += 2;\n\n                offsetIdx = ( offsetT1 * weightT1 + offsetT2 * weightT2 ) / weight;\n                offset = this.getUVOffset( offsetIdx );\n\n                kernel.push( ' offset = ' + offset );\n                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (vTexCoord0.xy + offset.xy)).rgb;' );\n                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (vTexCoord0.xy - offset.xy)).rgb;' );\n            }\n        }\n        var fgt = [\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform float width;',\n\n            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',\n            this._pack || 'vec4 pack(vec4 pix) { return pix; }',\n\n            'void main (void)',\n            '{',\n            '  vec3 pixel;',\n            kernel.join( '\\n' ),\n            '  gl_FragColor = pack(vec4(pixel, 1.0));',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {\n            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );\n        }\n        this._stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\n// Operate a Gaussian vertical blur\nComposer.Filter.VBlur = function ( nbSamplesOpt, linear, unpack, pack ) {\n    Composer.Filter.HBlur.call( this, nbSamplesOpt, linear, unpack, pack );\n    this._fragmentName = 'VBlur' + this._nbSamples;\n};\n\nComposer.Filter.VBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.HBlur.prototype, {\n    getUVOffset: function ( value ) {\n        return 'vec2(0.0, float(' + value + ')/RenderSize[1]) ;';\n    }\n} );\n\n// Sobel filter\n// http://en.wikipedia.org/wiki/Sobel_operator\nComposer.Filter.SobelFilter = function () {\n    Composer.Filter.call( this );\n    this._color = Uniform.createFloat3( vec3.fromValues( 1.0, 1.0, 1.0 ), 'color' );\n    this._factor = Uniform.createFloat( 1.0, 'factor' );\n    this._fragmentName = 'SobelFilter';\n};\n\nComposer.Filter.SobelFilter.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    setColor: function ( color ) {\n        this._color.setVec3( color );\n    },\n    setFactor: function ( f ) {\n        this._factor.setFloat( f );\n    },\n    build: function () {\n        var stateSet = this._stateSet;\n        var vtx = Composer.Filter.defaultVertexShader;\n        var fgt = [\n            '',\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform vec3 color;',\n            'uniform float factor;',\n            'void main (void)',\n            '{',\n            '  float fac0 = 2.0;',\n            '  float fac1 = 1.0;',\n            '  float offsetx = 1.0/RenderSize[0];',\n            '  float offsety = 1.0/RenderSize[1];',\n            '  vec4 texel0 = texture2D(Texture0, vTexCoord0 + vec2(offsetx, offsety));',\n            '  vec4 texel1 = texture2D(Texture0, vTexCoord0 + vec2(offsetx, 0.0));',\n            '  vec4 texel2 = texture2D(Texture0, vTexCoord0 + vec2(offsetx, -offsety));',\n            '  vec4 texel3 = texture2D(Texture0, vTexCoord0 + vec2(0.0, -offsety));',\n            '  vec4 texel4 = texture2D(Texture0, vTexCoord0 + vec2(-offsetx, -offsety));',\n            '  vec4 texel5 = texture2D(Texture0, vTexCoord0 + vec2(-offsetx, 0.0));',\n            '  vec4 texel6 = texture2D(Texture0, vTexCoord0 + vec2(-offsetx, offsety));',\n            '  vec4 texel7 = texture2D(Texture0, vTexCoord0 + vec2(0.0, offsety));',\n            '  vec4 rowx = -fac0*texel5 + fac0*texel1 +  -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;',\n            '  vec4 rowy = -fac0*texel3 + fac0*texel7 +  -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;',\n            '  float mag = sqrt(dot(rowy,rowy)+dot(rowx,rowx));',\n            '  if (mag < 1.0/255.0) discard;',\n            '  mag *= factor;',\n            '  mag = min(1.0, mag);',\n            '  gl_FragColor = vec4(color*mag,mag);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        stateSet.setAttributeAndModes( program );\n        stateSet.addUniform( this._color );\n        stateSet.addUniform( this._factor );\n        stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );\n        this._dirty = false;\n    }\n} );\n\nComposer.Filter.BlendMix = function () {\n    Composer.Filter.call( this );\n    var texture0, texture1, mixValue;\n    var unit0 = 0;\n    var unit1 = 1;\n    var stateSet = this._stateSet;\n    if ( arguments.length === 3 ) {\n        texture0 = arguments[ 0 ];\n        texture1 = arguments[ 1 ];\n        mixValue = arguments[ 2 ];\n        unit0 = 1;\n        unit1 = 2;\n        stateSet.setTextureAttributeAndModes( unit0, texture0 );\n    } else if ( arguments.length === 2 ) {\n        texture1 = arguments[ 0 ];\n        mixValue = arguments[ 1 ];\n    } else if ( arguments.length === 1 ) {\n        texture1 = arguments[ 0 ];\n        mixValue = 0.5;\n    }\n    stateSet.setTextureAttributeAndModes( unit1, texture1 );\n    stateSet.addUniform( Uniform.createInt1( unit0, 'Texture0' ) );\n    stateSet.addUniform( Uniform.createInt1( unit1, 'Texture1' ) );\n    this._mixValueUniform = Uniform.createFloat1( mixValue, 'MixValue' );\n    stateSet.addUniform( this._mixValueUniform );\n    this._fragmentName = 'BlendMix';\n};\n\nComposer.Filter.BlendMix.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    getBlendFactorUniform: function () {\n        return this._mixValueUniform;\n    },\n\n    build: function () {\n        var stateSet = this._stateSet;\n        var vtx = Composer.Filter.defaultVertexShader;\n        var fgt = [\n            '',\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform sampler2D Texture1;',\n            'uniform float MixValue;',\n\n            'void main (void)',\n            '{',\n            '  gl_FragColor = mix(texture2D(Texture0,vTexCoord0), texture2D(Texture1,vTexCoord0),MixValue);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\n\nComposer.Filter.BlendMultiply = function () {\n    Composer.Filter.call( this );\n    var stateSet = this._stateSet;\n    var texture0, texture1;\n    var unit0 = 0;\n    var unit1 = 1;\n    if ( arguments.length === 2 ) {\n        texture0 = arguments[ 0 ];\n        texture1 = arguments[ 1 ];\n        unit0 = 1;\n        unit0 = 2;\n        stateSet.setTextureAttributeAndModes( unit0, texture0 );\n    } else if ( arguments.length === 1 ) {\n        texture1 = arguments[ 0 ];\n    }\n    stateSet.setTextureAttributeAndModes( unit1, texture1 );\n    stateSet.addUniform( Uniform.createInt1( unit0, 'Texture0' ) );\n    stateSet.addUniform( Uniform.createInt1( unit1, 'Texture1' ) );\n    this._fragmentName = 'BlendMultiply';\n};\n\nComposer.Filter.BlendMultiply.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n    build: function () {\n        var vtx = Composer.Filter.defaultVertexShader;\n        var fgt = [\n            '',\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform sampler2D Texture1;',\n            'uniform float MixValue;',\n\n            'void main (void)',\n            '{',\n            '  gl_FragColor = texture2D(Texture0,vTexCoord0)*texture2D(Texture1,vTexCoord0);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );\n\n        this._stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\nComposer.Filter.SSAO = function ( options ) {\n    Composer.Filter.call( this );\n\n    var stateSet = this._stateSet;\n    var nbSamples = 16;\n    var radius = 0.05;\n    if ( options !== undefined ) {\n        if ( options.nbSamples !== undefined )\n            nbSamples = options.nbSamples;\n\n        if ( options.radius !== undefined )\n            radius = options.radius;\n        var textureNormal = options.normal;\n        var texturePosition = options.position;\n        var w = textureNormal.getWidth();\n        var h = textureNormal.getHeight();\n        this._size = vec2.fromValues( w, h );\n\n        stateSet.setTextureAttributeAndModes( 0, textureNormal );\n        stateSet.setTextureAttributeAndModes( 1, texturePosition );\n    }\n\n    this._radius = radius;\n    this._nbSamples = nbSamples;\n    this._noiseTextureSize = 16;\n    this._sceneRadius = 2.0;\n\n    stateSet.addUniform( Uniform.createFloat1( 1.0, 'Power' ) );\n    stateSet.addUniform( Uniform.createFloat1( radius, 'Radius' ) );\n    stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );\n    stateSet.addUniform( Uniform.createInt1( 1, 'Texture1' ) );\n    stateSet.addUniform( Uniform.createInt1( 2, 'Texture2' ) );\n    stateSet.addUniform( Uniform.createFloat1( 0.1, 'AngleLimit' ) );\n\n    this.initNoise();\n    this._fragmentName = 'SSAO';\n};\n\nComposer.Filter.SSAO.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {\n\n    initNoise: function () {\n        var sizeNoise = this._noiseTextureSize;\n        var noise = new Array( sizeNoise * sizeNoise * 3 );\n        ( function ( array ) {\n            var n = vec2.fromValues( 0.0, 0.0 );\n            for ( var i = 0; i < sizeNoise * sizeNoise; i++ ) {\n                n[ 0 ] = 2.0 * ( Math.random() - 0.5 );\n                n[ 1 ] = 2.0 * ( Math.random() - 0.5 );\n\n                vec2.normalize( n, n );\n                array[ i * 3 + 0 ] = 255 * ( n[ 0 ] * 0.5 + 0.5 );\n                array[ i * 3 + 1 ] = 255 * ( n[ 1 ] * 0.5 + 0.5 );\n                array[ i * 3 + 2 ] = 255 * 0.5;\n            }\n        } )( noise );\n\n        var noiseTexture = new Texture();\n        noiseTexture.setWrapS( 'REPEAT' );\n        noiseTexture.setWrapT( 'REPEAT' );\n        noiseTexture.setMinFilter( 'NEAREST' );\n        noiseTexture.setMagFilter( 'NEAREST' );\n\n        noiseTexture.setTextureSize( sizeNoise, sizeNoise );\n        noiseTexture.setImage( new Uint8Array( noise ), 'RGB' );\n        this._noiseTexture = noiseTexture;\n    },\n    setSceneRadius: function ( value ) {\n        this._sceneRadius = value;\n        this.dirty();\n    },\n    setAngleLimit: function ( value ) {\n        var uniform = this._stateSet.getUniform( 'AngleLimit' );\n        uniform.setFloat( value );\n    },\n    setNbSamples: function ( value ) {\n        if ( value === this._nbSamples ) {\n            return;\n        }\n        this._nbSamples = Math.floor( value );\n        this.dirty();\n    },\n    setRadius: function ( value ) {\n        var uniform = this._stateSet.getUniform( 'Radius' );\n        uniform.setFloat( value );\n    },\n    setPower: function ( value ) {\n        var uniform = this._stateSet.getUniform( 'Power' );\n        uniform.setFloat( value );\n    },\n    build: function () {\n        var stateSet = this._stateSet;\n        var nbSamples = this._nbSamples;\n        var kernel = new Array( nbSamples * 4 );\n        ( function ( array ) {\n            var v = vec3.create();\n            for ( var i = 0; i < nbSamples; i++ ) {\n                v[ 0 ] = 2.0 * ( Math.random() - 0.5 );\n                v[ 1 ] = 2.0 * ( Math.random() - 0.5 );\n                v[ 2 ] = Math.random();\n\n                vec3.normalize( v, v );\n                var scale = Math.max( i / nbSamples, 0.1 );\n                scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );\n                array[ i * 3 + 0 ] = v[ 0 ];\n                array[ i * 3 + 1 ] = v[ 1 ];\n                array[ i * 3 + 2 ] = v[ 2 ];\n                array[ i * 3 + 3 ] = scale;\n            }\n        } )( kernel );\n\n\n        stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );\n        var uniform = stateSet.getUniform( 'noiseSampling' );\n        if ( uniform === undefined ) {\n            uniform = Uniform.createFloat2( vec2.fromValues( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ), 'noiseSampling' );\n            stateSet.addUniform( uniform );\n        } else {\n            uniform.setVec2( vec2.fromValues( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ) );\n        }\n        var vertexShader = [\n            '',\n            'attribute vec3 Vertex;',\n            'attribute vec2 TexCoord0;',\n            'varying vec2 vTexCoord0;',\n            'uniform mat4 uModelViewMatrix;',\n            'uniform mat4 uProjectionMatrix;',\n            'void main(void) {',\n            '  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex,1.0);',\n            '  vTexCoord0 = TexCoord0;',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var kernelglsl = [];\n        for ( var i = 0; i < nbSamples; i++ ) {\n            kernelglsl.push( 'kernel[' + i + '] = vec4(' + kernel[ i * 3 ] + ',' + kernel[ i * 3 + 1 ] + ', ' + kernel[ i * 3 + 2 ] + ', ' + kernel[ i * 3 + 3 ] + ');' );\n        }\n        kernelglsl = kernelglsl.join( '\\n' );\n\n        //var ssaoRadiusMin = this._sceneRadius * 0.002;\n        //var ssaoRadiusMax = this._sceneRadius * 0.05;\n        //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;\n\n        var fragmentShader = [\n            '',\n            Composer.Filter.defaultFragmentShaderHeader,\n            'uniform sampler2D Texture1;',\n            'uniform sampler2D Texture2;',\n            'uniform mat4 projection;',\n            'uniform vec2 noiseSampling;',\n            'uniform float Power;', //'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',\n            'uniform float Radius;', //'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',\n            'uniform float AngleLimit;',\n            '#define NB_SAMPLES ' + this._nbSamples,\n            'float depth;',\n            'vec3 normal;',\n            'vec4 position;',\n            'vec4 kernel[' + nbSamples + '];',\n\n\n            'mat3 computeBasis()',\n            '{',\n            '  vec2 uvrand = vTexCoord0*noiseSampling;',\n            '  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);',\n            '  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));',\n            '  vec3 bitangent = cross(normal, tangent);',\n            '  mat3 tbn = mat3(tangent, bitangent, normal);',\n            '  return tbn;',\n            '}',\n\n            'void main (void)',\n            '{',\n            kernelglsl,\n            '  position = texture2D(Texture1, vTexCoord0);',\n            '  vec4 p = texture2D(Texture0, vTexCoord0);',\n            '  depth = p.w;',\n            '  normal = vec3(p);',\n            '  if ( position.w == 0.0) {',\n            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',\n            '     return;',\n            '  }',\n            '',\n            ' mat3 tbn = computeBasis();',\n            ' float occlusion = 0.0;',\n            ' for (int i = 0; i < NB_SAMPLES; i++) {',\n            '    vec3 vecKernel = vec3(kernel[i]);',\n            '    vecKernel[2] = max(AngleLimit,vecKernel[2]);',\n            '    vec3 sample = tbn * vecKernel;',\n            '    vec3 dir = sample;',\n            '    float w = dot(dir, normal);',\n            '    float dist = 1.0-kernel[i].w;',\n            '    w *= dist*dist*Power;',\n            '    sample = dir * float(Radius) + position.xyz;',\n\n            '    vec4 offset = projection * vec4(sample,1.0);',\n            '    offset.xy /= offset.w;',\n            '    offset.xy = offset.xy * 0.5 + 0.5;',\n\n            '    float sample_depth = texture2D(Texture1, offset.xy).z;',\n            '    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;',\n            '    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;',\n\n            ' }',\n            ' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));',\n            ' gl_FragColor = vec4(vec3(occlusion),1.0);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vertexShader + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fragmentShader + this.getDefineFragmentName() ) );\n\n        stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\nComposer.Filter.SSAO8 = function ( options ) {\n    Composer.Filter.SSAO.call( this, options );\n    this._fragmentName = 'SSAO8';\n};\n\nComposer.Filter.SSAO8.prototype = MACROUTILS.objectInherit( Composer.Filter.SSAO.prototype, {\n    buildGeometry: function ( quad ) {\n        quad.getAttributes().TexCoord1 = this._texCoord1;\n        return quad;\n    },\n    build: function () {\n        var stateSet = this._stateSet;\n        var nbSamples = this._nbSamples;\n        var kernel = new Array( nbSamples * 4 );\n        //var angleLimit = this._angleLimit;\n        ( function ( array ) {\n            var v = vec3.create();\n            for ( var i = 0; i < nbSamples; i++ ) {\n                v[ 0 ] = 2.0 * ( Math.random() - 0.5 );\n                v[ 1 ] = 2.0 * ( Math.random() - 0.5 );\n                v[ 2 ] = Math.random();\n\n                vec3.normalize( v, v );\n                var scale = Math.max( i / nbSamples, 0.1 );\n                scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );\n                array[ i * 3 + 0 ] = v[ 0 ];\n                array[ i * 3 + 1 ] = v[ 1 ];\n                array[ i * 3 + 2 ] = v[ 2 ];\n                array[ i * 3 + 3 ] = scale;\n            }\n        } )( kernel );\n\n        //var sizeNoise = this._noiseTextureSize;\n        stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );\n        var uniform = stateSet.getUniform( 'noiseSampling' );\n        if ( uniform === undefined ) {\n            uniform = Uniform.createFloat2( vec2.fromValues( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ), 'noiseSampling' );\n            stateSet.addUniform( uniform );\n        } else {\n            uniform.setVec2( vec2.fromValues( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ) );\n        }\n        var vertexShader = [\n            '',\n            'attribute vec3 Vertex;',\n            'attribute vec2 TexCoord0;',\n            'attribute vec3 TexCoord1;',\n            'varying vec2 vTexCoord0;',\n            'varying vec3 vTexCoord1;',\n            'uniform mat4 uModelViewMatrix;',\n            'uniform mat4 uProjectionMatrix;',\n            'void main(void) {',\n            '  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex,1.0);',\n            '  vTexCoord0 = TexCoord0;',\n            '  vTexCoord1 = TexCoord1;',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var kernelglsl = [];\n        for ( var i = 0; i < nbSamples; i++ ) {\n            kernelglsl.push( 'kernel[' + i + '] = vec4(' + kernel[ i * 3 ] + ',' + kernel[ i * 3 + 1 ] + ', ' + kernel[ i * 3 + 2 ] + ', ' + kernel[ i * 3 + 3 ] + ');' );\n        }\n        kernelglsl = kernelglsl.join( '\\n' );\n\n        //var ssaoRadiusMin = this._sceneRadius * 0.002;\n        //var ssaoRadiusMax = this._sceneRadius * 0.05;\n        //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;\n\n        var fragmentShader = [\n            '',\n            Composer.Filter.defaultFragmentShaderHeader,\n            'varying vec3 vTexCoord1;',\n            'uniform sampler2D Texture1;',\n            'uniform sampler2D Texture2;',\n            'uniform mat4 projection;',\n            'uniform vec2 noiseSampling;',\n            'uniform float Power;', //'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',\n            'uniform float Radius;', //'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',\n            'uniform float AngleLimit;',\n            '#define NB_SAMPLES ' + this._nbSamples,\n            'float depth;',\n            'float znear, zfar, zrange;',\n            'vec3 normal;',\n            'vec3 position;',\n            'vec4 kernel[' + nbSamples + '];',\n\n            Composer.Filter.shaderUtils,\n\n            'mat3 computeBasis()',\n            '{',\n            '  vec2 uvrand = vTexCoord0*noiseSampling;',\n            '  //uvrand = rand(gl_FragCoord.xy);',\n            '  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);',\n            '  //vec3 rvec = normalize(vec3(uvrand,0.0));',\n            '  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));',\n            '  vec3 bitangent = cross(normal, tangent);',\n            '  mat3 tbn = mat3(tangent, bitangent, normal);',\n            '  return tbn;',\n            '}',\n\n            'float getDepthValue(vec4 v) {',\n            '  float depth = unpack4x8ToFloat(v);',\n            '  depth = depth*zrange+znear;',\n            '  //depth = depth*zrange;',\n            '  return -depth;',\n            '}',\n\n            'void main (void)',\n            '{',\n            kernelglsl,\n            '  vec4 p = texture2D(Texture0, vTexCoord0);',\n            '  if (dot(p,p) < 0.001) { ',\n            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',\n            '     return;',\n            '  }',\n            '  znear = projection[3][2] / (projection[2][2]-1.0);',\n            '  zfar = projection[3][2] / (projection[2][2]+1.0);',\n            '  zrange = zfar-znear;',\n            '  depth = getDepthValue(texture2D(Texture1, vTexCoord0));',\n            //B = (A - znear)/(zfar-znear);',\n            //B = A/(zfar-znear) - znear/(zfar-znear);',\n            //B+ znear/(zfar-znear) = A/(zfar-znear) ;',\n            //(zfar-znear)*(B+ znear/(zfar-znear)) = A ;',\n            //(zfar-znear)*B+ znear = A ;',\n\n            '  if ( -depth < znear) {',\n            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',\n            '     return;',\n            '  }',\n\n            '  normal = decodeNormal(unpack4x8To2Float(p));',\n\n            '  position = -vTexCoord1*depth;',\n            '  position.z = -position.z;',\n\n            '',\n            ' mat3 tbn = computeBasis();',\n            ' float occlusion = 0.0;',\n            ' for (int i = 0; i < NB_SAMPLES; i++) {',\n            '    vec3 vecKernel = vec3(kernel[i]);',\n            '    vecKernel[2] = max(AngleLimit,vecKernel[2]);',\n            '    vec3 sample = tbn * vec3(vecKernel);',\n            '    vec3 dir = sample;',\n            '    float w = dot(dir, normal);',\n            '    float dist = 1.0-kernel[i].w;',\n            '    w *= dist*dist*Power;',\n            '    sample = dir * float(Radius) + position.xyz;',\n\n            '    vec4 offset = projection * vec4(sample,1.0);',\n            '    offset.xy /= offset.w;',\n            '    offset.xy = offset.xy * 0.5 + 0.5;',\n\n            '    float sample_depth = getDepthValue(texture2D(Texture1, offset.xy));',\n            '    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;',\n            '    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;',\n\n            ' }',\n            ' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));',\n            ' gl_FragColor = vec4(vec3(occlusion),1.0);',\n            '}',\n            ''\n        ].join( '\\n' );\n\n        var program = new Program(\n            new Shader( Shader.VERTEX_SHADER, vertexShader + this.getDefineVertexName() ),\n            new Shader( Shader.FRAGMENT_SHADER, fragmentShader + this.getDefineFragmentName() ) );\n\n        stateSet.setAttributeAndModes( program );\n        this._dirty = false;\n    }\n} );\n\nmodule.exports = Composer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/Composer.js\n// module id = 185\n// module chunks = 0 1 2","'use strict';\nvar Shape = require( 'osg/shape' );\n\n/*\n * Given a Camera, update a wireframe representation of its\n * view frustum from a projection and depthrange\n * @param Geomtry g frustum geometry\n * @param Matrix proj Projection\n * @param Vec2 dR depthRange (optional, only if proj is infinite)\n */\nvar updateFrustum = function ( proj, dR ) {\n\n    var near, far;\n    if ( !dR ) {\n\n        // Get near and far from the Projection matrix.\n        near = proj[ 14 ] / ( proj[ 10 ] - 1.0 );\n        far = proj[ 14 ] / ( 1.0 + proj[ 10 ] );\n\n    } else {\n        near = dR[ 0 ];\n        far = dR[ 1 ];\n    }\n\n    // Get the sides of the near plane.\n    var nLeft = near * ( proj[ 8 ] - 1.0 ) / proj[ 0 ];\n    var nRight = near * ( 1.0 + proj[ 8 ] ) / proj[ 0 ];\n    var nTop = near * ( 1.0 + proj[ 9 ] ) / proj[ 5 ];\n    var nBottom = near * ( proj[ 9 ] - 1.0 ) / proj[ 5 ];\n\n    // Get the sides of the far plane.\n    var fLeft = far * ( proj[ 8 ] - 1.0 ) / proj[ 0 ];\n    var fRight = far * ( 1.0 + proj[ 8 ] ) / proj[ 0 ];\n    var fTop = far * ( 1.0 + proj[ 9 ] ) / proj[ 5 ];\n    var fBottom = far * ( proj[ 9 ] - 1.0 ) / proj[ 5 ];\n\n    var vBuff = this.getAttributes().Vertex;\n    var v = vBuff.getElements();\n\n    // eight corners of the near and far planes.\n    v[ 0 ] = nLeft;\n    v[ 1 ] = nBottom;\n    v[ 2 ] = -near;\n\n    v[ 3 ] = nRight;\n    v[ 4 ] = nBottom;\n    v[ 5 ] = -near;\n\n\n    v[ 6 ] = nRight;\n    v[ 7 ] = nTop;\n    v[ 8 ] = -near;\n\n    v[ 9 ] = nLeft;\n    v[ 10 ] = nTop;\n    v[ 11 ] = -near;\n\n    v[ 12 ] = fLeft;\n    v[ 13 ] = fBottom;\n    v[ 14 ] = -far;\n\n    v[ 15 ] = fRight;\n    v[ 16 ] = fBottom;\n    v[ 17 ] = -far;\n\n    v[ 18 ] = fRight;\n    v[ 19 ] = fTop;\n    v[ 20 ] = -far;\n\n    v[ 21 ] = fLeft;\n    v[ 22 ] = fTop;\n    v[ 23 ] = -far;\n\n    vBuff.dirty();\n\n};\n/*\n * Given a Camera, create a wireframe representation\n *  of its view frustum\n */\nvar createDebugFrustrumGeometry = function () {\n\n    var g = Shape.createBoundingBoxGeometry();\n    g.updateGeometry = updateFrustum;\n    return g;\n\n};\n\nmodule.exports = {\n    createDebugFrustumGeometry: createDebugFrustrumGeometry\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/debug.js\n// module id = 186\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Geometry = require( 'osg/Geometry' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar StateSet = require( 'osg/StateSet' );\nvar Uniform = require( 'osg/Uniform' );\nvar Depth = require( 'osg/Depth' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar ShaderGenerator = require( 'osgShader/ShaderGenerator' );\nvar Compiler = require( 'osgShader/Compiler' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\nvar UpdateMorph = require( 'osgAnimation/UpdateMorph' );\n\n\n////////////////////////\n// COMPILER OFFSET NORMAL\n////////////////////////\nvar CompilerOffsetNormal = function () {\n    Compiler.apply( this, arguments );\n};\n\nCompilerOffsetNormal.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\n    getCompilerName: function () {\n        return 'CompilerOffsetNormal';\n    },\n    initTextureAttributes: function () {},\n    createFragmentShaderGraph: function () {\n        var frag = this.getNode( 'glFragColor' );\n\n        this.getNode( 'SetAlpha' ).inputs( {\n            color: this.getOrCreateUniform( 'vec3', 'uColorDebug' ),\n            alpha: this.createVariable( 'float' ).setValue( '1.0' )\n        } ).outputs( {\n            color: frag\n        } );\n\n        return [ frag ];\n    },\n    getOffsetDirection: function () {\n        return this.getOrCreateModelNormal();\n    },\n    getOrCreateModelVertex: function () {\n        var vertexOffset = this.getVariable( 'vertexOffset' );\n        if ( vertexOffset ) return vertexOffset;\n\n        vertexOffset = this.createVariable( 'vec3', 'vertexOffset' );\n\n        var str = '%out = %offset == 1.0 ? %vertex + normalize(%direction.xyz) * %scale: %vertex;';\n        this.getNode( 'InlineCode' ).code( str ).inputs( {\n            offset: this.getOrCreateAttribute( 'float', 'Offset' ),\n            direction: this.getOffsetDirection(),\n            vertex: Compiler.prototype.getOrCreateModelVertex.call( this ),\n            scale: this.getOrCreateUniform( 'float', 'uScale' )\n        } ).outputs( {\n            out: vertexOffset\n        } );\n\n        return vertexOffset;\n    },\n    getOrCreateViewVertex: function () {\n        var out = this._variables.FragEyeVector;\n        if ( out && !out.isEmpty() ) return out;\n        out = this._varyings.FragEyeVector || this.createVariable( 'vec4', 'FragEyeVector' );\n\n        this.getNode( 'MatrixMultPosition' ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat4', 'uViewMatrix' ),\n            vec: this.getOrCreateModelVertex()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    }\n} );\n\nvar ShaderGeneratorCompilerOffsetNormal = function () {\n    ShaderGenerator.apply( this, arguments );\n    this.setShaderCompiler( CompilerOffsetNormal );\n};\nShaderGeneratorCompilerOffsetNormal.prototype = ShaderGenerator.prototype;\n\n////////////////////////\n// COMPILER OFFSET TANGENT\n////////////////////////\nvar CompilerOffsetTangent = function () {\n    CompilerOffsetNormal.apply( this, arguments );\n};\n\nCompilerOffsetTangent.prototype = MACROUTILS.objectInherit( CompilerOffsetNormal.prototype, {\n    getCompilerName: function () {\n        return 'CompilerOffsetTangent';\n    },\n    getOffsetDirection: function () {\n        return this.getOrCreateModelTangent();\n    }\n} );\n\nvar ShaderGeneratorCompilerOffsetTangent = function () {\n    ShaderGenerator.apply( this, arguments );\n    this.setShaderCompiler( CompilerOffsetTangent );\n};\nShaderGeneratorCompilerOffsetTangent.prototype = ShaderGenerator.prototype;\n\n////////////////////////\n// DISPLAY NORMAL VISITOR\n////////////////////////\n\nvar DisplayNormalVisitor = function () {\n    NodeVisitor.call( this );\n\n    this._unifScale = Uniform.createFloat( 1.0, 'uScale' );\n\n    var ns = this._normalStateSet = new StateSet();\n    ns.addUniform( Uniform.createFloat3( vec3.fromValues( 1.0, 0.0, 0.0 ), 'uColorDebug' ) );\n    ns.addUniform( this._unifScale );\n    ns.setAttributeAndModes( new Depth( Depth.NEVER ) );\n    ns.setShaderGeneratorName( 'debugNormal' );\n\n    var ts = this._tangentStateSet = new StateSet();\n    ts.addUniform( Uniform.createFloat3( vec3.fromValues( 0.0, 1.0, 0.0 ), 'uColorDebug' ) );\n    ts.addUniform( this._unifScale );\n    ts.setAttributeAndModes( new Depth( Depth.NEVER ) );\n    ts.setShaderGeneratorName( 'debugTangent' );\n};\n\nDisplayNormalVisitor.CompilerOffsetNormal = CompilerOffsetNormal;\nDisplayNormalVisitor.CompilerOffsetTangent = CompilerOffsetTangent;\nDisplayNormalVisitor.ShaderGeneratorCompilerOffsetNormal = ShaderGeneratorCompilerOffsetNormal;\nDisplayNormalVisitor.ShaderGeneratorCompilerOffsetTangent = ShaderGeneratorCompilerOffsetTangent;\n\nDisplayNormalVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    setScale: function ( scale ) {\n        this._unifScale.setFloat( scale );\n    },\n    setTangentVisibility: function ( bool ) {\n        this._tangentStateSet.setAttributeAndModes( new Depth( bool ? Depth.LESS : Depth.NEVER ) );\n    },\n    setNormalVisibility: function ( bool ) {\n        this._normalStateSet.setAttributeAndModes( new Depth( bool ? Depth.LESS : Depth.NEVER ) );\n    },\n    apply: function ( node ) {\n        var list = node.getUpdateCallbackList();\n        // dirty the UpdateMorph so that they detect the normal/tangent geometry and update the target/weights correctly\n        for ( var i = 0, nbCB = list.length; i < nbCB; ++i ) {\n            if ( list[ i ] instanceof UpdateMorph ) {\n                list[ i ]._isInitialized = false;\n            }\n        }\n\n        if ( node._isVisitedNormalDebug )\n            return;\n\n        node._isVisitedNormalDebug = true;\n\n        if ( node instanceof Geometry === false )\n            return this.traverse( node );\n\n        this._createDebugGeom( node, 'Normal', this._normalStateSet );\n        this._createDebugGeom( node, 'Tangent', this._tangentStateSet );\n    },\n    _createDoubleOffsetArray: function ( nbVertices ) {\n        // 0 means original vertex pos\n        // 1 means offseted vertex\n        var elts = new Float32Array( nbVertices * 2 );\n        for ( var i = 0; i < nbVertices; ++i ) {\n            elts[ i * 2 ] = 1.0;\n        }\n        return new BufferArray( BufferArray.ARRAY_BUFFER, elts, 1 );\n    },\n    _createDoubledBufferArray: function ( bufferArray ) {\n        // in case of morphs\n        if ( bufferArray.getInitialBufferArray )\n            bufferArray = bufferArray.getInitialBufferArray();\n\n        var itemSize = bufferArray.getItemSize();\n        var elements = bufferArray.getElements();\n        var nbElements = elements.length / itemSize;\n\n        var ctor = elements.constructor;\n        var elementsDouble = new ctor( elements.length * 2 );\n        for ( var i = 0; i < nbElements; ++i ) {\n            var iSize = i * itemSize;\n            var iSize2 = iSize * 2;\n\n            for ( var j = 0; j < itemSize; ++j ) {\n                elementsDouble[ iSize2 + j ] = elementsDouble[ iSize2 + j + itemSize ] = elements[ iSize + j ];\n            }\n        }\n\n        return new BufferArray( BufferArray.ARRAY_BUFFER, elementsDouble, itemSize );\n    },\n    _addMorphTargets: function ( originMorph, morph, vecName ) {\n        var targets = morph.getMorphTargets();\n        morph.setName( originMorph.getName() ); // for the UpdateMorph\n\n        var originTargets = originMorph.getMorphTargets();\n        for ( var i = 0, nbTarget = originTargets.length; i < nbTarget; ++i ) {\n            var origTarget = originTargets[ i ];\n            var origAttrs = origTarget.getVertexAttributeList();\n\n            var newTarget = new Geometry();\n            newTarget.setName( origTarget.getName() ); // for the UpdateMorph\n            var newAttrs = newTarget.getVertexAttributeList();\n\n            newAttrs.Vertex = this._createDoubledBufferArray( origAttrs.Vertex );\n            if ( origAttrs[ vecName ] ) newAttrs[ vecName ] = this._createDoubledBufferArray( origAttrs[ vecName ] );\n\n            targets.push( newTarget );\n        }\n\n        morph.mergeChildrenVertexAttributeList();\n        return morph;\n    },\n    _createDebugGeom: function ( node, vecName, stateSet ) {\n        var attrs = node.getAttributes();\n        var dispVec = attrs[ vecName ];\n        if ( !dispVec )\n            return;\n\n        var vertices = attrs.Vertex;\n        if ( !vertices )\n            return;\n\n        var originMorph;\n        if ( node instanceof MorphGeometry ) originMorph = node;\n        else if ( node.getSourceGeometry && node.getSourceGeometry() instanceof MorphGeometry ) originMorph = node.getSourceGeometry();\n\n        var nbVertices = vertices.getElements().length / vertices.getItemSize();\n\n        // vertex and normals\n        var source = originMorph ? new MorphGeometry() : new Geometry();\n        source.getAttributes().Vertex = this._createDoubledBufferArray( vertices );\n        source.getAttributes().Offset = this._createDoubleOffsetArray( nbVertices );\n        source.getAttributes()[ vecName ] = this._createDoubledBufferArray( dispVec );\n\n        // primitive\n        source.getPrimitives().push( new DrawArrays( PrimitiveSet.LINES, 0, nbVertices * 2 ) );\n\n        if ( originMorph )\n            this._addMorphTargets( originMorph, source, vecName );\n\n        var geom;\n        if ( node instanceof RigGeometry ) {\n\n            var rig = new RigGeometry();\n            rig.setSourceGeometry( source );\n\n            rig.getVertexAttributeList().Bones = this._createDoubledBufferArray( attrs.Bones );\n            rig.getVertexAttributeList().Weights = this._createDoubledBufferArray( attrs.Weights );\n\n            // we can simply share the rig-animated stateSet attributes\n            // (unlike morph, the stateSet and update animation doesn't operate at per vertex level)\n            rig._rigTransformImplementation = node._rigTransformImplementation;\n            rig._stateSetAnimation = node._stateSetAnimation;\n\n            rig.mergeChildrenData();\n            geom = rig;\n\n        } else {\n            geom = source;\n        }\n\n\n        // add geom to the graph\n        var parents = node.getParents();\n        var nbParents = parents.length;\n        geom._isVisitedNormalDebug = true;\n        geom._isNormalDebug = true;\n        geom.setStateSet( stateSet );\n        for ( var i = 0; i < nbParents; ++i )\n            parents[ i ].addChild( geom );\n\n        return geom;\n    }\n} );\n\n\nmodule.exports = DisplayNormalVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DisplayNormalVisitor.js\n// module id = 187\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar Compiler = require( 'osgShader/Compiler' );\nvar ShaderProcessor = require( 'osgShader/ShaderProcessor' );\n\n// this is the list of attributes type we support by default to generate shader\n// if you need to adjust for your need provide or modify this list\n// if you still need more fine tuning to the filter, override the filterAttributeTypes\nvar DefaultsAcceptAttributeTypes = [\n    'ShadowReceive',\n    'Skinning',\n    'Morph',\n    'ShadowTexture',\n    'Texture',\n    'Light',\n    'Material',\n    'Billboard',\n    'PointSize'\n];\n\nvar ShaderGenerator = function () {\n    this._cache = new window.Map();\n\n    // ShaderProcessor singleton used by ShaderGenerator\n    // but user can replace it if needed\n    this._shaderProcessor = new ShaderProcessor();\n    this._acceptAttributeTypes = new window.Set( DefaultsAcceptAttributeTypes );\n\n    // ShaderCompiler Object to instanciate\n    this._ShaderCompiler = Compiler;\n};\n\nShaderGenerator.prototype = {\n\n    // setShaderCompiler that will be used to createShader\n    setShaderCompiler: function ( compiler ) {\n        this._ShaderCompiler = compiler;\n    },\n\n    getShaderCompiler: function () {\n        return this._ShaderCompiler;\n    },\n\n\n    // return a Set of accepted attribtues to generate shader\n    getAcceptAttributeTypes: function () {\n        return this._acceptAttributeTypes;\n    },\n\n\n    getShaderProcessor: function () {\n        return this._shaderProcessor;\n    },\n\n    setShaderProcessor: function ( shaderProcessor ) {\n        this._shaderProcessor = shaderProcessor;\n    },\n\n    // filter input types and write the result in the outputs array\n    filterAttributeTypes: function ( attribute ) {\n\n        // TODO: use same mechanism as acceptAttributesTypes ?\n        // with a default set in a var and use overwrittable Set\n        // when inheriting the class\n        // Faster && Flexiblier\n        if ( attribute.libraryName() !== 'osg' && attribute.libraryName() !== 'osgShadow' && attribute.libraryName() !== 'osgAnimation' )\n            return true;\n\n        var attributeType = attribute.getType();\n\n        // accept only attribute listed in the container\n        if ( !this._acceptAttributeTypes.has( attributeType ) )\n            return true;\n\n        // works for attribute that contains isEnabled\n        // Light, Shadow. It let us to filter them to build a shader if not enabled\n        if ( attribute.isEnabled && !attribute.isEnabled() )\n            return true;\n        // // if it's a light and it's not enable we filter it\n        // if ( attribute.typeID === Light.typeID && !attribute.isEnabled() ) {\n        //     return true;\n        // }\n\n        return false;\n    },\n\n    // get actives attribute that comes from state\n    getActiveAttributeList: function ( state, list ) {\n\n        var hash = '';\n        var attributeMap = state.attributeMap;\n        for ( var keya in attributeMap ) {\n            var attributeStack = attributeMap[ keya ];\n            var attr = attributeStack.lastApplied;\n\n            if ( this.filterAttributeTypes( attr ) )\n                continue;\n\n            if ( attr.getHash ) {\n                hash += attr.getHash();\n            } else {\n                hash += attr.getType();\n            }\n            list.push( attr );\n        }\n        return hash;\n    },\n\n    // get actives texture attribute that comes from state\n    getActiveTextureAttributeList: function ( state, list ) {\n        var hash = '';\n        var attributeMapList = state.textureAttributeMapList;\n        var i, l;\n\n        for ( i = 0, l = attributeMapList.length; i < l; i++ ) {\n            var attributeMapForUnit = attributeMapList[ i ];\n            if ( !attributeMapForUnit ) {\n                continue;\n            }\n            list[ i ] = [];\n\n            for ( var key in attributeMapForUnit ) {\n                var attributeStack = attributeMapForUnit[ key ];\n                if ( attributeStack.values().length === 0 ) {\n                    continue;\n                }\n\n                var attr = attributeStack.lastApplied;\n                if ( this.filterAttributeTypes( attr ) )\n                    continue;\n\n                if ( attr.isTextureNull() )\n                    continue;\n\n                if ( attr.getHash ) {\n                    hash += attr.getHash();\n                } else {\n                    hash += attr.getType();\n                }\n                list[ i ].push( attr );\n            }\n        }\n        return hash;\n    },\n\n    getActiveUniforms: function ( state, attributeList, textureAttributeList ) {\n\n        var uniforms = {};\n\n        for ( var i = 0, l = attributeList.length; i < l; i++ ) {\n\n            var at = attributeList[ i ];\n            if ( at.getOrCreateUniforms ) {\n                var attributeUniformMap = at.getOrCreateUniforms();\n                // It could happen that uniforms are declared conditionally\n                if ( attributeUniformMap !== undefined ) {\n                    for ( var keyAttribute in attributeUniformMap ) {\n                        var uniform = attributeUniformMap[ keyAttribute ];\n                        uniforms[ uniform.getName() ] = uniform;\n                    }\n                }\n            }\n        }\n\n        for ( var a = 0, n = textureAttributeList.length; a < n; a++ ) {\n            var tat = textureAttributeList[ a ];\n            if ( tat ) {\n                for ( var b = 0, o = tat.length; b < o; b++ ) {\n                    var attr = tat[ b ];\n\n                    var texUniformMap = attr.getOrCreateUniforms( a );\n\n                    for ( var tname in texUniformMap ) {\n                        var tuniform = texUniformMap[ tname ];\n                        uniforms[ tuniform.getName() ] = tuniform;\n                    }\n                }\n            }\n        }\n\n        return uniforms;\n    },\n\n    getOrCreateProgram: ( function () {\n        // TODO: double check GC impact of this stack\n        // TODO: find a way to get a hash dirty/cache on stateAttribute\n        var textureAttributes = [];\n        var attributes = [];\n\n        return function ( state ) {\n            // extract valid attributes\n            var hash = '';\n            attributes.length = 0;\n            textureAttributes.length = 0;\n            hash += this.getActiveAttributeList( state, attributes );\n            hash += this.getActiveTextureAttributeList( state, textureAttributes );\n\n            var cache = this._cache.get( hash );\n            if ( cache !== undefined ) {\n                return cache;\n            }\n\n\n            // use ShaderCompiler, it can be overrided by a custom one\n            var ShaderCompiler = this._ShaderCompiler;\n            var shaderGen = new ShaderCompiler( attributes, textureAttributes, this._shaderProcessor );\n\n\n            var fragmentshader = shaderGen.createFragmentShader();\n            var vertexshader = shaderGen.createVertexShader();\n\n            var program = new Program(\n                new Shader( Shader.VERTEX_SHADER, vertexshader ),\n                new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\n\n            program.hash = hash;\n            program.setActiveUniforms( this.getActiveUniforms( state, attributes, textureAttributes ) );\n            program.generated = true;\n\n            this._cache.set( hash, program );\n            return program;\n        };\n    } )()\n};\n\nmodule.exports = ShaderGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/ShaderGenerator.js\n// module id = 188\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\nvar Uniform = require( 'osg/Uniform' );\nvar factory = require( 'osgShader/nodeFactory' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar CompilerVertex = require( 'osgShader/CompilerVertex' );\nvar CompilerFragment = require( 'osgShader/CompilerFragment' );\n\nvar Compiler = function ( attributes, textureAttributes, shaderProcessor ) {\n    this._attributes = attributes;\n    this._textureAttributes = textureAttributes;\n\n    this._fragmentShaderMode = false; // current context\n\n    this._activeNodeList = {};\n    this._compiledNodeList = {};\n    this._traversedNodeList = {};\n\n    this._variables = {};\n    this._varyings = {};\n    this._vertexShader = [];\n    this._fragmentShader = [];\n\n    this._shaderProcessor = shaderProcessor;\n    this._texturesByName = {};\n\n    // TODO: Have to handle better textures\n    // 4 separate loop over texture list: one here, one for declareTexture, 2 for vertexShader (varying decl + varying store)\n    // (not counting loops done above in shader generator)\n\n    this._shadowsTextures = [];\n    this._lights = [];\n    this._shadows = [];\n    this._textures = [];\n    this._material = null;\n\n    this._invariantPosition = false;\n    this._isBillboard = false;\n\n    // Important: if not using Compiler for Both VS and FS Check either of those\n    // it allow override by custom Processor of some check between the VS & FS pass (varying mostly)\n    this._customVertexShader = false;\n    this._customFragmentShader = false;\n\n    // from Attributes to variables to build shader nodes graph from\n    this.initAttributes();\n    this.initTextureAttributes();\n};\n\nCompiler.prototype = MACROUTILS.extend( {}, CompilerVertex, CompilerFragment, {\n\n    createFragmentShader: function () {\n        this._fragmentShaderMode = true;\n        return this._createFragmentShader();\n    },\n\n    createVertexShader: function () {\n        this._fragmentShaderMode = false;\n        return this._createVertexShader();\n    },\n\n    getOrCreateProjectionMatrix: function () {\n        return this.getOrCreateUniform( 'mat4', 'uProjectionMatrix' );\n    },\n\n    getCompilerName: function () {\n        return this._material ? 'CompilerOSGJS' : 'NoMaterialCompilerOSGJS';\n    },\n\n    getFragmentShaderName: function () {\n        var compilerName = this.getCompilerName();\n\n        var materialName = this._material && this._material.getName();\n        if ( materialName ) {\n            // escape everything but letter and number\n            materialName = materialName.replace( /[^a-zA-Z0-9]+/g, '_' ).slice( 0, 20 );\n            compilerName += '(' + materialName + ')';\n        }\n\n        return compilerName;\n    },\n\n    getVertexShaderName: function () {\n        return this.getFragmentShaderName();\n    },\n\n    getDebugIdentifier: function () {\n        var vname = this.getVertexShaderName();\n        var fname = this.getFragmentShaderName();\n        return vname === fname ? fname : vname + '|' + fname;\n    },\n\n    logError: function ( msg ) {\n        Notify.error( this.getDebugIdentifier() + ' : ' + msg );\n    },\n\n    logWarn: function ( msg ) {\n        Notify.warn( this.getDebugIdentifier() + ' : ' + msg );\n    },\n\n    getOrCreateConstantOne: function ( type ) {\n        return this.getOrCreateConstant( type, type + 'White' ).setValue( type + '(1.0)' );\n    },\n\n    getOrCreateConstantZero: function ( type ) {\n        return this.getOrCreateConstant( type, type + 'Black' ).setValue( type + '(0.0)' );\n    },\n\n    initAttributes: function () {\n        var attributes = this._attributes;\n        var lights = this._lights;\n        var shadows = this._shadows;\n        for ( var i = 0, l = attributes.length; i < l; i++ ) {\n\n            var type = attributes[ i ].className();\n\n            // Test one light at a time\n            if ( type === 'Light' ) { // && lights.length === 0) {\n                lights.push( attributes[ i ] );\n            } else if ( type === 'Material' ) {\n                this._material = attributes[ i ];\n            } else if ( type === 'ShadowReceiveAttribute' ) {\n                shadows.push( attributes[ i ] );\n            } else if ( type === 'Billboard' ) {\n                this._isBillboard = !!attributes[ i ];\n            } else if ( type === 'SkinningAttribute' ) {\n                this._skinningAttribute = attributes[ i ];\n            } else if ( type === 'MorphAttribute' ) {\n                this._morphAttribute = attributes[ i ];\n            } else if ( type === 'PointSizeAttribute' ) {\n                this._pointSizeAttribute = attributes[ i ];\n            }\n        }\n    },\n\n    initTextureAttributes: function () {\n\n        var textureAttributes = this._textureAttributes;\n        var texturesNum = textureAttributes.length;\n        this._textures.length = this._shadowsTextures.length = texturesNum;\n\n        for ( var j = 0; j < texturesNum; j++ ) {\n            var tu = textureAttributes[ j ];\n            if ( tu === undefined )\n                continue;\n\n            for ( var t = 0, tl = tu.length; t < tl; t++ ) {\n                this.registerTextureAttributes( tu[ t ], j );\n            }\n        }\n    },\n\n    registerTextureAttributes: function ( tuTarget, tunit ) {\n        var tType = tuTarget.className();\n        if ( tType === 'Texture' ) return this.registerTexture( tuTarget, tunit );\n        if ( tType.indexOf( 'ShadowTexture' ) !== -1 ) return this.registerTextureShadow( tuTarget, tunit );\n    },\n\n    registerTexture: function ( tuTarget, texUnit ) {\n        var tName = tuTarget.getName();\n        if ( !tName ) {\n            tName = 'Texture' + texUnit;\n            tuTarget.setName( tName );\n        }\n        this._textures[ texUnit ] = tuTarget;\n\n        this._texturesByName[ tName ] = {\n            texture: tuTarget,\n            variable: undefined,\n            textureUnit: texUnit\n        };\n    },\n\n    registerTextureShadow: function ( tuTarget, texUnit ) {\n        var tName = tuTarget.getName();\n        if ( !tName ) {\n            tName = 'Texture' + texUnit;\n            tuTarget.setName( tName );\n        }\n        this._shadowsTextures[ texUnit ] = tuTarget;\n\n        this._texturesByName[ tName ] = {\n            texture: tuTarget,\n            variable: undefined,\n            textureUnit: texUnit,\n            shadow: true\n        };\n    },\n\n    getTextureByName: function ( name ) {\n        var texObj = this._texturesByName[ name ];\n        if ( !texObj || texObj.variable )\n            return texObj;\n\n        var texture = texObj.texture;\n        var texCoordUnit = texObj.textureUnit;\n\n        var textureSampler;\n\n        var className = texture.className();\n        var samplerName = 'Texture' + texCoordUnit;\n        if ( className === 'Texture' ) {\n            textureSampler = this.getOrCreateSampler( 'sampler2D', samplerName );\n        } else if ( className === 'TextureCubeMap' ) {\n            textureSampler = this.getOrCreateSampler( 'samplerCube', samplerName );\n        } else {\n            return;\n        }\n\n        var texCoord = this._fragmentShaderMode ? this.getOrCreateVarying( 'vec2', 'vTexCoord' + texCoordUnit ) : this.getOrCreateAttribute( 'vec2', 'TexCoord' + texCoordUnit );\n\n        texObj.variable = this.createTextureRGBA( texture, textureSampler, texCoord );\n\n        return texObj;\n    },\n\n    // The Compiler Main Code called on Vertex or Fragment Shader Graph\n    createShaderFromGraphs: function ( roots ) {\n        this._compiledNodeList = {};\n\n        // list all vars\n        var variables = [];\n        for ( var keyVariable in this._variables ) {\n            var varNode = this._variables[ keyVariable ];\n            var d = varNode.declare();\n            if ( d ) {\n                variables.push( d );\n            }\n        }\n\n        // defines and extensions are added by process shader\n        var extensions = this.evaluateExtensions( roots );\n        var defines = this.evaluateDefines( roots );\n\n        var shaderStack = [];\n        shaderStack.push( '\\n' );\n        shaderStack.push( this.evaluateGlobalVariableDeclaration( roots ) );\n        if ( this._invariantPosition && !this._fragmentShaderMode ) shaderStack.push( '\\ninvariant gl_Position;' );\n        shaderStack.push( '\\n' );\n        shaderStack.push( this.evaluateGlobalFunctionDeclaration( roots ) );\n\n        shaderStack.push( 'void main() {' );\n\n        // declare variables in main\n        if ( variables.length !== 0 ) {\n            shaderStack.push( '// vars\\n' );\n            shaderStack.push( variables.join( ' ' ) );\n            shaderStack.push( '\\n// end vars\\n' );\n        }\n\n        // make sure we have at least one output\n        if ( roots.length === 0 ) {\n            this.logError( 'shader without any final Node output (need at least one)' );\n        }\n\n        shaderStack.push( this.evaluate( roots ) );\n\n        shaderStack.push( '}' );\n\n        // Shader Graph has been outputed an array of string\n        // we concatenate it to a shader string program\n        var shaderStr = shaderStack.join( '\\n' );\n\n        // Process defines, add precision, resolve include pragma\n        var shader = this._shaderProcessor.processShader( shaderStr, defines, extensions, this._fragmentShaderMode ? 'fragment' : 'vertex' );\n\n\n        return shader;\n    },\n\n    getNode: function ( /*name, arg1, etc*/) {\n        var n = factory.getNode.apply( factory, arguments );\n        var cacheID = n.getID();\n        this._activeNodeList[ cacheID ] = n;\n        return n;\n    },\n\n    getVariable: function ( nameID ) {\n        return this._variables[ nameID ];\n    },\n\n    getAttributeType: function ( type ) {\n\n        for ( var i = 0; i < this._attributes.length; i++ ) {\n            if ( this._attributes[ i ].getType() === type )\n                return this._attributes[ i ];\n        }\n        return undefined;\n\n    },\n\n    // TODO: add Precision qualifier\n    // if doesn't exist create a new on\n    // if nameID given and var already exist, create a varname +\n    createVariable: function ( type, varname, deepness ) {\n\n        var nameID = varname;\n\n        if ( nameID === undefined ) {\n\n            var len = window.Object.keys( this._variables ).length;\n            nameID = 'tmp_' + len;\n\n        } else if ( this._variables[ nameID ] ) {\n            // create a new variable\n            // if we want to reuse a variable we should NOT\n            // call this function in the first place and do the\n            // test before...\n            // however for uniform, varying and sampler, we return\n            // the variable if it already exists, because they are\n            // meant to be read only\n            nameID = nameID + deepness;\n            if ( deepness === undefined ) {\n                return this.createVariable( type, varname, 1 );\n            } else if ( this._variables[ nameID ] ) {\n                deepness++;\n                return this.createVariable( type, varname, deepness );\n            }\n\n        }\n\n        var v = this.getNode( 'Variable', type, nameID );\n        this._variables[ nameID ] = v;\n        return v;\n    },\n\n    // Map of uniform from a StateAttribute or TextureStateAttribute\n    getOrCreateUniformFromUniformMap: function ( uniforms, prefix ) {\n        var object = {};\n\n        var prefixUniform = prefix ? prefix : '';\n\n        for ( var keyUniform in uniforms ) {\n            var k = prefixUniform + keyUniform;\n            object[ k ] = this.getOrCreateUniform( uniforms[ keyUniform ] );\n        }\n\n        return object;\n    },\n\n    // specialized for texture, enforcing last parameter usage.\n    getOrCreateTextureStateAttributeUniforms: function ( stateAttribute, prefix, unit ) {\n\n        var uniforms = stateAttribute.getOrCreateUniforms( unit );\n        return this.getOrCreateUniformFromUniformMap( uniforms, prefix );\n    },\n\n    getOrCreateStateAttributeUniforms: function ( stateAttribute, prefix ) {\n\n        var uniforms = stateAttribute.getOrCreateUniforms();\n        return this.getOrCreateUniformFromUniformMap( uniforms, prefix );\n    },\n\n    getOrCreateUniform: function ( type, varname, size ) {\n\n        var nameID = varname;\n\n        // accept uniform as parameter to simplify code\n        if ( type instanceof Uniform ) {\n\n            var uniform = type;\n            type = uniform.getType();\n            nameID = uniform.getName();\n\n        } else if ( nameID === undefined ) {\n            this.logError( 'Cannot create unamed Uniform' );\n        }\n\n        var exist = this._variables[ nameID ];\n        if ( exist ) {\n            if ( exist.getType() === type ) {\n                return exist;\n            }\n\n        }\n\n        var v = this.getNode( 'Uniform', type, nameID, size );\n        this._variables[ nameID ] = v;\n\n        return v;\n    },\n\n    // make sure we get correct Node\n    getOrCreateSampler: function ( type, varname ) {\n\n        if ( varname === undefined ) {\n            this.logError( 'No name given for sampler type : ' + type );\n        }\n\n        var exist = this._variables[ varname ];\n        if ( exist ) {\n            return exist; // see comment in Variable function\n        }\n\n        var v = this.getNode( 'Sampler', type, varname );\n        this._variables[ varname ] = v;\n\n        return v;\n    },\n\n    // make sure we get correct Node\n    getOrCreateAttribute: function ( type, nameID ) {\n\n        if ( this._fragmentShaderMode ) {\n            this.logError( 'No Vertex Attribute in Fragment Shader' );\n        }\n\n        var exist = this._variables[ nameID ];\n        if ( exist ) {\n\n\n            return exist;\n        }\n\n        var v = this.getNode( 'Attribute', type, nameID );\n        this._variables[ nameID ] = v;\n        return v;\n    },\n\n    getOrCreateConstant: function ( type, varname ) {\n        var nameID = varname;\n        if ( nameID === undefined ) {\n            // TODO: temp constant ? or enforcing reuse ?\n            // maybe could parse variable to find other constant\n            // but would need having scope info\n            var len = window.Object.keys( this._variables ).length;\n            nameID = 'tmp_' + len;\n\n        } else {\n\n            var exist = this._variables[ nameID ];\n            if ( exist ) {\n\n\n                // see comment in Variable function\n                return exist;\n            }\n\n        }\n\n        var v = this.getNode( 'Constant', type, nameID );\n        this._variables[ nameID ] = v;\n        return v;\n    },\n\n    // make sure we get correct Node\n    getOrCreateVarying: function ( type, nameID ) {\n\n        if ( nameID === undefined ) {\n            this.logError( 'Error: Mandatory to name varying (as you need to retrieve them)' );\n        }\n\n        var variable = this._variables[ nameID ];\n        if ( variable ) {\n            if ( !this._varyings[ nameID ] ) {\n                this.logError( 'Error: requesting a varying not declared with getOrCreateVarying previously' );\n            }\n\n            if ( variable.getType() !== type ) {\n                this.logError( 'Error: Same varying, but different type' );\n            }\n\n            return variable;\n        }\n\n        // if it's not in Varying Cache, but requested from vertex shader it means => error\n        if ( !this._fragmentShaderMode && !this._customFragmentShader ) {\n            this.logError( 'Error: requesting a varying not declared in Fragment Shader Graph (for Custom Vertex Shader, add this._customFragmentShader to the processor): ' + nameID + ' ' + type );\n        }\n\n        variable = this._variables[ nameID ] = this._varyings[ nameID ] = this.getNode( 'Varying', type, nameID );\n\n        return variable;\n    },\n\n    //////////////////\n    // TRAVERSE STUFFS\n    //////////////////\n\n    markNodeAsVisited: function ( n ) {\n        var cacheID = n.getID();\n        if ( this._activeNodeList[ cacheID ] === n ) {\n            this._compiledNodeList[ cacheID ] = n;\n        } else {\n            this.logWarn( 'Node not requested by using Compiler getNode and/or not registered in nodeFactory ' + n.toString() );\n        }\n    },\n\n    // make sure we traverse once per evaluation of graph\n    checkOrMarkNodeAsTraversed: function ( n ) {\n        var cacheID = n.getID();\n        if ( this._traversedNodeList[ cacheID ] ) {\n            return true;\n        }\n        this._traversedNodeList[ cacheID ] = n;\n        return false;\n    },\n\n    // TODO: add a visitor to debug the graph\n    traverse: function ( functor, node ) {\n\n        if ( this.checkOrMarkNodeAsTraversed( node ) ) return;\n\n        var inputs = node.getInputs();\n        if ( !Array.isArray( inputs ) ) {\n            var objectToArray = [];\n            for ( var keyInput in inputs ) {\n                objectToArray.push( inputs[ keyInput ] );\n            }\n            inputs = objectToArray;\n        }\n\n        for ( var i = 0, l = inputs.length; i < l; i++ ) {\n            node.checkInputsOutputs();\n\n            var child = inputs[ i ];\n\n            if ( child !== undefined &&\n                child !== node ) {\n                this.traverse( functor, child );\n            }\n        }\n        functor.call( functor, node );\n\n        // keep trace we visited\n        this.markNodeAsVisited( node );\n\n    },\n\n    // clean necessary bits before traversing called in each evaluate func belows\n    preTraverse: function ( visitor ) {\n\n        // store traversed list to prevent double traverse\n        this._traversedNodeList = {};\n\n        visitor._map = {};\n        visitor._text = [];\n\n        return visitor;\n    },\n\n    // Gather a particular output field\n    // for now one of\n    // ['define', 'extensions']\n    //\n    // from a nodeGraph\n    //\n    // In case a node of same Type have different outputs (shadow with different defines)\n    // it use ID rather than Type as map index UNIQUE PER TYPE\n    // TODO: adds includes so that we can remove it from the eval Global Functions ?\n    evaluateAndGatherField: function ( nodes, field ) {\n\n        var func = function ( node ) {\n\n            var idx = node.getType();\n            if ( idx === undefined || idx === '' ) {\n                this.logError( 'Your node ' + node + ' has no type' );\n            }\n            if ( node[ field ] && this._map[ idx ] === undefined ) {\n\n                this._map[ idx ] = true;\n                var c = node[ field ]();\n                // push all elements of the array on text array\n                // node[field]()  must return an array\n                Array.prototype.push.apply( this._text, c );\n\n            }\n\n        };\n\n        this.preTraverse( func );\n\n        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {\n            this.traverse( func, nodes[ j ] );\n        }\n\n        return func._text;\n    },\n\n    // Gather a functions declartions of nodesfrom a nodeGraph\n    // (for now pragma include done here too. could be done with define/etc...)\n    // Node of same Type has to share exact same \"node.globalFunctionDeclaration\" output\n    // as it use Type rather than ID as map index\n    evaluateGlobalFunctionDeclaration: function ( nodes ) {\n\n        var func = function ( node ) {\n\n            // UNIQUE PER TYPE\n            var idx = node.getType();\n\n            if ( idx === undefined || idx === '' ) {\n                this.logError( 'Your node ' + node + ' has no type' );\n            }\n            if ( node.globalFunctionDeclaration &&\n                this._map[ idx ] === undefined ) {\n\n                this._map[ idx ] = true;\n                var c = node.globalFunctionDeclaration();\n                if ( c !== undefined ) {\n                    this._text.push( c );\n                }\n\n            }\n\n        };\n\n        this.preTraverse( func );\n\n        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {\n            this.traverse( func, nodes[ j ] );\n        }\n\n        return func._text.join( '\\n' );\n    },\n\n    // Gather a Variables declarations of nodes from a nodeGraph to be outputted\n    // outside the VOID MAIN code ( Uniforms, Varying )\n    // Node of same Type has different output as it use Type rather than ID as map index\n    evaluateGlobalVariableDeclaration: function ( nodes ) {\n\n        var func = function ( node ) {\n\n            // UNIQUE PER NODE\n            var idx = node.getID();\n\n            if ( node.globalDeclaration &&\n                this._map[ idx ] === undefined ) {\n\n                this._map[ idx ] = true;\n                var c = node.globalDeclaration();\n                if ( c !== undefined ) {\n                    this._text.push( c );\n                }\n            }\n        };\n\n\n        this.preTraverse( func );\n\n        var i = 0;\n        var nbNodes = nodes.length;\n        for ( i = 0; i < nbNodes; i++ ) {\n            this.traverse( func, nodes[ i ] );\n        }\n\n        // beautify/formatting with empty line between type of var\n        var declarations = func._text;\n        var len = declarations.length;\n        if ( len > 0 ) {\n            this.sortDeclarations( declarations );\n\n            var type = declarations[ 0 ][ 0 ];\n            for ( i = 0; i < len; ++i ) {\n                var iType = declarations[ i ][ 0 ];\n                if ( iType !== type ) {\n                    type = iType;\n                    declarations[ i - 1 ] += '\\n';\n                }\n            }\n        }\n\n        return declarations.join( '\\n' );\n    },\n\n    sortDeclarations: function ( declarations ) {\n        // sort in alphabetical order attr, unif, sample, varying\n        declarations.sort();\n\n        if ( this._fragmentShaderMode ) return;\n\n        // making sure Vertex is always coming first (because of webgl warning)\n        for ( var i = 0, len = declarations.length; i < len; ++i ) {\n            var vatt = declarations[ i ];\n\n            if ( vatt[ 0 ] !== 'a' ) break;\n\n            if ( vatt.indexOf( 'Vertex' ) !== -1 ) {\n                declarations.splice( i, 1 );\n                declarations.unshift( vatt );\n                break;\n            }\n        }\n    },\n\n    evaluate: function ( nodes ) {\n\n\n        var func = function ( node ) {\n\n            var id = node.getID();\n            if ( this._map[ id ] !== undefined ) {\n                return;\n            }\n\n            var c = node.computeShader();\n            if ( c !== undefined ) {\n\n                if ( node.getComment !== undefined ) {\n\n                    var comment = node.getComment();\n                    if ( comment !== undefined ) {\n                        this._text.push( comment );\n                    }\n\n                }\n\n                this._text.push( c );\n            }\n\n            this._map[ id ] = true;\n        };\n\n        this.preTraverse( func );\n\n        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {\n            this.traverse( func, nodes[ j ] );\n        }\n        return func._text.join( '\\n' );\n    },\n\n    evaluateDefines: function ( roots ) {\n        return this.evaluateAndGatherField( roots, 'getDefines' );\n    },\n\n    evaluateExtensions: function ( roots ) {\n        return this.evaluateAndGatherField( roots, 'getExtensions' );\n    }\n} );\n\n\nmodule.exports = Compiler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/Compiler.js\n// module id = 189\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar skinning = require( 'osgShader/node/skinning' );\nvar data = require( 'osgShader/node/data' );\nvar functions = require( 'osgShader/node/functions' );\nvar lights = require( 'osgShader/node/lights' );\nvar shadows = require( 'osgShader/node/shadows' );\nvar operations = require( 'osgShader/node/operations' );\nvar textures = require( 'osgShader/node/textures' );\nvar morph = require( 'osgShader/node/morph' );\nvar billboard = require( 'osgShader/node/billboard' );\n\nvar Factory = function () {\n\n    this._nodes = new window.Map();\n\n    this.registerNodes( skinning );\n    this.registerNodes( data );\n    this.registerNodes( textures );\n    this.registerNodes( functions );\n    this.registerNodes( lights );\n    this.registerNodes( morph );\n    this.registerNodes( shadows );\n    this.registerNodes( operations );\n    this.registerNodes( billboard );\n};\n\nFactory.prototype = {\n\n    registerNodes: function ( obj ) {\n        for ( var key in obj ) {\n            this.registerNode( key, obj[ key ] );\n        }\n    },\n\n    registerNode: function ( name, constructor ) {\n\n        if ( this._nodes.has( name ) ) {\n            Notify.warn( 'Node ' + name + ' already registered' );\n        }\n        this._nodes.set( name, constructor );\n\n    },\n    // extra argument are passed to the constructor of the node\n    getNode: function ( name ) {\n\n        var Constructor = this._nodes.get( name );\n        if ( !Constructor ) {\n            // Means either:\n            // - the node isn't registered by methods above\n            // - you mistyped the name\n            // - Core Node has changed its Name\n            Notify.warn( 'Node ' + name + ' does not exist' );\n            return undefined;\n        }\n\n        // call a constructor with array arguments\n        // http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2\n        var instance = window.Object.create( Constructor.prototype );\n        Constructor.apply( instance, Array.prototype.slice.call( arguments, 1 ) );\n\n        return instance;\n    }\n\n};\n\nvar instance = new Factory();\n\nmodule.exports = instance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/nodeFactory.js\n// module id = 190\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar ShaderUtils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar Skinning = function () {\n    Node.call( this );\n};\n\nSkinning.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'Skinning',\n    validInputs: [ 'weights', 'bonesIndex', 'matrixPalette' ],\n    validOutputs: [ 'mat4' ],\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"skinning.glsl\"';\n    },\n\n    computeShader: function () {\n        // For now matrixPalette is used as a global (uBones) because an array means a dynamic function signature in the glsl...\n        return ShaderUtils.callFunction( 'skeletalTransform', this._outputs.mat4, [ this._inputs.weights, this._inputs.bonesIndex ] );\n    }\n} );\n\nmodule.exports = {\n    Skinning: Skinning\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/skinning.js\n// module id = 191\n// module chunks = 0 1 2","'use strict';\n\nvar sprintf = function ( string, args ) {\n    if ( !string || !args ) {\n        return '';\n    }\n\n    var arg;\n\n    for ( var index in args ) {\n        arg = args[ index ];\n\n        if ( arg === undefined )\n            continue;\n\n        if ( arg.getVariable ) {\n            arg = arg.getVariable();\n        }\n        string = string.replace( '%s', arg );\n    }\n    return string;\n};\n\n\nvar checkVariableType = function ( vars, optionalPrefix ) {\n\n    var inputs = vars;\n    var varsList = [];\n    var prefix = optionalPrefix;\n    if ( optionalPrefix === undefined ) {\n        prefix = '';\n    }\n\n    for ( var i = 0, l = inputs.length; i < l; i++ ) {\n\n        var variable = inputs[ i ];\n        var output;\n\n        if ( variable === undefined ) {\n            output = 'undefined';\n        } else if ( typeof variable === 'string' ) {\n            output = variable;\n        } else if ( variable.getType ) {\n            output = variable.getType() + ' ' + variable.getVariable();\n        } else {\n            output = variable.getVariable();\n        }\n\n        varsList.push( prefix + output );\n    }\n\n    return varsList;\n\n};\n\n\n// call glsl function\n// generate a string with output = funcName ( inputs )\n// useful when debuging to print inputs / outputs\n// TODO check type of arguments with regexp in glsl\n// shader function regex\n// [\\r\\n]\\s[(vec4)|(vec3)|(vec2)|(float)|(bool)|(int)].*\\(.*[.|\\r\\n]*\\).*[\\r\\n]*{\n// doesn't handle multiline\n// then split(',')\n// then substring (out,in)\n// then type matching\n// (works by hand here.)\n// for instance, gather types from input and compare themt to glsl decl\n// var inputTypes = [\n//             'vec4',\n//             'vec4',\n//             'sampler2D',\n//             'vec4',\n//             'vec4',\n//             'vec3',\n//             'float',\n//             'vec3',\n//             'float',\n//             'float',\n//             'float',\n//             'float',\n//             'float'\n//         ];\n//         console.assert( inputs.length === inputTypes.length );\n//         var i = inputs.length;\n//         while ( i-- ) {\n//             console.assert( inputs[ i ]._type === inputTypes[ i ], inputs[ i ]._prefix );\n//         }\nvar callFunction = function ( funcName, output, inputs ) {\n\n    var osgShader = require( 'osgShader/osgShader' );\n\n    var debug = [];\n    var callString = '';\n\n    // debug\n    if ( osgShader.debugShaderNode ) {\n        debug.push( '\\n// output' );\n        Array.prototype.push.apply( debug, checkVariableType( [ output ], '// ' ) );\n    }\n\n    if ( output ) {\n        if ( output.getVariable )\n            output = output.getVariable();\n        callString = output + ' = ';\n    }\n\n    callString = callString + funcName + '( ';\n\n    if ( inputs && inputs.length > 0 ) {\n\n        // debug\n        if ( osgShader.debugShaderNode ) {\n            debug.push( '// inputs' );\n            Array.prototype.push.apply( debug, checkVariableType( inputs, '// ' ) );\n        }\n\n        for ( var i = 0, l = inputs.length; i < l; i++ ) {\n\n            // check if it's a variable and not a constant\n            if ( inputs[ i ].getVariable )\n                callString += inputs[ i ].getVariable();\n            else\n                callString += inputs[ i ];\n\n            if ( i !== l - 1 )\n                callString += ', ';\n        }\n    }\n\n    callString += ' );\\n';\n\n    if ( osgShader.debugShaderNode )\n        return debug.join( '\\n' ) + '\\n' + callString;\n\n    return callString;\n};\n\n\nmodule.exports = {\n    callFunction: callFunction,\n    checkVariableType: checkVariableType,\n    sprintf: sprintf\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/utils.js\n// module id = 192\n// module chunks = 0 1 2","'use strict';\nvar Compiler = require( 'osgShader/Compiler' );\nvar ShaderGenerator = require( 'osgShader/ShaderGenerator' );\nvar ShaderGeneratorProxy = require( 'osgShader/ShaderGeneratorProxy' );\nvar ShaderProcessor = require( 'osgShader/ShaderProcessor' );\nvar nodeFactory = require( 'osgShader/nodeFactory' );\nvar node = require( 'osgShader/node' );\nvar utils = require( 'osgShader/utils' );\n\n\nvar lib = {};\n\nlib.Compiler = Compiler;\nlib.ShaderGenerator = ShaderGenerator;\nlib.ShaderGeneratorProxy = ShaderGeneratorProxy;\nlib.ShaderProcessor = ShaderProcessor;\nlib.nodeFactory = nodeFactory;\nlib.node = node;\n\nlib.utils = utils;\n\n\n// debug utility: set it to one to have verbose in shaders\nlib.debugShaderNode = false;\n\nmodule.exports = lib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/osgShader.js\n// module id = 193\n// module chunks = 0 1 2","'use strict';\nvar ShaderGenerator = require( 'osgShader/ShaderGenerator' );\nvar ShadowCastShaderGenerator = require( 'osgShadow/ShadowCastShaderGenerator' );\nvar DisplayNormalVisitor = require( 'osgUtil/DisplayNormalVisitor' );\nvar DisplayGeometryVisitor = require( 'osgUtil/DisplayGeometryVisitor' );\n\nvar ShaderGeneratorProxy = function () {\n\n    // object of shader generators\n    this._generators = new window.Map();\n    this.addShaderGenerator( 'default', new ShaderGenerator() );\n    this.addShaderGenerator( 'ShadowCast', new ShadowCastShaderGenerator() );\n    this.addShaderGenerator( 'debugNormal', new DisplayNormalVisitor.ShaderGeneratorCompilerOffsetNormal() );\n    this.addShaderGenerator( 'debugTangent', new DisplayNormalVisitor.ShaderGeneratorCompilerOffsetTangent() );\n    this.addShaderGenerator( 'debugGeometry', new DisplayGeometryVisitor.ShaderGeneratorCompilerColorGeometry() );\n    this.addShaderGenerator( 'debugSkinning', new DisplayGeometryVisitor.ShaderGeneratorCompilerColorSkinning() );\n\n    return this;\n};\n\nShaderGeneratorProxy.prototype = {\n\n    getShaderGenerator: function ( name ) {\n\n        if ( !name )\n            return this._generators.get( 'default' );\n\n        return this._generators.get( name );\n    },\n\n    // user-space facility to provide its own\n    addShaderGenerator: function ( name, sg ) {\n\n        this._generators.set( name, sg );\n\n    }\n\n};\n\nmodule.exports = ShaderGeneratorProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/ShaderGeneratorProxy.js\n// module id = 194\n// module chunks = 0 1 2","'use strict';\nvar ShaderGenerator = require( 'osgShader/ShaderGenerator' );\nvar ShadowCompiler = require( 'osgShadow/ShadowCastCompiler' );\n\nvar ShaderGeneratorShadowCast = function () {\n\n    ShaderGenerator.apply( this, arguments );\n    this.setShaderCompiler( ShadowCompiler );\n    // only one attribute makes change to the compilation\n    // ignore all others\n    this._acceptAttributeTypes = new window.Set( [ 'ShadowCast', 'Skinning', 'Morph', 'PointSize' ] );\n\n};\n\nShaderGeneratorShadowCast.prototype = ShaderGenerator.prototype;\n\nmodule.exports = ShaderGeneratorShadowCast;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowCastShaderGenerator.js\n// module id = 195\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Compiler = require( 'osgShader/Compiler' );\n\n\nvar CompilerShadowCast = function () {\n    Compiler.apply( this, arguments );\n};\n\nCompilerShadowCast.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\n    getCompilerName: function () {\n        return 'ShadowCast';\n    },\n\n    initAttributes: function () {\n        var attributes = this._attributes;\n\n        for ( var i = 0, l = attributes.length; i < l; i++ ) {\n\n            var type = attributes[ i ].className();\n\n            if ( type === 'ShadowCastAttribute' ) {\n                this._shadowCastAttribute = attributes[ i ];\n            } else if ( type === 'Billboard' ) {\n                this._isBillboard = !!attributes[ i ];\n            } else if ( type === 'SkinningAttribute' ) {\n                this._skinningAttribute = attributes[ i ];\n            } else if ( type === 'MorphAttribute' ) {\n                this._morphAttribute = attributes[ i ];\n            } else if ( type === 'PointSizeAttribute' ) {\n                this._pointSizeAttribute = attributes[ i ];\n            }\n        }\n    },\n\n    registerTextureAttributes: function () {},\n\n    // Depth Shadow Map Casted from Light POV Depth encoded in color buffer\n    createShadowCastDepth: function ( out ) {\n\n        this.getNode( 'ShadowCast' ).setShadowCastAttribute( this._shadowCastAttribute ).inputs( {\n\n            shadowDepthRange: this.getOrCreateUniform( 'vec4', 'uShadowDepthRange' ),\n            fragEye: this.getOrCreateVarying( 'vec4', 'vViewVertex' )\n\n        } ).outputs( {\n\n            color: out\n\n        } );\n\n        return out;\n    },\n\n    // encapsulate for easier overwrite by user defined compiler\n    // that would inherint from this compiler Do not merge with above method\n    createFragmentShaderGraph: function () {\n        var frag = this.getNode( 'glFragColor' );\n        return [ this.createShadowCastDepth( frag ) ];\n    }\n\n} );\n\nmodule.exports = CompilerShadowCast;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowCastCompiler.js\n// module id = 196\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Geometry = require( 'osg/Geometry' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar Uniform = require( 'osg/Uniform' );\nvar StateSet = require( 'osg/StateSet' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar ShaderGenerator = require( 'osgShader/ShaderGenerator' );\nvar Compiler = require( 'osgShader/Compiler' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Depth = require( 'osg/Depth' );\n\n\n////////////////////////\n// COMPILER DEBUG GEOMETRY\n////////////////////////\nvar CompilerColorGeometry = function () {\n    Compiler.apply( this, arguments );\n};\n\nCompilerColorGeometry.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\n    getCompilerName: function () {\n        return 'CompilerDebugGeometry';\n    },\n    initTextureAttributes: function () {},\n    createFragmentShaderGraph: function () {\n        var frag = this.getNode( 'glFragColor' );\n\n        this.getNode( 'SetAlpha' ).inputs( {\n            color: this.getOrCreateUniform( 'vec3', 'uColorDebug' ),\n            alpha: this.createVariable( 'float' ).setValue( '1.0' )\n        } ).outputs( {\n            color: frag\n        } );\n\n        return [ frag ];\n    }\n} );\n\nvar ShaderGeneratorCompilerColorGeometry = function () {\n    ShaderGenerator.apply( this, arguments );\n    this.setShaderCompiler( CompilerColorGeometry );\n};\nShaderGeneratorCompilerColorGeometry.prototype = ShaderGenerator.prototype;\n\n\n////////////////////////\n// COMPILER SKINNING DEBUG\n////////////////////////\nvar CompilerColorSkinning = function () {\n    Compiler.apply( this, arguments );\n};\n\nCompilerColorSkinning.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\n    getCompilerName: function () {\n        return 'CompilerDebugSkinning';\n    },\n    initTextureAttributes: function () {},\n    createFragmentShaderGraph: function () {\n        var frag = this.getNode( 'glFragColor' );\n\n        this.getNode( 'SetAlpha' ).inputs( {\n            color: this.getOrCreateVarying( 'vec3', 'vBonesColor' ),\n            alpha: this.createVariable( 'float' ).setValue( '1.0' )\n        } ).outputs( {\n            color: frag\n        } );\n\n        return [ frag ];\n    },\n    declareVertexVaryings: function ( roots ) {\n        var color = this.getOrCreateVarying( 'vec3', 'vBonesColor' );\n        this.getNode( 'SetFromNode' ).inputs( this.getOrCreateAttribute( 'vec3', 'BonesColor' ) ).outputs( color );\n        return Compiler.prototype.declareVertexVaryings.call( this, roots );\n    }\n} );\n\nvar ShaderGeneratorCompilerColorSkinning = function () {\n    ShaderGenerator.apply( this, arguments );\n    this.setShaderCompiler( CompilerColorSkinning );\n};\nShaderGeneratorCompilerColorSkinning.prototype = ShaderGenerator.prototype;\n\n///////////////////////////\n// DISPLAY GEOMETRY VISITOR\n///////////////////////////\n\nvar GeometryColorDebugVisitor = function () {\n    NodeVisitor.call( this );\n    this._debugColor = true;\n    this._debugSkinning = false;\n\n    this._stCenter = new StateSet(); // state set of center crosses\n    this._stCenter.setShaderGeneratorName( 'debugGeometry' );\n};\n\nGeometryColorDebugVisitor.CompilerColorGeometry = CompilerColorGeometry;\nGeometryColorDebugVisitor.ShaderGeneratorCompilerColorGeometry = ShaderGeneratorCompilerColorGeometry;\n\nGeometryColorDebugVisitor.CompilerSkinningGeometry = CompilerColorSkinning;\nGeometryColorDebugVisitor.ShaderGeneratorCompilerColorSkinning = ShaderGeneratorCompilerColorSkinning;\n\nGeometryColorDebugVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    setGeometryDebug: function ( node ) {\n        this._stCenter.setAttributeAndModes( new Depth( Depth.ALWAYS ) );\n        this._debugColor = true;\n        this._debugSkinning = false;\n        this.apply( node );\n    },\n    setSkinningDebug: function ( node ) {\n        this._stCenter.setAttributeAndModes( new Depth( Depth.NEVER ) );\n        this._debugColor = false;\n        this._debugSkinning = true;\n        this.apply( node );\n    },\n    disableDebug: function ( node ) {\n        this._stCenter.setAttributeAndModes( new Depth( Depth.NEVER ) );\n        this._debugColor = false;\n        this._debugSkinning = false;\n        this.apply( node );\n    },\n    apply: function ( node ) {\n        if ( node._isNormalDebug || node._isCenterDebug )\n            return;\n\n        if ( node instanceof Geometry ) {\n\n            if ( this._debugColor || ( this._debugSkinning && node instanceof RigGeometry ) ) {\n\n                if ( node._originalStateSet === undefined )\n                    node._originalStateSet = node.getStateSet() || null;\n\n                var st = new StateSet();\n                node.setStateSet( st );\n\n                if ( this._debugSkinning ) {\n                    st.setShaderGeneratorName( 'debugSkinning' );\n\n                    // a bone can be shared between several rigs so we use the instanceID to get unique color\n                    var vList = node.getVertexAttributeList();\n                    if ( !vList.BonesColor ) {\n                        var eltBones = vList.Bones.getElements();\n                        var eltWeights = vList.Weights.getElements();\n\n                        var bones = node._rigTransformImplementation._bones;\n                        var nbBones = eltBones.length / 4;\n\n                        var bonesColor = new Float32Array( nbBones * 3 );\n\n                        for ( var i = 0; i < nbBones; ++i ) {\n                            var idb = i * 4;\n                            var c0 = bones[ eltBones[ idb ] ].getOrCreateDebugColor();\n                            var c1 = bones[ eltBones[ idb + 1 ] ].getOrCreateDebugColor();\n                            var c2 = bones[ eltBones[ idb + 2 ] ].getOrCreateDebugColor();\n                            var c3 = bones[ eltBones[ idb + 3 ] ].getOrCreateDebugColor();\n\n                            var w0 = eltWeights[ idb ];\n                            var w1 = eltWeights[ idb + 1 ];\n                            var w2 = eltWeights[ idb + 2 ];\n                            var w3 = eltWeights[ idb + 3 ];\n\n                            var idc = i * 3;\n                            bonesColor[ idc ] = w0 * c0[ 0 ] + w1 * c1[ 0 ] + w2 * c2[ 0 ] + w3 * c3[ 0 ];\n                            bonesColor[ idc + 1 ] = w0 * c0[ 1 ] + w1 * c1[ 1 ] + w2 * c2[ 1 ] + w3 * c3[ 1 ];\n                            bonesColor[ idc + 2 ] = w0 * c0[ 2 ] + w1 * c1[ 2 ] + w2 * c2[ 2 ] + w3 * c3[ 2 ];\n                        }\n\n                        vList.BonesColor = new BufferArray( BufferArray.ARRAY_BUFFER, bonesColor, 3 );\n                    }\n\n                } else {\n\n                    var color = vec3.fromValues( Math.random(), Math.random(), Math.random() );\n                    st.addUniform( Uniform.createFloat3( color, 'uColorDebug' ) );\n                    st.setShaderGeneratorName( 'debugGeometry' );\n\n                    // draw crosses\n                    var bb = node.getBound();\n\n                    var verts = new Float32Array( 18 );\n                    var off = bb.radius() * 0.1;\n                    verts[ 0 ] = off;\n                    verts[ 3 ] = -off;\n\n                    verts[ 7 ] = off;\n                    verts[ 10 ] = -off;\n\n                    verts[ 14 ] = off;\n                    verts[ 17 ] = -off;\n\n                    var geo = new Geometry();\n                    geo.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, verts, 3 );\n                    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 6 );\n                    geo.getPrimitives().push( primitive );\n\n                    var mt = new MatrixTransform();\n                    var center = bb.center();\n                    mt.getMatrix()[ 12 ] = center[ 0 ];\n                    mt.getMatrix()[ 13 ] = center[ 1 ];\n                    mt.getMatrix()[ 14 ] = center[ 2 ];\n\n                    mt.addChild( geo );\n                    this.nodePath[ this.nodePath.length - 2 ].addChild( mt );\n                    color = vec3.fromValues( color[ 0 ] * 0.8, color[ 1 ] * 0.8, color[ 2 ] * 0.8 );\n                    geo.getOrCreateStateSet().addUniform( Uniform.createFloat3( color, 'uColorDebug' ) );\n                    mt.setStateSet( this._stCenter );\n\n                    mt._isCenterDebug = true;\n                }\n\n            } else if ( node._originalStateSet !== undefined ) {\n                node.setStateSet( node._originalStateSet || undefined );\n            }\n\n        }\n\n        this.traverse( node );\n    }\n} );\n\nmodule.exports = GeometryColorDebugVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DisplayGeometryVisitor.js\n// module id = 197\n// module chunks = 0 1 2","'use strict';\n\nvar subnamespace = [\n    require( 'osgShader/node/skinning' ),\n    require( 'osgShader/node/morph' ),\n    require( 'osgShader/node/data' ),\n    require( 'osgShader/node/textures' ),\n    require( 'osgShader/node/functions' ),\n    require( 'osgShader/node/lights' ),\n    require( 'osgShader/node/operations' )\n];\n\nvar lib = {};\n\n// add all sub component to root level of the lib\nsubnamespace.forEach( function ( component /*, index */ ) {\n\n    for ( var key in component ) {\n        var element = component[ key ];\n\n        if ( this[ key ] !== undefined ) { // if exist throw exception\n            throw 'duplicate entry in node library';\n        }\n\n        this[ key ] = element;\n    }\n\n}, lib );\n\nmodule.exports = lib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node.js\n// module id = 198\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar ShaderUtils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar Morph = function () {\n    Node.call( this );\n};\n\nvar getVec3 = function ( vec ) {\n    return vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;\n};\n\nMorph.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'Morph',\n    validInputs: [ 'weights', 'vertex', 'target0', /*'target1','target2','target3'*/ ],\n    validOutputs: [ 'out' ],\n\n    globalFunctionDeclaration: function () {\n\n        //vec3 morphTransform( const in vec4 weights,  const in vec3 vertex, const in vec3 target0, const in vec3 target1, const in vec3 target2 ) {\n        //  return vertex * (1.0 - ( + weights[0] + weights[1] + weights[2])) + target0 * weights[0] + target1 * weights[1] + target2 * weights[2];\n        //}\n        var nbTargets = window.Object.keys( this._inputs ).length - 2;\n        var i = 0;\n\n        // TODO: this should be rewrote with sprintf\n        ////// Signature\n        var str = 'vec3 morphTransform( const in vec4 weights,  const in vec3 vertex, const in vec3 target0';\n        for ( i = 1; i < nbTargets; ++i )\n            str += ', const in vec3 target' + i;\n        str += ' ) { \\n';\n\n        ////// Morphing\n        if ( nbTargets === 1 ) {\n\n            str += 'return mix(vertex, target0, weights[0])';\n\n        } else {\n\n            str += '\\tvec3 vecOut = vertex * (1.0 - ( weights[0]';\n            for ( i = 1; i < nbTargets; ++i )\n                str += ' + weights[' + i + ']';\n            str += '));\\n';\n\n            for ( i = 0; i < nbTargets; ++i )\n                str += '\\tvecOut += target' + i + ' * weights[' + i + '];\\n';\n\n            str += '\\treturn vecOut';\n        }\n\n        str += ';\\n}\\n';\n        return str;\n    },\n\n    computeShader: function () {\n\n        var inps = this._inputs;\n        var inputs = [ inps.weights, getVec3( inps.vertex ) ];\n\n        for ( var i = 0; i < 4; i++ ) {\n\n            if ( !inps[ 'target' + i ] ) break;\n            inputs.push( getVec3( inps[ 'target' + i ] ) );\n\n        }\n\n        return ShaderUtils.callFunction( 'morphTransform', this._outputs.out, inputs );\n\n    }\n} );\n\nmodule.exports = {\n    Morph: Morph\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/morph.js\n// module id = 199\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\n\nvar instance = 0;\nvar Node = function () {\n    this._name = 'AbstractNode';\n    this._inputs = [];\n    this._outputs = null;\n\n    // category of node\n    // same name implies same\n    // define/function\n    //this.type = '';\n\n    // uuid: unicity\n    // allows multipe node of same type\n    // declaring multipe code paths\n    // inside the main\n    this._id = instance++;\n\n    this._text = undefined;\n};\n\nNode.prototype = {\n\n    getID: function () {\n        return this._id;\n    },\n    getName: function () {\n        return this._name;\n    },\n\n    getType: function () {\n        return this.type;\n    },\n\n    toString: function () {\n        var str = 'name : ' + this._name;\n        if ( this.type ) str += ' (' + this.type + ')';\n        return str;\n    },\n\n    getInputs: function () {\n        return this._inputs;\n    },\n\n    getOutputs: function () {\n        return this._outputs;\n    },\n\n    checkInputsOutputs: function () {\n\n        var i, key;\n        if ( this.validInputs ) {\n\n            for ( i = 0; i < this.validInputs.length; i++ ) {\n                key = this.validInputs[ i ];\n                if ( !this._inputs[ key ] ) {\n                    Notify.error( 'Shader node ' + this.type + ' validation error input ' + key + ' is missing' );\n                    return false;\n                }\n            }\n        }\n\n        if ( this.validOutputs ) {\n\n            for ( i = 0; i < this.validOutputs.length; i++ ) {\n                key = this.validOutputs[ i ];\n                if ( !this._outputs[ key ] ) {\n                    Notify.error( 'Shader node ' + this.type + ' validation error output ' + key + ' is missing' );\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    },\n\n    // accepts inputs like that:\n    // inputs( [ a, b, c , d] )\n    // inputs( { a: x, b: y } )\n    // inputs( a, b, c, d )\n    inputs: function () {\n        // handle inputs ( a, b, c, d)\n        for ( var i = 0, l = arguments.length; i < l; i++ ) {\n\n            var input = arguments[ i ];\n            if ( !input ) {\n                Notify.error( 'Shader node ' + this.type + ' input number ' + l + ' is undefined ' );\n                break;\n            }\n\n            // handle inputs( [a, b, c ,d] )\n            if ( Array.isArray( input ) ) {\n\n                this.inputs.apply( this, input );\n                return this;\n\n                // check for an object {} and not something from base class Node\n            } else if ( typeof input === 'object' && input !== null && ( input instanceof Node === false ) ) {\n                this._inputs = input;\n                return this;\n\n            } else { // add argument to the array\n                this._inputs.push( input );\n            }\n        }\n\n        return this;\n    },\n\n    // accepts inputs like that:\n    // outputs( { a: x, b: y } )\n    // outputs( a )\n    outputs: function ( outputs ) {\n\n        this._outputs = outputs;\n\n        // single output\n        if ( this._outputs instanceof Node === true ) {\n\n            this.autoLink( this._outputs );\n\n        } else {\n\n            // iterate on objects keys\n            for ( var key in this._outputs ) {\n                this.autoLink( this._outputs[ key ] );\n            }\n        }\n\n        return this;\n    },\n\n    autoLink: function ( output ) {\n\n        if ( output === undefined )\n            return this;\n\n        output.inputs( this );\n\n        return this;\n    },\n\n    computeShader: function () {\n        return this._text;\n    },\n\n    comment: function ( txt ) {\n        this._comment = '//' + txt;\n    },\n\n    getComment: function () {\n        return this._comment;\n    }\n};\n\n\nmodule.exports = Node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/Node.js\n// module id = 200\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar utils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar sprintf = utils.sprintf;\n\n// Base Class for all variables Nodes\n// TODO: add precision\n// type {string} vec3/4/2, float, int, etc.\n// prefix {string} vec3/4/2, float, int, etc.\nvar Variable = function ( type, prefix ) {\n    Node.call( this );\n    this._name = 'Variable';\n    this._prefix = prefix;\n    this._type = type;\n    this._value = undefined;\n};\n\nVariable.prototype = MACROUTILS.objectInherit( Node.prototype, {\n\n    getType: function () {\n        return this._type;\n    },\n\n    getVariable: function () {\n        return this._prefix;\n    },\n\n    setValue: function ( value ) {\n        this._value = value;\n        return this;\n    },\n\n    toString: function () {\n        var str = 'prefix : ' + this._prefix;\n        str += ', name : ' + this._prefix;\n        if ( this.type ) str += ' (' + this.type + ')';\n        return str;\n    },\n\n    declare: function () {\n        if ( this._value !== undefined ) {\n            return sprintf( '%s %s = %s;', [ this._type, this.getVariable(), this._value ] );\n        } else {\n            return sprintf( '%s %s;', [ this._type, this.getVariable() ] );\n        }\n    },\n\n    isEmpty: function () {\n        return this._value === undefined && this._inputs.length === 0;\n    },\n\n    reset: function () {\n        this._inputs = [];\n        this._outputs = null;\n        this._value = undefined;\n        this._text = undefined;\n    }\n} );\n\n// Constant Variable\n// help glsl compiler and make sure no one writes in it :)\nvar Constant = function ( type, prefix ) {\n    Variable.call( this, type, prefix );\n};\nConstant.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n\n    declare: function () {\n        return sprintf( 'const %s %s = %s;', [ this._type, this.getVariable(), this._value ] );\n    }\n} );\n\nvar Uniform = function ( type, prefix, size ) {\n    Variable.call( this, type, prefix );\n    this._size = size;\n};\n\nUniform.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n    declare: function () {\n        return undefined;\n    },\n\n    globalDeclaration: function () {\n        if ( this._size ) {\n            return sprintf( 'uniform %s %s[%s];', [ this._type, this.getVariable(), this._size ] );\n        } else {\n            return sprintf( 'uniform %s %s;', [ this._type, this.getVariable() ] );\n        }\n    }\n\n} );\n\n// Vertex Attribute Variables\nvar Attribute = function ( type, prefix ) {\n    Variable.call( this, type, prefix );\n};\n\nAttribute.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n    declare: function () {\n        return undefined;\n    },\n\n    globalDeclaration: function () {\n        return sprintf( 'attribute %s %s;', [ this._type, this.getVariable() ] );\n    }\n\n} );\n\n\nvar Varying = function ( type, prefix ) {\n    Variable.call( this, type, prefix );\n};\n\nVarying.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n    declare: function () {\n        return undefined;\n    },\n\n    globalDeclaration: function () {\n        return sprintf( 'varying %s %s;', [ this._type, this.getVariable() ] );\n    }\n} );\n\nvar Sampler = function ( type, prefix ) {\n    Variable.call( this, type, prefix );\n};\n\nSampler.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n    declare: function () {\n        return undefined;\n    },\n\n    globalDeclaration: function () {\n        return sprintf( 'uniform %s %s;', [ this._type, this.getVariable() ] );\n    }\n\n} );\n\n// Graph Root Node Abstract Class\n// Derive from that for new outputs\n// gl_FragDepth, etc.\nvar Output = function ( type, wholeName ) {\n    Variable.call( this, type, wholeName );\n};\n\nOutput.prototype = MACROUTILS.objectInherit( Variable.prototype, {\n    _unique: true,\n    isUnique: function () {\n        return this._unique;\n    },\n    outputs: function () { /* do nothing for variable */\n        return this;\n    },\n    getVariable: function () {\n        return this._prefix;\n    }\n} );\n\n// Graph Root Nodes\nvar glFragColor = function () {\n    Output.call( this, 'vec4', 'gl_FragColor' );\n    this._name = 'glFragColor';\n};\nglFragColor.prototype = MACROUTILS.objectInherit( Output.prototype, {} );\n\nvar glPosition = function () {\n    Output.call( this, 'vec4', 'gl_Position' );\n    this._name = 'glPosition';\n};\nglPosition.prototype = MACROUTILS.objectInherit( Output.prototype, {} );\n\n\nvar glPointSize = function () {\n    Output.call( this, 'float', 'gl_PointSize' );\n    this._name = 'glPointSize';\n};\nglPointSize.prototype = MACROUTILS.objectInherit( Output.prototype, {} );\n\nmodule.exports = {\n    Output: Output,\n    glPointSize: glPointSize,\n    glPosition: glPosition,\n    glFragColor: glFragColor,\n    Sampler: Sampler,\n    Variable: Variable,\n    Constant: Constant,\n    Attribute: Attribute,\n    Varying: Varying,\n    Uniform: Uniform\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/data.js\n// module id = 201\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar utils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar NodeTextures = function () {\n    Node.call( this );\n};\n\nNodeTextures.prototype = MACROUTILS.objectInherit( Node.prototype, {\n\n    type: 'TextureAbstractNode',\n\n    // functionName is here to simplify all texture base functions\n    // it's possible later it will have to move into another class\n    // if base class needs to be more generic. But right now it simplify\n    // all simple class to fetch texture ( seed above )\n    functionName: 'noTextureFunction',\n\n    validInputs: [ 'sampler', 'uv' ],\n    validOutputs: [ 'color' ],\n\n    computeShader: function () {\n\n        return utils.callFunction( this.functionName,\n            this._outputs.color, [\n                this._inputs.sampler,\n                this._inputs.uv.getVariable() + '.xy'\n            ] );\n    },\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"textures.glsl\"';\n    }\n\n} );\n\n\n\nvar TextureRGB = function () {\n    NodeTextures.call( this );\n};\n\nTextureRGB.prototype = MACROUTILS.objectInherit( NodeTextures.prototype, {\n\n    type: 'TextureRGB',\n    functionName: 'textureRGB'\n\n} );\n\n\n\nvar TextureRGBA = function () {\n    TextureRGB.call( this );\n};\n\nTextureRGBA.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\n\n    type: 'TextureRGBA',\n    functionName: 'textureRGBA'\n\n} );\n\n\nvar TextureAlpha = function () {\n    TextureRGB.call( this );\n};\n\nTextureAlpha.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\n\n    type: 'TextureAlpha',\n    functionName: 'textureAlpha'\n\n} );\n\n\n\nvar TextureIntensity = function () {\n    TextureRGB.call( this );\n};\n\nTextureIntensity.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\n\n    type: 'TextureIntensity',\n    functionName: 'textureIntensity'\n\n} );\n\nmodule.exports = {\n    NodeTextures: NodeTextures,\n    TextureRGB: TextureRGB,\n    TextureRGBA: TextureRGBA,\n    TextureAlpha: TextureAlpha,\n    TextureIntensity: TextureIntensity\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/textures.js\n// module id = 202\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar utils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar sprintf = utils.sprintf;\n\n// base to avoid redundant global declarations\n// it's to keep node more readable\nvar NodeFunctions = function () {\n    Node.call( this );\n};\n\nNodeFunctions.prototype = MACROUTILS.objectInherit( Node.prototype, {\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"functions.glsl\"';\n    }\n\n} );\n\n\nvar Normalize = function () {\n    NodeFunctions.call( this );\n};\nNormalize.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {\n    type: 'Normalize',\n    validInputs: [ 'vec' ],\n    validOuputs: [ 'vec' ],\n    computeShader: function () {\n        return utils.callFunction( 'normalize', this._outputs.vec, [ this._inputs.vec ] );\n    }\n} );\n\n\nvar sRGBToLinear = function () {\n    NodeFunctions.call( this );\n};\n\nsRGBToLinear.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {\n\n    type: 'sRGBToLinear',\n\n    validInputs: [ 'color' ],\n    validOuputs: [ 'color' ],\n\n    computeShader: function () {\n        return this.computeConversion( 'sRGBToLinear' );\n    },\n    computeConversion: function ( funcName ) {\n        var out = this._outputs.color;\n        var color = this._inputs.color;\n        var rgb = out.getType() !== color.getType() ? '.rgb' : '';\n\n        return utils.callFunction( funcName, out.getVariable() + rgb, [ color.getVariable() + rgb ] );\n    }\n\n} );\n\nvar LinearTosRGB = function () {\n    sRGBToLinear.call( this );\n};\n\nLinearTosRGB.prototype = MACROUTILS.objectInherit( sRGBToLinear.prototype, {\n    type: 'LinearTosRGB',\n    computeShader: function () {\n        return this.computeConversion( 'linearTosRGB' );\n    }\n} );\n\nvar FrontNormal = function () {\n    NodeFunctions.call( this );\n};\n\n// https://twitter.com/pyalot/status/711956736639418369\n// https://github.com/mrdoob/three.js/issues/10331\nFrontNormal.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {\n\n    type: 'FrontNormal',\n    validInputs: [ 'normal' ],\n    validOuputs: [ 'normal' ],\n\n    computeShader: function () {\n        return sprintf( '%s = gl_FrontFacing ? %s : -%s ;', [\n            this._outputs.normal.getVariable(),\n            this._inputs.normal.getVariable(),\n            this._inputs.normal.getVariable()\n        ] );\n    }\n} );\n\nvar getVec3 = function ( vec ) {\n    return vec.getType && vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;\n};\nvar EncodeRGBM = function () {\n    NodeFunctions.call( this );\n};\nEncodeRGBM.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {\n    type: 'EncodeRGBM',\n    validInputs: [ 'color', 'range' ],\n    validOutputs: [ 'color' ],\n    computeShader: function () {\n        return utils.callFunction( 'encodeRGBM', this._outputs.color, [ getVec3( this._inputs.color ), this._inputs.range ] );\n    }\n} );\n\nvar DecodeRGBM = function () {\n    NodeFunctions.call( this );\n};\nDecodeRGBM.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {\n    type: 'DecodeRGBM',\n    validInputs: [ 'color', 'range' ],\n    validOutputs: [ 'color' ],\n    computeShader: function () {\n        return utils.callFunction( 'decodeRGBM', this._outputs.color, [ this._inputs.color, this._inputs.range ] );\n    }\n} );\n\nvar Define = function ( name ) {\n    Node.call( this );\n    this._defineName = name;\n    this._defineValue = '';\n};\nDefine.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'Define',\n    setValue: function ( value ) {\n        this._defineValue = value;\n        return this;\n    },\n    getDefines: function () {\n        return [ '#define ' + this._defineName + ' ' + this._defineValue ];\n    }\n} );\n\nmodule.exports = {\n    NodeFunctions: NodeFunctions,\n    Normalize: Normalize,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    FrontNormal: FrontNormal,\n    DecodeRGBM: DecodeRGBM,\n    EncodeRGBM: EncodeRGBM,\n    Define: Define\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/functions.js\n// module id = 203\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar shaderUtils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\n// base class for all point based light: Point/Directional/Spot/Hemi\n// avoid duplicate code\nvar NodeLights = function () {\n    Node.call( this );\n};\n\nNodeLights.prototype = MACROUTILS.objectInherit( Node.prototype, {\n\n    validOutputs: [ 'color' ],\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"lights.glsl\"';\n    }\n\n} );\n\nvar getVec3 = function ( vec ) {\n    return vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;\n};\n\nvar PointLight = function () {\n    NodeLights.call( this );\n};\n\nPointLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {\n\n    type: 'PointLight',\n\n    validInputs: [\n        'normal',\n        'eyeVector',\n        'materialambient',\n        'materialdiffuse',\n        'materialspecular',\n        'materialshininess',\n\n        'lightambient',\n        'lightdiffuse',\n        'lightspecular',\n\n        'lightposition',\n        'lightattenuation',\n\n        'lightmatrix',\n\n        'lighted',\n        'lightEyePos',\n        'lightEyeDir'\n\n    ],\n\n    computeShader: function () {\n\n        return shaderUtils.callFunction(\n            'computePointLightShading',\n            this._outputs.color, [ this._inputs.normal,\n                this._inputs.eyeVector,\n\n                getVec3( this._inputs.materialambient ),\n                getVec3( this._inputs.materialdiffuse ),\n                getVec3( this._inputs.materialspecular ),\n                this._inputs.materialshininess,\n\n                getVec3( this._inputs.lightambient ),\n                getVec3( this._inputs.lightdiffuse ),\n                getVec3( this._inputs.lightspecular ),\n\n                this._inputs.lightposition,\n                this._inputs.lightattenuation,\n\n                this._inputs.lightmatrix,\n\n                this._inputs.lightEyePos,\n                this._inputs.lightEyeDir,\n                this._inputs.lighted\n            ] );\n    }\n\n} );\n\n\n\nvar SpotLight = function () {\n    NodeLights.call( this );\n};\n\nSpotLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {\n\n    type: 'SpotLight',\n\n    validInputs: [\n        'normal',\n        'eyeVector',\n\n        'materialambient',\n        'materialdiffuse',\n        'materialspecular',\n        'materialshininess',\n\n        'lightambient',\n        'lightdiffuse',\n        'lightspecular',\n\n        'lightdirection',\n        'lightattenuation',\n        'lightposition',\n        'lightspotCutOff',\n        'lightspotBlend',\n\n        'lightmatrix',\n        'lightinvMatrix',\n\n        'lighted',\n        'lightEyePos',\n        'lightEyeDir'\n\n    ],\n\n    computeShader: function () {\n\n        return shaderUtils.callFunction(\n            'computeSpotLightShading',\n            this._outputs.color, [ this._inputs.normal,\n                this._inputs.eyeVector,\n\n                getVec3( this._inputs.materialambient ),\n                getVec3( this._inputs.materialdiffuse ),\n                getVec3( this._inputs.materialspecular ),\n                this._inputs.materialshininess,\n\n                getVec3( this._inputs.lightambient ),\n                getVec3( this._inputs.lightdiffuse ),\n                getVec3( this._inputs.lightspecular ),\n\n                this._inputs.lightdirection,\n                this._inputs.lightattenuation,\n                this._inputs.lightposition,\n                this._inputs.lightspotCutOff,\n                this._inputs.lightspotBlend,\n\n                this._inputs.lightmatrix,\n                this._inputs.lightinvMatrix,\n\n                this._inputs.lightEyePos,\n                this._inputs.lightEyeDir,\n                this._inputs.lighted\n            ] );\n    }\n\n} );\n\n\nvar SunLight = function () {\n    NodeLights.call( this );\n};\n\nSunLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {\n\n    type: 'SunLight',\n\n    validInputs: [\n        'normal',\n        'eyeVector',\n        'materialambient',\n        'materialdiffuse',\n        'materialspecular',\n        'materialshininess',\n\n        'lightambient',\n        'lightdiffuse',\n        'lightspecular',\n\n        'lightposition',\n\n        'lightmatrix',\n\n        'lighted',\n        'lightEyeDir'\n\n    ],\n\n    computeShader: function () {\n\n        return shaderUtils.callFunction(\n            'computeSunLightShading',\n            this._outputs.color, [ this._inputs.normal,\n                this._inputs.eyeVector,\n\n                getVec3( this._inputs.materialambient ),\n                getVec3( this._inputs.materialdiffuse ),\n                getVec3( this._inputs.materialspecular ),\n                this._inputs.materialshininess,\n\n                getVec3( this._inputs.lightambient ),\n                getVec3( this._inputs.lightdiffuse ),\n                getVec3( this._inputs.lightspecular ),\n\n                this._inputs.lightposition,\n\n                this._inputs.lightmatrix,\n\n                this._inputs.lightEyeDir,\n                this._inputs.lighted\n            ] );\n    }\n} );\n\nvar HemiLight = function () {\n    NodeLights.call( this );\n};\n\nHemiLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {\n\n    type: 'HemiLight',\n\n    validInputs: [\n        'normal',\n        'eyeVector',\n        'materialdiffuse',\n        'materialspecular',\n        'materialshininess',\n\n        'lightdiffuse',\n        'lightground',\n\n        'lightposition',\n\n        'lightmatrix',\n\n        'lighted',\n        'lightEyeDir'\n    ],\n\n    computeShader: function () {\n\n        return shaderUtils.callFunction(\n            'computeHemiLightShading',\n            this._outputs.color, [ this._inputs.normal,\n                this._inputs.eyeVector,\n\n                getVec3( this._inputs.materialdiffuse ),\n                getVec3( this._inputs.materialspecular ),\n                this._inputs.materialshininess,\n\n                getVec3( this._inputs.lightdiffuse ),\n                getVec3( this._inputs.lightground ),\n\n                this._inputs.lightposition,\n\n                this._inputs.lightmatrix,\n\n                this._inputs.lightEyeDir,\n                this._inputs.lighted\n            ] );\n    }\n} );\n\nmodule.exports = {\n    PointLight: PointLight,\n    SpotLight: SpotLight,\n    SunLight: SunLight,\n    HemiLight: HemiLight\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/lights.js\n// module id = 204\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Node = require( 'osgShader/node/Node' );\nvar utils = require( 'osgShader/utils' );\n\nvar sprintf = utils.sprintf;\n\n// Abstract class\n// base operator contains helper for the constructor\n// it helps to do that:\n// arg0 = output\n// arg1 = input0 or [ inputs ]\n// arg2 = input1\n// ...\nvar BaseOperator = function () {\n    Node.call( this );\n};\n\nBaseOperator.prototype = Node.prototype;\n\n\n// Add support this syntax:\n// new Add( output, input0, input1, ... )\n// new Add( output, [ inputs ] )\n// glsl code output = input0 + input1 +...\nvar Add = function () {\n    BaseOperator.call( this );\n};\n\nAdd.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {\n\n    type: 'Add',\n\n    operator: '+',\n\n    computeShader: function () {\n        // force inputs type to be all the same from the output\n        var outputType = this._outputs.getType();\n        var addType = '';\n\n        if ( outputType === 'vec4' )\n            addType = '.rgba';\n        else if ( outputType === 'vec3' )\n            addType = '.rgb';\n        else if ( outputType === 'vec2' )\n            addType = '.rg';\n\n\n        var str = this._outputs.getVariable() + ' = ' + this._inputs[ 0 ].getVariable() + addType;\n        for ( var i = 1, l = this._inputs.length; i < l; i++ ) {\n            var input = this._inputs[ i ];\n            str += this.operator + input.getVariable();\n            // special var case that doesn't need any postfix\n            if ( input.getType() !== 'float' )\n                str += addType;\n        }\n        str += ';';\n        return str;\n    }\n} );\n\n\n\n// Mult works like Add\n// glsl code output = input0 * input1 * ...\nvar Mult = function () {\n    Add.call( this );\n};\n\nMult.prototype = MACROUTILS.objectInherit( Add.prototype, {\n    type: 'Mult',\n    operator: '*'\n} );\n\n// basic assignement alias: output = input\n// glsl code output = input0\nvar SetFromNode = function () {\n    Add.call( this );\n};\nSetFromNode.prototype = MACROUTILS.objectInherit( Add.prototype, {\n    type: 'SetFromNode'\n} );\n\n// Mult Matrix * vector4\n// making the cast vector4(input.xyz, 0)\n// if needed\n// glsl code output = matrix * vector4(vec.xyz, 0)\nvar MatrixMultDirection = function () {\n    Add.call( this );\n    this._overwriteW = true; // if set to false, we copy the input alpha in the output alpha\n    this._forceComplement = true;\n    this._inverseOp = false;\n};\n\nMatrixMultDirection.prototype = MACROUTILS.objectInherit( Add.prototype, {\n    type: 'MatrixMultDirection',\n    operator: '*',\n    validInputs: [ 'vec', 'matrix' ],\n    validOutputs: [ 'vec' ],\n    complement: '0.',\n    setInverse: function ( bool ) {\n        this._inverseOp = bool;\n        return this;\n    },\n    setForceComplement: function ( bool ) {\n        this._forceComplement = bool;\n        return this;\n    },\n    setOverwriteW: function ( bool ) {\n        this._overwriteW = bool;\n        return this;\n    },\n    computeShader: function () {\n        // force inputs type to be all the same from the output\n        // and handle vector complement\n        var vecIn = this._inputs.vec.getVariable();\n        var matrix = this._inputs.matrix.getVariable();\n        var vecOut = this._outputs.vec.getVariable();\n\n        var inputType = this._inputs.vec.getType();\n        var outputType = this._outputs.vec.getType();\n        var matrixType = this._inputs.matrix.getType();\n\n        var strOut = vecOut;\n\n        if ( matrixType === 'mat4' ) {\n            strOut += ' = ';\n\n            if ( outputType !== 'vec4' )\n                strOut += outputType + '(';\n\n            var strCasted = vecIn;\n            if ( this._forceComplement || inputType !== 'vec4' )\n                strCasted = 'vec4(' + vecIn + '.xyz, ' + this.complement + ')';\n\n            strOut += this._inverseOp ? strCasted + this.operator + matrix : matrix + this.operator + strCasted;\n\n            if ( outputType !== 'vec4' )\n                strOut += ')';\n\n            strOut += ';';\n\n            if ( !this._overwriteW && inputType === 'vec4' )\n                strOut += '\\n' + vecOut + '.a = ' + vecIn + '.a;';\n\n        } else {\n            if ( outputType === 'vec4' ) strOut += '.xyz';\n            strOut += ' = ';\n\n            var strvec3 = vecIn + '.xyz';\n            strOut += ( this._inverseOp ? strvec3 + this.operator + matrix : matrix + this.operator + strvec3 ) + ';';\n\n            if ( !this._overwriteW && outputType === 'vec4' && inputType === 'vec4' )\n                strOut += '\\n' + vecOut + '.a = ' + vecIn + '.a;';\n        }\n\n        return strOut;\n    }\n} );\n\n// override only for complement.\n// glsl code output = matrix * vector4(vec.xyz, 1)\nvar MatrixMultPosition = function () {\n    MatrixMultDirection.call( this );\n    this._forceComplement = false;\n};\nMatrixMultPosition.prototype = MACROUTILS.objectInherit( MatrixMultDirection.prototype, {\n    type: 'MatrixMultPosition',\n    complement: '1.'\n} );\n\n// For all you custom needs.\n//\n// call Code() with variable input/output replace\n// indexed by the '%'\n// getNode( 'InlineCode' ).code( '%out = %input;' ).inputs( {\n//             input: this.getOrCreateConstant( 'float', 'unitFloat' ).setValue( '1.0' )\n//        } ).outputs( {\n//            out: this.getNode( 'glPointSize' )\n// }\n//\nvar InlineCode = function () {\n    Node.call( this );\n};\n\nInlineCode.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'InlineCode',\n    code: function ( txt ) {\n        this._text = txt;\n        return this;\n    },\n    computeShader: function () {\n\n        // merge inputs and outputs dict to search in both\n        var replaceVariables = MACROUTILS.objectMix( {}, this._inputs );\n        replaceVariables = MACROUTILS.objectMix( replaceVariables, this._outputs );\n\n        // find all %string\n        var r = new RegExp( '%[A-Za-z0-9_]+', 'gm' );\n        var text = this._text;\n        var result = this._text.match( r );\n\n        var done = new Set(); // keep trace of replaced string\n\n        for ( var i = 0; i < result.length; i++ ) {\n\n            var str = result[ i ].substr( 1 );\n            if ( !done.has( str ) ) {\n                if ( !replaceVariables[ str ] ) {\n                    Notify.error( 'error with inline code\\n' + this._text );\n                    Notify.error( 'input ' + str + ' not provided for ' + result[ i ] );\n                }\n                var reg = new RegExp( result[ i ].toString(), 'gm' );\n                text = text.replace( reg, replaceVariables[ str ].getVariable() );\n                done.add( str );\n            }\n        }\n\n        return text;\n    }\n} );\n\n\n// glsl code  output = vec4( color.rgb, alpha )\nvar SetAlpha = function () {\n    BaseOperator.call( this );\n};\n\nSetAlpha.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {\n    type: 'SetAlpha',\n    validInputs: [ 'color', 'alpha' ],\n    validOuputs: [ 'color' ],\n    computeShader: function () {\n        var alpha = this._inputs.alpha;\n        return sprintf( '%s = vec4( %s.rgb, %s );', [\n            this._outputs.color.getVariable(),\n            this._inputs.color.getVariable(),\n            alpha.getType() !== 'float' ? alpha.getVariable() + '.a' : alpha.getVariable()\n        ] );\n    }\n} );\n\n\n\n// alpha is optional, if not provided the following operation is generated:\n// glsl code output.rgb = color.rgb * color.a;\nvar PreMultAlpha = function () {\n    BaseOperator.call( this );\n};\n\n// TODO put the code in glsl\nPreMultAlpha.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {\n\n    type: 'PreMultAlpha',\n    validInputs: [ 'color' /*,'alpha'*/ ],\n    validOuputs: [ 'color' ],\n\n    computeShader: function () {\n        var variable = this._inputs.alpha !== undefined ? this._inputs.alpha : this._inputs.color;\n\n        var srcAlpha;\n        if ( variable.getType() !== 'float' )\n            srcAlpha = variable.getVariable() + '.a';\n        else\n            srcAlpha = variable.getVariable();\n\n        return sprintf( '%s.rgb = %s.rgb * %s;', [\n            this._outputs.color.getVariable(),\n            this._inputs.color.getVariable(),\n            srcAlpha\n        ] );\n    }\n} );\n\nmodule.exports = {\n    BaseOperator: BaseOperator,\n    Mult: Mult,\n    MatrixMultPosition: MatrixMultPosition,\n    MatrixMultDirection: MatrixMultDirection,\n    Add: Add,\n    InlineCode: InlineCode,\n    SetAlpha: SetAlpha,\n    SetFromNode: SetFromNode,\n    PreMultAlpha: PreMultAlpha\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/operations.js\n// module id = 205\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar ShaderUtils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar ShadowReceive = function () {\n    Node.call( this );\n\n};\n\nShadowReceive.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'ShadowReceiveNode',\n\n    validInputs: [ 'lighted',\n        'shadowTexture',\n        //'shadowTextureMapSize',\n        //'shadowTextureRenderSize',\n        'shadowTextureProjectionMatrix',\n        'shadowTextureViewMatrix',\n        'shadowTextureDepthRange',\n        'vertexWorld',\n        'shadowbias',\n    ],\n    validOutputs: [ 'float' ],\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"shadowsReceive.glsl\"';\n    },\n\n    setShadowAttribute: function ( shadowAttr ) {\n        this._shadow = shadowAttr;\n    },\n\n    // must return an array of defines\n    // because it will be passed to the ShaderGenerator\n    getDefines: function () {\n        return this._shadow.getDefines();\n    },\n    getExtensions: function () {\n        return this._shadow.getExtensions();\n    },\n    computeShader: function () {\n\n        var inp = this._inputs;\n\n        // common inputs\n        var inputs = [\n            inp.lighted,\n            inp.shadowTexture\n        ];\n\n        if ( this._shadow.getAtlas() ) {\n            inputs.push( inp.shadowTextureMapSize );\n        }\n\n        inputs = inputs.concat( [\n            inp.shadowTextureRenderSize,\n            inp.shadowTextureProjectionMatrix,\n            inp.shadowTextureViewMatrix,\n            inp.shadowTextureDepthRange,\n            inp.normalWorld,\n            inp.vertexWorld,\n            inp.shadowbias\n        ] );\n\n        if ( this._shadow.getNormalBias() ) {\n            inputs.push( inp.shadownormalBias );\n        }\n\n        return ShaderUtils.callFunction( 'computeShadow', this._outputs.float, inputs );\n    }\n\n} );\n\nvar ShadowCast = function () {\n    Node.call( this );\n\n};\n\nShadowCast.prototype = MACROUTILS.objectInherit( Node.prototype, {\n\n    type: 'ShadowCast',\n    validInputs: [ 'shadowDepthRange', 'fragEye' ],\n    validOutputs: [ 'color' ],\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"shadowsCastFrag.glsl\"';\n    },\n\n    setShadowCastAttribute: function ( shadowAttr ) {\n        this._shadowCast = shadowAttr;\n        return this;\n    },\n\n    // must return an array of defines\n    // because it will be passed to the ShaderGenerator\n    getDefines: function () {\n        return this._shadowCast.getDefines();\n    },\n\n    computeShader: function () {\n        var inp = this._inputs;\n        return ShaderUtils.callFunction( 'computeShadowDepth', this._outputs.color, [ inp.fragEye, inp.shadowDepthRange ] );\n    }\n\n} );\n\nmodule.exports = {\n    ShadowCast: ShadowCast,\n    ShadowReceive: ShadowReceive\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/shadows.js\n// module id = 206\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar ShaderUtils = require( 'osgShader/utils' );\nvar Node = require( 'osgShader/node/Node' );\n\nvar Billboard = function () {\n    Node.apply( this );\n};\n\nBillboard.prototype = MACROUTILS.objectInherit( Node.prototype, {\n    type: 'Billboard',\n    validInputs: [ 'Vertex', 'ModelViewMatrix', 'ProjectionMatrix' ],\n    validOutputs: [ 'vec' ],\n\n    globalFunctionDeclaration: function () {\n        return '#pragma include \"billboard.glsl\"';\n    },\n    computeShader: function () {\n        return ShaderUtils.callFunction( 'billboard', this._outputs.vec, [ this._inputs.Vertex, this._inputs.ModelViewMatrix, this._inputs.ProjectionMatrix ] );\n    }\n} );\n\nmodule.exports = {\n    Billboard: Billboard\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/node/billboard.js\n// module id = 207\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\n\nvar CompilerVertex = {\n\n    _createVertexShader: function () {\n        // Call to specialised inhenrited shader Compiler\n        var roots = this.declareVertexMain();\n        var vname = this.getVertexShaderName();\n        if ( vname ) roots.push( this.getNode( 'Define', 'SHADER_NAME' ).setValue( vname ) );\n\n        // call the graph compiler itself\n        var shader = this.createShaderFromGraphs( roots );\n\n        Notify.debug( this.getDebugIdentifier() );\n        Notify.debug( shader );\n\n        return shader;\n    },\n\n    declareVertexMain: function () {\n\n        // Because of a weird bug on iOS, glPosition should be computed in the vertex shader before some varyings\n        var roots = [ this.declarePointSize(), this.declareVertexPosition() ];\n\n        this.declareVertexVaryings( roots );\n\n        return roots;\n    },\n\n    declarePointSize: function () {\n        var glPointSize = this.getNode( 'glPointSize' );\n\n        if ( !this._pointSizeAttribute || !this._pointSizeAttribute.isEnabled() ) {\n            this.getNode( 'SetFromNode' ).inputs( this.getOrCreateConstantOne( 'float' ) ).outputs( glPointSize );\n            return glPointSize;\n        }\n\n        this.getNode( 'InlineCode' ).code( '%pointSize = min(64.0, max(1.0, -%size / %position.z));' ).inputs( {\n            position: this.getOrCreateViewVertex(),\n            size: this.getOrCreateUniform( 'float', 'uPointSize' )\n        } ).outputs( {\n            pointSize: glPointSize\n        } );\n\n        return glPointSize;\n    },\n\n    declareVertexVaryings: function ( roots ) {\n        var varyings = this._varyings;\n\n        if ( varyings.vModelVertex ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateModelVertex() ).outputs( varyings.vModelVertex );\n        if ( varyings.vModelNormal ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateModelNormal() ).outputs( varyings.vModelNormal );\n        if ( varyings.vModelTangent ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateModelTangent() ).outputs( varyings.vModelTangent );\n\n        if ( varyings.vViewVertex ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateViewVertex() ).outputs( varyings.vViewVertex );\n        if ( varyings.vViewNormal ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateViewNormal() ).outputs( varyings.vViewNormal );\n        if ( varyings.vViewTangent ) this.getNode( 'SetFromNode' ).inputs( this.getOrCreateViewTangent() ).outputs( varyings.vViewTangent );\n\n        if ( varyings.vVertexColor ) {\n            this.getNode( 'InlineCode' ).code( '%vcolor = %venabled == 1.0 ? %acolor : vec4(1.0, 1.0, 1.0, 1.0);' ).inputs( {\n                venabled: this.getOrCreateUniform( 'float', 'uArrayColorEnabled' ),\n                acolor: this.getOrCreateAttribute( 'vec4', 'Color' )\n            } ).outputs( {\n                vcolor: this.getOrCreateVarying( 'vec4', 'vVertexColor' )\n            } );\n        }\n\n        for ( var keyVarying in varyings ) {\n            var varying = varyings[ keyVarying ];\n            roots.push( varying );\n\n            var name = varying.getVariable();\n            if ( name.indexOf( 'vTexCoord' ) !== -1 ) {\n                this.getNode( 'SetFromNode' ).inputs( this.getOrCreateAttribute( 'vec2', name.substring( 1 ) ) ).outputs( varying );\n            }\n        }\n    },\n\n    declareVertexPosition: function () {\n        var glPosition = this.getNode( 'glPosition' );\n        if ( this._isBillboard ) this.declareVertexTransformBillboard( glPosition );\n        else this.declareScreenVertex( glPosition );\n        return glPosition;\n    },\n\n    getOrCreateModelVertex: function () {\n        var out = this._variables.modelVertex;\n        if ( out ) return out;\n        out = this.createVariable( 'vec3', 'modelVertex' );\n\n        this.getNode( 'MatrixMultPosition' ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat4', 'uModelMatrix' ),\n            vec: this.getOrCreateLocalVertex()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateModelNormal: function () {\n        var out = this._variables.modelNormal;\n        if ( out ) return out;\n        out = this.createVariable( 'vec3', 'modelNormal' );\n\n        this.getNode( 'MatrixMultDirection' ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat3', 'uModelNormalMatrix' ),\n            vec: this.getOrCreateLocalNormal()\n        } ).outputs( {\n            vec: out\n        } );\n\n        // not normalized\n\n        return out;\n    },\n\n    getOrCreateModelTangent: function () {\n        var out = this._variables.modelTangent;\n        if ( out ) return out;\n        out = this.createVariable( 'vec4', 'modelTangent' );\n\n        this.getNode( 'MatrixMultDirection' ).setOverwriteW( false ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat3', 'uModelNormalMatrix' ),\n            vec: this.getOrCreateLocalTangent()\n        } ).outputs( {\n            vec: out\n        } );\n\n        // not normalized\n\n        return out;\n    },\n\n    getOrCreateViewVertex: function () {\n        var out = this._variables.viewVertex;\n        if ( out ) return out;\n        out = this.createVariable( 'vec4', 'viewVertex' );\n\n        this.getNode( 'MatrixMultPosition' ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat4', 'uModelViewMatrix' ),\n            vec: this.getOrCreateLocalVertex()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateViewNormal: function () {\n        var out = this._variables.viewNormal;\n        if ( out ) return out;\n        out = this.createVariable( 'vec3', 'viewNormal' );\n\n        this.getNode( 'MatrixMultDirection' ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat3', 'uModelViewNormalMatrix' ),\n            vec: this.getOrCreateLocalNormal()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateViewTangent: function () {\n        var out = this._variables.viewTangent;\n        if ( out ) return out;\n        out = this.createVariable( 'vec4', 'viewTangent' );\n\n        this.getNode( 'MatrixMultDirection' ).setOverwriteW( false ).inputs( {\n            matrix: this.getOrCreateUniform( 'mat3', 'uModelViewNormalMatrix' ),\n            vec: this.getOrCreateLocalTangent()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    declareScreenVertex: function ( glPosition ) {\n        this.getNode( 'MatrixMultPosition' ).inputs( {\n            matrix: this.getOrCreateProjectionMatrix(),\n            vec: this.getOrCreateViewVertex()\n        } ).outputs( {\n            vec: glPosition\n        } );\n    },\n\n    declareVertexTransformBillboard: function ( glPosition ) {\n        this.getNode( 'Billboard' ).inputs( {\n            Vertex: this.getOrCreateAttribute( 'vec3', 'Vertex' ),\n            ModelViewMatrix: this.getOrCreateUniform( 'mat4', 'uModelViewMatrix' ),\n            ProjectionMatrix: this.getOrCreateUniform( 'mat4', 'uProjectionMatrix' )\n        } ).outputs( {\n            vec: glPosition\n        } );\n    },\n\n    getOrCreateBoneMatrix: function () {\n        // reusable BoneMatrix between Vertex, Normal, Tangent\n        // Manadatory: scale animations must be uniform scale\n        var boneMatrix = this._variables[ 'boneMatrix' ];\n        if ( boneMatrix )\n            return boneMatrix;\n\n        boneMatrix = this.createVariable( 'mat4', 'boneMatrix' );\n\n        var inputWeights = this.getOrCreateAttribute( 'vec4', 'Weights' );\n        var inputBones = this.getOrCreateAttribute( 'vec4', 'Bones' );\n        var matrixPalette = this.getOrCreateUniform( 'vec4', 'uBones', this._skinningAttribute.getBoneUniformSize() );\n\n        this.getNode( 'Skinning' ).inputs( {\n            weights: inputWeights,\n            bonesIndex: inputBones,\n            matrixPalette: matrixPalette\n        } ).outputs( {\n            mat4: boneMatrix\n        } );\n\n        return boneMatrix;\n    },\n\n    getTarget: function ( name, i ) {\n        var type = name.indexOf( 'Tangent' ) !== -1 ? 'vec4' : 'vec3';\n        return this.getOrCreateAttribute( type, name + '_' + i );\n    },\n\n    morphTangentApproximation: function ( inputVertex, outputVertex ) {\n        var normalizedMorph = this.getOrCreateLocalNormal();\n        // kind of tricky, here we retrieve the normalized normal after morphing\n        // if there is no rigging we do not recompute it\n        if ( this._skinningAttribute ) {\n\n            normalizedMorph = this.createVariable( 'vec3' );\n            this.getNode( 'Normalize' ).inputs( {\n                vec: this.getOrCreateMorphNormal()\n            } ).outputs( {\n                vec: normalizedMorph\n            } );\n\n        }\n\n        this.getNode( 'InlineCode' ).code( '%out = %tangent.rgb - dot(%tangent.rgb, %normal) * %normal;' ).inputs( {\n            tangent: inputVertex,\n            normal: normalizedMorph\n        } ).outputs( {\n            out: outputVertex\n        } );\n\n        return outputVertex;\n    },\n\n    morphTransformVec3: function ( inputVertex, outputVertex ) {\n        var inputs = {\n            vertex: inputVertex,\n            weights: this.getOrCreateUniform( 'vec4', 'uTargetWeights' )\n        };\n\n        var numTargets = this._morphAttribute.getNumTargets();\n        for ( var i = 0; i < numTargets; i++ )\n            inputs[ 'target' + i ] = this.getTarget( inputVertex.getVariable(), i );\n\n        this.getNode( 'Morph' ).inputs( inputs ).outputs( {\n            out: outputVertex\n        } );\n\n        return outputVertex;\n    },\n\n    skinTransformVertex: function ( inputVertex, outputVertex ) {\n        this.getNode( 'MatrixMultPosition' ).setInverse( true ).inputs( {\n            matrix: this.getOrCreateBoneMatrix(),\n            vec: inputVertex\n        } ).outputs( {\n            vec: outputVertex\n        } );\n        return outputVertex;\n    },\n\n    skinTransformNormal: function ( inputVertex, outputVertex ) {\n        this.getNode( 'MatrixMultDirection' ).setInverse( true ).inputs( {\n            matrix: this.getOrCreateBoneMatrix(),\n            vec: inputVertex\n        } ).outputs( {\n            vec: outputVertex\n        } );\n        return outputVertex;\n    },\n\n    getOrCreateMorphVertex: function () {\n        var vecOut = this.getVariable( 'morphVertex' );\n        if ( vecOut ) return vecOut;\n\n        var inputVertex = this.getOrCreateAttribute( 'vec3', 'Vertex' );\n        if ( !this._morphAttribute || !this._morphAttribute.hasTarget( 'Vertex' ) ) return inputVertex;\n\n        return this.morphTransformVec3( inputVertex, this.createVariable( 'vec3', 'morphVertex' ) );\n    },\n\n    getOrCreateMorphNormal: function () {\n        var vecOut = this.getVariable( 'morphNormal' );\n        if ( vecOut ) return vecOut;\n\n        var inputNormal = this.getOrCreateAttribute( 'vec3', 'Normal' );\n        if ( !this._morphAttribute || !this._morphAttribute.hasTarget( 'Normal' ) ) return inputNormal;\n\n        return this.morphTransformVec3( inputNormal, this.createVariable( 'vec3', 'morphNormal' ) );\n    },\n\n    getOrCreateMorphTangent: function () {\n        var vecOut = this.getVariable( 'morphTangent' );\n        if ( vecOut ) return vecOut;\n\n        var inputTangent = this.getOrCreateAttribute( 'vec4', 'Tangent' );\n        var hasMorphTangent = this._morphAttribute && this._morphAttribute.hasTarget( 'Tangent' );\n\n        if ( !hasMorphTangent ) return inputTangent;\n\n        return this.morphTransformVec3( inputTangent, this.createVariable( 'vec3', 'morphTangent' ) );\n\n        // if ( !hasMorphTangent && !this._morphAttribute && !this._morphAttribute.hasTarget( 'Normal' ) ) return inputTangent;\n\n        // if ( hasMorphTangent ) return this.morphTransformVec3( inputTangent, this.createVariable( 'vec3', 'morphTangent' ) );\n\n        // // Approximate tangent morphing depending of the normal morphing (disabled as we are not sure it's worth it for now)\n        // return this.morphTangentApproximation( inputTangent, this.createVariable( 'vec3', 'morphTangent' ) );\n    },\n\n    getOrCreateSkinVertex: function () {\n        var vecOut = this.getVariable( 'skinVertex' );\n        if ( vecOut ) return vecOut;\n\n        var inputVertex = this.getOrCreateMorphVertex();\n        if ( !this._skinningAttribute ) return inputVertex;\n\n        return this.skinTransformVertex( inputVertex, this.createVariable( 'vec3', 'skinVertex' ) );\n    },\n\n    getOrCreateSkinNormal: function () {\n        var vecOut = this.getVariable( 'skinNormal' );\n        if ( vecOut ) return vecOut;\n\n        var inputNormal = this.getOrCreateMorphNormal();\n        if ( !this._skinningAttribute ) return inputNormal;\n\n        return this.skinTransformNormal( inputNormal, this.createVariable( 'vec3', 'skinNormal' ) );\n    },\n\n    getOrCreateSkinTangent: function () {\n        var vecOut = this.getVariable( 'skinTangent' );\n        if ( vecOut ) return vecOut;\n\n        var inputTangent = this.getOrCreateMorphTangent();\n        if ( !this._skinningAttribute ) return inputTangent;\n\n        return this.skinTransformNormal( inputTangent, this.createVariable( 'vec3', 'skinTangent' ) );\n    },\n\n    getOrCreateLocalVertex: function () {\n        return this.getOrCreateSkinVertex();\n    },\n\n    getOrCreateLocalNormal: function () {\n        var vecOut = this.getVariable( 'localNormal' );\n        if ( vecOut ) return vecOut;\n\n        var normal = this.getOrCreateSkinNormal();\n        if ( normal === this.getOrCreateAttribute( 'vec3', 'Normal' ) ) return normal;\n\n        vecOut = this.createVariable( 'vec3', 'localNormal' );\n        this.getNode( 'Normalize' ).inputs( {\n            vec: normal\n        } ).outputs( {\n            vec: vecOut\n        } );\n\n        return vecOut;\n    },\n\n    getOrCreateLocalTangent: function () {\n        var vecOut = this.getVariable( 'localTangent' );\n        if ( vecOut ) return vecOut;\n\n        var inputTangent = this.getOrCreateAttribute( 'vec4', 'Tangent' );\n        var tangent = this.getOrCreateSkinTangent();\n        if ( tangent === inputTangent ) return tangent;\n\n        return this.normalizeAndSetAlpha( tangent, inputTangent, this.createVariable( 'vec4', 'localTangent' ) );\n    },\n\n    normalizeAndSetAlpha: function ( tang3, tang4, vecOut ) {\n        var tangNormalized = this.createVariable( 'vec3' );\n        this.getNode( 'Normalize' ).inputs( {\n            vec: tang3\n        } ).outputs( {\n            vec: tangNormalized\n        } );\n\n        this.getNode( 'SetAlpha' ).inputs( {\n            color: tangNormalized,\n            alpha: tang4\n        } ).outputs( {\n            color: vecOut\n        } );\n\n        return vecOut;\n    }\n};\n\nvar wrapperVertexOnly = function ( fn, name ) {\n    return function () {\n        if ( this._fragmentShaderMode )\n            this.logError( 'This function should not be called from fragment shader : ' + name );\n        return fn.apply( this, arguments );\n    };\n};\n\nfor ( var fnName in CompilerVertex ) {\n    CompilerVertex[ fnName ] = wrapperVertexOnly( CompilerVertex[ fnName ], fnName );\n}\n\nmodule.exports = CompilerVertex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/CompilerVertex.js\n// module id = 208\n// module chunks = 0 1 2","'use strict';\n\nvar Light = require( 'osg/Light' );\nvar Notify = require( 'osg/notify' );\nvar MACROUTILS = require( 'osg/Utils' );\n\nvar CompilerFragment = {\n\n    _createFragmentShader: function () {\n        // Call to specialised inhenrited shader Compiler\n        var roots = this.createFragmentShaderGraph();\n        var fname = this.getFragmentShaderName();\n        if ( fname ) roots.push( this.getNode( 'Define', 'SHADER_NAME' ).setValue( fname ) );\n\n        var shader = this.createShaderFromGraphs( roots );\n\n        Notify.debug( this.getDebugIdentifier() );\n        Notify.debug( shader );\n\n        this.cleanAfterFragment();\n\n        return shader;\n    },\n\n    applyPointSizeCircle: function ( color ) {\n        if ( !this._pointSizeAttribute || !this._pointSizeAttribute.isEnabled() || !this._pointSizeAttribute.isCircleShape() )\n            return color;\n\n        this.getNode( 'InlineCode' ).code( 'if (length(2.0 * gl_PointCoord - 1.0) > %radius) discard;' ).inputs( {\n            radius: this.getOrCreateConstantOne( 'float' )\n        } ).outputs( {\n            output: color\n        } );\n\n        return color;\n    },\n\n    cleanAfterFragment: function () {\n        // reset for next\n        this._variables = {};\n        this._activeNodeList = {};\n\n        // clean texture cache variable (for vertex shader re-usage)\n        for ( var keyTexture in this._texturesByName ) {\n            this._texturesByName[ keyTexture ].variable = undefined;\n        }\n\n        for ( var keyVarying in this._varyings ) {\n            var varying = this._varyings[ keyVarying ];\n            varying.reset();\n            this._activeNodeList[ varying.getID() ] = varying;\n            this._variables[ keyVarying ] = varying;\n        }\n    },\n\n    createDefaultFragmentShaderGraph: function () {\n        var fofd = this.getOrCreateConstant( 'vec4', 'fofd' ).setValue( 'vec4(1.0, 0.0, 1.0, 0.7)' );\n        var fragCol = this.getNode( 'glFragColor' );\n        this.getNode( 'SetFromNode' ).inputs( fofd ).outputs( fragCol );\n        return fragCol;\n    },\n\n    createFragmentShaderGraph: function () {\n\n        // shader graph can have multiple output (glPointsize, varyings)\n        // here named roots all outputs must be pushed inside\n        var roots = [];\n\n        // no material then return a default shader\n        if ( !this._material ) {\n            roots.push( this.createDefaultFragmentShaderGraph() );\n            return roots;\n        }\n\n        var materialUniforms = this.getOrCreateStateAttributeUniforms( this._material );\n\n        // vertex color needs to be computed to diffuse\n        var diffuseColor = this.getVertexColor( materialUniforms.diffuse );\n\n        var finalColor;\n\n        if ( this._lights.length > 0 ) {\n\n            var lightedOutput = this.createLighting( {\n                materialdiffuse: diffuseColor\n            } );\n            finalColor = lightedOutput;\n\n        } else {\n            finalColor = diffuseColor;\n        }\n\n        if ( materialUniforms.emission ) {\n            // add emission if any\n            var outputDiffEm = this.createVariable( 'vec3' ).setValue( 'vec3(0.0)' );\n            this.getNode( 'Add' ).inputs( finalColor, materialUniforms.emission ).outputs( outputDiffEm );\n            finalColor = outputDiffEm;\n        }\n\n        // finalColor = primary color * texture color\n        var textureColor = this.getDiffuseColorFromTextures();\n        if ( textureColor !== undefined ) {\n            this.getNode( 'InlineCode' ).code( '%color.rgb *= %texture.rgb;' ).inputs( {\n                texture: textureColor\n            } ).outputs( {\n                color: finalColor\n            } );\n        }\n\n        // compute alpha\n        var alpha = this.createVariable( 'float' );\n        var textureTexel = this.getFirstValidTexture();\n        var alphaCompute;\n        if ( textureTexel ) // use alpha of the first valid texture if has texture\n            alphaCompute = '%alpha = %color.a * %texelAlpha.a;';\n        else\n            alphaCompute = '%alpha = %color.a;';\n\n        // Discard fragments totally transparents when rendering billboards\n        if ( this._isBillboard )\n            alphaCompute += 'if ( %alpha == 0.0) discard;';\n\n        this.getNode( 'InlineCode' ).code( alphaCompute ).inputs( {\n            color: materialUniforms.diffuse,\n            texelAlpha: textureTexel\n        } ).outputs( {\n            alpha: alpha\n        } );\n\n        // premult alpha\n        finalColor = this.getPremultAlpha( finalColor, alpha );\n\n        var fragColor = this.getNode( 'glFragColor' );\n\n        // todo add gamma corrected color, but it would also mean to handle correctly srgb texture\n        // so it should be done at the same time. see osg.Tetxure to implement srgb\n        this.getNode( 'SetAlpha' ).inputs( {\n            color: finalColor,\n            alpha: alpha\n        } ).outputs( {\n            color: fragColor\n        } );\n\n        roots.push( fragColor );\n\n        return roots;\n    },\n\n    getOrCreateFrontViewTangent: function () {\n        var out = this._variables[ 'frontViewTangent' ];\n        if ( out )\n            return out;\n\n        out = this.createVariable( 'vec4', 'frontViewTangent' );\n\n        this.getNode( 'FrontNormal' ).inputs( {\n            normal: this.getOrCreateVarying( 'vec4', 'vViewTangent' )\n        } ).outputs( {\n            normal: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateFrontViewNormal: function () {\n        var out = this._variables[ 'frontViewNormal' ];\n        if ( out )\n            return out;\n\n        out = this.createVariable( 'vec3', 'frontViewNormal' );\n\n        this.getNode( 'FrontNormal' ).inputs( {\n            normal: this.getOrCreateVarying( 'vec3', 'vViewNormal' )\n        } ).outputs( {\n            normal: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateNormalizedViewEyeDirection: function () {\n        var eye = this._variables[ 'eyeVector' ];\n        if ( eye )\n            return eye;\n\n        var nor = this.createVariable( 'vec3' );\n        var castEye = this.createVariable( 'vec3' );\n        this.getNode( 'SetFromNode' ).inputs( this.getOrCreateVarying( 'vec4', 'vViewVertex' ) ).outputs( castEye );\n        this.getNode( 'Normalize' ).inputs( {\n            vec: castEye\n        } ).outputs( {\n            vec: nor\n        } );\n\n        var out = this.createVariable( 'vec3', 'eyeVector' );\n        this.getNode( 'Mult' ).inputs( nor, this.createVariable( 'float' ).setValue( '-1.0' ) ).outputs( out );\n        return out;\n    },\n\n    getOrCreateNormalizedFrontViewNormal: function () {\n        var out = this._variables[ 'nFrontViewNormal' ];\n        if ( out )\n            return out;\n\n        out = this.createVariable( 'vec3', 'nFrontViewNormal' );\n        this.getNode( 'Normalize' ).inputs( {\n            vec: this.getOrCreateFrontViewNormal()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateFrontModelNormal: function () {\n        var out = this._variables[ 'frontModelNormal' ];\n        if ( out )\n            return out;\n\n        out = this.createVariable( 'vec3', 'frontModelNormal' );\n\n        this.getNode( 'FrontNormal' ).inputs( {\n            normal: this.getOrCreateVarying( 'vec3', 'vModelNormal' )\n        } ).outputs( {\n            normal: out\n        } );\n\n        return out;\n    },\n\n    getOrCreateNormalizedFrontModelNormal: function () {\n        var out = this._variables[ 'nFrontModelNormal' ];\n        if ( out )\n            return out;\n\n        out = this.createVariable( 'vec3', 'nFrontModelNormal' );\n        this.getNode( 'Normalize' ).inputs( {\n            vec: this.getOrCreateFrontModelNormal()\n        } ).outputs( {\n            vec: out\n        } );\n\n        return out;\n    },\n\n    getPremultAlpha: function ( finalColor, alpha ) {\n\n        if ( alpha === undefined )\n            return finalColor;\n\n        var premultAlpha = this.createVariable( 'vec4' );\n\n        this.getNode( 'PreMultAlpha' ).inputs( {\n            color: finalColor,\n            alpha: alpha\n        } ).outputs( {\n            color: premultAlpha\n        } );\n\n        return premultAlpha;\n    },\n\n\n    getColorsRGB: function ( finalColor ) {\n        var finalSrgbColor = this.createVariable( 'vec3' );\n        this.getNode( 'LinearTosRGB' ).inputs( {\n            color: finalColor\n        } ).outputs( {\n            color: finalSrgbColor\n        } );\n\n        return finalSrgbColor;\n    },\n\n\n    // Declare variable / varying to handle vertex color\n    // return a variable that contains the following operation\n    // newDiffuseColor = diffuseColor * vertexColor\n    // TODO: this code should move in the shader instead\n    getVertexColor: function ( diffuseColor ) {\n\n        if ( diffuseColor === undefined )\n            return undefined;\n\n        var vertexColor = this.getOrCreateVarying( 'vec4', 'vVertexColor' );\n        var vertexColorUniform = this.getOrCreateUniform( 'float', 'uArrayColorEnabled' );\n        var tmp = this.createVariable( 'vec4' );\n\n        var str = [ '',\n            '%color.rgb = %diffuse.rgb;',\n            'if ( %hasVertexColor == 1.0)',\n            '  %color *= %vertexColor.rgba;'\n        ].join( '\\n' );\n\n        this.getNode( 'InlineCode' ).code( str ).inputs( {\n            diffuse: diffuseColor,\n            hasVertexColor: vertexColorUniform,\n            vertexColor: vertexColor\n        } ).outputs( {\n            color: tmp\n        } ).comment( 'diffuse color = diffuse color * vertex color' );\n\n        return tmp;\n    },\n\n    getDiffuseColorFromTextures: function () {\n\n        var texturesInput = [];\n        var textures = this._texturesByName;\n\n        for ( var keyTexture in textures ) {\n            var texture = textures[ keyTexture ];\n\n            if ( texture.shadow )\n                continue;\n\n            texturesInput.push( this.getTextureByName( keyTexture ).variable );\n        }\n\n        // if multi texture multiply them all with diffuse\n        // but if only one, return the first\n        if ( texturesInput.length > 1 ) {\n\n            var texAccum = this.createVariable( 'vec3', 'texDiffuseAccum' );\n\n            this.getNode( 'Mult' ).inputs( texturesInput ).outputs( texAccum );\n            return texAccum;\n\n        } else if ( texturesInput.length === 1 ) {\n\n            return texturesInput[ 0 ];\n        }\n\n        return undefined;\n    },\n\n    getFirstValidTexture: function () {\n        var textures = this._textures;\n        for ( var i = 0, nb = textures.length; i < nb; ++i ) {\n            var tex = textures[ i ];\n            if ( tex ) return this.getTextureByName( tex.getName() ).variable;\n        }\n        return undefined;\n    },\n\n    createShadowingLight: function ( light, inputs, lightedOutput ) {\n\n        var k;\n        var shadow;\n        var shadowTexture;\n        var hasShadows = false;\n        var shadowTextures = new Array( this._shadowsTextures.length );\n        var lightIndex = -1;\n\n        // seach current light its corresponding shadow and shadowTextures.\n        // if none, no shadow, hop we go.\n        // TODO: harder Link shadowTexture and shadowAttribute ?\n        // TODO: multi shadow textures for 1 light\n        var lightNum = light.getLightNumber();\n        for ( k = 0; k < this._shadows.length; k++ ) {\n\n            shadow = this._shadows[ k ];\n            if ( shadow.getLightNumber() !== lightNum ) continue;\n\n            lightIndex = k;\n            for ( var p = 0; p < this._shadowsTextures.length; p++ ) {\n\n                shadowTexture = this._shadowsTextures[ p ];\n                if ( shadowTexture && shadowTexture.hasLightNumber( lightNum ) ) {\n                    shadowTextures[ p ] = shadowTexture;\n                    hasShadows = true;\n                }\n\n            }\n        }\n\n        if ( !hasShadows ) return undefined;\n\n        // Varyings\n        var vertexWorld = this.getOrCreateVarying( 'vec3', 'vModelVertex' );\n        var normalWorld = this.getOrCreateNormalizedFrontModelNormal();\n\n        // asserted we have a shadow we do the shadow node allocation\n        // and mult with lighted output\n        var shadowedOutput = this.createVariable( 'float' );\n\n        // shadow Attribute uniforms\n        var shadowUniforms = this.getOrCreateStateAttributeUniforms( this._shadows[ lightIndex ], 'shadow' );\n        var shadowInputs = MACROUTILS.objectMix( inputs, shadowUniforms );\n\n        // shadowTexture  Attribute uniforms AND varying\n        // TODO: better handle multi texture shadow (CSM/PSM/etc.)\n        for ( k = 0; k < shadowTextures.length; k++ ) {\n            shadowTexture = shadowTextures[ k ];\n            if ( shadowTexture ) {\n                shadowInputs = this.createShadowTextureInputVarying( shadowTexture, shadowInputs, vertexWorld, normalWorld, k, lightNum );\n            }\n\n        }\n        // TODO: shadow Attributes in node, is this the legit way\n        this.getNode( 'ShadowReceive' ).inputs( inputs ).outputs( {\n            float: shadowedOutput\n        } ).setShadowAttribute( shadow );\n\n        // allow overwrite by inheriting compiler where shadow inputs ( NDotL notably) can be used for non standard shadows\n        return this.connectShadowLightNode( light, lightedOutput, shadowedOutput, shadowInputs );\n\n    },\n\n    connectShadowLightNode: function ( light, lightedOutput, shadowedOutput ) {\n\n        var lightAndShadowTempOutput = this.createVariable( 'vec3', 'lightAndShadowTempOutput' );\n\n        this.getNode( 'Mult' ).inputs( lightedOutput, shadowedOutput ).outputs( lightAndShadowTempOutput );\n\n        return lightAndShadowTempOutput;\n\n    },\n\n    createShadowTextureInputVarying: function ( shadowTexture, inputs, vertexWorld, normalWorld, tUnit, lightNum ) {\n        var shadowTexSamplerName = 'Texture' + tUnit;\n\n\n        // we declare first this uniform so that the Int one\n        var tex = this.getOrCreateSampler( 'sampler2D', shadowTexSamplerName );\n\n        // per texture uniforms\n        var uniforms = shadowTexture.getOrCreateUniforms( tUnit );\n        var backupInt = uniforms[ shadowTexSamplerName ];\n        // remove the uniform texture unit uniform\n        delete uniforms[ shadowTexSamplerName ];\n\n\n        // get subset of shadow texture uniform corresponding to light\n        var object = {};\n\n        var prefixUniform = 'shadowTexture';\n\n        for ( var keyUniform in uniforms ) {\n            var lightIndexed = keyUniform.split( '_' );\n\n            var k;\n\n            if ( lightIndexed.length === 2 ) {\n\n                if ( Number( lightIndexed[ 1 ] ) === lightNum ) {\n\n                    k = prefixUniform + lightIndexed[ 0 ];\n                    object[ k ] = this.getOrCreateUniform( uniforms[ keyUniform ] );\n                }\n\n            } else {\n\n                k = prefixUniform + keyUniform;\n                object[ k ] = this.getOrCreateUniform( uniforms[ keyUniform ] );\n\n            }\n\n\n        }\n\n        var shadowTextureUniforms = object;\n\n\n        // tUnit, lightNum\n        uniforms[ shadowTexSamplerName ] = backupInt;\n\n        var inputsShadow = MACROUTILS.objectMix( inputs, shadowTextureUniforms );\n\n        inputsShadow.shadowTexture = tex;\n\n        var shadowVarying = {\n            vertexWorld: vertexWorld,\n            normalWorld: normalWorld,\n            lightEyeDir: inputsShadow.lightEyeDir\n        };\n        inputsShadow = MACROUTILS.objectMix( inputsShadow, shadowVarying );\n        return inputsShadow;\n    },\n\n    createCommonLightingVars: function ( /*materials, enumLights*/) {\n        // Shared var between all lights and shadows useful for compilers overriding default compiler\n        return {};\n    },\n\n    // Shared var between each light and its respective shadow\n    createLightAndShadowVars: function ( materials, enumLights, lightNum ) {\n\n        var type = this._lights[ lightNum ].getLightType();\n\n        var lighted = this.createVariable( 'bool', 'lighted' + lightNum );\n        var lightPos;\n        if ( type === Light.SPOT || type === Light.POINT ) {\n            lightPos = this.createVariable( 'vec3', 'lightEyePos' + lightNum );\n        }\n        var lightDir = this.createVariable( 'vec3', 'lightEyeDir' + lightNum );\n\n\n\n        return {\n            lighted: lighted,\n            lightEyePos: lightPos,\n            lightEyeDir: lightDir\n        };\n\n    },\n\n    createLighting: function ( materials, overrideNodeName ) {\n\n        var output = this.createVariable( 'vec3' );\n        var lightOutputVarList = [];\n\n        var enumToNodeName = overrideNodeName || {\n            DIRECTION: 'SunLight',\n            SPOT: 'SpotLight',\n            POINT: 'PointLight',\n            HEMI: 'HemiLight'\n        };\n\n\n        var materialUniforms = this.getOrCreateStateAttributeUniforms( this._material, 'material' );\n        var sharedLightingVars = this.createCommonLightingVars( materials, enumToNodeName );\n\n        for ( var i = 0; i < this._lights.length; i++ ) {\n\n            var light = this._lights[ i ];\n\n            var lightedOutput = this.createVariable( 'vec3' );\n            var nodeName = enumToNodeName[ light.getLightType() ];\n\n            // create uniforms from stateAttribute and mix them with materials\n            // to pass the result as input for light node\n            var lightUniforms = this.getOrCreateStateAttributeUniforms( this._lights[ i ], 'light' );\n            var lightOutShadowIn = this.createLightAndShadowVars( materials, enumToNodeName, i );\n\n            var inputs = MACROUTILS.objectMix( {}, lightUniforms );\n            inputs = MACROUTILS.objectMix( inputs, materialUniforms );\n            inputs = MACROUTILS.objectMix( inputs, materials );\n            inputs = MACROUTILS.objectMix( inputs, sharedLightingVars );\n            inputs = MACROUTILS.objectMix( inputs, lightOutShadowIn );\n\n            if ( !inputs.normal )\n                inputs.normal = this.getOrCreateNormalizedFrontViewNormal();\n            if ( !inputs.eyeVector )\n                inputs.eyeVector = this.getOrCreateNormalizedViewEyeDirection();\n\n            this.getNode( nodeName ).inputs( inputs ).outputs( {\n                color: lightedOutput,\n                lightEyePos: inputs.lightEyePos, // spot and point only\n                lightEyeDir: inputs.lightEyeDir,\n                lighted: inputs.lighted\n            } );\n\n            var shadowedOutput = this.createShadowingLight( light, inputs, lightedOutput );\n            if ( shadowedOutput ) {\n                lightOutputVarList.push( shadowedOutput );\n            } else {\n                lightOutputVarList.push( lightedOutput );\n            }\n\n            var lightMatAmbientOutput = this.createVariable( 'vec3', 'lightMatAmbientOutput' );\n\n            this.getNode( 'Mult' ).inputs( inputs.materialambient, lightUniforms.lightambient ).outputs( lightMatAmbientOutput );\n\n\n            lightOutputVarList.push( lightMatAmbientOutput );\n        }\n\n        // do not delete on the assumption that light list is always filled\n        // in case CreateLighting is called with a empty lightList\n        // when Compiler is overriden.\n        if ( lightOutputVarList.length === 0 )\n            lightOutputVarList.push( this.createVariable( 'vec3' ).setValue( 'vec3(0.0)' ) );\n\n        this.getNode( 'Add' ).inputs( lightOutputVarList ).outputs( output );\n\n        return output;\n    },\n\n    createTextureRGBA: function ( texture, textureSampler, texCoord ) {\n        // but we could later implement srgb inside and read differents flag\n        // as read only in the texture\n\n        var texel = this.createVariable( 'vec4' );\n        this.getNode( 'TextureRGBA' ).inputs( {\n            sampler: textureSampler,\n            uv: texCoord\n        } ).outputs( {\n            color: texel\n        } );\n\n        return texel;\n    }\n};\n\nvar wrapperFragmentOnly = function ( fn, name ) {\n    return function () {\n        if ( !this._fragmentShaderMode )\n            this.logError( 'This function should not be called from vertex shader : ' + name );\n        return fn.apply( this, arguments );\n    };\n};\n\n\nfor ( var fnName in CompilerFragment ) {\n    CompilerFragment[ fnName ] = wrapperFragmentOnly( CompilerFragment[ fnName ], fnName );\n}\n\nmodule.exports = CompilerFragment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShader/CompilerFragment.js\n// module id = 209\n// module chunks = 0 1 2","'use strict';\n\nvar DisplayGraphRenderer = require( 'osgUtil/DisplayGraphRenderer' );\nvar DisplayGraphNode = require( 'osgUtil/DisplayGraphNode' );\nvar Notify = require( 'osg/notify' );\n\nvar $;\n\nvar init$ = function () {\n    try {\n        $ = require( 'jquery' );\n    } catch ( e ) {\n        Notify.warn( 'You will not be able to use osgUtil.DisplayGraph until you add jQuery in your page' );\n    }\n};\n\n// Simple tooltips implementation\nvar SimpleTooltips = function ( options ) {\n\n    this.options = options;\n    var css = document.createElement( 'style' );\n    css.type = 'text/css';\n    css.innerHTML = [\n        '.osgDebugSimpleTooltip {',\n        'display: none;',\n        'position: absolute;',\n        'margin-left: 10px;',\n        'border-radius: 4px;',\n        'padding: 10px;',\n        'background: rgba(0,0,0,.9);',\n        'color: #ffffff;',\n        '}',\n        '.osgDebugSimpleTooltip:before {',\n        'content: ',\n        ';',\n        'position: absolute;',\n        'left: -10px;',\n        'top: 8px;',\n        'border: 10px solid transparent;',\n        'border-width: 10px 10px 10px 0;',\n        'border-right-color: rgba(0,0,0,.9);',\n        '}'\n    ].join( '\\n' );\n    document.getElementsByTagName( 'head' )[ 0 ].appendChild( css );\n\n    this.el = document.createElement( 'div' );\n    this.el.className = 'osgDebugSimpleTooltip';\n    document.body.appendChild( this.el );\n    var nodes = document.querySelectorAll( this.options.selector );\n    for ( var i = 0; i < nodes.length; i++ ) {\n        nodes[ i ].addEventListener( 'mouseover', this.showTooltip.bind( this ), false );\n        nodes[ i ].addEventListener( 'mouseout', this.hideTooltip.bind( this ), false );\n    }\n};\nSimpleTooltips.prototype = {\n    showTooltip: function ( e ) {\n        if ( !$ ) return;\n\n        var target = e.currentTarget;\n        this.el.innerHTML = target.getAttribute( 'title' );\n        this.el.style.display = 'block';\n        this.el.style.left = $( target ).position().left + $( target ).get( 0 ).getBoundingClientRect().width + 'px';\n        this.el.style.top = $( target ).position().top + 'px';\n    },\n    hideTooltip: function () {\n        this.el.style.display = 'none';\n    }\n};\n\nvar DisplayGraph = function () {\n\n    init$();\n    if ( !$ ) return;\n\n    // indexed with instanceID, references nodes, stateSet, sourceGeometry...\n    // referenced with strings !\n    this._selectables = new window.Map();\n\n    this._graphNode = new DisplayGraphNode( this._selectables );\n    this._graphRender = new DisplayGraphRenderer( this._selectables );\n\n    this._displayNode = true;\n    this._displayRenderer = false;\n\n    // callback when selecting a node\n    this._cbSelect = undefined;\n\n    this._focusedElement = 'graph';\n    this._idToDomElement = new window.Map();\n\n    this._$svg = $( '<svg width=100% height=100%></svg>' );\n    $( 'body' ).append( this._$svg );\n\n    this._css = '.node {text-align: center;cursor: pointer;}.node rect {stroke: #FFF;}.edgePath path {stroke: #FFF;fill: none;}table {text-align: right;}svg {position: absolute;left: 0px;top: 0px;}.osgDebugButton {position: absolute;left: 15px;top: 15px;z-index: 5;border: 0;background: #65a9d7;background: -webkit-gradient(linear, left top, left bottom, from(#3e779d), to(#65a9d7));background: -webkit-linear-gradient(top, #3e779d, #65a9d7);background: -moz-linear-gradient(top, #3e779d, #65a9d7);background: -ms-linear-gradient(top, #3e779d, #65a9d7);background: -o-linear-gradient(top, #3e779d, #65a9d7);padding: 5px 10px;-webkit-border-radius: 7px;-moz-border-radius: 7px;border-radius: 7px;-webkit-box-shadow: rgba(0,0,0,1) 0 1px 0;-moz-box-shadow: rgba(0,0,0,1) 0 1px 0;box-shadow: rgba(0,0,0,1) 0 1px 0;text-shadow: rgba(0,0,0,.4) 0 1px 0;color: white;font-size: 15px;font-family: Helvetica, Arial, Sans-Serif;text-decoration: none;vertical-align: middle;}.osgDebugButton:hover {border-top-color: #28597a;background: #28597a;color: #ccc;}.osgDebugButton:active {border-top-color: #1b435e;background: #1b435e;}.osgDebugSimpleTooltip .osgDebugName {font-weight: bold;color: #60b1fc;margin: 0;}.osgDebugSimpleTooltip .osgDebugDescription {margin: 0;}';\n};\n\nDisplayGraph.instance = function () {\n    if ( !DisplayGraph._instance )\n        DisplayGraph._instance = new DisplayGraph();\n    return DisplayGraph._instance;\n};\n\nDisplayGraph.prototype = {\n    getColorFromClassName: DisplayGraphNode.prototype.getColorFromClassName,\n\n    setCallbackSelect: function ( cb ) {\n        this._cbSelect = cb;\n    },\n\n    reset: function () {\n        if ( !$ ) return;\n\n        this._selectables.clear();\n        this._$svg.empty();\n        this._focusedElement = 'scene';\n        $( '.osgDebugButton' ).hide();\n    },\n\n    setDisplayGraphRenderer: function ( bool ) {\n        this._displayRenderer = bool;\n    },\n\n    createRenderGraph: function ( renderStage ) {\n        // called by renderer\n        this._graphRender.createGraph( renderStage );\n        this.displayGraph();\n    },\n\n    createGraph: function ( root ) {\n        if ( !$ ) return;\n        this.reset();\n\n        this._displayNode = !!root;\n        if ( root ) {\n            this._graphNode.createGraph( root );\n        }\n\n        // check if asynchronous is necessary\n        if ( !this._displayRenderer ) {\n            this.displayGraph();\n        } else {\n            // circular dependency\n            require( 'osgViewer/Renderer' ).debugGraph = true;\n        }\n    },\n\n    // Create and display a dagre d3 graph\n    displayGraph: function () {\n        if ( !$ ) return;\n        if ( window.d3 && window.dagreD3 ) {\n            this._createGraphApply();\n            return;\n        }\n\n        var d3url = '//cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.min.js';\n        var dagreurl = '//cdn.jsdelivr.net/dagre-d3/0.2.9/dagre-d3.min.js';\n\n        var cb = this._createGraphApply.bind( this );\n        $.getScript( d3url ).done( function () {\n            $.getScript( dagreurl ).done( cb );\n        } );\n    },\n\n    _createGraphApply: function () {\n        var diGraph = new window.dagreD3.Digraph();\n        if ( this._displayNode ) this._graphNode.generateNodeAndLink( diGraph );\n        if ( this._displayRenderer ) this._graphRender.generateNodeAndLink( diGraph );\n\n\n        // Add the style of the graph\n        this.injectStyleElement();\n        $( '.osgDebugButton' ).show();\n\n        // Create the renderer\n        var renderer = this.renderer = new window.dagreD3.Renderer();\n\n        // Set up an SVG group so that we can translate the final graph.\n        var svg = window.d3.select( this._$svg.get( 0 ) );\n        var svgGroup = svg.append( 'g' );\n\n        // Set initial zoom to 75%\n        var initialScale = 0.75;\n        var oldZoom = renderer.zoom();\n        renderer.zoom( function ( g, argSVG ) {\n            var zoom = oldZoom( g, argSVG );\n\n            zoom.scale( initialScale ).event( argSVG );\n            return zoom;\n        } );\n\n        // Simple function to style the tooltip for the given node.\n        var styleTooltip = function ( instanceID, description ) {\n            // instanceID is used by onNodeSelect to retrieve the node\n            return '<p class=\"osgDebugName\">' + instanceID + '</p><pre class=\"osgDebugDescription\">' + description + '</pre>';\n        };\n\n        var idToDom = this._idToDomElement;\n        // Override drawNodes to set up the hover.\n        var oldDrawNodes = renderer.drawNodes();\n        renderer.drawNodes( function ( g, argSVG ) {\n            var svgNodes = oldDrawNodes( g, argSVG );\n\n            // Set the title on each of the nodes and use tipsy to display the tooltip on hover\n            svgNodes.attr( 'title', function ( d ) {\n                idToDom.set( d, this );\n                return styleTooltip( d, g.node( d ).description || '' );\n            } );\n\n            return svgNodes;\n        } );\n\n        // Run the renderer. This is what draws the final graph.\n        renderer.run( diGraph, svgGroup );\n\n        this.tooltip = new SimpleTooltips( {\n            selector: '.node'\n        } );\n\n        // Do a console log of the node (or stateset) and save it in window.*\n        $( '.node' ).click( this.onNodeSelect.bind( this ) );\n        this.focusOnGraph();\n    },\n\n    selectNode: function ( node ) {\n        var id = node.getInstanceID();\n        var dom = this._idToDomElement.get( id );\n        if ( dom )\n            $( dom ).click();\n    },\n\n    onNodeSelect: function ( e ) {\n        var target = e.currentTarget;\n        var identifier = $( target.getAttribute( 'title' ) )[ 0 ].innerHTML;\n        var selectables = this._selectables;\n\n        // color the node back\n        if ( this.lastNode ) {\n            this.lastNode.style.fill = this.lastColor;\n        }\n\n        // non selectables nodes\n        var elt = selectables.get( identifier );\n        if ( !elt )\n            return;\n\n        this.lastNode = target.childNodes[ 0 ];\n        this.lastColor = this.lastNode.style.fill;\n        target.childNodes[ 0 ].style.fill = '#f00';\n\n        window.activeNode = elt;\n        Notify.info( 'window.activeNode is set with the node below !' );\n        Notify.log( window.activeNode );\n        Notify.log( '\\n' );\n\n        if ( this._cbSelect )\n            this._cbSelect( elt );\n    },\n\n    focusOnScene: function () {\n        $( '.osgDebugButton' ).text( 'Access to the graph' );\n        this._$svg.css( 'zIndex', '-2' );\n        this._focusedElement = 'scene';\n    },\n\n    focusOnGraph: function () {\n        $( '.osgDebugButton' ).text( 'Access to the scene' );\n        this._$svg.css( 'zIndex', '2' );\n        $( '.osgDebugSimpleTooltip' ).css( 'zIndex', '3' );\n        this._focusedElement = 'graph';\n    },\n\n    // Apply all the style\n    injectStyleElement: function () {\n        if ( this._cssInjected )\n            return;\n        this._cssInjected = true;\n\n        $( 'body' ).append( '<button class=\"osgDebugButton\">Access to the scene</button>' );\n        $( '.osgDebugButton' ).click( function () {\n            if ( this._focusedElement === 'scene' )\n                this.focusOnGraph();\n            else\n                this.focusOnScene();\n        }.bind( this ) );\n\n        var css = document.createElement( 'style' );\n        css.type = 'text/css';\n        css.innerHTML = this._css;\n        document.getElementsByTagName( 'head' )[ 0 ].appendChild( css );\n    }\n};\n\nmodule.exports = DisplayGraph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DisplayGraph.js\n// module id = 210\n// module chunks = 0 1 2","'use strict';\nvar DisplayGraphNode = require( 'osgUtil/DisplayGraphNode' );\nvar RenderBin = require( 'osg/RenderBin' );\n\nvar DisplayGraphRenderer = function ( selectables ) {\n\n    this._selectables = selectables;\n    this._nodeList = [];\n    this._linkList = [];\n\n    this._renderBinMap = new window.Map();\n    this._renderBinStack = [];\n\n    this._generatorID = 0;\n    this._refID = 0; // invalide old _instanceID if we recreate the graph\n\n    this._uniqueEdges = new window.Set();\n};\n\nDisplayGraphRenderer.prototype = {\n    getColorFromClassName: DisplayGraphNode.prototype.getColorFromClassName,\n\n    createGraph: function ( renderBin ) {\n        this.reset();\n        this.apply( renderBin );\n    },\n\n    reset: function () {\n        this._renderBinMap.clear();\n        this._renderBinStack.length = 0;\n        this._generatorID = 0;\n        this._refID++;\n\n        this._nodeList.length = 0;\n        this._linkList.length = 0;\n\n        this._uniqueEdges.clear();\n    },\n\n    apply: function ( rb ) {\n\n        var instanceID = rb.getInstanceID();\n        if ( !this._renderBinMap.has( instanceID ) ) {\n            this._renderBinMap.set( instanceID, rb );\n        }\n\n        this._renderBinStack.push( rb );\n\n        // pre render stage if render stage node\n        if ( rb.getPreRenderStageList ) {\n            var preRenderList = rb.getPreRenderStageList();\n            for ( var i = 0, ni = preRenderList.length; i < ni; ++i ) {\n                this.apply( preRenderList[ i ].renderStage );\n            }\n        }\n\n        // draw implementation\n        // handle rs camera\n        this.registerNode( rb );\n\n        // post render stage if render stage node\n        if ( rb.getPostRenderStageList ) {\n            var postRenderList = rb.getPostRenderStageList();\n            for ( var j = 0, nj = postRenderList.length; j < nj; ++j ) {\n                this.apply( postRenderList[ j ].renderStage );\n            }\n        }\n\n        this._renderBinStack.pop();\n    },\n\n    registerNode: function ( rb ) {\n\n        var childID = rb.getInstanceID();\n\n        this._nodeList.push( rb );\n\n        // register bins\n        var bins = rb._bins;\n        for ( var binKey in bins ) {\n            this.apply( bins[ binKey ] );\n        }\n\n        // register fine grained leafs\n        if ( rb._leafs.length ) {\n            for ( var j = 0, nj = rb._leafs.length; j < nj; j++ ) {\n                this.createNodeAndSetID( childID, rb._leafs[ j ] );\n            }\n        }\n\n        // register coarse grained leafs\n        for ( var k = 0, nk = rb.stateGraphList.length; k < nk; k++ ) {\n            var sg = rb.stateGraphList[ k ];\n            this.createNodeAndSetID( childID, sg );\n            var stateGraphID = sg._instanceID;\n            for ( var l = 0, nl = sg.leafs.length; l < nl; l++ )\n                this.createNodeAndSetID( stateGraphID, sg.leafs[ l ] );\n        }\n\n\n        // no parent no link\n        if ( this._renderBinStack.length < 2 )\n            return;\n\n        var parentID = this._renderBinStack[ this._renderBinStack.length - 2 ].getInstanceID();\n        this.createLink( parentID, childID );\n    },\n\n    createLink: function ( parent, child ) {\n        var key = parent + '+' + child;\n        if ( !this._uniqueEdges.has( key ) ) {\n            this._linkList.push( {\n                parentNode: parent,\n                childrenNode: child\n            } );\n            this._uniqueEdges.add( key );\n        }\n    },\n\n    createNodeAndSetID: function ( parentID, node ) {\n\n        // register render leaf\n        this._nodeList.push( node );\n\n        // generate fake id < 0 because RenderLeaf does not inherit from Object\n        if ( node._instanceID === undefined || ( node._instanceID < 0 && node._refID !== this._refID ) ) {\n            node._instanceID = -1 - this._generatorID++;\n            node._refID = this._refID;\n        }\n\n        this.createLink( parentID, node._instanceID );\n    },\n\n    generateRenderLeaf: function ( g, node ) {\n\n        var instanceID = node._instanceID;\n        var className = 'RenderLeaf';\n        var geomName = node._geometry && node._geometry.getName() ? '\\n' + node._geometry.getName() : 'Geometry';\n\n        var label = className + ' ( ' + node._instanceID + ' )';\n        label += '\\n' + geomName + ' ( ' + node._geometry.getInstanceID() + ' )';\n\n        this._selectables.set( instanceID.toString(), node );\n        g.addNode( instanceID, {\n            label: label,\n            description: '',\n            style: 'fill: ' + this.getColorFromClassName( className ) + ';stroke-width: 0px;'\n        } );\n    },\n\n    generateStateGraph: function ( g, node ) {\n\n        var instanceID = node._instanceID;\n        var className = 'StateGraph';\n        var label = className + ' ( ' + node._instanceID + ' )';\n        label += '\\n' + node.leafs.length + ' leafs';\n\n        this._selectables.set( instanceID.toString(), node );\n        g.addNode( instanceID, {\n            label: label,\n            description: '',\n            style: 'fill: ' + this.getColorFromClassName( className ) + ';stroke-width: 0px;'\n        } );\n    },\n\n    generateRenderStage: function ( g, node ) {\n\n        var label = node.className() + ' ( ' + node._instanceID + ' )';\n        if ( node.getName() ) label += '\\n' + node.getName();\n        label += '\\nViewport ( ' + node.getViewport().width() + ' x ' + node.getViewport().height() + ' )';\n\n        this._selectables.set( node.getInstanceID().toString(), node );\n        g.addNode( node.getInstanceID(), {\n            label: label,\n            description: '',\n            style: 'fill: ' + this.getColorFromClassName( node.className() ) + ';stroke-width: 0px;'\n        } );\n\n    },\n\n    generateRenderBin: function ( g, rb ) {\n\n        var label = rb.className() + ' ( ' + rb.getInstanceID() + ' )';\n        if ( rb.getName() ) label += '\\n' + rb.getName();\n\n        var sortMode = '';\n        if ( rb.getSortMode() === RenderBin.SORT_BACK_TO_FRONT )\n            sortMode = 'SortMode: BackToFront';\n\n        var description = 'BinNumber: ' + rb.getBinNumber() + '\\n' + sortMode;\n\n        this._selectables.set( rb.getInstanceID().toString(), rb );\n        g.addNode( rb.getInstanceID(), {\n            label: label,\n            description: description,\n            style: 'fill: ' + this.getColorFromClassName( rb.className() ) + ';stroke-width: 0px;'\n        } );\n\n    },\n\n    // Subfunction of createGraph, will iterate to create all the node and link in dagre\n    generateNodeAndLink: function ( g ) {\n        for ( var i = 0, ni = this._nodeList.length; i < ni; i++ ) {\n\n            var node = this._nodeList[ i ];\n\n            // detect if RenderLeaf\n            if ( node._geometry && node._depth !== undefined ) {\n                this.generateRenderLeaf( g, node );\n\n            } else if ( node.depth !== undefined && node.leafs && node.children ) {\n                // it's StateGraph\n                this.generateStateGraph( g, node );\n\n            } else if ( node.className() === 'RenderStage' ) {\n                this.generateRenderStage( g, node );\n\n            } else {\n                // it's a RenderBin\n                this.generateRenderBin( g, node );\n            }\n\n        }\n\n        for ( var j = 0, nj = this._linkList.length; j < nj; j++ ) {\n            g.addEdge( null, this._linkList[ j ].parentNode, this._linkList[ j ].childrenNode );\n        }\n    }\n};\n\nmodule.exports = DisplayGraphRenderer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DisplayGraphRenderer.js\n// module id = 211\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar MorphGeometry = require( 'osgAnimation/MorphGeometry' );\n\nvar DisplayGraphNode = function ( selectables ) {\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n\n    this._selectables = selectables;\n    this._nodeList = [];\n    this._linkList = [];\n\n    // don't reference twice same node\n    this._uniqueNodes = new window.Set();\n    this._uniqueEdges = new window.Set();\n};\n\nDisplayGraphNode.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    getColorFromClassName: function ( name ) {\n        switch ( name ) {\n        case 'ShadowedScene':\n            return '#3D3D3D';\n        case 'Camera':\n            return '#AB7BCF';\n        case 'RenderBin':\n            return '#59778B';\n        case 'LightSource':\n            return '#53967D';\n        case 'RenderStage':\n            return '#DDCC55';\n        case 'RenderLeaf':\n        case 'Geometry':\n            return '#FFCC55';\n        case 'RigGeometry':\n            return '#DD8800';\n        case 'MorphGeometry':\n            return '#AA5500';\n        case 'MatrixTransform':\n            return '#CE697E';\n        case 'StateSet':\n            return '#0099FF';\n        case 'StateGraph':\n        case 'Skeleton':\n            return '#96999E';\n        case 'Bone':\n            return '#A9DEAA';\n        case 'Node':\n            return '#FFFFFF';\n        default:\n            return '#FF00AA';\n        }\n    },\n\n    createGraph: function ( root ) {\n        this.reset();\n        root.accept( this );\n    },\n\n    reset: function () {\n        this._nodeList.length = 0;\n        this._linkList.length = 0;\n        this._uniqueNodes.clear();\n        this._uniqueEdges.clear();\n    },\n\n    apply: function ( node ) {\n        if ( node._isNormalDebug )\n            return;\n\n        if ( !this._uniqueNodes.has( node.getInstanceID() ) ) {\n            this._uniqueNodes.add( node.getInstanceID() );\n            this._nodeList.push( node );\n        }\n\n        if ( this.nodePath.length >= 2 ) {\n            var parentID = this.nodePath[ this.nodePath.length - 2 ].getInstanceID();\n            var childID = node.getInstanceID();\n            var key = parentID + '+' + childID;\n            if ( !this._uniqueEdges.has( key ) ) {\n                this._linkList.push( {\n                    parentNode: parentID,\n                    childrenNode: childID\n                } );\n                this._uniqueEdges.add( key );\n            }\n        }\n\n        this.traverse( node );\n    },\n\n    // Create an array to display the matrix\n    createMatrixGrid: function ( node, matrixArray ) {\n\n        var nodeMatrix = '';\n\n        nodeMatrix += '<table><tr><td>' + matrixArray[ 0 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 4 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 8 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 12 ] + '</td></tr>';\n\n        nodeMatrix += '<tr><td>' + matrixArray[ 1 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 5 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 9 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 13 ] + '</td></tr>';\n\n        nodeMatrix += '<tr><td>' + matrixArray[ 2 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 6 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 10 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 14 ] + '</td></tr>';\n\n        nodeMatrix += '<tr><td>' + matrixArray[ 3 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 7 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 11 ] + '</td>';\n        nodeMatrix += '<td>' + matrixArray[ 15 ] + '</td></tr></table>';\n\n        return nodeMatrix;\n    },\n\n    getLabel: function ( obj ) {\n        var label = obj.className() + ' (' + obj.getInstanceID() + ')';\n        if ( obj.getName && obj.getName() ) label += '\\n' + obj.getName();\n        return label;\n    },\n\n    generateNode: function ( g, node ) {\n        var description = '';\n        if ( node.getMatrix && node.getMatrix() ) {\n            description += '<br /><br />' + this.createMatrixGrid( node, node.getMatrix() );\n        }\n\n        this._selectables.set( node.getInstanceID().toString(), node );\n        g.addNode( node.getInstanceID(), {\n            label: this.getLabel( node ),\n            description: description,\n            style: 'fill: ' + this.getColorFromClassName( node.className() ) + ';stroke-width: 0px;'\n        } );\n    },\n\n    generateStateSet: function ( g, node ) {\n        var stateSet = node.getStateSet();\n        var stateSetID = stateSet.getInstanceID();\n\n        var label = this.getLabel( stateSet );\n        label += '\\nNbTexture : ' + stateSet.getNumTextureAttributeLists();\n\n        if ( !g.hasNode( stateSetID ) ) {\n\n            this._selectables.set( stateSetID.toString(), stateSet );\n            g.addNode( stateSetID, {\n                label: label,\n                style: 'fill: ' + this.getColorFromClassName( stateSet.className() ) + ';stroke-width: 0px;'\n            } );\n        }\n\n        g.addEdge( null, node.getInstanceID(), stateSetID, {\n            style: 'stroke: ' + this.getColorFromClassName( stateSet.className() ) + ';'\n        } );\n    },\n\n    generateSourceGeometry: function ( g, node ) {\n        var sourceGeom = node.getSourceGeometry();\n        var sourceGeomID = sourceGeom.getInstanceID();\n\n        this._selectables.set( sourceGeomID.toString(), sourceGeom );\n        g.addNode( sourceGeomID, {\n            label: this.getLabel( sourceGeom ),\n            style: 'fill: ' + this.getColorFromClassName( sourceGeom.className() ) + ';stroke-width: 0px;'\n        } );\n\n        g.addEdge( null, node.getInstanceID(), sourceGeomID, {\n            style: 'stroke: ' + this.getColorFromClassName( sourceGeom.className() ) + ';'\n        } );\n    },\n\n    // Subfunction of createGraph, will iterate to create all the node and link in dagre\n    generateNodeAndLink: function ( g ) {\n\n        for ( var i = 0, ni = this._nodeList.length; i < ni; i++ ) {\n            var node = this._nodeList[ i ];\n\n            // node\n            this.generateNode( g, node );\n\n            // adds statesets node\n            if ( node.getStateSet() ) {\n                this.generateStateSet( g, node );\n            }\n\n            // adds source geometry node\n            if ( node.getSourceGeometry && node.getSourceGeometry() instanceof MorphGeometry ) {\n                this.generateSourceGeometry( g, node );\n            }\n        }\n\n        for ( var j = 0, nj = this._linkList.length; j < nj; j++ ) {\n            g.addEdge( null, this._linkList[ j ].parentNode, this._linkList[ j ].childrenNode );\n        }\n    }\n} );\n\nmodule.exports = DisplayGraphNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/DisplayGraphNode.js\n// module id = 212\n// module chunks = 0 1 2","if(typeof __WEBPACK_EXTERNAL_MODULE_213__ === 'undefined') {var e = new Error(\"Cannot find module \\\"undefined\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_213__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"$\",\"commonjs2\":\"jquery\",\"commonjs\":\"jquery\",\"amd\":\"jquery\"}\n// module id = 213\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar CullSettings = require( 'osg/CullSettings' );\nvar CullVisitor = require( 'osg/CullVisitor' );\nvar Object = require( 'osg/Object' );\nvar RenderStage = require( 'osg/RenderStage' );\nvar State = require( 'osg/State' );\nvar StateGraph = require( 'osg/StateGraph' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar osgShader = require( 'osgShader/osgShader' );\nvar DisplayGraph = require( 'osgUtil/DisplayGraph' );\n\n\nvar Renderer = function ( camera ) {\n    Object.call( this );\n\n    this._state = undefined;\n    this._camera = camera;\n    this._renderStage = undefined;\n    this._stateGraph = undefined;\n\n    this._frameStamp = undefined;\n\n    this._previousCullsettings = new CullSettings();\n\n    this.setDefaults();\n};\n\nRenderer.debugGraph = false;\n\nRenderer.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    setDefaults: function () {\n\n        this._state = new State( new osgShader.ShaderGeneratorProxy() );\n\n        this._cullVisitor = new CullVisitor();\n        this._cullVisitor.setRenderer( this );\n        this._stateGraph = new StateGraph();\n\n        this.getCamera().setClearColor( vec4.create() );\n        this.setRenderStage( new RenderStage() );\n\n        var osg = require( 'osg/osg' );\n        var stateSet = this.getCamera().getOrCreateStateSet();\n        stateSet.setAttributeAndModes( new osg.Material() );\n        stateSet.setAttributeAndModes( new osg.Depth() );\n        stateSet.setAttributeAndModes( new osg.BlendFunc() );\n        stateSet.setAttributeAndModes( new osg.CullFace() );\n\n    },\n\n    getCullVisitor: function () {\n        return this._cullVisitor;\n    },\n\n    setCullVisitor: function ( cv ) {\n        if ( cv && !cv.getRenderer() ) cv.setRenderer( this );\n        this._cullVisitor = cv;\n    },\n\n    setRenderStage: function ( rs ) {\n        this._renderStage = rs;\n    },\n\n    getCamera: function () {\n        return this._camera;\n    },\n\n    setFrameStamp: function ( fs ) {\n        this._frameStamp = fs;\n    },\n\n    getFrameStamp: function () {\n        return this._frameStamp;\n    },\n\n    getState: function () {\n        return this._state;\n    },\n\n    setState: function ( state ) {\n        this._state = state;\n    },\n\n    setGraphicContext: function ( gc ) {\n        this._state.setGraphicContext( gc );\n    },\n\n    getGraphicContext: function () {\n        return this._state.getGraphicContext();\n    },\n\n    cullAndDraw: function () {\n        this.cull();\n        this.draw();\n    },\n\n    cull: function () {\n\n        var camera = this.getCamera();\n        var view = camera.getView();\n\n        this._cullVisitor.setFrameStamp( this._frameStamp );\n\n        // reset stats\n        this._cullVisitor.resetStats();\n\n        // this part of code should be called for each view\n        // right now, we dont support multi view\n        this._stateGraph.clean();\n        this._renderStage.reset();\n\n        this._cullVisitor.reset();\n        this._cullVisitor.setStateGraph( this._stateGraph );\n        this._cullVisitor.setRenderStage( this._renderStage );\n\n        this._cullVisitor.pushStateSet( camera.getStateSet() );\n\n        // save cullSettings\n        this._previousCullsettings.reset();\n        this._previousCullsettings.setCullSettings( this._cullVisitor );\n        this._cullVisitor.setCullSettings( camera );\n        if ( this._previousCullsettings.getSettingSourceOverrider() === this._cullVisitor && this._previousCullsettings.getEnableFrustumCulling() ) {\n            this._cullVisitor.setEnableFrustumCulling( true );\n        }\n\n        // Push reference on the projection stack, it means that if compute near/far\n        // is activated, it will update the projection matrix of the camera\n        this._cullVisitor.pushCameraModelViewProjectionMatrix( camera, camera.getViewMatrix(), camera.getProjectionMatrix() );\n\n        // update bound\n        camera.getBound();\n\n        var light = view.getLight();\n        var View = require( 'osgViewer/View' );\n\n        if ( light ) {\n\n            switch ( view.getLightingMode() ) {\n\n            case View.LightingMode.HEADLIGHT:\n                this._cullVisitor.addPositionedAttribute( null, light );\n                break;\n\n            case View.LightingMode.SKY_LIGHT:\n                this._cullVisitor.addPositionedAttribute( camera.getViewMatrix(), light );\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        this._cullVisitor.pushViewport( camera.getViewport() );\n\n\n        this._renderStage.setClearDepth( camera.getClearDepth() );\n        this._renderStage.setClearColor( camera.getClearColor() );\n        this._renderStage.setClearMask( camera.getClearMask() );\n        this._renderStage.setViewport( camera.getViewport() );\n\n        // pass de dbpager to the cullvisitor, so plod's can do the requests\n        this._cullVisitor.setDatabaseRequestHandler( this._camera.getView().getDatabasePager() );\n        // dont add camera on the stack just traverse it\n        this._cullVisitor.handleCullCallbacksAndTraverse( camera );\n\n        // fix projection matrix if camera has near/far auto compute\n        this._cullVisitor.popCameraModelViewProjectionMatrix( camera );\n\n        // Important notes about near/far\n        // If you are using the picking on the main camera and\n        // you use only children sub camera for RTT, your\n        // main camera will keep +/-infinity for near/far because\n        // the computation of near/far is done by camera and use Geometry\n\n\n        // restore previous state of the camera\n        this._cullVisitor.setCullSettings( this._previousCullsettings );\n\n        this._cullVisitor.popViewport();\n        this._cullVisitor.popStateSet();\n\n        this._renderStage.sort();\n\n    },\n\n    draw: function () {\n\n        var state = this.getState();\n\n        // important because cache are used in cullvisitor\n        state.resetCacheFrame();\n\n        // reset stats counter\n        state.resetStats();\n\n        this._renderStage.setCamera( this._camera );\n        this._renderStage.draw( state );\n\n        if ( Renderer.debugGraph ) {\n            DisplayGraph.instance().createRenderGraph( this._renderStage );\n            Renderer.debugGraph = false;\n        }\n\n        this._renderStage.setCamera( undefined );\n\n        state.applyDefault();\n\n    }\n\n\n} ), 'osgViewer', 'Renderer' );\n\nmodule.exports = Renderer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/Renderer.js\n// module id = 214\n// module chunks = 0 1 2","'use strict';\nvar BufferArray = require( 'osg/BufferArray' );\nvar Camera = require( 'osg/Camera' );\nvar FrameStamp = require( 'osg/FrameStamp' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar Light = require( 'osg/Light' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Texture = require( 'osg/Texture' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar Viewport = require( 'osg/Viewport' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\nvar IntersectionVisitor = require( 'osgUtil/IntersectionVisitor' );\nvar LineSegmentIntersector = require( 'osgUtil/LineSegmentIntersector' );\nvar Renderer = require( 'osgViewer/Renderer' );\nvar Scene = require( 'osgViewer/Scene' );\nvar DisplayGraph = require( 'osgUtil/DisplayGraph' );\nvar Notify = require( 'osg/notify' );\n\n\n// View is normally inherited from osg/View. In osgjs we dont need it yet\n// this split, so everything is in osgViewer/View\n\nvar View = function () {\n\n    this._camera = new Camera();\n    this._camera.setName( 'OSGJS camera' );\n\n    this._scene = new Scene();\n    this._camera.setName( 'OSGJS Scene' );\n\n    this._frameStamp = new FrameStamp();\n    this._lightingMode = undefined;\n    this._manipulator = undefined;\n    this._canvasWidth = 0;\n    this._canvasHeight = 0;\n\n    this._requestContinousUpdate = true;\n    this._requestRedraw = true;\n\n    this.setLightingMode( View.LightingMode.HEADLIGHT );\n    // assign a renderer to the camera\n    var renderer = this.createRenderer( this.getCamera() );\n    renderer.setFrameStamp( this._frameStamp );\n    this.getCamera().setRenderer( renderer );\n    this.getCamera().setView( this );\n\n};\n\nView.LightingMode = {\n    NO_LIGHT: 0,\n    HEADLIGHT: 1,\n    SKY_LIGHT: 2\n};\n\nView.prototype = {\n    requestRedraw: function () {\n        this._requestRedraw = true;\n    },\n    requestContinuousUpdate: function ( bool ) {\n        this._requestContinousUpdate = bool;\n    },\n    createRenderer: function ( camera ) {\n        var render = new Renderer( camera );\n        //camera->setStats(new osg::Stats(\"Camera\"));\n        return render;\n    },\n\n    setGraphicContext: function ( gc ) {\n        this.getCamera().getRenderer().getState().setGraphicContext( gc );\n    },\n\n    getGraphicContext: function () {\n        return this.getCamera().getRenderer().getState().getGraphicContext();\n    },\n\n\n    initWebGLCaps: function ( gl ) {\n\n        WebGLCaps.instance( gl );\n\n    },\n\n    // check Each frame because HTML standard inconsistencies\n    // - mobile full-screen, device orientation, etc\n    // peculiarity of webgl canvas resizing here some details\n    // http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    // screen size\n    // http://tripleodeon.com/2011/12/first-understand-your-screen/\n    // touchy is touchy: many things to know\n    // http://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    computeCanvasSize: ( function () {\n        return function ( canvas ) {\n\n            var clientWidth, clientHeight;\n            clientWidth = canvas.clientWidth;\n            clientHeight = canvas.clientHeight;\n\n            if ( clientWidth < 1 ) clientWidth = 1;\n            if ( clientHeight < 1 ) clientHeight = 1;\n\n            var devicePixelRatio = this._devicePixelRatio;\n\n            var widthPixel = Math.floor( clientWidth * devicePixelRatio );\n            var heightPixel = Math.floor( clientHeight * devicePixelRatio );\n\n            var hasChanged = false;\n            if ( this._canvasWidth !== widthPixel ) {\n                canvas.width = widthPixel;\n                this._canvasWidth = widthPixel;\n                hasChanged = true;\n            }\n\n            if ( this._canvasHeight !== heightPixel ) {\n                canvas.height = heightPixel;\n                this._canvasHeight = heightPixel;\n                hasChanged = true;\n            }\n            return hasChanged;\n        };\n    } )(),\n\n    getCanvasWidth: function () {\n        return this._canvasWidth;\n    },\n\n    getCanvasHeight: function () {\n        return this._canvasHeight;\n    },\n\n    getCanvasClientWidth: function () {\n        return Math.ceil( this._canvasWidth / this._devicePixelRatio );\n    },\n\n    getCanvasClientHeight: function () {\n        return Math.ceil( this._canvasHeight / this._devicePixelRatio );\n    },\n\n    getCanvasPixelRatio: function () {\n        // in case of VR headset, it's probably not relevant anymore\n        return this._devicePixelRatio;\n    },\n\n    setUpView: function ( canvas, options ) {\n\n\n        var devicePixelRatio = window.devicePixelRatio || 1;\n        var overrideDevicePixelRatio = options.getNumber( 'overrideDevicePixelRatio' );\n        var maxDevicePixelRatio = options.getNumber( 'maxDevicePixelRatio' ) || -1;\n\n        // override the pixel ratio, used to save pixel on mobile\n        if ( typeof overrideDevicePixelRatio === 'number' ) {\n            devicePixelRatio = overrideDevicePixelRatio;\n        } else if ( maxDevicePixelRatio !== -1 ) {\n            devicePixelRatio = Math.min( devicePixelRatio, maxDevicePixelRatio );\n        }\n        this._devicePixelRatio = devicePixelRatio;\n\n        this.computeCanvasSize( canvas );\n\n        var width = canvas.width;\n        var height = canvas.height;\n        var ratio = width / height;\n\n        this._camera.setViewport( new Viewport( 0, 0, width, height ) );\n\n        this._camera.setGraphicContext( this.getGraphicContext() );\n        mat4.lookAt( this._camera.getViewMatrix(), vec3.fromValues( 0.0, 0.0, -10.0 ), vec3.create(), vec3.fromValues( 0.0, 1.0, 0.0 ) );\n        mat4.perspective( this._camera.getProjectionMatrix(), Math.PI / 180 * 55, ratio, 1.0, 1000.0 );\n\n\n\n        if ( options && options.enableFrustumCulling )\n            this.getCamera().getRenderer().getCullVisitor().setEnableFrustumCulling( true );\n\n\n        // add a function to refresh the graph from the console\n        if ( options && options.debugGraph ) {\n\n            var camera = this.getCamera();\n            DisplayGraph.instance().refreshGraph = function () {\n                var displayGraph = DisplayGraph.instance();\n                displayGraph.setDisplayGraphRenderer( true );\n                displayGraph.createGraph( camera );\n            };\n\n            Notify.log( 'to refresh the graphs type in the console:\\nOSG.osgUtil.DisplayGraph.instance().refreshGraph()' );\n\n        }\n\n    },\n\n    /**\n     * X = 0 at the left\n     * Y = 0 at the BOTTOM\n     */\n    computeIntersections: function ( x, y, traversalMask ) {\n\n        /*jshint bitwise: false */\n        if ( traversalMask === undefined ) {\n            traversalMask = ~0;\n        }\n        /*jshint bitwise: true */\n\n\n        if ( !this._lsi ) {\n            this._lsi = new LineSegmentIntersector();\n        } else {\n            this._lsi.reset();\n        }\n\n        if ( !this._origIntersect ) {\n            this._origIntersect = vec3.create();\n            this._dstIntersect = vec3.create();\n        }\n\n        this._lsi.set( vec3.set( this._origIntersect, x, y, 0.0 ),\n            vec3.set( this._dstIntersect, x, y, 1.0 ) );\n\n\n        if ( !this._iv ) {\n            this._iv = new IntersectionVisitor();\n            this._iv.setIntersector( this._lsi );\n        } else {\n            this._iv.reset();\n        }\n        this._iv.setTraversalMask( traversalMask );\n        this._camera.accept( this._iv );\n\n        return this._lsi.getIntersections();\n    },\n\n    setFrameStamp: function ( frameStamp ) {\n        this._frameStamp = frameStamp;\n    },\n\n    getFrameStamp: function () {\n        return this._frameStamp;\n    },\n\n    setCamera: function ( camera ) {\n        this._camera = camera;\n    },\n\n    getCamera: function () {\n        return this._camera;\n    },\n\n    setSceneData: function ( node ) {\n\n        if ( node === this._scene.getSceneData() )\n            return;\n\n        this._scene.setSceneData( node );\n\n        this._camera.removeChildren();\n        this._camera.addChild( node );\n\n    },\n\n    getSceneData: function () {\n        return this._scene.getSceneData();\n    },\n\n    setDatabasePager: function ( dbpager ) {\n        this._scene.setDatabasePager( dbpager );\n    },\n\n    getDatabasePager: function () {\n        return this._scene.getDatabasePager();\n    },\n\n    getScene: function () {\n        return this._scene;\n    },\n\n    getManipulator: function () {\n        return this._manipulator;\n    },\n\n    setManipulator: function ( manipulator ) {\n        this._manipulator = manipulator;\n    },\n\n    getLight: function () {\n        return this._light;\n    },\n\n    setLight: function ( light ) {\n        this._light = light;\n        if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {\n            this._scene.getOrCreateStateSet().setAttributeAndModes( this._light );\n        }\n    },\n\n    getLightingMode: function () {\n        return this._lightingMode;\n    },\n\n    setLightingMode: function ( lightingMode ) {\n\n        if ( this._lightingMode !== lightingMode ) {\n            this._lightingMode = lightingMode;\n\n            if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {\n\n                if ( !this._light ) this._light = new Light();\n\n            } else {\n                this._light = undefined;\n            }\n        }\n    },\n\n    // In OSG this call is done in SceneView\n    flushDeletedGLObjects: function ( /*currentTime,*/ availableTime ) {\n        // Flush all deleted OpenGL objects within the specified availableTime\n        var gl = this.getGraphicContext();\n        availableTime = BufferArray.flushDeletedGLBufferArrays( gl, availableTime );\n        availableTime = Texture.getTextureManager( gl ).flushDeletedTextureObjects( gl, availableTime );\n        availableTime = Program.flushDeletedGLPrograms( gl, availableTime );\n        availableTime = Shader.flushDeletedGLShaders( gl, availableTime );\n        availableTime = FrameBufferObject.flushDeletedGLFrameBuffers( gl, availableTime );\n        availableTime = FrameBufferObject.flushDeletedGLRenderBuffers( gl, availableTime );\n    },\n\n    flushAllDeletedGLObjects: function () {\n        // Flush all deleted OpenGL objects\n        var gl = this.getGraphicContext();\n        BufferArray.flushAllDeletedGLBufferArrays( gl );\n        Texture.getTextureManager( gl ).flushAllDeletedTextureObjects( gl );\n        Program.flushAllDeletedGLPrograms( gl );\n        Shader.flushAllDeletedGLShaders( gl );\n        FrameBufferObject.flushAllDeletedGLFrameBuffers( gl );\n        FrameBufferObject.flushAllDeletedGLRenderBuffers( gl );\n    }\n};\n\nmodule.exports = View;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/View.js\n// module id = 215\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Object = require( 'osg/Object' );\nvar DatabasePager = require( 'osgDB/DatabasePager' );\n\n\nvar Scene = function () {\n    Object.call( this );\n    this._databasePager = new DatabasePager();\n    this._sceneData = undefined;\n};\n\nScene.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    getSceneData: function () {\n        return this._sceneData;\n    },\n\n    setSceneData: function ( node ) {\n        this._sceneData = node;\n    },\n\n    setDatabasePager: function ( dbpager ) {\n        this._databasePager = dbpager;\n    },\n\n    getDatabasePager: function () {\n        return this._databasePager;\n    },\n\n    // database pager are not implemented yet here\n    updateSceneGraph: function ( updateVisitor ) {\n        if ( this._databasePager )\n            this._databasePager.updateSceneGraph( updateVisitor.getFrameStamp() );\n        if ( this._sceneData )\n            this._sceneData.accept( updateVisitor );\n    }\n\n\n} ), 'osgViewer', 'Scene' );\n\nmodule.exports = Scene;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/Scene.js\n// module id = 216\n// module chunks = 0 1 2","'use strict';\nvar Node = require( 'osg/Node' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Depth = require( 'osg/Depth' );\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar CullFace = require( 'osg/CullFace' );\nvar Uniform = require( 'osg/Uniform' );\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar IntersectionVisitor = require( 'osgUtil/IntersectionVisitor' );\nvar LineSegmentIntersector = require( 'osgUtil/LineSegmentIntersector' );\nvar GizmoGeometry = require( 'osgUtil/gizmoGeometry' );\nvar TransformEnums = require( 'osg/transformEnums' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n\nvar getCanvasCoord = function ( vec, e ) {\n    vec[ 0 ] = e.offsetX === undefined ? e.layerX : e.offsetX;\n    vec[ 1 ] = e.offsetY === undefined ? e.layerY : e.offsetY;\n};\n\nvar HideCullCallback = function () {};\nHideCullCallback.prototype = {\n    cull: function () {\n        return false;\n    }\n};\n\nvar blendAttribute = new BlendFunc( BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA );\n\nvar LineCustomIntersector = function ( testPlane ) {\n    this._testPlane = testPlane; // intersection plane or line\n    this._inter = vec3.create(); // translate distance\n    LineSegmentIntersector.call( this );\n};\nLineCustomIntersector.prototype = MACROUTILS.objectInherit( LineSegmentIntersector.prototype, {\n    setTestPlane: function ( testPlane ) {\n        this._testPlane = testPlane; // intersection plane or line\n    },\n    getTranslateDistance: function () {\n        return this._inter;\n    },\n    enter: ( function () {\n        var axis = vec3.create();\n        var dir = vec3.create();\n\n        return function ( node ) {\n            if ( node._nbAxis === undefined )\n                return true;\n\n            vec3.init( axis );\n            axis[ node._nbAxis ] = 1.0;\n            if ( !this._testPlane ) {\n                // intersection line line\n                vec3.normalize( dir, vec3.sub( dir, this._iEnd, this._iStart ) );\n\n                var a01 = -vec3.dot( dir, axis );\n                var b0 = vec3.dot( this._iStart, dir );\n                var det = Math.abs( 1.0 - a01 * a01 );\n\n                var b1 = -vec3.dot( this._iStart, axis );\n                vec3.init( this._inter );\n                this._inter[ node._nbAxis ] = ( a01 * b0 - b1 ) / det;\n            } else {\n                // intersection line plane\n                var dist1 = vec3.dot( this._iStart, axis );\n                var dist2 = vec3.dot( this._iEnd, axis );\n                // ray copplanar to triangle\n                if ( dist1 === dist2 )\n                    return false;\n                // intersection between ray and triangle\n                var val = -dist1 / ( dist2 - dist1 );\n                this._inter[ 0 ] = this._iStart[ 0 ] + ( this._iEnd[ 0 ] - this._iStart[ 0 ] ) * val;\n                this._inter[ 1 ] = this._iStart[ 1 ] + ( this._iEnd[ 1 ] - this._iStart[ 1 ] ) * val;\n                this._inter[ 2 ] = this._iStart[ 2 ] + ( this._iEnd[ 2 ] - this._iStart[ 2 ] ) * val;\n            }\n            return false;\n        };\n    } )(),\n    intersect: function () {\n        return false;\n    }\n} );\n\n// The MT node can be detected as such because they\n// have a '_nbAxis' property on them (x=0, y=1, z=2)\n//\n// MatrixTransform _________________________________________\n//           |                    |                         |\n//    ____ Rotate             Translate               TranslatePlane\n//   |     / | \\                / | \\                     / | \\\n//   MT   MT MT MT             MT MT MT                  MT MT MT\n//   |     \\ | /                \\ | /                     \\ | /\n// FullArc  \\|/                  \\|/                       \\|/\n//       ____|_____            ___|________              ___|________\n//      |          |          |            |            |            |\n//   DrawArc   HideNode   DrawArrow    HideNode     DrawPlane    HideNode\n//                 |                       |                         |\n//              PickArc                PickArrow                  PickPlane\n//\nvar NodeGizmo = function ( viewer ) {\n    MatrixTransform.call( this );\n\n    this._tmask = 1; // traversal mask when picking the scene\n\n    // We can set this boolean to true if we want to insert a MatrixTransform just\n    // before the picked geometry.\n    // Otherwise, we simply select the first MatrixTransform with an 'editMask' property\n    this._autoInsertMT = false;\n\n    this._viewer = viewer;\n    this._canvas = viewer.getGraphicContext().canvas;\n    this._manipulator = viewer.getManipulator();\n\n    this._rotateNode = new MatrixTransform();\n    this._translateNode = new MatrixTransform();\n    this._planeNode = new MatrixTransform();\n\n    this._rotateInLocal = true; // local vs world space\n    this._translateInLocal = true; // local vs world space\n    this._showAngle = new MatrixTransform();\n\n    //for realtime picking\n    this._downCanvasCoord = vec2.create();\n    this._hoverNode = null; // the hovered x/y/z MT node\n    this._keepHoverColor = vec4.create();\n\n    // for editing\n    this._isEditing = false;\n\n    this._editLineOrigin = vec3.create();\n    this._editLineDirection = vec3.create();\n    this._editOffset = vec3.create();\n\n    // cached matrices when starting the editing operations\n    this._editLocal = mat4.create();\n    this._editWorldTrans = mat4.create();\n    this._editWorldScaleRot = mat4.create();\n    this._editInvWorldScaleRot = mat4.create();\n\n    // red line, it can be useful as helpers too\n    this._debugNode = new Node();\n\n    this._lastDistToEye = 0.0; // see updateGizmo comment\n\n    this._attachedNode = null;\n    this.attachToGeometry( null );\n\n    // Intersectors\n    this._lsi = new LineCustomIntersector();\n    this._origIntersect = vec3.create();\n    this._dstIntersect = vec3.create();\n    this._iv = new IntersectionVisitor();\n    this._iv.setIntersector( this._lsi );\n\n    // disable mouse camera event when interacting with gizmo\n    this._eventMouse = viewer._eventProxy.StandardMouseKeyboard;\n    this._enableMouseBack = false;\n\n    this.init();\n};\n\n// picking masks\nNodeGizmo.NO_PICK = 1 << 0;\n\nNodeGizmo.PICK_ARC_X = 1 << 1;\nNodeGizmo.PICK_ARC_Y = 1 << 2;\nNodeGizmo.PICK_ARC_Z = 1 << 3;\n\nNodeGizmo.PICK_ARROW_X = 1 << 4;\nNodeGizmo.PICK_ARROW_Y = 1 << 5;\nNodeGizmo.PICK_ARROW_Z = 1 << 6;\n\nNodeGizmo.PICK_PLANE_X = 1 << 7;\nNodeGizmo.PICK_PLANE_Y = 1 << 8;\nNodeGizmo.PICK_PLANE_Z = 1 << 9;\n\nNodeGizmo.NO_FULL_CIRCLE = 1 << 10; // don't display the full non pickable circle (visual cue)\n\nNodeGizmo.PICK_ARC = NodeGizmo.PICK_ARC_X | NodeGizmo.PICK_ARC_Y | NodeGizmo.PICK_ARC_Z;\nNodeGizmo.PICK_ARROW = NodeGizmo.PICK_ARROW_X | NodeGizmo.PICK_ARROW_Y | NodeGizmo.PICK_ARROW_Z;\nNodeGizmo.PICK_PLANE = NodeGizmo.PICK_PLANE_X | NodeGizmo.PICK_PLANE_Y | NodeGizmo.PICK_PLANE_Z;\n\nNodeGizmo.PICK_GIZMO = NodeGizmo.PICK_ARC | NodeGizmo.PICK_ARROW | NodeGizmo.PICK_PLANE;\n\nNodeGizmo.prototype = MACROUTILS.objectInherit( MatrixTransform.prototype, {\n\n    setRotateInLocal: function ( bool ) {\n        this._rotateInLocal = bool;\n    },\n\n    setTranslateInLocal: function ( bool ) {\n        this._translateInLocal = bool;\n    },\n\n    setTraversalMask: function ( tmask ) {\n        this._tmask = tmask;\n    },\n\n    isEditing: function () {\n        return this._isEditing;\n    },\n\n    init: function () {\n        this.getOrCreateStateSet().setAttributeAndModes( new Depth( Depth.DISABLE ) );\n        this.getOrCreateStateSet().setAttributeAndModes( new CullFace( CullFace.DISABLE ) );\n\n        var UpdateCallback = function () {};\n        UpdateCallback.prototype = {\n            update: this.updateGizmo.bind( this )\n        };\n        this.addUpdateCallback( new UpdateCallback() );\n        this.addChild( this.initNodeTranslate() );\n        this.addChild( this.initNodeTranslatePlane() );\n        this.addChild( this.initNodeRotate() );\n        if ( this._debugNode ) {\n            this._debugNode.addChild( GizmoGeometry.createDebugLineGeometry() );\n            this.addChild( this._debugNode );\n            this._debugNode.setNodeMask( 0x0 );\n        }\n\n        var canvas = this._canvas;\n        canvas.addEventListener( 'mousemove', this.onMouseMove.bind( this ) );\n        canvas.addEventListener( 'mousedown', this.onMouseDown.bind( this ) );\n        canvas.addEventListener( 'mouseup', this.onMouseUp.bind( this ) );\n        canvas.addEventListener( 'mouseout', this.onMouseUp.bind( this ) );\n    },\n\n    attachToNodePath: function ( nodepath ) {\n        var node;\n        if ( nodepath ) {\n            for ( var i = nodepath.length - 1; i >= 0; --i ) {\n                var editMask = nodepath[ i ].editMask || 0;\n                if ( editMask & NodeGizmo.PICK_GIZMO ) {\n                    node = nodepath[ i ];\n                    break;\n                }\n            }\n        }\n        if ( !node ) {\n            this._attachedNode = null;\n            this.setNodeMask( 0x0 );\n            return;\n        }\n\n        this._attachedNode = node;\n        this.updateGizmoMask();\n    },\n\n    attachToMatrixTransform: function ( node ) {\n        if ( !node ) {\n            this._attachedNode = null;\n            this.setNodeMask( 0x0 );\n            return;\n        }\n        if ( node.editMask === undefined )\n            node.editMask = NodeGizmo.PICK_GIZMO;\n\n        this._attachedNode = node;\n        this.updateGizmoMask();\n    },\n\n    attachToGeometry: function ( argNode ) {\n\n        var node = argNode;\n\n        if ( !node ) {\n            this._attachedNode = null;\n            this.setNodeMask( 0x0 );\n            return;\n        }\n\n        // insert MatrixTransform node before geometry node\n        var pr = node.getParents();\n        if ( pr[ 0 ].editMask === undefined ) {\n            var imt = new MatrixTransform();\n            while ( pr.length > 0 ) {\n                pr[ 0 ].addChild( imt );\n                pr[ 0 ].removeChild( node );\n            }\n            imt.addChild( node );\n            imt.editMask = NodeGizmo.PICK_GIZMO;\n            node = imt;\n        } else {\n            node = pr[ 0 ];\n        }\n\n        this._attachedNode = node;\n        this.updateGizmoMask();\n    },\n\n    updateGizmoMask: function () {\n        if ( !this._attachedNode ) {\n            this.setNodeMask( 0x0 );\n            return;\n        }\n\n        var mask = this._attachedNode.editMask;\n\n        this.setNodeMask( mask & NodeGizmo.PICK_GIZMO ? NodeGizmo.NO_PICK : 0x0 );\n\n        this._translateNode.setNodeMask( mask & NodeGizmo.PICK_ARROW ? NodeGizmo.PICK_ARROW : 0x0 );\n        this._rotateNode.setNodeMask( mask & NodeGizmo.PICK_ARC ? NodeGizmo.PICK_ARC : 0x0 );\n        this._planeNode.setNodeMask( mask & NodeGizmo.PICK_PLANE ? NodeGizmo.PICK_PLANE : 0x0 );\n\n        var transChildren = this._translateNode.getChildren();\n        transChildren[ 0 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_X ? NodeGizmo.PICK_ARROW_X : 0x0 );\n        transChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_Y ? NodeGizmo.PICK_ARROW_Y : 0x0 );\n        transChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_Z ? NodeGizmo.PICK_ARROW_Z : 0x0 );\n\n        // children 0 is full arc\n        var rotChildren = this._rotateNode.getChildren();\n        rotChildren[ 0 ].setNodeMask( mask & NodeGizmo.NO_FULL_CIRCLE ? 0x0 : NodeGizmo.NO_PICK );\n        rotChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_ARC_X ? NodeGizmo.PICK_ARC_X : 0x0 );\n        rotChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_ARC_Y ? NodeGizmo.PICK_ARC_Y : 0x0 );\n        rotChildren[ 3 ].setNodeMask( mask & NodeGizmo.PICK_ARC_Z ? NodeGizmo.PICK_ARC_Z : 0x0 );\n\n        var planeChildren = this._planeNode.getChildren();\n        planeChildren[ 0 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_X ? NodeGizmo.PICK_PLANE_X : 0x0 );\n        planeChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_Y ? NodeGizmo.PICK_PLANE_Y : 0x0 );\n        planeChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_Z ? NodeGizmo.PICK_PLANE_Z : 0x0 );\n    },\n\n    onNodeHovered: ( function () {\n        var hoverColor = vec4.fromValues( 1.0, 1.0, 0.0, 1.0 );\n\n        return function ( hit ) {\n\n            if ( this._hoverNode )\n                this._hoverNode.getStateSet().getUniform( 'uColor' ).setFloat4( this._keepHoverColor );\n            if ( !hit ) {\n                this._hoverNode = null;\n                return;\n            }\n\n            // stop at the first X/Y/Z matrix node\n            var np = hit.nodepath;\n            var i = np.length - 1;\n            var node = np[ i ];\n            while ( node._nbAxis === undefined ) {\n                if ( i === 0 )\n                    return;\n                node = np[ --i ];\n            }\n\n            var unif = node.getStateSet().getUniform( 'uColor' );\n            this._hoverNode = node;\n            vec4.copy( this._keepHoverColor, unif.getInternalArray() );\n            unif.setFloat4( hoverColor );\n        };\n    } )(),\n\n    initNodeRotate: function () {\n        var drawArcXYZ = GizmoGeometry.createTorusGeometry( 1.0, 0.01, 6, 64, Math.PI * 2 );\n        var drawArc = GizmoGeometry.createTorusGeometry( 1.0, 0.01, 6, 64, Math.PI );\n        var pickArc = GizmoGeometry.createTorusGeometry( 1.0, 0.1, 6, 64, Math.PI );\n\n        var mtXYZ = new MatrixTransform();\n        var mtX = new MatrixTransform();\n        var mtY = new MatrixTransform();\n        var mtZ = new MatrixTransform();\n        mtX._nbAxis = 0;\n        mtY._nbAxis = 1;\n        mtZ._nbAxis = 2;\n\n        var hideNode = new Node();\n        hideNode.setCullCallback( new HideCullCallback() );\n        hideNode.addChild( pickArc );\n\n        // set masks\n        drawArcXYZ.setNodeMask( NodeGizmo.NO_PICK );\n        drawArc.setNodeMask( NodeGizmo.NO_PICK );\n        mtX.setNodeMask( NodeGizmo.PICK_ARC_X );\n        mtY.setNodeMask( NodeGizmo.PICK_ARC_Y );\n        mtZ.setNodeMask( NodeGizmo.PICK_ARC_Z );\n\n        mtXYZ.addChild( drawArcXYZ );\n        mtX.addChild( drawArc );\n        mtY.addChild( drawArc );\n        mtZ.addChild( drawArc );\n\n        mtX.addChild( hideNode );\n        mtY.addChild( hideNode );\n        mtZ.addChild( hideNode );\n\n        mtXYZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.2, 0.2, 0.2, 1.0 ), 'uColor' ) );\n        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 1.0, 0.0, 0.0, 1.0 ), 'uColor' ) );\n        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 1.0, 0.0, 1.0 ), 'uColor' ) );\n        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 0.0, 1.0, 1.0 ), 'uColor' ) );\n\n        var showAngle = this._showAngle;\n        showAngle.getOrCreateStateSet().setAttributeAndModes( blendAttribute );\n        showAngle.setNodeMask( 0x0 );\n        showAngle.getOrCreateStateSet().addUniform( Uniform.createFloat3( vec3.fromValues( 1.0, 0.0, 0.0 ), 'uBase' ) );\n        showAngle.getOrCreateStateSet().addUniform( Uniform.createFloat( 0.0, 'uAngle' ) );\n        showAngle.addChild( GizmoGeometry.createQuadCircleGeometry() );\n\n        var rotate = this._rotateNode;\n        rotate.setNodeMask( NodeGizmo.PICK_ARC );\n        rotate.addChild( mtXYZ );\n        rotate.addChild( mtX );\n        rotate.addChild( mtY );\n        rotate.addChild( mtZ );\n        rotate.addChild( showAngle );\n        return rotate;\n    },\n\n    initNodeTranslate: function () {\n        var aHeight = 1.5;\n        var aConeHeight = 0.3;\n        var pickStart = 0.5; // offset (because of the picking plane)\n        var pickHeight = ( aHeight - pickStart + aConeHeight ) * 1.1;\n\n        // cone arrow\n        var mtCone = new MatrixTransform();\n        mat4.fromTranslation( mtCone.getMatrix(), vec3.fromValues( 0.0, 0.0, aHeight + aConeHeight * 0.5 ) );\n        mtCone.addChild( GizmoGeometry.createCylinderGeometry( 0.0, 0.07, aConeHeight, 32, 1, true, true ) );\n        // arrow base\n        var mtArrow = new MatrixTransform();\n        mat4.fromTranslation( mtArrow.getMatrix(), vec3.fromValues( 0.0, 0.0, aHeight * 0.5 ) );\n        mtArrow.addChild( GizmoGeometry.createCylinderGeometry( 0.01, 0.01, aHeight, 32, 1, true, true ) );\n        // draw arrow\n        var drawArrow = new Node();\n        drawArrow.addChild( mtArrow );\n        drawArrow.addChild( mtCone );\n\n        var pickArrow = GizmoGeometry.createCylinderGeometry( 0.1, 0.1, pickHeight, 32, 1, true, true );\n\n        var mtX = new MatrixTransform();\n        var mtY = new MatrixTransform();\n        var mtZ = new MatrixTransform();\n        mtX._nbAxis = 0;\n        mtY._nbAxis = 1;\n        mtZ._nbAxis = 2;\n\n        mat4.fromRotation( mtX.getMatrix(), Math.PI * 0.5, vec3.fromValues( 0.0, 1.0, 0.0 ) );\n        mat4.fromRotation( mtY.getMatrix(), -Math.PI * 0.5, vec3.fromValues( 1.0, 0.0, 0.0 ) );\n\n        var hideNode = new MatrixTransform();\n        hideNode.setCullCallback( new HideCullCallback() );\n        mat4.fromTranslation( hideNode.getMatrix(), vec3.fromValues( 0.0, 0.0, pickStart + pickHeight * 0.5 ) );\n        hideNode.addChild( pickArrow );\n\n        // set masks\n        drawArrow.setNodeMask( NodeGizmo.NO_PICK );\n        mtX.setNodeMask( NodeGizmo.PICK_ARROW_X );\n        mtY.setNodeMask( NodeGizmo.PICK_ARROW_Y );\n        mtZ.setNodeMask( NodeGizmo.PICK_ARROW_Z );\n\n        mtX.addChild( drawArrow );\n        mtY.addChild( drawArrow );\n        mtZ.addChild( drawArrow );\n\n        mtX.addChild( hideNode );\n        mtY.addChild( hideNode );\n        mtZ.addChild( hideNode );\n\n        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 1.0, 0.0, 0.0, 1.0 ), 'uColor' ) );\n        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 1.0, 0.0, 1.0 ), 'uColor' ) );\n        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 0.0, 1.0, 1.0 ), 'uColor' ) );\n\n        var translate = this._translateNode;\n        translate.setNodeMask( NodeGizmo.PICK_ARROW );\n        translate.addChild( mtX );\n        translate.addChild( mtY );\n        translate.addChild( mtZ );\n        return translate;\n    },\n\n    initNodeTranslatePlane: function () {\n        var mtPlane = new MatrixTransform();\n        mat4.fromTranslation( mtPlane.getMatrix(), vec3.fromValues( 0.5, 0.5, 0.0 ) );\n        mat4.mul( mtPlane.getMatrix(), mat4.fromScaling( mat4.create(), vec3.fromValues( 0.5, 0.5, 1.0 ) ), mtPlane.getMatrix() );\n        mtPlane.addChild( GizmoGeometry.createPlaneGeometry() );\n\n        var mtX = new MatrixTransform();\n        var mtY = new MatrixTransform();\n        var mtZ = new MatrixTransform();\n        mtX._nbAxis = 0;\n        mtY._nbAxis = 1;\n        mtZ._nbAxis = 2;\n\n        mat4.fromRotation( mtX.getMatrix(), -Math.PI * 0.5, vec3.fromValues( 0.0, 1.0, 0.0 ) );\n        mat4.fromRotation( mtY.getMatrix(), Math.PI * 0.5, vec3.fromValues( 1.0, 0.0, 0.0 ) );\n\n        // set masks\n        mtX.setNodeMask( NodeGizmo.PICK_PLANE_X );\n        mtY.setNodeMask( NodeGizmo.PICK_PLANE_Y );\n        mtZ.setNodeMask( NodeGizmo.PICK_PLANE_Z );\n\n        mtX.addChild( mtPlane );\n        mtY.addChild( mtPlane );\n        mtZ.addChild( mtPlane );\n\n        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 1.0, 0.0, 0.0, 0.3 ), 'uColor' ) );\n        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 1.0, 0.0, 0.3 ), 'uColor' ) );\n        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( vec4.fromValues( 0.0, 0.0, 1.0, 0.3 ), 'uColor' ) );\n\n        var plane = this._planeNode;\n        plane.setNodeMask( NodeGizmo.PICK_PLANE );\n        plane.getOrCreateStateSet().setAttributeAndModes( blendAttribute );\n        plane.addChild( mtX );\n        plane.addChild( mtY );\n        plane.addChild( mtZ );\n        return plane;\n    },\n\n    updateArcRotation: ( function () {\n        var qTmp = quat.create();\n        var quatx = quat.setAxisAngle( quat.create(), [ 0.0, 1.0, 0.0 ], -Math.PI * 0.5 );\n        var quaty = quat.setAxisAngle( quat.create(), [ 1.0, 0.0, 0.0 ], -Math.PI * 0.5 );\n        return function ( eye ) {\n            var rotateNode = this._rotateNode;\n            var arcs = rotateNode.getChildren();\n            // eye arc\n            qTmp[ 0 ] = -eye[ 1 ];\n            qTmp[ 1 ] = eye[ 0 ];\n            qTmp[ 2 ] = 0.0;\n            qTmp[ 3 ] = 1.0 + eye[ 2 ];\n            quat.normalize( qTmp, qTmp );\n            mat4.fromQuat( arcs[ 0 ].getMatrix(), qTmp );\n            // x arc\n            quat.setAxisAngle( qTmp, [ 1.0, 0.0, 0.0 ], Math.atan2( eye[ 2 ], eye[ 1 ] ) );\n            quat.mul( qTmp, qTmp, quatx );\n            mat4.fromQuat( arcs[ 1 ].getMatrix(), qTmp );\n            // y arc\n            quat.setAxisAngle( qTmp, [ 0.0, 1.0, 0.0 ], Math.atan2( -eye[ 0 ], -eye[ 2 ] ) );\n            quat.mul( qTmp, qTmp, quaty );\n            mat4.fromQuat( arcs[ 2 ].getMatrix(), qTmp );\n            // z arc\n            quat.setAxisAngle( qTmp, [ 0.0, 0.0, 1.0 ], Math.atan2( -eye[ 0 ], eye[ 1 ] ) );\n            mat4.fromQuat( arcs[ 3 ].getMatrix(), qTmp );\n\n            arcs[ 1 ].dirtyBound();\n            arcs[ 2 ].dirtyBound();\n            arcs[ 3 ].dirtyBound();\n        };\n    } )(),\n\n    getTransformType: function ( node ) {\n        var n = node;\n        while ( n.getParents().length > 0 ) {\n            if ( n.referenceFrame !== undefined && n.referenceFrame === TransformEnums.ABSOLUTE_RF )\n                return TransformEnums.ABSOLUTE_RF;\n            n = n.getParents()[ 0 ];\n        }\n        return TransformEnums.RELATIVE_RF;\n    },\n\n    updateGizmo: ( function () {\n        var eye = vec3.create();\n        var trVec = vec3.create();\n        var tmpVec = vec3.create();\n\n        var temp = mat4.create();\n        var trWorld = mat4.create();\n        var invScale = mat4.create();\n        var scGiz = mat4.create();\n\n        return function () {\n            if ( !this._attachedNode )\n                return;\n            var ttype = this.getTransformType( this._attachedNode );\n            this.setReferenceFrame( ttype );\n            this.setCullingActive( ttype === TransformEnums.RELATIVE_RF );\n            var worldMat = this._attachedNode.getWorldMatrices()[ 0 ];\n\n            // world trans\n            mat4.getTranslation( trVec, worldMat );\n            mat4.fromTranslation( trWorld, trVec );\n\n            // normalize gizmo size\n            var scaleFactor = 3.0;\n            if ( ttype === TransformEnums.ABSOLUTE_RF ) {\n                eye[ 0 ] = eye[ 1 ] = eye[ 2 ] = 0.0;\n                tmpVec[ 0 ] = tmpVec[ 1 ] = tmpVec[ 2 ] = 1.0;\n            } else {\n                // normalize gizmo size relative to screen size\n                var proj = this._viewer.getCamera().getProjectionMatrix();\n                var scaleFov = this._canvas.clientWidth * 0.023 * proj[ 0 ];\n                this._manipulator.getEyePosition( eye );\n                // while we are editing we don't normalize the gizmo\n                // it gives a better depth feedback, especially if we are editing a geometry that has\n                // a constant screen size (for example an icon)\n                this._lastDistToEye = this._isEditing ? this._lastDistToEye : vec3.distance( trVec, eye );\n                scaleFactor *= this._lastDistToEye / scaleFov;\n            }\n            mat4.fromScaling( scGiz, [ scaleFactor, scaleFactor, scaleFactor ] );\n\n            // gizmo node\n            mat4.mul( this.getMatrix(), trWorld, scGiz );\n\n            vec3.sub( eye, eye, trVec );\n            vec3.normalize( eye, eye );\n\n            // rotate node\n            if ( this._rotateInLocal || this._translateInLocal ) {\n                // world scale\n                mat4.getScale( tmpVec, worldMat );\n                mat4.fromScaling( invScale, tmpVec );\n                mat4.invert( invScale, invScale );\n\n                mat4.mul( temp, worldMat, invScale );\n                temp[ 12 ] = temp[ 13 ] = temp[ 14 ] = 0.0;\n\n                if ( this._translateInLocal ) {\n                    mat4.copy( this._translateNode.getMatrix(), temp );\n                    mat4.copy( this._planeNode.getMatrix(), temp );\n                }\n\n                if ( this._rotateInLocal ) {\n                    mat4.copy( this._rotateNode.getMatrix(), temp );\n                    mat4.invert( temp, temp );\n                    vec3.transformMat4( eye, eye, temp );\n                }\n            } else {\n                mat4.identity( this._rotateNode.getMatrix() );\n            }\n\n            this.updateArcRotation( eye );\n\n            this._rotateNode.dirtyBound();\n            this._translateNode.dirtyBound();\n            this._planeNode.dirtyBound();\n\n            if ( this._isEditing )\n                mat4.copy( this._showAngle.getMatrix(), this._hoverNode.getMatrix() );\n        };\n    } )(),\n\n    computeNearestIntersection: ( function () {\n        var sortByRatio = function ( a, b ) {\n            return a.ratio - b.ratio;\n        };\n        var coord = vec2.create();\n\n        return function ( e, tmask ) {\n            getCanvasCoord( coord, e );\n\n            // canvas to webgl coord\n            var viewer = this._viewer;\n            var canvas = this._canvas;\n            var x = coord[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );\n            var y = ( canvas.clientHeight - coord[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );\n\n            var hits = this._viewer.computeIntersections( x, y, tmask );\n\n            if ( hits.length === 0 )\n                return undefined;\n\n            hits.sort( sortByRatio );\n            return hits[ 0 ];\n        };\n    } )(),\n\n    setOnlyGizmoPicking: function () {\n        // enable picking only for the gizmo\n        this._viewer.getCamera().addChild( this );\n        this._viewer.getSceneData().setNodeMask( 0x0 );\n        this.setNodeMask( ~0x0 );\n    },\n\n    setOnlyScenePicking: function () {\n        this._viewer.getCamera().removeChild( this );\n        this._viewer.getSceneData().setNodeMask( ~0x0 );\n        this.setNodeMask( NodeGizmo.NO_PICK );\n    },\n\n    pickGizmo: function ( e, tmask ) {\n        this.setOnlyGizmoPicking();\n        var hit = this.computeNearestIntersection( e, tmask );\n        this.setOnlyScenePicking();\n        return hit;\n    },\n\n    getCanvasPositionFromWorldPoint: ( function () {\n        var mat = mat4.create();\n\n        return function ( worldPoint, out ) {\n            var cam = this._viewer.getCamera();\n\n            var screenPoint = out;\n\n            if ( cam.getViewport() ) {\n                cam.getViewport().computeWindowMatrix( mat );\n            } else {\n                mat4.identity( mat );\n            }\n\n            mat4.mul( mat, mat, cam.getProjectionMatrix() );\n            if ( this.getReferenceFrame() === TransformEnums.RELATIVE_RF )\n                mat4.mul( mat, mat, cam.getViewMatrix() );\n\n            vec3.transformMat4( screenPoint, worldPoint, mat );\n\n            // canvas to webgl coord\n            var viewer = this._viewer;\n            var canvas = this._canvas;\n            screenPoint[ 0 ] = screenPoint[ 0 ] / ( viewer._canvasWidth / canvas.clientWidth );\n            screenPoint[ 1 ] = canvas.clientHeight - screenPoint[ 1 ] / ( viewer._canvasHeight / canvas.clientHeight );\n            return screenPoint;\n        };\n    } )(),\n\n    onMouseDown: function ( e ) {\n        getCanvasCoord( this._downCanvasCoord, e );\n        if ( !this._hoverNode || !this._attachedNode )\n            return;\n\n        this._enableMouseBack = this._eventMouse.getEnable();\n        this._eventMouse.setEnable( false );\n\n        this.saveEditMatrices();\n        var nm = this._hoverNode.getParents()[ 0 ].getNodeMask();\n        this._isEditing = true;\n\n        if ( nm & NodeGizmo.PICK_ARC ) {\n            this._translateNode.setNodeMask( 0x0 );\n            this._planeNode.setNodeMask( 0x0 );\n            this.startRotateEdit( e );\n        } else if ( nm & NodeGizmo.PICK_ARROW ) {\n            this._rotateNode.setNodeMask( 0x0 );\n            this._planeNode.setNodeMask( 0x0 );\n            this.startTranslateEdit( e );\n        } else if ( nm & NodeGizmo.PICK_PLANE ) {\n            this._rotateNode.setNodeMask( 0x0 );\n            this._translateNode.setNodeMask( 0x0 );\n            this.startPlaneEdit( e );\n        }\n    },\n\n    saveEditMatrices: function () {\n        mat4.copy( this._editLocal, this._attachedNode.getMatrix() );\n        // save the world translation\n        var wm = this._attachedNode.getWorldMatrices()[ 0 ];\n        mat4.fromTranslation( this._editWorldTrans, vec3.fromValues( wm[ 12 ], wm[ 13 ], wm[ 14 ] ) );\n        // save the inv of world rotation + scale\n        mat4.copy( this._editWorldScaleRot, wm );\n        // removes translation\n        this._editWorldScaleRot[ 12 ] = this._editWorldScaleRot[ 13 ] = this._editWorldScaleRot[ 14 ] = 0.0;\n        mat4.invert( this._editInvWorldScaleRot, this._editWorldScaleRot );\n    },\n\n    startRotateEdit: function ( e ) {\n        var gizmoMat = this._rotateNode.getWorldMatrices()[ 0 ];\n\n        // center of gizmo on screen\n        var projCenter = vec3.create();\n        vec3.transformMat4( projCenter, projCenter, gizmoMat );\n        this.getCanvasPositionFromWorldPoint( projCenter, projCenter );\n\n        // pick rotate gizmo\n        var hit = this.pickGizmo( e, this._hoverNode.getNodeMask() | NodeGizmo.PICK_ARC );\n        if ( !hit ) return;\n\n        // compute tangent direction\n        var sign = this._hoverNode._nbAxis === 0 ? -1.0 : 1.0;\n        var tang = vec3.create();\n        tang[ 0 ] = sign * hit.point[ 1 ];\n        tang[ 1 ] = -sign * hit.point[ 0 ];\n        tang[ 2 ] = hit.point[ 2 ];\n\n        // project tangent on screen\n        var projArc = vec3.create();\n        vec3.transformMat4( projArc, tang, this._hoverNode.getMatrix() );\n        vec3.transformMat4( projArc, projArc, gizmoMat );\n        this.getCanvasPositionFromWorldPoint( projArc, projArc );\n\n        var dir = this._editLineDirection;\n        vec2.sub( dir, projArc, projCenter );\n        vec2.normalize( dir, dir );\n\n        // show angle\n        this._showAngle.setNodeMask( NodeGizmo.NO_PICK );\n        hit.point[ 2 ] = 0.0;\n        var stateAngle = this._showAngle.getStateSet();\n        stateAngle.getUniform( 'uAngle' ).setFloat( 0.0 );\n        stateAngle.getUniform( 'uBase' ).setVec3( vec3.normalize( hit.point, hit.point ) );\n\n        getCanvasCoord( this._editLineOrigin, e );\n    },\n\n    startTranslateEdit: function ( e ) {\n        var origin = this._editLineOrigin;\n        var dir = this._editLineDirection;\n\n        // 3d origin (center of gizmo)\n        var gizmoMat = this._translateNode.getWorldMatrices()[ 0 ];\n        mat4.getTranslation( origin, gizmoMat );\n\n        // 3d direction\n        vec3.init( dir );\n        dir[ this._hoverNode._nbAxis ] = 1.0;\n        if ( this._translateInLocal ) {\n            vec3.transformMat4( dir, dir, this._editWorldScaleRot );\n            vec3.normalize( dir, dir );\n        }\n        vec3.add( dir, origin, dir );\n\n        // project on canvas\n        this.getCanvasPositionFromWorldPoint( origin, origin );\n        this.getCanvasPositionFromWorldPoint( dir, dir );\n\n        vec2.sub( dir, dir, origin );\n        vec2.normalize( dir, dir );\n\n        var offset = this._editOffset;\n        getCanvasCoord( offset, e );\n        vec2.sub( offset, offset, origin );\n    },\n\n    startPlaneEdit: function ( e ) {\n        var origin = this._editLineOrigin; // just used to determine the 2d offset\n\n        // 3d origin (center of gizmo)\n        var gizmoMat = this._planeNode.getWorldMatrices()[ 0 ];\n        mat4.getTranslation( origin, gizmoMat );\n\n        // project on canvas\n        this.getCanvasPositionFromWorldPoint( origin, origin );\n\n        var offset = this._editOffset;\n        getCanvasCoord( offset, e );\n        vec2.sub( offset, offset, origin );\n    },\n\n    drawLineCanvasDebug: function ( x1, y1, x2, y2 ) {\n        this._debugNode.setNodeMask( NodeGizmo.NO_PICK );\n        var buffer = this._debugNode.getChildren()[ 0 ].getAttributes().Vertex;\n        buffer.getElements()[ 0 ] = ( ( x1 / this._canvas.clientWidth ) * 2 ) - 1.0;\n        buffer.getElements()[ 1 ] = ( ( ( this._canvas.clientHeight - y1 ) / this._canvas.clientHeight ) ) * 2 - 1.0;\n        buffer.getElements()[ 2 ] = ( ( x2 / this._canvas.clientWidth ) * 2 ) - 1.0;\n        buffer.getElements()[ 3 ] = ( ( ( this._canvas.clientHeight - y2 ) / this._canvas.clientHeight ) ) * 2 - 1.0;\n        buffer.dirty();\n    },\n\n    pickAndSelect: function ( e ) {\n        this.setNodeMask( 0x0 );\n        var hit = this.computeNearestIntersection( e, this._tmask );\n        if ( this._autoInsertMT )\n            this.attachToGeometry( hit ? hit.nodepath[ hit.nodepath.length - 1 ] : hit );\n        else\n            this.attachToNodePath( hit ? hit.nodepath : hit );\n    },\n\n    onMouseUp: function ( e ) {\n        if ( this._enableMouseBack ) {\n            this._enableMouseBack = false;\n            this._eventMouse.setEnable( true );\n            this._eventMouse.mouseup( e );\n        }\n\n        if ( this._debugNode )\n            this._debugNode.setNodeMask( 0x0 );\n\n        var v = vec2.create();\n        getCanvasCoord( v, e );\n        if ( vec2.distance( v, this._downCanvasCoord ) === 0.0 )\n            this.pickAndSelect( e );\n\n        this._showAngle.setNodeMask( 0x0 );\n        this._isEditing = false;\n        if ( !this._hoverNode )\n            return;\n        this.updateGizmoMask();\n    },\n\n    onMouseMove: function ( e ) {\n        if ( !this._attachedNode )\n            return;\n        var hit;\n        if ( this._isEditing === false ) {\n            hit = this.pickGizmo( e, NodeGizmo.PICK_GIZMO );\n            this.onNodeHovered( hit );\n            return;\n        }\n\n        if ( !this._hoverNode )\n            return;\n\n        var par = this._hoverNode.getParents()[ 0 ];\n        if ( par === this._rotateNode )\n            this.updateRotateEdit( e );\n        else if ( par === this._translateNode )\n            this.updateTranslateEdit( e );\n        else if ( par === this._planeNode )\n            this.updatePlaneEdit( e );\n    },\n\n    updateRotateEdit: ( function () {\n        var mrot = mat4.create();\n        var vec = vec2.create();\n        var right = vec3.fromValues( 1.0, 0.0, 0.0 );\n        var upy = vec3.fromValues( 0.0, 1.0, 0.0 );\n        var upz = vec3.fromValues( 0.0, 0.0, 1.0 );\n        return function ( e ) {\n\n            var origin = this._editLineOrigin;\n            var dir = this._editLineDirection;\n\n            getCanvasCoord( vec, e );\n            vec2.sub( vec, vec, origin );\n            var dist = vec2.dot( vec, dir );\n\n            if ( this._debugNode )\n                this.drawLineCanvasDebug( origin[ 0 ], origin[ 1 ], origin[ 0 ] + dir[ 0 ] * dist, origin[ 1 ] + dir[ 1 ] * dist );\n\n            var angle = 7 * dist / Math.min( this._canvas.clientWidth, this._canvas.clientHeight );\n            angle %= ( Math.PI * 2 );\n            var nbAxis = this._hoverNode._nbAxis;\n            if ( nbAxis === 0 )\n                mat4.fromRotation( mrot, -angle, right );\n            else if ( nbAxis === 1 )\n                mat4.fromRotation( mrot, -angle, upy );\n            else if ( nbAxis === 2 )\n                mat4.fromRotation( mrot, -angle, upz );\n\n            this._showAngle.getOrCreateStateSet().getUniform( 'uAngle' ).setFloat( nbAxis === 0 ? -angle : angle );\n\n            if ( !this._rotateInLocal ) {\n                mat4.mul( mrot, this._editInvWorldScaleRot, mrot );\n                mat4.mul( mrot, mrot, this._editWorldScaleRot );\n            }\n\n            mat4.mul( this._attachedNode.getMatrix(), this._editLocal, mrot );\n\n            this._attachedNode.dirtyBound();\n        };\n    } )(),\n\n    updateTranslateEdit: ( function () {\n        var vec = vec2.create();\n        var tra = vec3.create();\n\n        return function ( e ) {\n\n            var origin = this._editLineOrigin;\n            var dir = this._editLineDirection;\n\n            getCanvasCoord( vec, e );\n            vec2.sub( vec, vec, origin );\n            vec2.sub( vec, vec, this._editOffset );\n\n            var dist = vec2.dot( vec, dir );\n            vec[ 0 ] = origin[ 0 ] + dir[ 0 ] * dist;\n            vec[ 1 ] = origin[ 1 ] + dir[ 1 ] * dist;\n\n            if ( this._debugNode )\n                this.drawLineCanvasDebug( origin[ 0 ], origin[ 1 ], vec[ 0 ], vec[ 1 ] );\n\n            // canvas to webgl coord\n            var viewer = this._viewer;\n            var canvas = this._canvas;\n            var coordx = vec[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );\n            var coordy = ( canvas.clientHeight - vec[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );\n\n            // project 2D point on the 3d line\n            this._lsi.reset();\n            this._lsi.setTestPlane( false );\n            this._lsi.set( vec3.set( this._origIntersect, coordx, coordy, 0.0 ),\n                vec3.set( this._dstIntersect, coordx, coordy, 1.0 ) );\n            this._iv.reset();\n            this._iv.setTraversalMask( this._hoverNode.getNodeMask() );\n\n            mat4.copy( this.getMatrix(), this._editWorldTrans );\n\n            this.setOnlyGizmoPicking();\n            this._viewer._camera.accept( this._iv );\n            this.setOnlyScenePicking();\n\n            if ( !this._translateInLocal ) {\n                vec3.transformMat4( tra, this._lsi.getTranslateDistance(), this._editInvWorldScaleRot );\n            } else {\n                mat4.getScale( tra, this._editInvWorldScaleRot );\n\n                var inter = this._lsi.getTranslateDistance();\n                vec3.mul( tra, tra, inter );\n            }\n\n            mat4.translate( this._attachedNode.getMatrix(), this._editLocal, tra );\n\n            this._attachedNode.dirtyBound();\n        };\n    } )(),\n\n    updatePlaneEdit: ( function () {\n        var vec = vec2.create();\n        var tra = vec3.create();\n\n        return function ( e ) {\n            getCanvasCoord( vec, e );\n            vec2.sub( vec, vec, this._editOffset );\n\n            // canvas to webgl coord\n            var viewer = this._viewer;\n            var canvas = this._canvas;\n            var coordx = vec[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );\n            var coordy = ( canvas.clientHeight - vec[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );\n\n            // project 2D point on the 3d plane\n            this._lsi.reset();\n            this._lsi.setTestPlane( true );\n            this._lsi.set( vec3.set( this._origIntersect, coordx, coordy, 0.0 ),\n                vec3.set( this._dstIntersect, coordx, coordy, 1.0 ) );\n            this._iv.reset();\n            this._iv.setTraversalMask( this._hoverNode.getNodeMask() );\n\n            mat4.copy( this.getMatrix(), this._editWorldTrans );\n\n            this.setOnlyGizmoPicking();\n            this._viewer._camera.accept( this._iv );\n            this.setOnlyScenePicking();\n\n            if ( !this._translateInLocal ) {\n                vec3.transformMat4( tra, this._lsi.getTranslateDistance(), this._editInvWorldScaleRot );\n            } else {\n                mat4.getScale( tra, this._editInvWorldScaleRot );\n                var inter = this._lsi.getTranslateDistance();\n                vec3.mul( tra, tra, inter );\n            }\n\n            mat4.translate( this._attachedNode.getMatrix(), this._editLocal, tra );\n\n            this._attachedNode.dirtyBound();\n        };\n    } )()\n\n} );\n\nmodule.exports = NodeGizmo;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/NodeGizmo.js\n// module id = 217\n// module chunks = 0 1 2","'use strict';\nvar BufferArray = require( 'osg/BufferArray' );\nvar Geometry = require( 'osg/Geometry' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar DrawArrays = require( 'osg/DrawArrays' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\n\n\nvar glPrecision = [ '#ifdef GL_ES',\n    'precision highp float;',\n    '#endif'\n].join( '\\n' );\n\nvar program;\nvar getOrCreateShader = function () {\n    if ( program )\n        return program;\n    var shaderName = '#define SHADER_NAME GizmoLine3D';\n    var vertexshader = [\n        glPrecision,\n        'attribute vec3 Vertex;',\n        'uniform mat4 uModelViewMatrix;',\n        'uniform mat4 uProjectionMatrix;',\n        shaderName,\n        '',\n        'void main(void) {',\n        '  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex, 1.0);',\n        '}'\n    ].join( '\\n' );\n\n    var fragmentshader = [\n        glPrecision,\n        'uniform vec4 uColor;',\n        shaderName,\n        '',\n        'void main(void) {',\n        '  gl_FragColor = uColor;',\n        '}'\n    ].join( '\\n' );\n\n    program = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),\n        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\n    return program;\n};\n\nvar program2D;\nvar getOrCreateShader2D = function () {\n    if ( program2D )\n        return program2D;\n    var shaderName = '#define SHADER_NAME GizmoLine2D';\n    var vertexshader = [\n        glPrecision,\n        'attribute vec2 Vertex;',\n        shaderName,\n        '',\n        'void main(void) {',\n        '  gl_Position = vec4(Vertex, 0.0, 1.0);',\n        '}'\n    ].join( '\\n' );\n\n    var fragmentshader = [\n        glPrecision,\n        shaderName,\n        '',\n        'void main(void) {',\n        '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',\n        '}'\n    ].join( '\\n' );\n\n    program2D = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),\n        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\n    return program2D;\n};\n\nvar programQC;\nvar getOrCreateShaderQuadCircle = function () {\n    if ( programQC )\n        return programQC;\n    var shaderName = '#define SHADER_NAME GizmoQuadCircle';\n    var vertexshader = [\n        glPrecision,\n        'attribute vec3 Vertex;',\n        'uniform mat4 uModelViewMatrix;',\n        'uniform mat4 uProjectionMatrix;',\n        'varying vec3 vViewVertex;',\n        shaderName,\n        '',\n        'void main(void) {',\n        '  vViewVertex = Vertex;',\n        '  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(Vertex, 1.0);',\n        '}'\n    ].join( '\\n' );\n\n    var fragmentshader = [\n        glPrecision,\n        'uniform float uAngle;',\n        'uniform vec3 uBase;',\n        'varying vec3 vViewVertex;',\n        'const float PI = 3.14159265358979323846264;',\n        'const float PI2 = PI * 2.0;',\n        shaderName,\n        '',\n        'void main(void) {',\n        '  if(length(vViewVertex) > 0.5)',\n        '    discard;',\n        '  vec3 vn = normalize(vViewVertex);',\n        '  float angle = atan(uBase.y * vn.x - uBase.x * vn.y, dot(uBase, vn));',\n        '  if(angle > 0.0) {',\n        '    if(uAngle >= 0.0 && angle > uAngle) discard;',\n        '    if(uAngle < -PI && angle < uAngle + PI2) discard;',\n        '    if(uAngle < 0.0 && uAngle > -PI) discard;',\n        '  }',\n        '  if(angle < 0.0) {',\n        '    if(uAngle <= 0.0 && angle < uAngle) discard;',\n        '    if(uAngle > PI && angle > uAngle - PI2) discard;',\n        '    if(uAngle > 0.0 && uAngle < PI) discard;',\n        '  }',\n        '  gl_FragColor = vec4(1.0, 1.0, 0.0, 0.5);',\n        '}'\n    ].join( '\\n' );\n\n    programQC = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),\n        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\n    return programQC;\n};\n\nvar createDebugLineGeometry = function () {\n    var g = new Geometry();\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, new Float32Array( 4 ), 2 );\n    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 2 );\n    g.getPrimitives().push( primitive );\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader2D() );\n    return g;\n};\n\nvar createTorusGeometry = function ( argRadiusOut, argRadiusWidth, argNbRadial, argNbTubular, argArc ) {\n    var radiusOut = argRadiusOut !== undefined ? argRadiusOut : 1.0;\n    var radiusWidth = argRadiusWidth !== undefined ? argRadiusWidth : 0.2;\n    var nbRadial = argNbRadial !== undefined ? argNbRadial : 6;\n    var nbTubular = argNbTubular !== undefined ? argNbTubular : 64;\n    var arc = argArc !== undefined ? argArc : Math.PI * 2;\n\n    var nbVertices = ( nbRadial + 1 ) * ( nbTubular + 1 );\n    var nbTriangles = nbRadial * nbTubular * 2;\n    var g = new Geometry();\n    var vertices = new Float32Array( nbVertices * 3 );\n    var indices = new Uint16Array( nbTriangles * 3 );\n    arc = arc || Math.PI * 2;\n    var id = 0;\n    var k = 0;\n    var i = 0;\n    var j = 0;\n    for ( j = 0; j <= nbRadial; ++j ) {\n        for ( i = 0; i <= nbTubular; ++i ) {\n            var u = i / nbTubular * arc;\n            var v = j / nbRadial * Math.PI * 2;\n            k = id * 3;\n            vertices[ k ] = ( radiusOut + radiusWidth * Math.cos( v ) ) * Math.cos( u );\n            vertices[ k + 1 ] = ( radiusOut + radiusWidth * Math.cos( v ) ) * Math.sin( u );\n            vertices[ k + 2 ] = radiusWidth * Math.sin( v );\n            id++;\n        }\n    }\n    id = 0;\n    for ( j = 1; j <= nbRadial; ++j ) {\n        for ( i = 1; i <= nbTubular; ++i ) {\n            k = id * 6;\n            indices[ k ] = ( nbTubular + 1 ) * j + i - 1;\n            indices[ k + 1 ] = indices[ k + 3 ] = ( nbTubular + 1 ) * ( j - 1 ) + i - 1;\n            indices[ k + 2 ] = indices[ k + 5 ] = ( nbTubular + 1 ) * j + i;\n            indices[ k + 4 ] = ( nbTubular + 1 ) * ( j - 1 ) + i;\n            id++;\n        }\n    }\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );\n    g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indices, 1 ) ) );\n    return g;\n};\n\nvar createCylinderGeometry = function ( argRadiusTop, argRadiusBottom, argHeight, argRadialSegments, argHeightSegments, argTopCap, argLowCap ) {\n    var radiusTop = argRadiusTop !== undefined ? argRadiusTop : 1.0;\n    var radiusBottom = argRadiusBottom !== undefined ? argRadiusBottom : 1.0;\n    var height = argHeight !== undefined ? argHeight : 5.0;\n    var radialSegments = argRadialSegments !== undefined ? argRadialSegments : 32;\n    var heightSegments = argHeightSegments !== undefined ? argHeightSegments : 1;\n    var topCap = argTopCap !== undefined ? argTopCap : true;\n    var lowCap = argLowCap !== undefined ? argLowCap : true;\n\n    topCap = topCap && radiusTop > 0.0;\n    lowCap = lowCap && radiusBottom > 0.0;\n    var heightHalf = height * 0.5;\n\n    var nbVertices = ( heightSegments + 1 ) * ( radialSegments + 1 );\n    var nbTriangles = heightSegments * radialSegments * 2;\n    if ( topCap ) {\n        nbVertices += 1;\n        nbTriangles += radialSegments;\n    }\n    if ( lowCap ) {\n        nbVertices += 1;\n        nbTriangles += radialSegments;\n    }\n    var g = new Geometry();\n    var vertices = new Float32Array( nbVertices * 3 );\n    var indices = new Uint16Array( nbTriangles * 3 );\n\n    var id = 0;\n    var k = 0;\n    var i = 0;\n    var j = 0;\n    for ( i = 0; i <= heightSegments; i++ ) {\n        var v = i / heightSegments;\n        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n        for ( j = 0; j <= radialSegments; j++ ) {\n            var u = j / radialSegments;\n            k = id * 3;\n            vertices[ k ] = radius * Math.sin( u * Math.PI * 2 );\n            vertices[ k + 1 ] = radius * Math.cos( u * Math.PI * 2 );\n            vertices[ k + 2 ] = -v * height + heightHalf;\n            id++;\n        }\n    }\n\n    id = 0;\n    for ( j = 0; j < radialSegments; j++ ) {\n        for ( i = 0; i < heightSegments; i++ ) {\n            k = id * 6;\n            indices[ k ] = ( radialSegments + 1 ) * i + j;\n            indices[ k + 1 ] = indices[ k + 3 ] = ( radialSegments + 1 ) * ( i + 1 ) + j;\n            indices[ k + 2 ] = indices[ k + 5 ] = ( radialSegments + 1 ) * i + j + 1;\n            indices[ k + 4 ] = ( radialSegments + 1 ) * ( i + 1 ) + j + 1;\n            id++;\n        }\n    }\n    id *= 2;\n    var last;\n    if ( topCap ) {\n        last = ( lowCap ? vertices.length - 6 : vertices.length - 3 ) / 3;\n        vertices[ last * 3 + 2 ] = heightHalf;\n        for ( j = 0; j < radialSegments; j++ ) {\n            k = id * 3;\n            indices[ k ] = j;\n            indices[ k + 1 ] = j + 1;\n            indices[ k + 2 ] = last;\n            id++;\n        }\n    }\n\n    if ( lowCap ) {\n        last = ( vertices.length - 3 ) / 3;\n        vertices[ last * 3 + 2 ] = -heightHalf;\n        var end = ( radialSegments + 1 ) * i;\n        for ( j = 0; j < radialSegments; j++ ) {\n            k = id * 3;\n            indices[ k ] = end + j + 1;\n            indices[ k + 1 ] = end + j;\n            indices[ k + 2 ] = last;\n            id++;\n        }\n    }\n\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );\n    g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indices, 1 ) ) );\n    return g;\n};\n\nvar createCircleGeometry = function ( nbVertices, radius, argArc ) {\n    var g = new Geometry();\n    var vertices = new Float32Array( nbVertices * 3 );\n    var arc = argArc || Math.PI * 2;\n    for ( var i = 0; i < nbVertices; ++i ) {\n        var j = i * 3;\n        var segment = arc * i / nbVertices;\n        vertices[ j ] = Math.cos( segment ) * radius;\n        vertices[ j + 1 ] = Math.sin( segment ) * radius;\n    }\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n    var primitive = new DrawArrays( PrimitiveSet.LINE_STRIP, 0, nbVertices );\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );\n    g.getPrimitives().push( primitive );\n    return g;\n};\n\nvar createPlaneGeometry = function ( width, height ) {\n    var offx = width ? width * 0.5 : 0.5;\n    var offy = height ? height * 0.5 : 0.5;\n\n    var g = new Geometry();\n    var vertices = new Float32Array( 12 );\n    vertices[ 0 ] = -offx;\n    vertices[ 1 ] = -offy;\n\n    vertices[ 3 ] = offx;\n    vertices[ 4 ] = -offy;\n\n    vertices[ 6 ] = -offx;\n    vertices[ 7 ] = offy;\n\n    vertices[ 9 ] = offx;\n    vertices[ 10 ] = offy;\n\n    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );\n    var primitive = new DrawArrays( PrimitiveSet.TRIANGLE_STRIP, 0, 4 );\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );\n    g.getPrimitives().push( primitive );\n    return g;\n};\n\nvar createQuadCircleGeometry = function () {\n    var g = createPlaneGeometry();\n    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShaderQuadCircle() );\n    return g;\n};\n\nvar GizmoGeometry = {};\nGizmoGeometry.createCircleGeometry = createCircleGeometry;\nGizmoGeometry.createCylinderGeometry = createCylinderGeometry;\nGizmoGeometry.createTorusGeometry = createTorusGeometry;\nGizmoGeometry.createDebugLineGeometry = createDebugLineGeometry;\nGizmoGeometry.createPlaneGeometry = createPlaneGeometry;\nGizmoGeometry.createQuadCircleGeometry = createQuadCircleGeometry;\n\nmodule.exports = GizmoGeometry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/gizmoGeometry.js\n// module id = 218\n// module chunks = 0 1 2","'use strict';\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar TriangleSphereIntersector = require( 'osgUtil/TriangleSphereIntersector' );\n\n\nvar SphereIntersector = function () {\n    this._center = vec3.create();\n    this._iCenter = vec3.create();\n    this._radius = 1.0;\n    this._iRadius = 1.0;\n    this._intersections = [];\n};\n\nSphereIntersector.prototype = {\n    set: function ( center, radius ) {\n        // we copy iCenter and iRadius in case setCurrentTransformation is never called\n        vec3.copy( this._center, center );\n        vec3.copy( this._iCenter, center );\n        this._radius = this._iRadius = radius;\n        this.reset();\n    },\n    setCenter: function ( center ) {\n        vec3.copy( this._center, center );\n        vec3.copy( this._iCenter, center );\n    },\n    setRadius: function ( radius ) {\n        this._radius = this._iRadius = radius;\n    },\n    reset: function () {\n        // Clear the intersections vector\n        this._intersections.length = 0;\n    },\n    enter: function ( node ) {\n        // Not working if culling disabled ??\n        return !node.isCullingActive() || this.intersects( node.getBound() );\n    },\n    // Intersection Sphere/Sphere\n    intersects: function ( bsphere ) {\n        if ( !bsphere.valid() ) return false;\n        var r = this._iRadius + bsphere.radius();\n        return vec3.sqrDist( bsphere.center(), this._iCenter ) <= r * r;\n    },\n\n    intersect: ( function () {\n\n        var ti = new TriangleSphereIntersector();\n\n        return function ( iv, node ) {\n\n            var kdtree = node.getShape();\n            if ( kdtree )\n                return kdtree.intersectSphere( this._iCenter, this._iRadius, this._intersections, iv.nodePath );\n\n            ti.reset();\n            ti.setNodePath( iv.nodePath );\n            ti.set( this._iCenter, this._iRadius );\n\n            // handle rig transformed vertices\n            if ( node.computeTransformedVertices ) {\n                var vList = node.getVertexAttributeList();\n                var originVerts = vList.Vertex.getElements();\n\n                // temporarily hook vertex buffer for the tri intersections\n                // don't call setElements as it dirty some stuffs because of gl buffer\n                vList.Vertex._elements = node.computeTransformedVertices();\n                ti.apply( node );\n                vList.Vertex._elements = originVerts;\n            } else {\n                ti.apply( node );\n            }\n\n            var l = ti._intersections.length;\n            for ( var i = 0; i < l; i++ ) {\n                this._intersections.push( ti._intersections[ i ] );\n            }\n\n            return l > 0;\n        };\n    } )(),\n\n    getIntersections: function () {\n        return this._intersections;\n    },\n\n    setCurrentTransformation: ( function () {\n        var tmp = vec3.create();\n\n        return function ( matrix ) {\n            mat4.invert( matrix, matrix );\n            vec3.transformMat4( this._iCenter, this._center, matrix );\n            this._iRadius = this._radius * mat4.getScale( tmp, matrix )[ 0 ];\n        };\n    } )()\n};\n\nmodule.exports = SphereIntersector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/SphereIntersector.js\n// module id = 219\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar Geometry = require( 'osg/Geometry' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\n\n\nvar osg = MACROUTILS;\n\nvar TangentSpaceGenerator = function () {\n    NodeVisitor.call( this );\n    this._T = undefined;\n    this._B = undefined;\n    this._N = undefined;\n    this._texCoordUnit = 0;\n};\n\nTangentSpaceGenerator.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n\n    apply: function ( node ) {\n\n        if ( node.getTypeID() === Geometry.getTypeID() )\n            this.generate( node, this._texCoordUnit );\n        else\n            this.traverse( node );\n\n    },\n\n    setTexCoordUnit: function ( texCoordUnit ) {\n        this._texCoordUnit = texCoordUnit;\n    },\n\n    computePrimitiveSet: function ( geometry, primitiveSet ) {\n\n        // no indices -> exit\n        if ( !primitiveSet.getIndices )\n            return;\n\n        var numIndices = primitiveSet.getNumIndices();\n\n        var vx = geometry.getAttributes().Vertex;\n        var nx = geometry.getAttributes().Normal;\n        var tx = geometry.getAttributes()[ 'TexCoord' + this._texCoordUnit ];\n\n        var i;\n\n        if ( primitiveSet.getMode() === PrimitiveSet.TRIANGLES ) {\n\n            for ( i = 0; i < numIndices; i += 3 ) {\n                this.compute( primitiveSet, vx, nx, tx, i, i + 1, i + 2 );\n            }\n\n        } else if ( primitiveSet.getMode() === PrimitiveSet.TRIANGLE_STRIP ) {\n\n            for ( i = 0; i < numIndices - 2; ++i ) {\n                if ( ( i % 2 ) === 0 ) {\n                    this.compute( primitiveSet, vx, nx, tx, i, i + 1, i + 2 );\n                } else {\n                    this.compute( primitiveSet, vx, nx, tx, i + 1, i, i + 2 );\n                }\n            }\n        }\n\n    },\n\n    generate: function ( geometry, texCoordUnit ) {\n\n        this._texCoordUnit = texCoordUnit;\n\n        if ( this._texCoordUnit === undefined )\n            this._texCoordUnit = 0;\n\n        var size = geometry.getAttributes().Vertex.getElements().length;\n        this._T = new osg.Float32Array( size );\n        this._B = new osg.Float32Array( size );\n        this._N = new osg.Float32Array( size );\n\n        geometry.getPrimitiveSetList().forEach( function ( primitiveSet ) {\n\n            this.computePrimitiveSet( geometry, primitiveSet );\n\n        }, this );\n\n        var nbElements = size / 3;\n        var tangents = new osg.Float32Array( nbElements * 4 );\n\n        var tmp0 = vec3.create();\n        var tmp1 = vec3.create();\n        var t3 = vec3.create();\n\n        for ( var i = 0; i < nbElements; i++ ) {\n            var t = this._T.subarray( i * 3, i * 3 + 3 );\n            var n = this._N.subarray( i * 3, i * 3 + 3 );\n            var b = this._B.subarray( i * 3, i * 3 + 3 );\n\n            vec3.normalize( n, n );\n\n            // Gram-Schmidt orthogonalize\n            // vec3 t3 = (t - n * (n * t));\n            // t3.normalize();\n            // finalTangent = Vec4(t3, 0.0);\n            // Calculate handedness\n            // finalTangent[3] = (((n ^ t) * b) < 0.0) ? -1.0 : 1.0;\n            // The bitangent vector B is then given by B = (N × T) · Tw\n\n            var nt = vec3.dot( n, t );\n            vec3.scale( tmp1, n, nt );\n            vec3.sub( tmp0, t, tmp1 );\n            vec3.normalize( t3, tmp0 );\n\n            vec3.cross( tmp0, n, t );\n            var sign = vec3.dot( tmp0, b );\n            sign = sign < 0.0 ? -1.0 : 0.0;\n\n            // TODO perf : cache index var id = i * 4;\n            tangents[ i * 4 ] = t3[ 0 ];\n            tangents[ i * 4 + 1 ] = t3[ 1 ];\n            tangents[ i * 4 + 2 ] = t3[ 2 ];\n            tangents[ i * 4 + 3 ] = sign;\n        }\n\n        geometry.getAttributes().Normal.setElements( this._N );\n        geometry.getAttributes().Tangent = new BufferArray( 'ARRAY_BUFFER', tangents, 4 );\n\n    },\n\n    compute: function ( primitiveSet, vx, nx, tx, ia, ib, ic ) {\n\n        var i0 = primitiveSet.index( ia );\n        var i1 = primitiveSet.index( ib );\n        var i2 = primitiveSet.index( ic );\n\n        // TODO perf : cache xx.getElements() but more importantly\n        // subarray call have very high overhead, it's super useful\n        // when you call it a few times for big array chunk, but for\n        // small array extraction (each vertex) it's better to use a temporary\n        // pre allocated array and simply fill it\n        // then, you'll have to write in the big arrays at the end\n        var P1 = vx.getElements().subarray( i0 * 3, i0 * 3 + 3 );\n        var P2 = vx.getElements().subarray( i1 * 3, i1 * 3 + 3 );\n        var P3 = vx.getElements().subarray( i2 * 3, i2 * 3 + 3 );\n\n        var N1 = nx.getElements().subarray( i0 * 3, i0 * 3 + 3 );\n        var N2 = nx.getElements().subarray( i1 * 3, i1 * 3 + 3 );\n        var N3 = nx.getElements().subarray( i2 * 3, i2 * 3 + 3 );\n\n        var uv1 = tx.getElements().subarray( i0 * 2, i0 * 2 + 2 );\n        var uv2 = tx.getElements().subarray( i1 * 2, i1 * 2 + 2 );\n        var uv3 = tx.getElements().subarray( i2 * 2, i2 * 2 + 2 );\n\n        var vz, vy;\n        // TODO perf : use temporary vec\n        var V = vec3.create();\n\n        var B1 = vec3.create();\n        var B2 = vec3.create();\n        var B3 = vec3.create();\n\n        var T1 = vec3.create();\n        var T2 = vec3.create();\n        var T3 = vec3.create();\n\n        var v1 = vec3.create();\n        var v2 = vec3.create();\n\n\n        vec3.set( v1, P2[ 0 ] - P1[ 0 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ] );\n        vec3.set( v2, P3[ 0 ] - P1[ 0 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ] );\n\n        vec3.cross( V, v1, v2 );\n\n        if ( V[ 0 ] !== 0.0 ) {\n            vec3.normalize( V, V );\n            vy = -V[ 1 ] / V[ 0 ];\n            vz = -V[ 2 ] / V[ 0 ];\n            T1[ 0 ] += vy;\n            B1[ 0 ] += vz;\n            T2[ 0 ] += vy;\n            B2[ 0 ] += vz;\n            T3[ 0 ] += vy;\n            B3[ 0 ] += vz;\n        }\n\n\n        vec3.set( v1, P2[ 1 ] - P1[ 1 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ] );\n        vec3.set( v2, P3[ 1 ] - P1[ 1 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ] );\n\n        vec3.cross( V, v1, v2 );\n\n        if ( V[ 0 ] !== 0.0 ) {\n            vec3.normalize( V, V );\n            vy = -V[ 1 ] / V[ 0 ];\n            vz = -V[ 2 ] / V[ 0 ];\n            T1[ 1 ] += vy;\n            B1[ 1 ] += vz;\n            T2[ 1 ] += vy;\n            B2[ 1 ] += vz;\n            T3[ 1 ] += vy;\n            B3[ 1 ] += vz;\n        }\n\n\n        vec3.set( v1, P2[ 2 ] - P1[ 2 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ] );\n        vec3.set( v2, P3[ 2 ] - P1[ 2 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ] );\n\n        vec3.cross( V, v1, v2 );\n\n        if ( V[ 0 ] !== 0.0 ) {\n            vec3.normalize( V, V );\n            vy = -V[ 1 ] / V[ 0 ];\n            vz = -V[ 2 ] / V[ 0 ];\n            T1[ 2 ] += vy;\n            B1[ 2 ] += vz;\n            T2[ 2 ] += vy;\n            B2[ 2 ] += vz;\n            T3[ 2 ] += vy;\n            B3[ 2 ] += vz;\n        }\n\n        var tempVec = vec3.create();\n        var tempVec2 = vec3.create();\n\n        var Tdst, Bdst, Ndst;\n\n        vec3.cross( tempVec, N1, T1 );\n        vec3.cross( tempVec2, tempVec, N1 );\n        Tdst = this._T.subarray( i0 * 3, i0 * 3 + 3 );\n        vec3.add( Tdst, tempVec2, Tdst );\n\n        vec3.cross( tempVec, B1, N1 );\n        vec3.cross( tempVec2, N1, tempVec );\n        Bdst = this._B.subarray( i0 * 3, i0 * 3 + 3 );\n        vec3.add( Bdst, tempVec2, Bdst );\n\n\n        vec3.cross( tempVec, N2, T2 );\n        vec3.cross( tempVec2, tempVec, N2 );\n        Tdst = this._T.subarray( i1 * 3, i1 * 3 + 3 );\n        vec3.add( Tdst, tempVec2, Tdst );\n\n        vec3.cross( tempVec, B2, N2 );\n        vec3.cross( tempVec2, N2, tempVec );\n        Bdst = this._B.subarray( i1 * 3, i1 * 3 + 3 );\n        vec3.add( Bdst, tempVec2, Bdst );\n\n\n        vec3.cross( tempVec, N3, T3 );\n        vec3.cross( tempVec2, tempVec, N3 );\n        Tdst = this._T.subarray( i2 * 3, i2 * 3 + 3 );\n        vec3.add( Tdst, tempVec2, Tdst );\n\n        vec3.cross( tempVec, B3, N3 );\n        vec3.cross( tempVec2, N3, tempVec );\n        Bdst = this._B.subarray( i2 * 3, i2 * 3 + 3 );\n        vec3.add( Bdst, tempVec2, Bdst );\n\n\n        Ndst = this._N.subarray( i0 * 3, i0 * 3 + 3 );\n        vec3.add( Ndst, N1, Ndst );\n\n        Ndst = this._N.subarray( i1 * 3, i1 * 3 + 3 );\n        vec3.add( Ndst, N2, Ndst );\n\n        Ndst = this._N.subarray( i2 * 3, i2 * 3 + 3 );\n        vec3.add( Ndst, N3, Ndst );\n    }\n\n} );\n\nmodule.exports = TangentSpaceGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/TangentSpaceGenerator.js\n// module id = 220\n// module chunks = 0 1 2","'use strict';\nvar Camera = require( 'osg/Camera' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Node = require( 'osg/Node' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar Shape = require( 'osg/shape' );\nvar Texture = require( 'osg/Texture' );\nvar Transform = require( 'osg/Transform' );\nvar Uniform = require( 'osg/Uniform' );\nvar vec2 = require( 'osg/glMatrix' ).vec2;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar Viewport = require( 'osg/Viewport' );\nvar Composer = require( 'osgUtil/Composer' );\n\n\nvar WebVRCustom = {};\n\n// no smart resize, we just recreate everything\nvar UpdateRecreateOnResize = function ( viewer, rttScene, hmdConfig, root, canvas ) {\n    this._viewer = viewer;\n    this._rttScene = rttScene;\n    this._hmdConfig = hmdConfig;\n    this._root = root;\n    this._canvas = canvas;\n    this._width = canvas.width;\n    this._height = canvas.height;\n};\n\nUpdateRecreateOnResize.prototype = {\n    update: function () {\n        var canvas = this._canvas;\n        var width = canvas.width;\n        var height = canvas.height;\n\n        if ( width !== this._width || height !== this._height ) {\n            this._root.removeChildren();\n\n            var hmdConfig = this._hmdConfig;\n            if ( hmdConfig && hmdConfig.isCardboard ) {\n                hmdConfig.hResolution = width;\n                hmdConfig.vResolution = height;\n            }\n            this._width = width;\n            this._height = height;\n\n            WebVRCustom.createScene( this._viewer, this._rttScene, hmdConfig, this._root );\n        }\n        return true;\n    }\n};\n\nvar UpdateOffsetCamera = function ( rootView, offsetView ) {\n    this._rootView = rootView;\n    this._offsetView = offsetView;\n};\n\nUpdateOffsetCamera.prototype = {\n    update: function ( node ) {\n        var nodeView = node.getViewMatrix();\n        mat4.mul( nodeView, this._offsetView, this._rootView );\n        return true;\n    }\n};\n\nvar setupWebVR = function ( worldFactor, HMD, webVRUniforms, webVRMatrices ) {\n\n    var aspect = HMD.hResolution / ( 2.0 * HMD.vResolution );\n    var r = -1.0 - ( 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize );\n    var distScale = ( HMD.distortionK[ 0 ] + HMD.distortionK[ 1 ] * Math.pow( r, 2 ) + HMD.distortionK[ 2 ] * Math.pow( r, 4 ) + HMD.distortionK[ 3 ] * Math.pow( r, 6 ) );\n    var fov = ( 180.0 / Math.PI ) * 2.0 * Math.atan2( HMD.vScreenSize * distScale, 2.0 * HMD.eyeToScreenDistance );\n\n    var proj = mat4.perspective( mat4.create(), Math.PI / 180 * fov, aspect, 0.3, 10000.0 );\n\n    var hOffset = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.interpupillaryDistance * 0.5 ) / HMD.hScreenSize;\n    var lensShift = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize;\n\n    var leftMat = mat4.create();\n    var rightMat = mat4.create();\n    webVRMatrices.projectionLeft = mat4.mul( leftMat, mat4.fromTranslation( leftMat, vec3.fromValues( hOffset, 0.0, 0.0 ) ), proj );\n    webVRMatrices.projectionRight = mat4.mul( rightMat, mat4.fromTranslation( rightMat, vec3.fromValues( -hOffset, 0.0, 0.0 ) ), proj );\n    webVRMatrices.viewLeft = mat4.fromTranslation( mat4.create(), vec3.fromValues( worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0 ) );\n    webVRMatrices.viewRight = mat4.fromTranslation( mat4.create(), vec3.fromValues( -worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0 ) );\n\n    webVRUniforms.lensCenterLeft = vec2.fromValues( lensShift, 0.0 );\n    webVRUniforms.lensCenterRight = vec2.fromValues( -lensShift, 0.0 );\n    webVRUniforms.hmdWarpParam = HMD.distortionK;\n    webVRUniforms.chromAbParam = HMD.chromaAbParameter;\n    webVRUniforms.scaleIn = vec2.fromValues( 1.0, 1.0 / aspect );\n    webVRUniforms.scale = vec2.fromValues( 1.0 / distScale, 1.0 * aspect / distScale );\n};\n\nvar getWebVRShader = function () {\n\n    var fragmentshader = [\n        '',\n        '#ifdef GL_ES',\n        'precision highp float;',\n        '#endif',\n\n        'uniform vec2 uScale;',\n        'uniform vec2 uScaleIn;',\n        'uniform vec2 uLensCenter;',\n        'uniform vec4 uHmdWarpParam;',\n        'uniform vec4 uChromAbParam;',\n        'uniform sampler2D Texture0;',\n\n        'varying vec2 vTexCoord0;',\n\n        // from http://paradise.untergrund.net/tmp/demoshit/examples/js/effects/OculusRiftEffect.js\n        'void main(void) {',\n        '  vec2 uv = (vTexCoord0 * 2.0) - 1.0;', // range from [0,1] to [-1,1]\n        '  vec2 theta = (uv - uLensCenter) * uScaleIn;',\n        '  float rSq = theta.x * theta.x + theta.y * theta.y;',\n        '  vec2 rvector = theta * (uHmdWarpParam.x + uHmdWarpParam.y * rSq + uHmdWarpParam.z * rSq * rSq + uHmdWarpParam.w * rSq * rSq * rSq);',\n        '  vec2 rBlue = rvector * (uChromAbParam.z + uChromAbParam.w * rSq);',\n        '  vec2 tcBlue = (uLensCenter + uScale * rBlue);',\n        '  tcBlue = (tcBlue + 1.0) * 0.5;', // range from [-1,1] to [0,1]\n        '  if (any(bvec2(clamp(tcBlue, vec2(0.0, 0.0), vec2(1.0, 1.0)) - tcBlue))) {',\n        '    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n        '    return;',\n        '  }',\n        '  vec2 tcGreen = uLensCenter + uScale * rvector;',\n        '  tcGreen = (tcGreen + 1.0) * 0.5;', // range from [-1,1] to [0,1]\n        '  vec2 rRed = rvector * (uChromAbParam.x + uChromAbParam.y * rSq);',\n        '  vec2 tcRed = uLensCenter + uScale * rRed;',\n        '  tcRed = (tcRed + 1.0) * 0.5;', // range from [-1,1] to [0,1]\n        '  gl_FragColor = vec4(texture2D(Texture0, tcRed).r, texture2D(Texture0, tcGreen).g, texture2D(Texture0, tcBlue).b, 1);',\n        '}',\n        ''\n    ].join( '\\n' );\n\n    return new Program(\n        new Shader( Shader.VERTEX_SHADER, Composer.Filter.defaultVertexShader ),\n        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\n};\n\nvar createTextureRtt = function ( rttSize ) {\n    var rttTexture = new Texture();\n    rttTexture.setTextureSize( rttSize[ 0 ], rttSize[ 1 ] );\n    rttTexture.setMinFilter( 'LINEAR' );\n    rttTexture.setMagFilter( 'LINEAR' );\n    return rttTexture;\n};\n\nvar createOrthoRtt = function ( left, viewportSize, canvasSize, cardboard, texture, webVRUniforms ) {\n    var orthoCamera = new Camera();\n    var vw = viewportSize[ 0 ];\n    var vh = viewportSize[ 1 ];\n    var cw = canvasSize[ 0 ];\n    var ch = canvasSize[ 1 ];\n    if ( cardboard === true ) {\n        if ( left )\n            orthoCamera.setViewport( new Viewport( 0.0, 0.0, cw / 2.0, ch ) );\n        else\n            orthoCamera.setViewport( new Viewport( cw / 2.0, 0.0, cw / 2.0, ch ) );\n    } else {\n        if ( left )\n            orthoCamera.setViewport( new Viewport( 0.5 * cw - vw, 0.5 * ( ch - vh ), vw, vh ) );\n        else\n            orthoCamera.setViewport( new Viewport( 0.5 * cw, 0.5 * ( ch - vh ), vw, vh ) );\n    }\n    mat4.ortho( orthoCamera.getProjectionMatrix(), -0.5, 0.5, -0.5, 0.5, -5, 5 );\n    orthoCamera.setRenderOrder( Camera.NESTED_RENDER, 0 );\n    orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );\n\n    var stateSet = orthoCamera.getOrCreateStateSet();\n    stateSet.setTextureAttributeAndModes( 0, texture );\n    stateSet.setAttributeAndModes( getWebVRShader() );\n    stateSet.addUniform( Uniform.createFloat2( webVRUniforms.scale, 'uScale' ) );\n    stateSet.addUniform( Uniform.createFloat2( webVRUniforms.scaleIn, 'uScaleIn' ) );\n    stateSet.addUniform( Uniform.createFloat2( left ? webVRUniforms.lensCenterLeft : webVRUniforms.lensCenterRight, 'uLensCenter' ) );\n    stateSet.addUniform( Uniform.createFloat4( webVRUniforms.hmdWarpParam, 'uHmdWarpParam' ) );\n    stateSet.addUniform( Uniform.createFloat4( webVRUniforms.chromAbParam, 'uChromAbParam' ) );\n\n    return orthoCamera;\n};\n\nvar createCameraRtt = function ( texture, projMatrix ) {\n    var camera = new Camera();\n    camera.setName( 'rtt camera' );\n    camera.setViewport( new Viewport( 0, 0, texture.getWidth(), texture.getHeight() ) );\n    camera.setProjectionMatrix( projMatrix );\n    camera.setClearColor( vec4.fromValues( 0.3, 0.3, 0.3, 0.0 ) );\n    camera.setRenderOrder( Camera.POST_RENDER, 0 );\n    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );\n    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\n    camera.setReferenceFrame( Transform.ABSOLUTE_RF );\n    return camera;\n};\n\nWebVRCustom.createScene = function ( viewer, rttScene, HMDconfig, rootOverride, worldFactorOverride ) {\n    var HMD = WebVRCustom.getDefaultConfig( HMDconfig );\n    var rttSize = vec2.fromValues( HMD.hResolution * 0.5, HMD.vResolution );\n    var viewportSize = vec2.fromValues( HMD.hResolution * 0.5, HMD.vResolution );\n    var vp = viewer.getCamera().getViewport();\n    var canvasSize = vec2.fromValues( vp.width(), vp.height() );\n\n    var canvas = viewer.getGraphicContext().canvas;\n    if ( HMD.isCardboard ) {\n        canvasSize[ 0 ] = canvas.width;\n        canvasSize[ 1 ] = canvas.height;\n    }\n\n    var worldFactor = worldFactorOverride !== undefined ? worldFactorOverride : 1.0;\n    var webVRUniforms = {};\n    var webVRMatrices = {};\n    setupWebVR( worldFactor, HMD, webVRUniforms, webVRMatrices );\n\n    var rootViewMatrix = viewer.getCamera().getViewMatrix();\n\n    var root = rootOverride || new Node();\n    root.addUpdateCallback( new UpdateRecreateOnResize( viewer, rttScene, HMDconfig, root, canvas ) );\n\n    var rttTextureLeft = createTextureRtt( rttSize );\n    var rttCamLeft = createCameraRtt( rttTextureLeft, webVRMatrices.projectionLeft );\n    var orthoCameraLeft = createOrthoRtt( true, viewportSize, canvasSize, HMD.isCardboard, rttTextureLeft, webVRUniforms );\n    rttCamLeft.addUpdateCallback( new UpdateOffsetCamera( rootViewMatrix, webVRMatrices.viewLeft ) );\n\n    var rttTextureRight = createTextureRtt( rttSize );\n    var rttCamRight = createCameraRtt( rttTextureRight, webVRMatrices.projectionRight );\n    var orthoCameraRight = createOrthoRtt( false, viewportSize, canvasSize, HMD.isCardboard, rttTextureRight, webVRUniforms );\n    rttCamRight.addUpdateCallback( new UpdateOffsetCamera( rootViewMatrix, webVRMatrices.viewRight ) );\n\n    rttCamLeft.addChild( rttScene );\n    rttCamRight.addChild( rttScene );\n\n    orthoCameraLeft.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );\n    orthoCameraRight.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );\n\n    root.addChild( rttCamLeft );\n    root.addChild( rttCamRight );\n\n\n    root.addChild( orthoCameraLeft );\n    root.addChild( orthoCameraRight );\n\n    return root;\n};\n\nWebVRCustom.getDefaultConfig = function ( hmdConfig ) {\n    // FOV: 103.506416\n    // vScreenCenter: 0.03645\n\n    // Oculus Rift DK2\n    var hmd = {\n        hResolution: 1920,\n        vResolution: 1080,\n        hScreenSize: 0.1296,\n        vScreenSize: 0.0729,\n        interpupillaryDistance: 0.064,\n        lensSeparationDistance: 0.0635,\n        eyeToScreenDistance: 0.04,\n        distortionK: vec4.fromValues( 1.0, 0.22, 0.13, 0.02 ),\n        chromaAbParameter: vec4.fromValues( 0.996, -0.004, 1.014, 0.0 ),\n        isCardboard: false\n    };\n\n    if ( hmdConfig === 2 || hmdConfig === undefined )\n        return hmd;\n\n    if ( hmdConfig === 1 ) {\n        // Oculus Rift DK1\n        hmd.hResolution = 1280;\n        hmd.vResolution = 800;\n        hmd.hScreenSize = 0.14976;\n        hmd.vScreenSize = 0.0936;\n        hmd.lensSeparationDistance = 0.064;\n        hmd.eyeToScreenDistance = 0.041;\n        hmd.distortionK = vec4.fromValues( 1.0, 0.22, 0.24, 0.0 );\n        return hmd;\n    }\n\n    // custom param\n    if ( hmdConfig.hResolution !== undefined ) hmd.hResolution = hmdConfig.hResolution;\n    if ( hmdConfig.vResolution !== undefined ) hmd.vResolution = hmdConfig.vResolution;\n    if ( hmdConfig.hScreenSize !== undefined ) hmd.hScreenSize = hmdConfig.hScreenSize;\n    if ( hmdConfig.vScreenSize !== undefined ) hmd.vScreenSize = hmdConfig.vScreenSize;\n    if ( hmdConfig.interpupillaryDistance !== undefined ) hmd.interpupillaryDistance = hmdConfig.interpupillaryDistance;\n    if ( hmdConfig.lensSeparationDistance !== undefined ) hmd.lensSeparationDistance = hmdConfig.lensSeparationDistance;\n    if ( hmdConfig.eyeToScreenDistance !== undefined ) hmd.eyeToScreenDistance = hmdConfig.eyeToScreenDistance;\n    if ( hmdConfig.distortionK !== undefined ) hmd.distortionK = hmdConfig.distortionK;\n    if ( hmdConfig.chromaAbParameter !== undefined ) hmd.chromaAbParameter = hmdConfig.chromaAbParameter;\n    if ( hmdConfig.isCardboard !== undefined ) hmd.isCardboard = hmdConfig.isCardboard;\n\n    return hmd;\n};\n\nmodule.exports = WebVRCustom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/WebVRCustom.js\n// module id = 221\n// module chunks = 0 1 2","'use strict';\nvar Camera = require( 'osg/Camera' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Node = require( 'osg/Node' );\nvar Program = require( 'osg/Program' );\nvar Shader = require( 'osg/Shader' );\nvar Shape = require( 'osg/shape' );\nvar Texture = require( 'osg/Texture' );\nvar Transform = require( 'osg/Transform' );\nvar Uniform = require( 'osg/Uniform' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar Viewport = require( 'osg/Viewport' );\nvar Composer = require( 'osgUtil/Composer' );\n\n\nvar UpdateRttCameraCallback = function ( rootView, offsetView ) {\n    this._rootView = rootView;\n    this._offsetView = offsetView;\n};\n\nUpdateRttCameraCallback.prototype = {\n    update: function ( node /*, nv */ ) {\n        var nodeView = node.getViewMatrix();\n        mat4.mul( nodeView, this._offsetView, this._rootView );\n        return true;\n    }\n};\n\nvar createTexture = function ( size ) {\n    var texture = new Texture();\n    texture.setTextureSize( size.width, size.height );\n    texture.setMinFilter( 'LINEAR' );\n    texture.setMagFilter( 'LINEAR' );\n    return texture;\n};\n\nvar getAssembleShader = function () {\n\n    var fragmentShader = [\n        '#ifdef GL_ES',\n        '   precision highp float;',\n        '#endif',\n        'varying vec2 vTexCoord0;',\n        'uniform sampler2D TextureLeft;',\n        'uniform sampler2D TextureRight;',\n\n        'void main() {',\n        '   if (vTexCoord0.x < 0.5)',\n        '       gl_FragColor = texture2D(TextureLeft, vec2(vTexCoord0.x * 2.0, vTexCoord0.y));',\n        '   else',\n        '       gl_FragColor = texture2D(TextureRight, vec2(vTexCoord0.x * 2.0 - 1.0, vTexCoord0.y));',\n        '}',\n    ].join( '\\n' );\n\n    return new Program(\n        new Shader( Shader.VERTEX_SHADER, Composer.Filter.defaultVertexShader ),\n        new Shader( Shader.FRAGMENT_SHADER, fragmentShader )\n    );\n};\n\n// This camera will render both textures on the canvas in a single pass\nvar createCameraCanvas = function ( leftEyeTexture, rightEyeTexture, viewport ) {\n\n    var orthoCamera = new Camera();\n    orthoCamera.setViewport( viewport );\n    orthoCamera.setRenderOrder( Camera.NESTED_RENDER, 0 );\n    orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );\n    mat4.ortho( orthoCamera.getProjectionMatrix(), 0.0, 1.0, 0.0, 1.0, -5.0, 5.0 );\n\n    var stateSet = orthoCamera.getOrCreateStateSet();\n    stateSet.addUniform( Uniform.createInt( 0, 'TextureLeft' ) );\n    stateSet.addUniform( Uniform.createInt( 1, 'TextureRight' ) );\n    stateSet.setTextureAttributeAndModes( 0, leftEyeTexture );\n    stateSet.setTextureAttributeAndModes( 1, rightEyeTexture );\n    stateSet.setAttributeAndModes( getAssembleShader() );\n\n    orthoCamera.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );\n\n    return orthoCamera;\n};\n\n// This camera will render the scene on a texture for an eye\nvar createCameraRtt = function ( texture, projection ) {\n    var camera = new Camera();\n    camera.setName( 'rtt camera' );\n    camera.setViewport( new Viewport( 0.0, 0.0, texture.getWidth(), texture.getHeight() ) );\n    camera.setProjectionMatrix( projection );\n    camera.setClearColor( vec4.fromValues( 0.3, 0.3, 0.3, 0.0 ) );\n    camera.setRenderOrder( Camera.POST_RENDER, 0 );\n    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );\n    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\n    camera.setReferenceFrame( Transform.ABSOLUTE_RF );\n    return camera;\n};\n\nvar WebVR = {};\n\nWebVR.createScene = function ( viewer, rttScene, HMDdevice, rootOverride, worldFactorOverride ) {\n\n    var root = rootOverride || new Node();\n    var worldFactor = worldFactorOverride !== undefined ? worldFactorOverride : 1.0;\n\n    var left = HMDdevice.getEyeParameters( 'left' );\n    var right = HMDdevice.getEyeParameters( 'right' );\n\n    var frameData = new window.VRFrameData();\n    HMDdevice.getFrameData( frameData );\n\n    // Compute projections and view matrices for both eyes\n    var viewLeft = mat4.fromTranslation( mat4.create(), vec3.fromValues( -worldFactor * left.offset[ 0 ], left.offset[ 1 ], left.offset[ 2 ] ) );\n    var viewRight = mat4.fromTranslation( mat4.create(), vec3.fromValues( -worldFactor * right.offset[ 0 ], right.offset[ 1 ], right.offset[ 2 ] ) );\n\n    // Each eye is rendered on a texture whose width is half of the final combined texture\n    var eyeTextureSize = {\n        width: Math.max( left.renderWidth, right.renderWidth ),\n        height: Math.max( left.renderHeight, right.renderHeight )\n    };\n\n    var leftEyeTexture = createTexture( eyeTextureSize );\n    var rightEyeTexture = createTexture( eyeTextureSize );\n\n    // Setup the render cameras for both eyes\n    var camRttLeft = createCameraRtt( leftEyeTexture, frameData.leftProjectionMatrix );\n    var camRttRight = createCameraRtt( rightEyeTexture, frameData.rightProjectionMatrix );\n\n    // The viewMatrix of each eye is updated with the current viewer's camera viewMatrix\n    var rootViewMatrix = viewer.getCamera().getViewMatrix();\n    camRttLeft.addUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewLeft ) );\n    camRttRight.addUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewRight ) );\n\n    // Render both textures on the canvas, using the viewer's camera viewport to render on the fullscreen canvas\n    var camCanvas = createCameraCanvas( leftEyeTexture, rightEyeTexture, viewer.getCamera().getViewport() );\n\n    camRttLeft.addChild( rttScene );\n    camRttRight.addChild( rttScene );\n\n    root.addChild( camRttLeft );\n    root.addChild( camRttRight );\n    root.addChild( camCanvas );\n\n    return root;\n};\n\nmodule.exports = WebVR;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/WebVR.js\n// module id = 222\n// module chunks = 0 1 2","'use strict';\nvar Renderer = require( 'osgViewer/Renderer' );\nvar View = require( 'osgViewer/View' );\nvar Viewer = require( 'osgViewer/Viewer' );\nvar EventProxy = require( 'osgViewer/eventProxy/eventProxy' );\nvar Scene = require( 'osgViewer/Scene' );\n\n\nvar osgViewer = {};\n\nosgViewer.Renderer = Renderer;\nosgViewer.View = View;\nosgViewer.Viewer = Viewer;\nosgViewer.EventProxy = EventProxy;\nosgViewer.Scene = Scene;\n\nmodule.exports = osgViewer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/osgViewer.js\n// module id = 223\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Options = require( 'osg/Options' );\nvar P = require( 'bluebird' );\nvar Timer = require( 'osg/Timer' );\nvar TimerGPU = require( 'osg/TimerGPU' );\nvar UpdateVisitor = require( 'osg/UpdateVisitor' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Texture = require( 'osg/Texture' );\nvar OrbitManipulator = require( 'osgGA/OrbitManipulator' );\nvar createStats = require( 'osgViewer/createStats' );\nvar EventProxy = require( 'osgViewer/eventProxy/eventProxy' );\nvar View = require( 'osgViewer/View' );\nvar WebGLUtils = require( 'osgViewer/webgl-utils' );\nvar WebGLDebugUtils = require( 'osgViewer/webgl-debug' );\nvar requestFile = require( 'osgDB/requestFile' );\n\n\nvar getGLSLOptimizer = function () {\n\n    var deferOptimizeGLSL = P.defer();\n    window.deferOptimizeGLSL = deferOptimizeGLSL;\n\n    var mod = [\n        '        var Module = {',\n        '            preRun: [],',\n        '            postRun: [ function () {',\n        '                var func = Module.cwrap( \"optimize_glsl\", \"string\", [ \"string\", \"number\", \"number\" ] );',\n        '                window.deferOptimizeGLSL.resolve( func );',\n        '            } ],',\n        '            print: function ( text ) {',\n        '                Notify.debug( text );',\n        '            },',\n        '            printErr: function ( text ) {',\n        '                Notify.debug( text );',\n        '            },',\n        '            setStatus: function ( text ) {',\n        '                Notify.debug( text );',\n        '            },',\n        '            totalDependencies: 0,',\n        '            monitorRunDependencies: function ( left ) {',\n        '                this.totalDependencies = Math.max( this.totalDependencies, left );',\n        '                Module.setStatus( left ? \"GLSL optimizer preparing... (\" + ( this.totalDependencies - left ) + \"/\" + this.totalDependencies + \")\" : \"All downloads complete.\" );',\n        '            },',\n        '            memoryInitializerPrefixURL: \"https://raw.githubusercontent.com/zz85/glsl-optimizer/gh-pages/\"',\n        '        };'\n    ].join( '\\n' );\n\n    Notify.log( 'try to load glsl optimizer' );\n    var url = 'https://raw.githubusercontent.com/zz85/glsl-optimizer/gh-pages/glsl-optimizer.js';\n    var promise = requestFile( url );\n    promise.then( function ( script ) {\n        /*jshint evil: true */\n        eval( mod + script );\n        /*jshint evil: false */\n    } ).catch( function () {\n        deferOptimizeGLSL.reject();\n    } );\n\n    return deferOptimizeGLSL.promise;\n};\n\nvar Viewer = function ( canvas, userOptions, error ) {\n    View.call( this );\n\n    this._startTick = Timer.instance().tick();\n    this._stats = undefined;\n    this._done = false;\n    this._runPromise = P.resolve();\n\n    var options = this.initOptions( userOptions );\n    var gl = this.initWebGLContext( canvas, options, error );\n\n    if ( !gl )\n        throw 'No WebGL implementation found';\n\n    // this MACROUTILS.init(); should be removed and replace by something\n    // more natural\n    MACROUTILS.init();\n\n    this.initDeviceEvents( options, canvas );\n    this.initStats( options, canvas );\n    this.initRun( options );\n    this._updateVisitor = new UpdateVisitor();\n\n    this.setUpView( gl.canvas, options );\n\n    this._hmd = null;\n    this._requestAnimationFrame = window.requestAnimationFrame.bind( window );\n\n    this._contextLost = false;\n};\n\n\nViewer.prototype = MACROUTILS.objectInherit( View.prototype, {\n\n    initDeviceEvents: function ( options, canvas ) {\n\n        // default argument for mouse binding\n        var defaultMouseEventNode = options.mouseEventNode || canvas;\n\n        var eventsBackend = options.EventBackend || {};\n        if ( !options.EventBackend ) options.EventBackend = eventsBackend;\n        eventsBackend.StandardMouseKeyboard = options.EventBackend.StandardMouseKeyboard || {};\n        var mouseEventNode = eventsBackend.StandardMouseKeyboard.mouseEventNode || defaultMouseEventNode;\n        eventsBackend.StandardMouseKeyboard.mouseEventNode = mouseEventNode;\n        eventsBackend.StandardMouseKeyboard.keyboardEventNode = eventsBackend.StandardMouseKeyboard.keyboardEventNode || document;\n\n        // hammer, Only activate it if we have a touch device in order to fix problems with IE11\n        if ( 'ontouchstart' in window ) {\n            eventsBackend.Hammer = eventsBackend.Hammer || {};\n            eventsBackend.Hammer.eventNode = eventsBackend.Hammer.eventNode || defaultMouseEventNode;\n        }\n        // gamepad\n        eventsBackend.GamePad = eventsBackend.GamePad || {};\n\n        this._eventProxy = this.initEventProxy( options );\n    },\n\n    initOptions: function ( userOptions ) {\n        // use default options\n        var options = new Options();\n\n        if ( userOptions ) {\n            // user options override by user options\n            options.extend( userOptions );\n        }\n\n        // if url options override url options\n        options.extendWithOptionsURL();\n\n        // Activate global trace on log call\n        if ( options.getBoolean( 'traceLogCall' ) === true ) Notify.traceLogCall = true;\n\n        // Check if Frustum culling is enabled to calculate the clip planes\n        if ( options.getBoolean( 'enableFrustumCulling' ) === true )\n            this.getCamera().getRenderer().getCullVisitor().setEnableFrustumCulling( true );\n\n\n        return options;\n    },\n\n    initWebGLContext: function ( canvas, options, error ) {\n\n        // #FIXME see tojiro's blog for webgl lost context stuffs\n        if ( options.get( 'SimulateWebGLLostContext' ) ) {\n            canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas( canvas );\n            canvas.loseContextInNCalls( options.get( 'SimulateWebGLLostContext' ) );\n        }\n\n        var gl = WebGLUtils.setupWebGL( canvas, options, error );\n\n        canvas.addEventListener( 'webglcontextlost', function ( event ) {\n            this.contextLost();\n            event.preventDefault();\n        }.bind( this ), false );\n\n        canvas.addEventListener( 'webglcontextrestored', function () {\n            this.contextRestored();\n        }.bind( this ), false );\n\n        if ( Notify.reportWebGLError || options.get( 'reportWebGLError' ) ) {\n            gl = WebGLDebugUtils.makeDebugContext( gl );\n        }\n\n        this.initWebGLCaps( gl );\n        this.setGraphicContext( gl );\n\n        return gl;\n    },\n\n    initRun: function ( options ) {\n\n        if ( options.getBoolean( 'GLSLOptimizer' ) === true ) {\n\n            var Shader = require( 'osg/Shader' );\n            Shader.enableGLSLOptimizer = true;\n\n            this._runPromise = getGLSLOptimizer();\n            this._runPromise.then( function ( glslOptimizer ) {\n                Shader.glslOptimizer = glslOptimizer;\n                if ( Shader.glslOptimizer )\n                    Notify.log( 'uses glsl optimizer, use ?log=info to see shader output' );\n                else\n                    Notify.error( 'failed to load glsl optimizer' );\n            } ).catch( function ( error ) {\n                Notify.error( error );\n            } );\n        }\n\n    },\n\n    setContextLostCallback: function ( cb ) {\n        this._contextLostCallback = cb;\n        // just in case callback registration\n        // happens after the context lost\n        if ( this._contextLost ) {\n            cb();\n        }\n    },\n\n    contextLost: function () {\n        Notify.log( 'webgl context lost' );\n        if ( this._contextLostCallback ) {\n            this._contextLostCallback();\n        }\n        this._contextLost = true;\n        window.cancelAnimationFrame( this._requestID );\n    },\n\n    contextRestored: function () {\n        Notify.log( 'webgl context restored, but not supported - reload the page' );\n        // Supporting it implies to have\n        // reloaded all your resources:\n        // textures, vertex/index buffers, shaders, frame buffers\n        // so only set it back if you happen to have restored the context\n        // this._contextLost = false;\n    },\n\n    init: function () {\n        //this._done = false;\n    },\n\n    getUpdateVisitor: function () {\n        return this._updateVisitor;\n    },\n\n    getState: function () {\n        return this.getCamera().getRenderer().getState();\n    },\n\n    initStats: function ( options ) {\n\n        var timerGPU = TimerGPU.instance( this.getGraphicContext() );\n\n        if ( !options.getBoolean( 'stats' ) ) {\n            timerGPU.disable();\n            return;\n        }\n\n        this._stats = createStats( options );\n\n        timerGPU.setCallback( this.callbackTimerGPU.bind( this ) );\n    },\n\n    callbackTimerGPU: function ( average, queryID ) {\n        if ( this._stats ) this._stats.rStats( queryID ).set( average / 1e6 );\n    },\n\n    getViewerStats: function () {\n        return this._stats;\n    },\n\n    renderingTraversal: function () {\n\n        if ( this.getScene().getSceneData() )\n            this.getScene().getSceneData().getBound();\n\n\n        if ( this.getCamera() ) {\n\n            var stats = this._stats;\n            var timerGPU = TimerGPU.instance( this.getGraphicContext() );\n\n            var renderer = this.getCamera().getRenderer();\n\n            if ( stats ) stats.rStats( 'cull' ).start();\n\n            renderer.cull();\n\n            if ( stats ) stats.rStats( 'cull' ).end();\n\n            timerGPU.pollQueries();\n            timerGPU.start( 'glframe' );\n\n            if ( stats ) {\n                stats.rStats( 'render' ).start();\n            }\n\n            renderer.draw();\n\n            if ( stats ) {\n                stats.rStats( 'render' ).end();\n            }\n\n            timerGPU.end( 'glframe' );\n\n            if ( stats ) {\n                var cullVisitor = renderer.getCullVisitor();\n                stats.rStats( 'cullcamera' ).set( cullVisitor._numCamera );\n                stats.rStats( 'cullmatrixtransform' ).set( cullVisitor._numMatrixTransform );\n                stats.rStats( 'cullprojection' ).set( cullVisitor._numProjection );\n                stats.rStats( 'cullnode' ).set( cullVisitor._numNode );\n                stats.rStats( 'cullightsource' ).set( cullVisitor._numLightSource );\n                stats.rStats( 'cullgeometry' ).set( cullVisitor._numGeometry );\n                stats.rStats( 'pushstateset' ).set( renderer.getState()._numPushStateSet );\n            }\n\n        }\n\n    },\n\n\n    updateTraversal: function () {\n\n        var stats = this._stats;\n\n        if ( stats ) stats.rStats( 'update' ).start();\n\n        // update the scene\n        this._updateVisitor.resetStats();\n        this.getScene().updateSceneGraph( this._updateVisitor );\n\n        if ( stats ) stats.rStats( 'updatecallback' ).set( this._updateVisitor._numUpdateCallback );\n\n        // Remove ExpiredSubgraphs from DatabasePager\n        this.getDatabasePager().releaseGLExpiredSubgraphs( 0.005 );\n        // In OSG this.is deferred until the draw traversal, to handle multiple contexts\n        this.flushDeletedGLObjects( 0.005 );\n\n        if ( stats ) stats.rStats( 'update' ).end();\n\n    },\n\n    advance: function ( simulationTime ) {\n\n        var sTime = simulationTime;\n\n        if ( sTime === undefined )\n            sTime = Number.MAX_VALUE;\n\n        var frameStamp = this._frameStamp;\n        var previousFrameNumber = frameStamp.getFrameNumber();\n\n        frameStamp.setFrameNumber( previousFrameNumber + 1 );\n\n        var deltaS = Timer.instance().deltaS( this._startTick, Timer.instance().tick() );\n        frameStamp.setReferenceTime( deltaS );\n\n        var lastSimulationTime = frameStamp.getSimulationTime();\n        frameStamp.setSimulationTime( sTime === Number.MAX_VALUE ? deltaS : sTime ); // set simul time\n        frameStamp.setDeltaTime( frameStamp.getSimulationTime() - lastSimulationTime ); // compute delta since last tick\n\n    },\n\n    beginFrame: function () {\n\n        var stats = this._stats;\n\n        if ( stats ) {\n            stats.rStats( 'frame' ).start();\n            stats.glS.start();\n\n            stats.rStats( 'rAF' ).tick();\n            stats.rStats( 'FPS' ).frame();\n        }\n\n    },\n\n    endFrame: function () {\n\n        var frameNumber = this.getFrameStamp().getFrameNumber();\n\n        var stats = this._stats;\n        var rStats = stats ? stats.rStats : undefined;\n\n        // update texture stats\n        if ( rStats ) {\n            Texture.getTextureManager( this.getGraphicContext() ).updateStats( frameNumber, rStats );\n            rStats( 'frame' ).end();\n\n            rStats( 'rStats' ).start();\n            rStats().update();\n            rStats( 'rStats' ).end();\n        }\n\n    },\n\n    checkNeedToDoFrame: function () {\n        return this._requestContinousUpdate || this._requestRedraw;\n    },\n\n    frame: function () {\n\n        // _contextLost check for code calling viewer::frame directly\n        // (likely force preload gl resource or direct render control )\n        if ( this._contextLost ) return;\n\n        this.beginFrame();\n\n        this.advance();\n\n        // update viewport if a resize occured\n        var canvasSizeChanged = this.updateViewport();\n\n        // update inputs devices\n        this.updateEventProxy( this._eventProxy, this.getFrameStamp() );\n\n        // setup framestamp\n        this._updateVisitor.setFrameStamp( this.getFrameStamp() );\n        // Update Manipulator/Event\n        if ( this.getManipulator() ) {\n            this.getManipulator().update( this._updateVisitor );\n            mat4.copy( this.getCamera().getViewMatrix(), this.getManipulator().getInverseMatrix() );\n        }\n\n        if ( this.checkNeedToDoFrame() || canvasSizeChanged ) {\n            this._requestRedraw = false;\n            this.updateTraversal();\n            this.renderingTraversal();\n        }\n\n        this.endFrame();\n\n        // submit frame to vr headset\n        if ( this._hmd && this._hmd.isPresenting )\n            this._hmd.submitFrame();\n    },\n\n    setDone: function ( bool ) {\n        this._done = bool;\n    },\n\n    done: function () {\n        return this._done;\n    },\n\n    _runImplementation: function () {\n        var self = this;\n        var render = function () {\n            if ( !self.done() ) {\n                self._requestID = self._requestAnimationFrame( render, self.getGraphicContext().canvas );\n                self.frame();\n            }\n        };\n        render();\n    },\n\n    run: function () {\n\n        var self = this;\n        this._runPromise.then( function () {\n            self._runImplementation();\n        } ).catch( function () {\n            self._runImplementation();\n        } );\n\n    },\n\n    setVRDisplay: function ( hmd ) {\n        this._hmd = hmd;\n        this._requestAnimationFrame = hmd.requestAnimationFrame.bind( hmd );\n    },\n\n    getVRDisplay: function () {\n        return this._hmd;\n    },\n\n    setPresentVR: function ( bool ) {\n        if ( !this._hmd ) {\n            Notify.warn( 'no hmd device provided to the viewer!' );\n            return P.reject();\n        }\n\n        // reset position/orientation of hmd device\n        if ( !this._hmd.capabilities.hasPosition )\n            this._hmd.resetPose();\n\n        if ( !this._hmd.capabilities.canPresent )\n            return P.reject();\n\n        if ( bool ) {\n            var layers = [ {\n                source: this.getGraphicContext().canvas\n            } ];\n            return this._hmd.requestPresent( layers );\n\n        } else {\n            return this._hmd.exitPresent();\n        }\n    },\n\n    setupManipulator: function ( manipulator /*, dontBindDefaultEvent */ ) {\n        if ( manipulator === undefined ) {\n            manipulator = new OrbitManipulator();\n        }\n\n        if ( manipulator.setNode !== undefined ) {\n            manipulator.setNode( this.getSceneData() );\n        } else {\n            // for backward compatibility\n            manipulator.view = this;\n        }\n\n        manipulator.setCamera( this.getCamera() );\n        this.setManipulator( manipulator );\n    },\n\n\n    // updateViewport\n    updateViewport: function () {\n\n        var gl = this.getGraphicContext();\n        var canvas = gl.canvas;\n\n        var hasChanged = this.computeCanvasSize( canvas );\n        if ( !hasChanged )\n            return false;\n\n        var camera = this.getCamera();\n        var vp = camera.getViewport();\n\n        var prevWidth = vp.width();\n        var prevHeight = vp.height();\n\n        var widthChangeRatio = canvas.width / prevWidth;\n        var heightChangeRatio = canvas.height / prevHeight;\n        var aspectRatioChange = widthChangeRatio / heightChangeRatio;\n        vp.setViewport( Math.round( vp.x() * widthChangeRatio ), Math.round( vp.y() * heightChangeRatio ), Math.round( vp.width() * widthChangeRatio ), Math.round( vp.height() * heightChangeRatio ) );\n\n        if ( aspectRatioChange !== 1.0 ) {\n            mat4.mul( camera.getProjectionMatrix(), camera.getProjectionMatrix(), mat4.fromScaling( mat4.create(), [ 1.0 / aspectRatioChange, 1.0, 1.0 ] ) );\n        }\n\n        return true;\n    },\n\n    // intialize all input devices\n    initEventProxy: function ( argsObject ) {\n        var args = argsObject || {};\n        var deviceEnabled = {};\n\n        var lists = EventProxy;\n        var argumentEventBackend = args.EventBackend;\n\n\n        // loop on each devices and try to initialize it\n        for ( var device in lists ) {\n\n            // check if the config has a require\n            var initialize = true;\n            var argDevice = {};\n            if ( argumentEventBackend && ( argumentEventBackend[ device ] !== undefined ) ) {\n                var bool = argumentEventBackend[ device ].enable;\n                initialize = bool !== undefined ? bool : true;\n                argDevice = argumentEventBackend[ device ];\n            }\n\n            // extend argDevice with regular options eg:\n            // var options = {\n            //     EventBackend: {\n            //         Hammer: {\n            //             drag_max_touches: 4,\n            //             transform_min_scale: 0.08,\n            //             transform_min_rotation: 180,\n            //             transform_always_block: true\n            //         }\n            //     },\n            //     zoomscroll: false\n            // };\n\n            // to options merged:\n            // var options = {\n            //     drag_max_touches: 4,\n            //     transform_min_scale: 0.08,\n            //     transform_min_rotation: 180,\n            //     transform_always_block: true,\n            //     zoomscroll: false\n            // };\n            //\n            var options = new Options();\n            options.extend( argDevice ).extend( argsObject );\n            delete options.EventBackend;\n\n            if ( initialize ) {\n                var inputDevice = new lists[ device ]( this );\n                inputDevice.init( options );\n                deviceEnabled[ device ] = inputDevice;\n            }\n        }\n        return deviceEnabled;\n    },\n    updateEventProxy: function ( list, frameStamp ) {\n        for ( var key in list ) {\n            var device = list[ key ];\n            if ( device.update )\n                device.update( frameStamp );\n        }\n    },\n\n    setManipulator: function ( manipulator ) {\n\n        if ( this._manipulator )\n            this.removeEventProxy();\n\n        if ( !manipulator.getCamera() )\n            manipulator.setCamera( this.getCamera() );\n\n        View.prototype.setManipulator.call( this, manipulator );\n    },\n\n    removeEventProxy: function () {\n        var list = this._eventProxy;\n        for ( var key in list ) {\n            var device = list[ key ];\n            if ( device.remove )\n                device.remove();\n        }\n    },\n\n    getEventProxy: function () {\n        return this._eventProxy;\n    }\n\n} );\n\nmodule.exports = Viewer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/Viewer.js\n// module id = 224\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar BrowserStats = window.BrowserStats;\nvar glStats = window.glStats;\nvar rStats = window.rStats;\n\nvar CanvasStats = function ( opts ) {\n\n    this.bS = new BrowserStats();\n    this.glS = new glStats();\n\n    var values = {\n        frame: {\n            caption: 'Total frame time (ms)',\n            over: 16,\n            average: true\n        },\n        fps: {\n            caption: 'Framerate (FPS)',\n            below: 30\n        },\n        calls: {\n            caption: 'Calls (three.js)',\n            over: 3000\n        },\n        raf: {\n            caption: 'Time since last rAF (ms)',\n            average: true,\n            avgMs: 500\n        },\n        rstats: {\n            caption: 'rStats update (ms)',\n            average: true,\n            avgMs: 100\n        },\n        update: {\n            caption: 'update',\n            average: true\n        },\n        cull: {\n            caption: 'cull',\n            average: true\n        },\n        render: {\n            caption: 'render',\n            average: true\n        },\n        glframe: {\n            caption: 'glframe',\n            average: true\n        },\n\n        textureused: {\n            caption: 'texture used'\n        },\n        texturereserved: {\n            caption: 'texture reserved'\n        },\n        texturetotal: {\n            caption: 'texture total'\n        },\n\n        pushstateset: {\n            caption: 'num pushStateSet'\n        },\n        updatecallback: {\n            caption: 'num updateCallback'\n        },\n\n        cullcamera: {\n            caption: 'camera'\n        },\n        cullmatrixtransform: {\n            caption: 'matrixTransform'\n        },\n        cullprojection: {\n            caption: 'projection'\n        },\n        cullnode: {\n            caption: 'node'\n        },\n        culllightsource: {\n            caption: 'lightSource'\n        },\n        cullgeometry: {\n            caption: 'geometry'\n        }\n    };\n\n    var fractions = [ {\n        base: 'frame',\n        steps: [ 'update', 'cull', 'render' ]\n    } ];\n\n    var groups = [ {\n        caption: 'Framerate',\n        values: [ 'fps', 'raf' ]\n    }, {\n        caption: 'Frame Budget',\n        values: [ 'frame', 'update', 'cull', 'render', 'glframe' ]\n    }, {\n        caption: 'Scene Graph',\n        values: [ 'pushstateset', 'updatecallback' ]\n    }, {\n        caption: 'Cull',\n        values: [ 'cullnode', 'cullmatrixtransform', 'cullgeometry', 'cullcamera', 'culllighsource', 'cullprojection' ]\n    }, {\n        caption: 'Texture Memory',\n        values: [ 'texturereserved', 'textureused', 'texturetotal' ]\n    } ];\n\n    var plugins = [ this.bS, this.glS ];\n\n    if ( opts ) {\n        if ( opts.values ) MACROUTILS.objectMix( values, opts.values );\n        if ( opts.groups ) Array.prototype.unshift.apply( groups, opts.groups );\n        if ( opts.fractions ) Array.prototype.push.apply( fractions, opts.fractions );\n        if ( opts.plugins ) Array.prototype.push.apply( plugins, opts.plugins );\n    }\n\n    this.rStats = new rStats( {\n        values: values,\n        groups: groups,\n        fractions: fractions,\n        plugins: plugins,\n        colours: [ '#cc9933', '#f20041', '#69818c', '#d90074', '#b6f2ee', '#660044', '#50664d', '#330022', '#f2eeb6', '#ee00ff', '#806460', '#1600a6', '#994d57', '#00004d', '#f279da', '#002933', '#395073', '#00eeff', '#79baf2', '#008066', '#79f2aa', '#00ff66', '#1a331d', '#004d14', '#8c6c46', '#388c00', '#602080', '#ff8800', '#6d3df2', '#995200', '#0d1233', '#402200', '#3d6df2', '#330e00', '#e6f23d', '#730000' ]\n    } );\n\n};\n\nvar createStats = function ( options ) {\n    // in case the deps are not here\n    if ( !rStats ) return undefined;\n\n\n    var css = '.rs-base{ position: absolute; z-index: 10000; padding: 10px; background-color: #222; font-size: 12px; line-height: 1.2em; width: 350px; font-family: \\'Roboto Condensed\\', tahoma, sans-serif; left: 0; top: 0; overflow: hidden; } .rs-base h1{ margin: 0; padding: 0; font-size: 1.4em; color: #fff; margin-bottom: 5px; cursor: pointer; } .rs-base div.rs-group{ margin-bottom: 10px; } .rs-base div.rs-group.hidden{ display: none; } .rs-base div.rs-fraction{ position: relative; margin-bottom: 5px; } .rs-base div.rs-fraction p{ width: 145px; text-align: right; margin: 0; padding: 0; } .rs-base div.rs-legend{ position: absolute; line-height: 1em; } .rs-base div.rs-counter-base{ position: relative; margin: 2px 0; height: 1em; } .rs-base span.rs-counter-id{ position: absolute; left: 0; top: 0; } .rs-base div.rs-counter-value{ position: absolute; left: 115px; width: 30px; height: 1em; top: 0; text-align: right; } .rs-base canvas.rs-canvas{ position: absolute; right: 0; } ',\n        head = document.head || document.getElementsByTagName( 'head' )[ 0 ],\n        style = document.createElement( 'style' );\n\n    style.type = 'text/css';\n    if ( style.styleSheet ) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild( document.createTextNode( css ) );\n    }\n    head.appendChild( style );\n\n    return new CanvasStats( options.rstats );\n};\n\nmodule.exports = createStats;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/createStats.js\n// module id = 225\n// module chunks = 0 1 2","'use strict';\nvar GamePad = require( 'osgViewer/eventProxy/GamePad' );\nvar HammerOsg = require( 'osgViewer/eventProxy/Hammer' );\nvar LeapMotion = require( 'osgViewer/eventProxy/LeapMotion' );\nvar StandardMouseKeyboard = require( 'osgViewer/eventProxy/StandardMouseKeyboard' );\nvar WebVR = require( 'osgViewer/eventProxy/WebVR' );\nvar DeviceOrientation = require( 'osgViewer/eventProxy/DeviceOrientation' );\n\nmodule.exports = {\n    GamePad: GamePad,\n    Hammer: HammerOsg,\n    LeapMotion: LeapMotion,\n    StandardMouseKeyboard: StandardMouseKeyboard,\n    WebVR: WebVR,\n    DeviceOrientation: DeviceOrientation\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/eventProxy.js\n// module id = 226\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\n\n\nvar GamePad = function ( viewer ) {\n    this._viewer = viewer;\n    this._type = 'GamePad';\n    this._enable = true;\n    this._gamepadIndex = -1;\n};\n\nGamePad.prototype = {\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function ( /*args*/) {},\n\n    isValid: function () {\n        if ( !this._enable )\n            return false;\n\n        var manipulator = this._viewer.getManipulator();\n        if ( !manipulator )\n            return false;\n\n        var constrollerList = manipulator.getControllerList();\n        if ( !constrollerList[ this._type ] )\n            return false;\n\n        return true;\n    },\n\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    gamepadPoll: function () {\n        if ( !navigator.getGamepads )\n            return null;\n        var gamepads = navigator.getGamepads();\n        var gamepad = gamepads[ this._gamepadIndex ];\n        if ( gamepad )\n            return gamepad;\n\n        for ( var i = 0, nb = gamepads.length; i < nb; ++i ) {\n            var gm = gamepads[ i ];\n            // https://code.google.com/p/chromium/issues/detail?id=413805\n            if ( gm && gm.id && gm.id.indexOf( 'Unknown Gamepad' ) === -1 ) {\n                this._gamepadIndex = i;\n                this.onGamepadConnect( gm );\n                return gm;\n            }\n        }\n        if ( this._gamepadIndex >= 0 ) {\n            this._gamepadIndex = -1;\n            this.onGamepadConnect();\n        }\n        return null;\n    },\n\n    onGamepadConnect: function ( gamepad ) {\n        Notify.log( 'Detected new gamepad!', gamepad );\n    },\n\n    onGamepadDisconnect: function () {\n        Notify.log( 'Gamepad disconnected' );\n    },\n\n    // Called in each frame\n    update: function () {\n        // we poll instead\n\n        if ( !this.isValid() )\n            return;\n\n        var gamepad = this.gamepadPoll();\n        if ( !gamepad )\n            return;\n\n        var manipulatorAdapter = this.getManipulatorController();\n        //manipulatorAdapter.setEventProxy(this);\n        if ( manipulatorAdapter.update ) {\n            manipulatorAdapter.update( gamepad );\n        }\n    }\n};\nmodule.exports = GamePad;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/GamePad.js\n// module id = 227\n// module chunks = 0 1 2","'use strict';\nvar Hammer = require( 'hammer' );\n\n\nvar HammerController = function ( viewer ) {\n    this._enable = true;\n    this._viewer = viewer;\n    this._type = 'Hammer';\n\n    this._eventNode = undefined;\n\n};\n\nHammerController.prototype = {\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function ( options ) {\n\n        /*jshint camelcase: false */\n\n        var deviceOptions = {\n            prevent_default: true,\n            drag_max_touches: 2,\n            transform_min_scale: 0.08,\n            transform_min_rotation: 180,\n            transform_always_block: true,\n            hold: false,\n            release: false,\n            swipe: false,\n            tap: false\n        };\n        /*jshint camelcase: true */\n\n        this._eventNode = options.eventNode;\n\n        if ( this._eventNode ) {\n\n            this._hammer = new Hammer( this._eventNode, deviceOptions );\n\n            if ( options.getBoolean( 'scrollwheel' ) === false )\n                this._hammer.get( 'pinch' ).set( {\n                    enable: false\n                } );\n            else\n                this._hammer.get( 'pinch' ).set( {\n                    enable: true\n                } );\n\n        }\n    },\n\n    isValid: function () {\n        if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )\n            return true;\n        return false;\n    },\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    // use the update to set the input device to mouse controller\n    // it's needed to compute size\n    update: function () {\n        if ( !this.isValid() )\n            return;\n\n        // we pass directly hammer object\n        this.getManipulatorController().setEventProxy( this._hammer );\n    },\n    remove: function () {\n        if ( !this.isValid() )\n            return;\n        this.getManipulatorController().removeEventProxy( this._hammer );\n    }\n\n};\nmodule.exports = HammerController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/Hammer.js\n// module id = 228\n// module chunks = 0 1 2","'use strict';\nvar Leap = require( 'leap' );\nvar Notify = require( 'osg/notify' );\n\nvar LeapMotion = function ( viewer ) {\n    this._viewer = viewer;\n    this._type = 'LeapMotion';\n    this._enable = true;\n};\n\nLeapMotion.prototype = {\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function ( args ) {\n\n        // add condition if no leap in global space\n        if ( typeof Leap === 'undefined' || !Leap.Controller )\n            return;\n\n        var self = this;\n        this._controller = new Leap.Controller( {\n            enableGestures: args.gestures || true,\n            tryReconnectOnDisconnect: true,\n            connectAttempts: 3\n        } );\n        this._controller.on( 'ready', function () {\n            if ( args.readyCallback )\n                args.readyCallback( self._controller );\n            self._leapMotionReady = true;\n            Notify.info( 'leapmotion ready' );\n        } );\n        this._controller.loop( this._update.bind( this ) );\n    },\n\n    isValid: function () {\n        if ( !this._enable )\n            return false;\n\n        var manipulator = this._viewer.getManipulator();\n        if ( !manipulator )\n            return false;\n\n        var constrollerList = manipulator.getControllerList();\n        if ( !constrollerList[ this._type ] )\n            return false;\n\n        return true;\n    },\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    // this is binded\n    _update: function ( frame ) {\n        if ( !frame.valid || !this.isValid() ) {\n            return;\n        }\n        var manipulatorAdapter = this.getManipulatorController();\n        if ( manipulatorAdapter.update ) {\n            manipulatorAdapter.update( frame );\n        }\n    }\n};\nmodule.exports = LeapMotion;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/LeapMotion.js\n// module id = 229\n// module chunks = 0 1 2","module.exports = __WEBPACK_EXTERNAL_MODULE_230__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Leap\",\"commonjs2\":\"leapjs\",\"commonjs\":\"leapjs\",\"amd\":\"leap\"}\n// module id = 230\n// module chunks = 0 1 2","'use strict';\nvar vec2 = require( 'osg/glMatrix' ).vec2;\n\n\nvar StandardMouseKeyboard = function ( viewer ) {\n    this._enable = true;\n    this._viewer = viewer;\n    this._type = 'StandardMouseKeyboard';\n\n    this._mouseEventNode = undefined;\n    this._wheelEventNode = undefined;\n    this._keyboardEventNode = undefined;\n    this._eventList = [ 'mousedown', 'mouseup', 'mouseout', 'mousemove', 'dblclick' ];\n    this._mousePosition = vec2.create();\n};\n\nStandardMouseKeyboard.prototype = {\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function ( options ) {\n\n        var mouse = options.mouseEventNode;\n\n        var mousewheel = options.wheelEventNode || mouse;\n        var keyboard = options.keyboardEventNode || mouse;\n\n        if ( options.getBoolean( 'scrollwheel' ) === false )\n            mousewheel = null;\n\n        this._mouseEventNode = mouse;\n        this._wheelEventNode = mousewheel;\n        this._keyboardEventNode = keyboard;\n\n        // to remove listeners, you need the exact same callback\n        this._callbacks = {\n            mousedown: this.mousedown.bind( this ),\n            mouseup: this.mouseup.bind( this ),\n            mouseout: this.mouseout.bind( this ),\n            mousemove: this.mousemove.bind( this ),\n            dblclick: this.dblclick.bind( this ),\n            mousewheel: this.mousewheel.bind( this ),\n            preventDefault: this.preventDefault.bind( this ),\n            keydown: this.keydown.bind( this ),\n            keyup: this.keyup.bind( this )\n        };\n\n        this.addEventListeners();\n    },\n\n    _addOrRemoveEventListeners: function ( remove ) {\n        var callbacks = this._callbacks;\n        var cb = remove ? 'removeEventListener' : 'addEventListener';\n        var cbMouse = this._mouseEventNode && this._mouseEventNode[ cb ].bind( this._mouseEventNode );\n        var cbMousewheel = this._wheelEventNode && this._wheelEventNode[ cb ].bind( this._wheelEventNode );\n        var cbKeyboard = this._keyboardEventNode && this._keyboardEventNode[ cb ].bind( this._keyboardEventNode );\n\n        if ( cbMouse ) {\n            for ( var i = 0, l = this._eventList.length; i < l; i++ ) {\n                var ev = this._eventList[ i ];\n                cbMouse( ev, callbacks[ ev ], false );\n            }\n        }\n\n        if ( cbMousewheel ) {\n            cbMousewheel( 'DOMMouseScroll', callbacks.mousewheel, false );\n            cbMousewheel( 'mousewheel', callbacks.mousewheel, false );\n            cbMousewheel( 'MozMousePixelScroll', callbacks.preventDefault, false );\n        }\n\n        if ( cbKeyboard ) {\n            cbKeyboard( 'keydown', callbacks.keydown, false );\n            cbKeyboard( 'keyup', callbacks.keyup, false );\n        }\n    },\n\n    addEventListeners: function () {\n        return this._addOrRemoveEventListeners( false );\n    },\n\n    removeEventListeners: function () {\n        return this._addOrRemoveEventListeners( true );\n    },\n\n    isValid: function () {\n        if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )\n            return true;\n        return false;\n    },\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    keyup: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().keyup )\n            return this.getManipulatorController().keyup( ev );\n\n        return undefined;\n    },\n\n    keydown: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().keydown )\n            return this.getManipulatorController().keydown( ev );\n\n        return undefined;\n    },\n\n    mousedown: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().mousedown ) {\n\n            // prevent browser to enter in scroll mode\n            if ( ev.button === 1 ) ev.preventDefault();\n\n            return this.getManipulatorController().mousedown( ev );\n        }\n\n        return undefined;\n    },\n\n    mouseup: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().mouseup )\n            return this.getManipulatorController().mouseup( ev );\n\n        return undefined;\n    },\n\n    mouseout: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().mouseout )\n            return this.getManipulatorController().mouseout( ev );\n\n        return undefined;\n    },\n\n    mousemove: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().mousemove )\n            return this.getManipulatorController().mousemove( ev );\n\n        return undefined;\n    },\n\n    dblclick: function ( ev ) {\n\n        if ( this.isValid() && this.getManipulatorController().dblclick )\n            return this.getManipulatorController().dblclick( ev );\n\n        return undefined;\n    },\n\n    mousewheel: function ( event ) {\n\n        if ( !this.isValid() )\n            return undefined;\n\n        var manipulatorAdapter = this.getManipulatorController();\n\n        if ( !manipulatorAdapter.mousewheel )\n            return undefined;\n\n        event.preventDefault();\n\n        // from jquery\n        var orgEvent = event || window.event,\n            args = [].slice.call( arguments, 1 ),\n            delta = 0,\n            deltaX = 0,\n            deltaY = 0;\n\n        // Old school scrollwheel delta\n        if ( event.wheelDelta ) {\n            delta = event.wheelDelta / 120;\n        }\n        if ( event.detail ) {\n            delta = -event.detail / 3;\n        }\n\n        // New school multidimensional scroll (touchpads) deltas\n        deltaY = delta;\n\n        // Gecko\n        if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {\n            deltaY = 0;\n            deltaX = -1 * delta;\n        }\n\n        // Webkit\n        if ( orgEvent.wheelDeltaY !== undefined ) {\n            deltaY = orgEvent.wheelDeltaY / 120;\n        }\n        if ( orgEvent.wheelDeltaX !== undefined ) {\n            deltaX = -1 * orgEvent.wheelDeltaX / 120;\n        }\n        // Add event and delta to the front of the arguments\n        args.unshift( event, delta, deltaX, deltaY );\n\n        return this.getManipulatorController().mousewheel.apply( manipulatorAdapter, args );\n    },\n\n    preventDefault: function ( event ) {\n        event.preventDefault();\n    },\n\n    divGlobalOffset: function ( obj ) {\n        var x = 0,\n            y = 0;\n        x = obj.offsetLeft;\n        y = obj.offsetTop;\n        var body = document.getElementsByTagName( 'body' )[ 0 ];\n        while ( obj.offsetParent && obj !== body ) {\n            x += obj.offsetParent.offsetLeft;\n            y += obj.offsetParent.offsetTop;\n            obj = obj.offsetParent;\n        }\n        this._mousePosition[ 0 ] = x;\n        this._mousePosition[ 1 ] = y;\n        return this._mousePosition;\n    },\n\n    getPositionRelativeToCanvas: function ( e, result ) {\n        var myObject = e.target;\n        var posx, posy;\n        if ( e.pageX || e.pageY ) {\n            posx = e.pageX;\n            posy = e.pageY;\n        } else if ( e.clientX || e.clientY ) {\n            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n\n        // posx and posy contain the mouse position relative to the document\n        // Do something with this information\n        var globalOffset = this.divGlobalOffset( myObject );\n        posx = posx - globalOffset[ 0 ];\n        posy = myObject.height - ( posy - globalOffset[ 1 ] );\n\n        // copy data to result if need to keep result\n        // else we use a tmp variable inside manipulator\n        // that we override at each call\n        if ( result === undefined ) {\n            result = this._mousePosition;\n        }\n        result[ 0 ] = posx;\n        result[ 1 ] = posy;\n        return result;\n    },\n\n    // use the update to set the input device to mouse controller\n    // it's needed to compute size\n    update: function () {\n        if ( !this.isValid() )\n            return;\n\n        this.getManipulatorController().setEventProxy( this );\n    }\n\n};\nmodule.exports = StandardMouseKeyboard;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/StandardMouseKeyboard.js\n// module id = 231\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar quat = require( 'osg/glMatrix' ).quat;\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nrequire( 'osgUtil/webvr-1-1' ); // polyfill\n\n\nvar WebVR = function ( viewer ) {\n    this._viewer = viewer;\n\n    this._type = 'WebVR';\n    this._enable = false;\n    this._hmd = undefined;\n    this._sensor = undefined;\n\n    this._frameData = undefined;\n    this._quat = quat.create();\n    this._pos = vec3.create();\n\n    this._worldScale = 1.0;\n};\n\nWebVR.prototype = {\n\n    setWorldScale: function ( val ) {\n        this._worldScale = val;\n    },\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function () {\n\n        if ( !navigator.getVRDisplays )\n            return;\n\n        var self = this;\n        navigator.getVRDisplays().then( function ( displays ) {\n            if ( displays.length > 0 ) {\n                self._hmd = displays[ 0 ];\n                self._frameData = new window.VRFrameData();\n                Notify.log( 'Found a VR display' );\n                // currently it's the event proxy webvr that has the responsability of detecting vr devices\n                self._viewer.setVRDisplay( self._hmd );\n            }\n        } );\n    },\n\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    isValid: function () {\n        if ( !this._enable )\n            return false;\n\n        var manipulator = this._viewer.getManipulator();\n        if ( !manipulator )\n            return false;\n\n        if ( !manipulator.getControllerList()[ this._type ] )\n            return false;\n\n        if ( !this._hmd )\n            return false;\n\n        return true;\n    },\n\n    update: ( function () {\n        var tempQuat = quat.create();\n        var tempPos = vec3.create();\n\n        return function () {\n\n            if ( !this.isValid() )\n                return;\n\n            var manipulatorAdapter = this.getManipulatorController();\n\n            // update the manipulator with the rotation of the device\n            if ( !manipulatorAdapter.update )\n                return;\n\n            if ( !this._hmd.capabilities.hasOrientation && !this._hmd.capabilities.hasPosition )\n                return;\n\n            this._hmd.getFrameData( this._frameData );\n\n            var pose = this._frameData.pose;\n\n            if ( !pose )\n                return;\n\n            // WebVR up vector is Y\n            // OSGJS up vector is Z\n\n            var sitToStand = this._hmd.stageParameters && this._hmd.stageParameters.sittingToStandingTransform;\n\n            var q = pose.orientation;\n            if ( q ) {\n                if ( sitToStand ) {\n                    q = mat4.getRotation( tempQuat, sitToStand );\n                    quat.mul( q, q, pose.orientation );\n                }\n\n                this._quat[ 0 ] = q[ 0 ];\n                this._quat[ 1 ] = -q[ 2 ];\n                this._quat[ 2 ] = q[ 1 ];\n                this._quat[ 3 ] = q[ 3 ];\n            }\n\n            var pos = pose.position;\n            if ( pos ) {\n                if ( sitToStand ) {\n                    pos = vec3.transformMat4( tempPos, pos, sitToStand );\n                }\n                this._pos[ 0 ] = pos[ 0 ] * this._worldScale;\n                this._pos[ 1 ] = -pos[ 2 ] * this._worldScale;\n                this._pos[ 2 ] = pos[ 1 ] * this._worldScale;\n            }\n\n            manipulatorAdapter.update( this._quat, this._pos );\n        };\n    } )(),\n\n\n    getHmd: function () {\n        return this._hmd;\n    }\n};\nmodule.exports = WebVR;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/WebVR.js\n// module id = 232\n// module chunks = 0 1 2","// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Installs a shim that emulates functionality from the WebVR '1.1' spec if the\n// browser only exposes WebVR '1.0'.\n'use strict';\n\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\nif ( 'getVRDisplays' in navigator ) {\n\n    // A lot of Chrome builds to date don't have depthNear and depthFar, even\n    // though they're in the WebVR 1.0 spec. They're more necessary in 1.1.\n    if ( !( 'depthNear' in window.VRDisplay.prototype ) ) {\n        window.VRDisplay.prototype.depthNear = 0.01;\n    }\n\n    if ( !( 'depthFar' in window.VRDisplay.prototype ) ) {\n        window.VRDisplay.prototype.depthFar = 10000.0;\n    }\n\n    // If the browser has a WebVR implementation but does not include the 1.1\n    // functionality patch it with JS.\n    if ( !( 'VRFrameData' in window ) ) {\n        window.VRFrameData = function () {\n            this.leftProjectionMatrix = new Float32Array( 16 );\n            this.leftViewMatrix = new Float32Array( 16 );\n            this.rightProjectionMatrix = new Float32Array( 16 );\n            this.rightViewMatrix = new Float32Array( 16 );\n            this.pose = null;\n        };\n\n        window.VRDisplay.prototype.getFrameData = ( function () {\n\n            var defaultOrientation = new Float32Array( [ 0, 0, 0, 1 ] );\n            var defaultPosition = new Float32Array( [ 0, 0, 0 ] );\n\n            function updateEyeMatrices( projection, view, pose, parameters, vrDisplay ) {\n                mat4.perspectiveFromFieldOfView( projection, parameters.fieldOfView, vrDisplay.depthNear, vrDisplay.depthFar );\n\n                var orientation = pose.orientation;\n                var position = pose.position;\n                if ( !orientation ) {\n                    orientation = defaultOrientation;\n                }\n                if ( !position ) {\n                    position = defaultPosition;\n                }\n\n                mat4.fromRotationTranslation( view, orientation, position );\n                mat4.translate( view, view, parameters.offset );\n                mat4.invert( view, view );\n            }\n\n            return function ( frameData ) {\n                var pose = this.getPose();\n                if ( !pose )\n                    return false;\n\n                frameData.pose = pose;\n                frameData.timestamp = pose.timestamp;\n\n                updateEyeMatrices(\n                    frameData.leftProjectionMatrix, frameData.leftViewMatrix,\n                    pose, this.getEyeParameters( 'left' ), this );\n                updateEyeMatrices(\n                    frameData.rightProjectionMatrix, frameData.rightViewMatrix,\n                    pose, this.getEyeParameters( 'right' ), this );\n\n                return true;\n            };\n        } )();\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgUtil/webvr-1-1.js\n// module id = 233\n// module chunks = 0 1 2","'use strict';\n\nvar DeviceOrientation = function ( viewer ) {\n    this._viewer = viewer;\n    this._type = 'DeviceOrientation';\n    this._enable = false;\n\n    // Landscape mobile orientation testing defaults\n    this._deviceOrientation = undefined;\n    this._screenOrientation = window.orientation || 90;\n};\n\nDeviceOrientation.prototype = {\n\n    setEnable: function ( bool ) {\n        this._enable = bool;\n    },\n\n    getEnable: function () {\n        return this._enable;\n    },\n\n    init: function () {\n\n        var self = this;\n\n        // Check because Chrome send _one_ event with all angles to null\n        window.addEventListener( 'deviceorientation', function ( rawEvtData ) {\n            if ( rawEvtData.alpha !== null && rawEvtData.alpha !== undefined )\n                self._deviceOrientation = rawEvtData;\n        }, false );\n\n        window.addEventListener( 'orientationchange', function () {\n            if ( window.orientation !== null && window.orientation !== undefined )\n                self._screenOrientation = window.orientation;\n        }, false );\n\n    },\n\n    getManipulatorController: function () {\n        return this._viewer.getManipulator().getControllerList()[ this._type ];\n    },\n\n    isValid: function () {\n        if ( !this._enable )\n            return false;\n\n        if ( !this._deviceOrientation )\n            return false;\n\n        var manipulator = this._viewer.getManipulator();\n        if ( !manipulator )\n            return false;\n\n        if ( !manipulator.getControllerList()[ this._type ] )\n            return false;\n\n        return true;\n    },\n\n    update: function () {\n\n        if ( !this.isValid() )\n            return;\n\n        // update the manipulator with the rotation of the device\n        var manipulatorAdapter = this.getManipulatorController();\n        if ( manipulatorAdapter.update ) {\n            manipulatorAdapter.update( this._deviceOrientation, this._screenOrientation );\n        }\n    }\n\n};\n\nmodule.exports = DeviceOrientation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/eventProxy/DeviceOrientation.js\n// module id = 234\n// module chunks = 0 1 2","// jshint ignore: start\n\n'use strict';\nvar Notify = require( 'osg/notify' );\n\n/*\n ** Copyright (c) 2012 The Khronos Group Inc.\n **\n ** Permission is hereby granted, free of charge, to any person obtaining a\n ** copy of this software and/or associated documentation files (the\n ** \"Materials\"), to deal in the Materials without restriction, including\n ** without limitation the rights to use, copy, modify, merge, publish,\n ** distribute, sublicense, and/or sell copies of the Materials, and to\n ** permit persons to whom the Materials are furnished to do so, subject to\n ** the following conditions:\n **\n ** The above copyright notice and this permission notice shall be included\n ** in all copies or substantial portions of the Materials.\n **\n ** THE MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n */\n\n// Various functions for helping debug WebGL apps.\n\nvar WebGLDebugUtils = function () {\n\n    /**\n     * Wrapped logging function.\n     * @param {string} msg Message to log.\n     */\n    var log = function ( msg ) {\n        if ( window.console && window.console.log ) {\n            window.console.log( msg );\n        }\n    };\n\n    /**\n     * Wrapped error logging function.\n     * @param {string} msg Message to log.\n     */\n    var error = function ( msg ) {\n        if ( window.console && window.console.error ) {\n            window.console.error( msg );\n        } else {\n            log( msg );\n        }\n    };\n\n\n    /**\n     * Which arguments are enums based on the number of arguments to the function.\n     * So\n     *    'texImage2D': {\n     *       9: { 0:true, 2:true, 6:true, 7:true },\n     *       6: { 0:true, 2:true, 3:true, 4:true },\n     *    },\n     *\n     * means if there are 9 arguments then 6 and 7 are enums, if there are 6\n     * arguments 3 and 4 are enums\n     *\n     * @type {!Object.<number, !Object.<number, string>}\n     */\n    var glValidEnumContexts = {\n        // Generic setters and getters\n\n        'enable': {\n            1: {\n                0: true\n            }\n        },\n        'disable': {\n            1: {\n                0: true\n            }\n        },\n        'getParameter': {\n            1: {\n                0: true\n            }\n        },\n\n        // Rendering\n\n        'drawArrays': {\n            3: {\n                0: true\n            }\n        },\n        'drawElements': {\n            4: {\n                0: true,\n                2: true\n            }\n        },\n\n        // Shaders\n\n        'createShader': {\n            1: {\n                0: true\n            }\n        },\n        'getShaderParameter': {\n            2: {\n                1: true\n            }\n        },\n        'getProgramParameter': {\n            2: {\n                1: true\n            }\n        },\n        'getShaderPrecisionFormat': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n\n        // Vertex attributes\n\n        'getVertexAttrib': {\n            2: {\n                1: true\n            }\n        },\n        'vertexAttribPointer': {\n            6: {\n                2: true\n            }\n        },\n\n        // Textures\n\n        'bindTexture': {\n            2: {\n                0: true\n            }\n        },\n        'activeTexture': {\n            1: {\n                0: true\n            }\n        },\n        'getTexParameter': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        'texParameterf': {\n            3: {\n                0: true,\n                1: true\n            }\n        },\n        'texParameteri': {\n            3: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints\n        'copyTexImage2D': {\n            8: {\n                0: true,\n                2: true\n            }\n        },\n        'copyTexSubImage2D': {\n            8: {\n                0: true\n            }\n        },\n        'generateMipmap': {\n            1: {\n                0: true\n            }\n        },\n        // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints\n\n        // Buffer objects\n\n        'bindBuffer': {\n            2: {\n                0: true\n            }\n        },\n        // bufferData and bufferSubData are defined below with WebGL 2 entrypoints\n        'getBufferParameter': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n\n        // Renderbuffers and framebuffers\n\n        'pixelStorei': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        // readPixels is defined below with WebGL 2 entrypoints\n        'bindRenderbuffer': {\n            2: {\n                0: true\n            }\n        },\n        'bindFramebuffer': {\n            2: {\n                0: true\n            }\n        },\n        'checkFramebufferStatus': {\n            1: {\n                0: true\n            }\n        },\n        'framebufferRenderbuffer': {\n            4: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        'framebufferTexture2D': {\n            5: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        'getFramebufferAttachmentParameter': {\n            3: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        'getRenderbufferParameter': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        'renderbufferStorage': {\n            4: {\n                0: true,\n                1: true\n            }\n        },\n\n        // Frame buffer operations (clear, blend, depth test, stencil)\n\n        'clear': {\n            1: {\n                0: {\n                    'enumBitwiseOr': [ 'COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT' ]\n                }\n            }\n        },\n        'depthFunc': {\n            1: {\n                0: true\n            }\n        },\n        'blendFunc': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        'blendFuncSeparate': {\n            4: {\n                0: true,\n                1: true,\n                2: true,\n                3: true\n            }\n        },\n        'blendEquation': {\n            1: {\n                0: true\n            }\n        },\n        'blendEquationSeparate': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        'stencilFunc': {\n            3: {\n                0: true\n            }\n        },\n        'stencilFuncSeparate': {\n            4: {\n                0: true,\n                1: true\n            }\n        },\n        'stencilMaskSeparate': {\n            2: {\n                0: true\n            }\n        },\n        'stencilOp': {\n            3: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        'stencilOpSeparate': {\n            4: {\n                0: true,\n                1: true,\n                2: true,\n                3: true\n            }\n        },\n\n        // Culling\n\n        'cullFace': {\n            1: {\n                0: true\n            }\n        },\n        'frontFace': {\n            1: {\n                0: true\n            }\n        },\n\n        // ANGLE_instanced_arrays extension\n\n        'drawArraysInstancedANGLE': {\n            4: {\n                0: true\n            }\n        },\n        'drawElementsInstancedANGLE': {\n            5: {\n                0: true,\n                2: true\n            }\n        },\n\n        // EXT_blend_minmax extension\n\n        'blendEquationEXT': {\n            1: {\n                0: true\n            }\n        },\n\n        // WebGL 2 Buffer objects\n\n        'bufferData': {\n            3: {\n                0: true,\n                2: true\n            }, // WebGL 1\n            4: {\n                0: true,\n                2: true\n            }, // WebGL 2\n            5: {\n                0: true,\n                2: true\n            } // WebGL 2\n        },\n        'bufferSubData': {\n            3: {\n                0: true\n            }, // WebGL 1\n            4: {\n                0: true\n            }, // WebGL 2\n            5: {\n                0: true\n            } // WebGL 2\n        },\n        'copyBufferSubData': {\n            5: {\n                0: true,\n                1: true\n            }\n        },\n        'getBufferSubData': {\n            3: {\n                0: true\n            },\n            4: {\n                0: true\n            },\n            5: {\n                0: true\n            }\n        },\n\n        // WebGL 2 Framebuffer objects\n\n        'blitFramebuffer': {\n            10: {\n                8: {\n                    'enumBitwiseOr': [ 'COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT' ]\n                },\n                9: true\n            }\n        },\n        'framebufferTextureLayer': {\n            5: {\n                0: true,\n                1: true\n            }\n        },\n        'invalidateFramebuffer': {\n            2: {\n                0: true\n            }\n        },\n        'invalidateSubFramebuffer': {\n            6: {\n                0: true\n            }\n        },\n        'readBuffer': {\n            1: {\n                0: true\n            }\n        },\n\n        // WebGL 2 Renderbuffer objects\n\n        'getInternalformatParameter': {\n            3: {\n                0: true,\n                1: true,\n                2: true\n            }\n        },\n        'renderbufferStorageMultisample': {\n            5: {\n                0: true,\n                2: true\n            }\n        },\n\n        // WebGL 2 Texture objects\n\n        'texStorage2D': {\n            5: {\n                0: true,\n                2: true\n            }\n        },\n        'texStorage3D': {\n            6: {\n                0: true,\n                2: true\n            }\n        },\n        'texImage2D': {\n            9: {\n                0: true,\n                2: true,\n                6: true,\n                7: true\n            }, // WebGL 1 & 2\n            6: {\n                0: true,\n                2: true,\n                3: true,\n                4: true\n            }, // WebGL 1\n            10: {\n                0: true,\n                2: true,\n                6: true,\n                7: true\n            } // WebGL 2\n        },\n        'texImage3D': {\n            10: {\n                0: true,\n                2: true,\n                7: true,\n                8: true\n            },\n            11: {\n                0: true,\n                2: true,\n                7: true,\n                8: true\n            }\n        },\n        'texSubImage2D': {\n            9: {\n                0: true,\n                6: true,\n                7: true\n            }, // WebGL 1 & 2\n            7: {\n                0: true,\n                4: true,\n                5: true\n            }, // WebGL 1\n            10: {\n                0: true,\n                6: true,\n                7: true\n            } // WebGL 2\n        },\n        'texSubImage3D': {\n            11: {\n                0: true,\n                8: true,\n                9: true\n            },\n            12: {\n                0: true,\n                8: true,\n                9: true\n            }\n        },\n        'copyTexSubImage3D': {\n            9: {\n                0: true\n            }\n        },\n        'compressedTexImage2D': {\n            7: {\n                0: true,\n                2: true\n            }, // WebGL 1 & 2\n            8: {\n                0: true,\n                2: true\n            }, // WebGL 2\n            9: {\n                0: true,\n                2: true\n            } // WebGL 2\n        },\n        'compressedTexImage3D': {\n            8: {\n                0: true,\n                2: true\n            },\n            9: {\n                0: true,\n                2: true\n            },\n            10: {\n                0: true,\n                2: true\n            }\n        },\n        'compressedTexSubImage2D': {\n            8: {\n                0: true,\n                6: true\n            }, // WebGL 1 & 2\n            9: {\n                0: true,\n                6: true\n            }, // WebGL 2\n            10: {\n                0: true,\n                6: true\n            } // WebGL 2\n        },\n        'compressedTexSubImage3D': {\n            10: {\n                0: true,\n                8: true\n            },\n            11: {\n                0: true,\n                8: true\n            },\n            12: {\n                0: true,\n                8: true\n            }\n        },\n\n        // WebGL 2 Vertex attribs\n\n        'vertexAttribIPointer': {\n            5: {\n                2: true\n            }\n        },\n\n        // WebGL 2 Writing to the drawing buffer\n\n        'drawArraysInstanced': {\n            4: {\n                0: true\n            }\n        },\n        'drawElementsInstanced': {\n            5: {\n                0: true,\n                2: true\n            }\n        },\n        'drawRangeElements': {\n            6: {\n                0: true,\n                4: true\n            }\n        },\n\n        // WebGL 2 Reading back pixels\n\n        'readPixels': {\n            7: {\n                4: true,\n                5: true\n            }, // WebGL 1 & 2\n            8: {\n                4: true,\n                5: true\n            } // WebGL 2\n        },\n\n        // WebGL 2 Multiple Render Targets\n\n        'clearBufferfv': {\n            3: {\n                0: true\n            },\n            4: {\n                0: true\n            }\n        },\n        'clearBufferiv': {\n            3: {\n                0: true\n            },\n            4: {\n                0: true\n            }\n        },\n        'clearBufferuiv': {\n            3: {\n                0: true\n            },\n            4: {\n                0: true\n            }\n        },\n        'clearBufferfi': {\n            4: {\n                0: true\n            }\n        },\n\n        // WebGL 2 Query objects\n\n        'beginQuery': {\n            2: {\n                0: true\n            }\n        },\n        'endQuery': {\n            1: {\n                0: true\n            }\n        },\n        'getQuery': {\n            2: {\n                0: true,\n                1: true\n            }\n        },\n        'getQueryParameter': {\n            2: {\n                1: true\n            }\n        },\n\n        // WebGL 2 Sampler objects\n\n        'samplerParameteri': {\n            3: {\n                1: true,\n                2: true\n            }\n        },\n        'samplerParameterf': {\n            3: {\n                1: true\n            }\n        },\n        'getSamplerParameter': {\n            2: {\n                1: true\n            }\n        },\n\n        // WebGL 2 Sync objects\n\n        'fenceSync': {\n            2: {\n                0: true,\n                1: {\n                    'enumBitwiseOr': []\n                }\n            }\n        },\n        'clientWaitSync': {\n            3: {\n                1: {\n                    'enumBitwiseOr': [ 'SYNC_FLUSH_COMMANDS_BIT' ]\n                }\n            }\n        },\n        'waitSync': {\n            3: {\n                1: {\n                    'enumBitwiseOr': []\n                }\n            }\n        },\n        'getSyncParameter': {\n            2: {\n                1: true\n            }\n        },\n\n        // WebGL 2 Transform Feedback\n\n        'bindTransformFeedback': {\n            2: {\n                0: true\n            }\n        },\n        'beginTransformFeedback': {\n            1: {\n                0: true\n            }\n        },\n        'transformFeedbackVaryings': {\n            3: {\n                2: true\n            }\n        },\n\n        // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers\n\n        'bindBufferBase': {\n            3: {\n                0: true\n            }\n        },\n        'bindBufferRange': {\n            5: {\n                0: true\n            }\n        },\n        'getIndexedParameter': {\n            2: {\n                0: true\n            }\n        },\n        'getActiveUniforms': {\n            3: {\n                2: true\n            }\n        },\n        'getActiveUniformBlockParameter': {\n            3: {\n                2: true\n            }\n        }\n    };\n\n    /**\n     * Map of numbers to names.\n     * @type {Object}\n     */\n    var glEnums = null;\n\n    /**\n     * Map of names to numbers.\n     * @type {Object}\n     */\n    var enumStringToValue = null;\n\n    /**\n     * Initializes this module. Safe to call more than once.\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\n     *    you have more than one context it doesn't matter which one\n     *    you pass in, it is only used to pull out constants.\n     */\n    function init( ctx ) {\n        if ( glEnums == null ) {\n            glEnums = {};\n            enumStringToValue = {};\n            for ( var propertyName in ctx ) {\n                if ( typeof ctx[ propertyName ] == 'number' ) {\n                    glEnums[ ctx[ propertyName ] ] = propertyName;\n                    enumStringToValue[ propertyName ] = ctx[ propertyName ];\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks the utils have been initialized.\n     */\n    function checkInit() {\n        if ( glEnums == null ) {\n            throw 'WebGLDebugUtils.init(ctx) not called';\n        }\n    }\n\n    /**\n     * Returns true or false if value matches any WebGL enum\n     * @param {*} value Value to check if it might be an enum.\n     * @return {boolean} True if value matches one of the WebGL defined enums\n     */\n    function mightBeEnum( value ) {\n        checkInit();\n        return ( glEnums[ value ] !== undefined );\n    }\n\n    /**\n     * Gets an string version of an WebGL enum.\n     *\n     * Example:\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n     *\n     * @param {number} value Value to return an enum for\n     * @return {string} The string version of the enum.\n     */\n    function glEnumToString( value ) {\n        checkInit();\n        var name = glEnums[ value ];\n        return ( name !== undefined ) ? ( \"gl.\" + name ) :\n            ( \"/*UNKNOWN WebGL ENUM*/ 0x\" + value.toString( 16 ) + \"\" );\n    }\n\n    /**\n     * Returns the string version of a WebGL argument.\n     * Attempts to convert enum arguments to strings.\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} numArgs the number of arguments passed to the function.\n     * @param {number} argumentIndx the index of the argument.\n     * @param {*} value The value of the argument.\n     * @return {string} The value as a string.\n     */\n    function glFunctionArgToString( functionName, numArgs, argumentIndex, value ) {\n        var funcInfo = glValidEnumContexts[ functionName ];\n        if ( funcInfo !== undefined ) {\n            var funcInfo = funcInfo[ numArgs ];\n            if ( funcInfo !== undefined ) {\n                if ( funcInfo[ argumentIndex ] ) {\n                    if ( typeof funcInfo[ argumentIndex ] === 'object' &&\n                        funcInfo[ argumentIndex ][ 'enumBitwiseOr' ] !== undefined ) {\n                        var enums = funcInfo[ argumentIndex ][ 'enumBitwiseOr' ];\n                        var orResult = 0;\n                        var orEnums = [];\n                        for ( var i = 0; i < enums.length; ++i ) {\n                            var enumValue = enumStringToValue[ enums[ i ] ];\n                            if ( ( value & enumValue ) !== 0 ) {\n                                orResult |= enumValue;\n                                orEnums.push( glEnumToString( enumValue ) );\n                            }\n                        }\n                        if ( orResult === value ) {\n                            return orEnums.join( ' | ' );\n                        } else {\n                            return glEnumToString( value );\n                        }\n                    } else {\n                        return glEnumToString( value );\n                    }\n                }\n            }\n        }\n        if ( value === null ) {\n            return \"null\";\n        } else if ( value === undefined ) {\n            return \"undefined\";\n        } else {\n            return value.toString();\n        }\n    }\n\n    /**\n     * Converts the arguments of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} args The arguments.\n     * @return {string} The arguments as a string.\n     */\n    function glFunctionArgsToString( functionName, args ) {\n        // apparently we can't do args.join(\",\");\n        var argStr = \"\";\n        var numArgs = args.length;\n        for ( var ii = 0; ii < numArgs; ++ii ) {\n            argStr += ( ( ii == 0 ) ? '' : ', ' ) +\n                glFunctionArgToString( functionName, numArgs, ii, args[ ii ] );\n        }\n        return argStr;\n    };\n\n\n    function makePropertyWrapper( wrapper, original, propertyName ) {\n        //log(\"wrap prop: \" + propertyName);\n        wrapper.__defineGetter__( propertyName, function () {\n            return original[ propertyName ];\n        } );\n        // TODO(gmane): this needs to handle properties that take more than\n        // one value?\n        wrapper.__defineSetter__( propertyName, function ( value ) {\n            //log(\"set: \" + propertyName);\n            original[ propertyName ] = value;\n        } );\n    }\n\n    // Makes a function that calls a function on another object.\n    function makeFunctionWrapper( original, functionName ) {\n        //log(\"wrap fn: \" + functionName);\n        var f = original[ functionName ];\n        return function () {\n            //log(\"call: \" + functionName);\n            var result = f.apply( original, arguments );\n            return result;\n        };\n    }\n\n    /**\n     * Given a WebGL context returns a wrapped context that calls\n     * gl.getError after every command and calls a function if the\n     * result is not gl.NO_ERROR.\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to\n     *        wrap.\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc\n     *        The function to call when gl.getError returns an\n     *        error. If not specified the default function calls\n     *        console.log with a message.\n     * @param {!function(funcName, args): void} opt_onFunc The\n     *        function to call when each webgl function is called.\n     *        You can use this to log all calls for example.\n     * @param {!WebGLRenderingContext} opt_err_ctx The webgl context\n     *        to call getError on if different than ctx.\n     */\n    function makeDebugContext( ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx ) {\n        opt_err_ctx = opt_err_ctx || ctx;\n        init( ctx );\n        opt_onErrorFunc = opt_onErrorFunc || function ( err, functionName, args ) {\n            // apparently we can't do args.join(\",\");\n            var argStr = \"\";\n            var numArgs = args.length;\n            for ( var ii = 0; ii < numArgs; ++ii ) {\n                argStr += ( ( ii == 0 ) ? '' : ', ' ) +\n                    glFunctionArgToString( functionName, numArgs, ii, args[ ii ] );\n            }\n            error( \"WebGL error \" + glEnumToString( err ) + \" in \" + functionName +\n                \"(\" + argStr + \")\" );\n        };\n\n        // Holds booleans for each GL error so after we get the error ourselves\n        // we can still return it to the client app.\n        var glErrorShadow = {};\n\n        // Makes a function that calls a WebGL function and then calls getError.\n        function makeErrorWrapper( ctx, functionName ) {\n            return function () {\n                if ( opt_onFunc ) {\n                    opt_onFunc( functionName, arguments );\n                }\n                var result = ctx[ functionName ].apply( ctx, arguments );\n                var err = opt_err_ctx.getError();\n                if ( err != 0 ) {\n                    glErrorShadow[ err ] = true;\n                    opt_onErrorFunc( err, functionName, arguments );\n                }\n                return result;\n            };\n        }\n\n        // Make a an object that has a copy of every property of the WebGL context\n        // but wraps all functions.\n        var wrapper = {};\n        for ( var propertyName in ctx ) {\n            if ( typeof ctx[ propertyName ] == 'function' ) {\n                if ( propertyName != 'getExtension' ) {\n                    wrapper[ propertyName ] = makeErrorWrapper( ctx, propertyName );\n                } else {\n                    var wrapped = makeErrorWrapper( ctx, propertyName );\n                    wrapper[ propertyName ] = function () {\n                        var result = wrapped.apply( ctx, arguments );\n                        if ( !result ) {\n                            return null;\n                        }\n                        return makeDebugContext( result, opt_onErrorFunc, opt_onFunc, opt_err_ctx );\n                    };\n                }\n            } else {\n                makePropertyWrapper( wrapper, ctx, propertyName );\n            }\n        }\n\n        // Override the getError function with one that returns our saved results.\n        wrapper.getError = function () {\n            for ( var err in glErrorShadow ) {\n                if ( glErrorShadow.hasOwnProperty( err ) ) {\n                    if ( glErrorShadow[ err ] ) {\n                        glErrorShadow[ err ] = false;\n                        return err;\n                    }\n                }\n            }\n            return ctx.NO_ERROR;\n        };\n\n        return wrapper;\n    }\n\n    function resetToInitialState( ctx ) {\n        var isWebGL2RenderingContext = !!ctx.createTransformFeedback;\n\n        if ( isWebGL2RenderingContext ) {\n            ctx.bindVertexArray( null );\n        }\n\n        var numAttribs = ctx.getParameter( ctx.MAX_VERTEX_ATTRIBS );\n        var tmp = ctx.createBuffer();\n        ctx.bindBuffer( ctx.ARRAY_BUFFER, tmp );\n        for ( var ii = 0; ii < numAttribs; ++ii ) {\n            ctx.disableVertexAttribArray( ii );\n            ctx.vertexAttribPointer( ii, 4, ctx.FLOAT, false, 0, 0 );\n            ctx.vertexAttrib1f( ii, 0 );\n            if ( isWebGL2RenderingContext ) {\n                ctx.vertexAttribDivisor( ii, 0 );\n            }\n        }\n        ctx.deleteBuffer( tmp );\n\n        var numTextureUnits = ctx.getParameter( ctx.MAX_TEXTURE_IMAGE_UNITS );\n        for ( var ii = 0; ii < numTextureUnits; ++ii ) {\n            ctx.activeTexture( ctx.TEXTURE0 + ii );\n            ctx.bindTexture( ctx.TEXTURE_CUBE_MAP, null );\n            ctx.bindTexture( ctx.TEXTURE_2D, null );\n            if ( isWebGL2RenderingContext ) {\n                ctx.bindTexture( ctx.TEXTURE_2D_ARRAY, null );\n                ctx.bindTexture( ctx.TEXTURE_3D, null );\n                ctx.bindSampler( ii, null );\n            }\n        }\n\n        ctx.activeTexture( ctx.TEXTURE0 );\n        ctx.useProgram( null );\n        ctx.bindBuffer( ctx.ARRAY_BUFFER, null );\n        ctx.bindBuffer( ctx.ELEMENT_ARRAY_BUFFER, null );\n        ctx.bindFramebuffer( ctx.FRAMEBUFFER, null );\n        ctx.bindRenderbuffer( ctx.RENDERBUFFER, null );\n        ctx.disable( ctx.BLEND );\n        ctx.disable( ctx.CULL_FACE );\n        ctx.disable( ctx.DEPTH_TEST );\n        ctx.disable( ctx.DITHER );\n        ctx.disable( ctx.SCISSOR_TEST );\n        ctx.blendColor( 0, 0, 0, 0 );\n        ctx.blendEquation( ctx.FUNC_ADD );\n        ctx.blendFunc( ctx.ONE, ctx.ZERO );\n        ctx.clearColor( 0, 0, 0, 0 );\n        ctx.clearDepth( 1 );\n        ctx.clearStencil( -1 );\n        ctx.colorMask( true, true, true, true );\n        ctx.cullFace( ctx.BACK );\n        ctx.depthFunc( ctx.LESS );\n        ctx.depthMask( true );\n        ctx.depthRange( 0, 1 );\n        ctx.frontFace( ctx.CCW );\n        ctx.hint( ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE );\n        ctx.lineWidth( 1 );\n        ctx.pixelStorei( ctx.PACK_ALIGNMENT, 4 );\n        ctx.pixelStorei( ctx.UNPACK_ALIGNMENT, 4 );\n        ctx.pixelStorei( ctx.UNPACK_FLIP_Y_WEBGL, false );\n        ctx.pixelStorei( ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n        // TODO: Delete this IF.\n        if ( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL ) {\n            ctx.pixelStorei( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL );\n        }\n        ctx.polygonOffset( 0, 0 );\n        ctx.sampleCoverage( 1, false );\n        ctx.scissor( 0, 0, ctx.canvas.width, ctx.canvas.height );\n        ctx.stencilFunc( ctx.ALWAYS, 0, 0xFFFFFFFF );\n        ctx.stencilMask( 0xFFFFFFFF );\n        ctx.stencilOp( ctx.KEEP, ctx.KEEP, ctx.KEEP );\n        ctx.viewport( 0, 0, ctx.canvas.width, ctx.canvas.height );\n        ctx.clear( ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT );\n\n        if ( isWebGL2RenderingContext ) {\n            ctx.drawBuffers( [ ctx.BACK ] );\n            ctx.readBuffer( ctx.BACK );\n            ctx.bindBuffer( ctx.COPY_READ_BUFFER, null );\n            ctx.bindBuffer( ctx.COPY_WRITE_BUFFER, null );\n            ctx.bindBuffer( ctx.PIXEL_PACK_BUFFER, null );\n            ctx.bindBuffer( ctx.PIXEL_UNPACK_BUFFER, null );\n            var numTransformFeedbacks = ctx.getParameter( ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS );\n            for ( var ii = 0; ii < numTransformFeedbacks; ++ii ) {\n                ctx.bindBufferBase( ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null );\n            }\n            var numUBOs = ctx.getParameter( ctx.MAX_UNIFORM_BUFFER_BINDINGS );\n            for ( var ii = 0; ii < numUBOs; ++ii ) {\n                ctx.bindBufferBase( ctx.UNIFORM_BUFFER, ii, null );\n            }\n            ctx.disable( ctx.RASTERIZER_DISCARD );\n            ctx.pixelStorei( ctx.UNPACK_IMAGE_HEIGHT, 0 );\n            ctx.pixelStorei( ctx.UNPACK_SKIP_IMAGES, 0 );\n            ctx.pixelStorei( ctx.UNPACK_ROW_LENGTH, 0 );\n            ctx.pixelStorei( ctx.UNPACK_SKIP_ROWS, 0 );\n            ctx.pixelStorei( ctx.UNPACK_SKIP_PIXELS, 0 );\n            ctx.pixelStorei( ctx.PACK_ROW_LENGTH, 0 );\n            ctx.pixelStorei( ctx.PACK_SKIP_ROWS, 0 );\n            ctx.pixelStorei( ctx.PACK_SKIP_PIXELS, 0 );\n            ctx.hint( ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE );\n        }\n\n        // TODO: This should NOT be needed but Firefox fails with 'hint'\n        while ( ctx.getError() );\n    }\n\n    function makeLostContextSimulatingCanvas( canvas ) {\n        var unwrappedContext_;\n        var wrappedContext_;\n        var onLost_ = [];\n        var onRestored_ = [];\n        var wrappedContext_ = {};\n        var contextId_ = 1;\n        var contextLost_ = false;\n        var resourceId_ = 0;\n        var resourceDb_ = [];\n        var numCallsToLoseContext_ = 0;\n        var numCalls_ = 0;\n        var canRestore_ = false;\n        var restoreTimeout_ = 0;\n        var isWebGL2RenderingContext;\n\n        // Holds booleans for each GL error so can simulate errors.\n        var glErrorShadow_ = {};\n\n        canvas.getContext = function ( f ) {\n            return function () {\n                var ctx = f.apply( canvas, arguments );\n                // Did we get a context and is it a WebGL context?\n                if ( ( ctx instanceof WebGLRenderingContext ) || ( window.WebGL2RenderingContext && ( ctx instanceof WebGL2RenderingContext ) ) ) {\n                    if ( ctx != unwrappedContext_ ) {\n                        if ( unwrappedContext_ ) {\n                            throw \"got different context\"\n                        }\n                        isWebGL2RenderingContext = window.WebGL2RenderingContext && ( ctx instanceof WebGL2RenderingContext );\n                        unwrappedContext_ = ctx;\n                        wrappedContext_ = makeLostContextSimulatingContext( unwrappedContext_ );\n                    }\n                    return wrappedContext_;\n                }\n                return ctx;\n            }\n        }( canvas.getContext );\n\n        function wrapEvent( listener ) {\n            if ( typeof ( listener ) == \"function\" ) {\n                return listener;\n            } else {\n                return function ( info ) {\n                    listener.handleEvent( info );\n                }\n            }\n        }\n\n        var addOnContextLostListener = function ( listener ) {\n            onLost_.push( wrapEvent( listener ) );\n        };\n\n        var addOnContextRestoredListener = function ( listener ) {\n            onRestored_.push( wrapEvent( listener ) );\n        };\n\n\n        function wrapAddEventListener( canvas ) {\n            var f = canvas.addEventListener;\n            canvas.addEventListener = function ( type, listener, bubble ) {\n                switch ( type ) {\n                case 'webglcontextlost':\n                    addOnContextLostListener( listener );\n                    break;\n                case 'webglcontextrestored':\n                    addOnContextRestoredListener( listener );\n                    break;\n                default:\n                    f.apply( canvas, arguments );\n                }\n            };\n        }\n\n        wrapAddEventListener( canvas );\n\n        canvas.loseContext = function () {\n            if ( !contextLost_ ) {\n                contextLost_ = true;\n                numCallsToLoseContext_ = 0;\n                ++contextId_;\n                while ( unwrappedContext_.getError() );\n                clearErrors();\n                glErrorShadow_[ unwrappedContext_.CONTEXT_LOST_WEBGL ] = true;\n                var event = makeWebGLContextEvent( \"context lost\" );\n                var callbacks = onLost_.slice();\n                setTimeout( function () {\n                    //log(\"numCallbacks:\" + callbacks.length);\n                    for ( var ii = 0; ii < callbacks.length; ++ii ) {\n                        //log(\"calling callback:\" + ii);\n                        callbacks[ ii ]( event );\n                    }\n                    if ( restoreTimeout_ >= 0 ) {\n                        setTimeout( function () {\n                            canvas.restoreContext();\n                        }, restoreTimeout_ );\n                    }\n                }, 0 );\n            }\n        };\n\n        canvas.restoreContext = function () {\n            if ( contextLost_ ) {\n                if ( onRestored_.length ) {\n                    setTimeout( function () {\n                        if ( !canRestore_ ) {\n                            throw \"can not restore. webglcontestlost listener did not call event.preventDefault\";\n                        }\n                        freeResources();\n                        resetToInitialState( unwrappedContext_ );\n                        contextLost_ = false;\n                        numCalls_ = 0;\n                        canRestore_ = false;\n                        var callbacks = onRestored_.slice();\n                        var event = makeWebGLContextEvent( \"context restored\" );\n                        for ( var ii = 0; ii < callbacks.length; ++ii ) {\n                            callbacks[ ii ]( event );\n                        }\n                    }, 0 );\n                }\n            }\n        };\n\n        canvas.loseContextInNCalls = function ( numCalls ) {\n            if ( contextLost_ ) {\n                throw \"You can not ask a lost contet to be lost\";\n            }\n            numCallsToLoseContext_ = numCalls_ + numCalls;\n        };\n\n        canvas.getNumCalls = function () {\n            return numCalls_;\n        };\n\n        canvas.setRestoreTimeout = function ( timeout ) {\n            restoreTimeout_ = timeout;\n        };\n\n        function isWebGLObject( obj ) {\n            //return false;\n            return ( obj instanceof WebGLBuffer ||\n                obj instanceof WebGLFramebuffer ||\n                obj instanceof WebGLProgram ||\n                obj instanceof WebGLRenderbuffer ||\n                obj instanceof WebGLShader ||\n                obj instanceof WebGLTexture );\n        }\n\n        function checkResources( args ) {\n            for ( var ii = 0; ii < args.length; ++ii ) {\n                var arg = args[ ii ];\n                if ( isWebGLObject( arg ) ) {\n                    return arg.__webglDebugContextLostId__ == contextId_;\n                }\n            }\n            return true;\n        }\n\n        function clearErrors() {\n            var k = Object.keys( glErrorShadow_ );\n            for ( var ii = 0; ii < k.length; ++ii ) {\n                delete glErrorShadow_[ k[ ii ] ];\n            }\n        }\n\n        function loseContextIfTime() {\n            ++numCalls_;\n            if ( !contextLost_ ) {\n                if ( numCallsToLoseContext_ == numCalls_ ) {\n                    canvas.loseContext();\n                }\n            }\n        }\n\n        // Makes a function that simulates WebGL when out of context.\n        function makeLostContextFunctionWrapper( ctx, functionName ) {\n            var f = ctx[ functionName ];\n            return function () {\n                // log(\"calling:\" + functionName);\n                // Only call the functions if the context is not lost.\n                loseContextIfTime();\n                if ( !contextLost_ ) {\n                    //if (!checkResources(arguments)) {\n                    //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;\n                    //  return;\n                    //}\n                    var result = f.apply( ctx, arguments );\n                    return result;\n                }\n            };\n        }\n\n        function freeResources() {\n            for ( var ii = 0; ii < resourceDb_.length; ++ii ) {\n                var resource = resourceDb_[ ii ];\n                if ( resource instanceof WebGLBuffer ) {\n                    unwrappedContext_.deleteBuffer( resource );\n                } else if ( resource instanceof WebGLFramebuffer ) {\n                    unwrappedContext_.deleteFramebuffer( resource );\n                } else if ( resource instanceof WebGLProgram ) {\n                    unwrappedContext_.deleteProgram( resource );\n                } else if ( resource instanceof WebGLRenderbuffer ) {\n                    unwrappedContext_.deleteRenderbuffer( resource );\n                } else if ( resource instanceof WebGLShader ) {\n                    unwrappedContext_.deleteShader( resource );\n                } else if ( resource instanceof WebGLTexture ) {\n                    unwrappedContext_.deleteTexture( resource );\n                } else if ( isWebGL2RenderingContext ) {\n                    if ( resource instanceof WebGLQuery ) {\n                        unwrappedContext_.deleteQuery( resource );\n                    } else if ( resource instanceof WebGLSampler ) {\n                        unwrappedContext_.deleteSampler( resource );\n                    } else if ( resource instanceof WebGLSync ) {\n                        unwrappedContext_.deleteSync( resource );\n                    } else if ( resource instanceof WebGLTransformFeedback ) {\n                        unwrappedContext_.deleteTransformFeedback( resource );\n                    } else if ( resource instanceof WebGLVertexArrayObject ) {\n                        unwrappedContext_.deleteVertexArray( resource );\n                    }\n                }\n            }\n        }\n\n        function makeWebGLContextEvent( statusMessage ) {\n            return {\n                statusMessage: statusMessage,\n                preventDefault: function () {\n                    canRestore_ = true;\n                }\n            };\n        }\n\n        return canvas;\n\n        function makeLostContextSimulatingContext( ctx ) {\n            // copy all functions and properties to wrapper\n            for ( var propertyName in ctx ) {\n                if ( typeof ctx[ propertyName ] == 'function' ) {\n                    wrappedContext_[ propertyName ] = makeLostContextFunctionWrapper(\n                        ctx, propertyName );\n                } else {\n                    makePropertyWrapper( wrappedContext_, ctx, propertyName );\n                }\n            }\n\n            // Wrap a few functions specially.\n            wrappedContext_.getError = function () {\n                loseContextIfTime();\n                if ( !contextLost_ ) {\n                    var err;\n                    while ( err = unwrappedContext_.getError() ) {\n                        glErrorShadow_[ err ] = true;\n                    }\n                }\n                for ( var err in glErrorShadow_ ) {\n                    if ( glErrorShadow_[ err ] ) {\n                        delete glErrorShadow_[ err ];\n                        return err;\n                    }\n                }\n                return wrappedContext_.NO_ERROR;\n            };\n\n            var creationFunctions = [\n                \"createBuffer\",\n                \"createFramebuffer\",\n                \"createProgram\",\n                \"createRenderbuffer\",\n                \"createShader\",\n                \"createTexture\"\n            ];\n            if ( isWebGL2RenderingContext ) {\n                creationFunctions.push(\n                    \"createQuery\",\n                    \"createSampler\",\n                    \"fenceSync\",\n                    \"createTransformFeedback\",\n                    \"createVertexArray\"\n                );\n            }\n            for ( var ii = 0; ii < creationFunctions.length; ++ii ) {\n                var functionName = creationFunctions[ ii ];\n                wrappedContext_[ functionName ] = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return null;\n                        }\n                        var obj = f.apply( ctx, arguments );\n                        obj.__webglDebugContextLostId__ = contextId_;\n                        resourceDb_.push( obj );\n                        return obj;\n                    };\n                }( ctx[ functionName ] );\n            }\n\n            var functionsThatShouldReturnNull = [\n                \"getActiveAttrib\",\n                \"getActiveUniform\",\n                \"getBufferParameter\",\n                \"getContextAttributes\",\n                \"getAttachedShaders\",\n                \"getFramebufferAttachmentParameter\",\n                \"getParameter\",\n                \"getProgramParameter\",\n                \"getProgramInfoLog\",\n                \"getRenderbufferParameter\",\n                \"getShaderParameter\",\n                \"getShaderInfoLog\",\n                \"getShaderSource\",\n                \"getTexParameter\",\n                \"getUniform\",\n                \"getUniformLocation\",\n                \"getVertexAttrib\"\n            ];\n            if ( isWebGL2RenderingContext ) {\n                functionsThatShouldReturnNull.push(\n                    \"getInternalformatParameter\",\n                    \"getQuery\",\n                    \"getQueryParameter\",\n                    \"getSamplerParameter\",\n                    \"getSyncParameter\",\n                    \"getTransformFeedbackVarying\",\n                    \"getIndexedParameter\",\n                    \"getUniformIndices\",\n                    \"getActiveUniforms\",\n                    \"getActiveUniformBlockParameter\",\n                    \"getActiveUniformBlockName\"\n                );\n            }\n            for ( var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii ) {\n                var functionName = functionsThatShouldReturnNull[ ii ];\n                wrappedContext_[ functionName ] = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return null;\n                        }\n                        return f.apply( ctx, arguments );\n                    }\n                }( wrappedContext_[ functionName ] );\n            }\n\n            var isFunctions = [\n                \"isBuffer\",\n                \"isEnabled\",\n                \"isFramebuffer\",\n                \"isProgram\",\n                \"isRenderbuffer\",\n                \"isShader\",\n                \"isTexture\"\n            ];\n            if ( isWebGL2RenderingContext ) {\n                isFunctions.push(\n                    \"isQuery\",\n                    \"isSampler\",\n                    \"isSync\",\n                    \"isTransformFeedback\",\n                    \"isVertexArray\"\n                );\n            }\n            for ( var ii = 0; ii < isFunctions.length; ++ii ) {\n                var functionName = isFunctions[ ii ];\n                wrappedContext_[ functionName ] = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return false;\n                        }\n                        return f.apply( ctx, arguments );\n                    }\n                }( wrappedContext_[ functionName ] );\n            }\n\n            wrappedContext_.checkFramebufferStatus = function ( f ) {\n                return function () {\n                    loseContextIfTime();\n                    if ( contextLost_ ) {\n                        return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;\n                    }\n                    return f.apply( ctx, arguments );\n                };\n            }( wrappedContext_.checkFramebufferStatus );\n\n            wrappedContext_.getAttribLocation = function ( f ) {\n                return function () {\n                    loseContextIfTime();\n                    if ( contextLost_ ) {\n                        return -1;\n                    }\n                    return f.apply( ctx, arguments );\n                };\n            }( wrappedContext_.getAttribLocation );\n\n            wrappedContext_.getVertexAttribOffset = function ( f ) {\n                return function () {\n                    loseContextIfTime();\n                    if ( contextLost_ ) {\n                        return 0;\n                    }\n                    return f.apply( ctx, arguments );\n                };\n            }( wrappedContext_.getVertexAttribOffset );\n\n            wrappedContext_.isContextLost = function () {\n                return contextLost_;\n            };\n\n            if ( isWebGL2RenderingContext ) {\n                wrappedContext_.getFragDataLocation = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return -1;\n                        }\n                        return f.apply( ctx, arguments );\n                    };\n                }( wrappedContext_.getFragDataLocation );\n\n                wrappedContext_.clientWaitSync = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return wrappedContext_.WAIT_FAILED;\n                        }\n                        return f.apply( ctx, arguments );\n                    };\n                }( wrappedContext_.clientWaitSync );\n\n                wrappedContext_.getUniformBlockIndex = function ( f ) {\n                    return function () {\n                        loseContextIfTime();\n                        if ( contextLost_ ) {\n                            return wrappedContext_.INVALID_INDEX;\n                        }\n                        return f.apply( ctx, arguments );\n                    };\n                }( wrappedContext_.getUniformBlockIndex );\n            }\n\n            return wrappedContext_;\n        }\n    }\n\n    return {\n        /**\n         * Initializes this module. Safe to call more than once.\n         * @param {!WebGLRenderingContext} ctx A WebGL context. If\n         *    you have more than one context it doesn't matter which one\n         *    you pass in, it is only used to pull out constants.\n         */\n        'init': init,\n\n        /**\n         * Returns true or false if value matches any WebGL enum\n         * @param {*} value Value to check if it might be an enum.\n         * @return {boolean} True if value matches one of the WebGL defined enums\n         */\n        'mightBeEnum': mightBeEnum,\n\n        /**\n         * Gets an string version of an WebGL enum.\n         *\n         * Example:\n         *   WebGLDebugUtil.init(ctx);\n         *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n         *\n         * @param {number} value Value to return an enum for\n         * @return {string} The string version of the enum.\n         */\n        'glEnumToString': glEnumToString,\n\n        /**\n         * Converts the argument of a WebGL function to a string.\n         * Attempts to convert enum arguments to strings.\n         *\n         * Example:\n         *   WebGLDebugUtil.init(ctx);\n         *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);\n         *\n         * would return 'TEXTURE_2D'\n         *\n         * @param {string} functionName the name of the WebGL function.\n         * @param {number} numArgs The number of arguments\n         * @param {number} argumentIndx the index of the argument.\n         * @param {*} value The value of the argument.\n         * @return {string} The value as a string.\n         */\n        'glFunctionArgToString': glFunctionArgToString,\n\n        /**\n         * Converts the arguments of a WebGL function to a string.\n         * Attempts to convert enum arguments to strings.\n         *\n         * @param {string} functionName the name of the WebGL function.\n         * @param {number} args The arguments.\n         * @return {string} The arguments as a string.\n         */\n        'glFunctionArgsToString': glFunctionArgsToString,\n\n        /**\n         * Given a WebGL context returns a wrapped context that calls\n         * gl.getError after every command and calls a function if the\n         * result is not NO_ERROR.\n         *\n         * You can supply your own function if you want. For example, if you'd like\n         * an exception thrown on any GL error you could do this\n         *\n         *    function throwOnGLError(err, funcName, args) {\n         *      throw WebGLDebugUtils.glEnumToString(err) +\n         *            \" was caused by call to \" + funcName;\n         *    };\n         *\n         *    ctx = WebGLDebugUtils.makeDebugContext(\n         *        canvas.getContext(\"webgl\"), throwOnGLError);\n         *\n         * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n         * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\n         *     to call when gl.getError returns an error. If not specified the default\n         *     function calls console.log with a message.\n         * @param {!function(funcName, args): void} opt_onFunc The\n         *     function to call when each webgl function is called. You\n         *     can use this to log all calls for example.\n         */\n        'makeDebugContext': makeDebugContext,\n\n        /**\n         * Given a canvas element returns a wrapped canvas element that will\n         * simulate lost context. The canvas returned adds the following functions.\n         *\n         * loseContext:\n         *   simulates a lost context event.\n         *\n         * restoreContext:\n         *   simulates the context being restored.\n         *\n         * lostContextInNCalls:\n         *   loses the context after N gl calls.\n         *\n         * getNumCalls:\n         *   tells you how many gl calls there have been so far.\n         *\n         * setRestoreTimeout:\n         *   sets the number of milliseconds until the context is restored\n         *   after it has been lost. Defaults to 0. Pass -1 to prevent\n         *   automatic restoring.\n         *\n         * @param {!Canvas} canvas The canvas element to wrap.\n         */\n        'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,\n\n        /**\n         * Resets a context to the initial state.\n         * @param {!WebGLRenderingContext} ctx The webgl context to\n         *     reset.\n         */\n        'resetToInitialState': resetToInitialState\n    };\n\n}();\n\nmodule.exports = WebGLDebugUtils;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgViewer/webgl-debug.js\n// module id = 235\n// module chunks = 0 1 2","'use strict';\nvar ShadowCastAttribute = require( 'osgShadow/ShadowCastAttribute' );\nvar ShadowCastCompiler = require( 'osgShadow/ShadowCastCompiler' );\nvar ShadowCastShaderGenerator = require( 'osgShadow/ShadowCastShaderGenerator' );\nvar ShadowCasterVisitor = require( 'osgShadow/ShadowCasterVisitor' );\nvar ShadowFrustumIntersection = require( 'osgShadow/ShadowFrustumIntersection' );\nvar ShadowMap = require( 'osgShadow/ShadowMap' );\nvar ShadowMapAtlas = require( 'osgShadow/ShadowMapAtlas' );\nvar ShadowReceiveAttribute = require( 'osgShadow/ShadowReceiveAttribute' );\nvar ShadowSettings = require( 'osgShadow/ShadowSettings' );\nvar ShadowTechnique = require( 'osgShadow/ShadowTechnique' );\nvar ShadowTexture = require( 'osgShadow/ShadowTexture' );\nvar ShadowTextureAtlas = require( 'osgShadow/ShadowTextureAtlas' );\nvar ShadowedScene = require( 'osgShadow/ShadowedScene' );\n\n\nvar osgShadow = {};\n\nosgShadow.ShadowCastAttribute = ShadowCastAttribute;\nosgShadow.ShadowCastCompiler = ShadowCastCompiler;\nosgShadow.ShadowReceiveAttribute = ShadowReceiveAttribute;\nosgShadow.ShadowCasterVisitor = ShadowCasterVisitor;\nosgShadow.ShadowFrustumIntersection = ShadowFrustumIntersection;\nosgShadow.ShadowMap = ShadowMap;\nosgShadow.ShadowMapAtlas = ShadowMapAtlas;\nosgShadow.ShadowedScene = ShadowedScene;\nosgShadow.ShadowSettings = ShadowSettings;\nosgShadow.ShadowCastShaderGenerator = ShadowCastShaderGenerator;\nosgShadow.ShadowTechnique = ShadowTechnique;\nosgShadow.ShadowTexture = ShadowTexture;\nosgShadow.ShadowTextureAtlas = ShadowTextureAtlas;\n\n\nmodule.exports = osgShadow;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/osgShadow.js\n// module id = 236\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\n\n\n// Used to notify the Compiler to create a Depth Casting optimized shader\nvar ShadowCastAttribute = function ( disable, shadowReceiveAttribute ) {\n    StateAttribute.call( this );\n    this._enable = !disable;\n    this._shadowReceiveAttribute = shadowReceiveAttribute;\n};\nShadowCastAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n    attributeType: 'ShadowCast',\n    cloneType: function () {\n        return new ShadowCastAttribute( true );\n    },\n    //\n    setReceiveAttribute: function ( shadowReceiveAttribute ) {\n        this._shadowReceiveAttribute = shadowReceiveAttribute;\n    },\n    getReceiveAttribute: function () {\n        return this._shadowReceiveAttribute;\n    },\n    getDefines: function () {\n        if ( !this._shadowReceiveAttribute ) return undefined; // test here because of cloneType\n        return this._shadowReceiveAttribute.getDefines();\n    },\n    getHash: function () {\n        return 'ShadowCast' + this._enable + this._shadowReceiveAttribute.getPrecision();\n    },\n    // need a isEnabled to let the ShaderGenerator to filter\n    // StateAttribute from the shader compilation\n    isEnabled: function () {\n        return this._enable;\n    }\n} ), 'osgShadow', 'ShadowCastAttribute' );\n\nMACROUTILS.setTypeID( ShadowCastAttribute );\n\nmodule.exports = ShadowCastAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowCastAttribute.js\n// module id = 237\n// module chunks = 0 1 2","'use strict';\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar Camera = require( 'osg/Camera' );\nvar Depth = require( 'osg/Depth' );\nvar Light = require( 'osg/Light' );\nvar LightSource = require( 'osg/LightSource' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n\n\n/*\n * Remove nodes that shouldn't not be culled when casting\n * like lights, camera with render texture targets,\n * transparent (alphablended) geometries\n * (otherwise it might break things)\n * visits whole underlying scene recursively\n */\nvar ShadowCasterVisitor = function ( mask ) {\n    NodeVisitor.call( this );\n    // mask setting to avoid casting shadows\n    this._noCastMask = mask;\n    this._nodeList = [];\n};\n\nShadowCasterVisitor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    reset: function () {\n        this._nodeList = [];\n    },\n    removeNodeFromCasting: function ( node ) {\n\n        /*jshint bitwise: false */\n\n        var nm = node.getNodeMask();\n        // ~0x0 as not to be processed\n\n        if ( nm === ~0x0 ) {\n\n            // set to avoid casting shadow\n            nm = this._noCastMask;\n            node.setNodeMask( nm );\n            this._nodeList.push( node );\n\n        } else if ( ( nm & ~( this._noCastMask ) ) !== 0 ) {\n\n            // set to avoid casting shadow\n            node.setNodeMask( nm | this._noCastMask );\n            this._nodeList.push( node );\n\n        }\n        /*jshint bitwise: true */\n\n    },\n    // Visiting whole casting scene recursively\n    apply: function ( node ) {\n\n        // check that and other things ?\n        // TODO: should check whole hierarchy to check for override/protected/etc\n        // Depth, BlendFunc Attributes...\n        var st = node.getStateSet();\n        if ( st ) {\n\n            // check for transparency not casting shadows\n            // as no alpha blending transparency shadow (no transmittance support)\n            var blend = st.getAttribute( 'BlendFunc' );\n            if ( blend !== undefined && blend.getSource() !== BlendFunc.DISABLE ) {\n                var depth = st.getAttribute( 'Depth' );\n                if ( depth && ( depth.getFunc() === Depth.DISABLE || depth.getWriteMask() === false ) ) {\n                    this.removeNodeFromCasting( node );\n                    return;\n                }\n            }\n        }\n\n        // check for lights, as lights are positionned attributes\n        if ( node.getTypeID() === Light.typeID || node.getTypeID() === LightSource.typeID ) {\n            this.removeNodeFromCasting( node );\n            return;\n        } else if ( node.getTypeID() === Camera.typeID && node.isRenderToTextureCamera() ) {\n            // no \"Subrender\" when rendering the shadow map as from light point of view\n            this.removeNodeFromCasting( node );\n            return;\n        }\n        this.traverse( node );\n    },\n\n    setNoCastMask: function ( mask ) {\n        this._noCastMask = mask;\n    },\n\n    // restore to any previous mask avoiding any breaks\n    // in other application mask usage.\n    restore: function () {\n\n        for ( var i = 0, l = this._nodeList.length; i < l; i++ ) {\n\n            var node = this._nodeList[ i ];\n            var nm = node.getNodeMask();\n\n            if ( nm === this._noCastMask ) {\n\n                node.setNodeMask( ~0x0 );\n\n            } else {\n\n                node.setNodeMask( nm & ~this._noCastMask );\n\n            }\n\n        }\n\n    }\n\n\n} ), 'osgShadow', 'ShadowCasterVisitor' );\n\n\nMACROUTILS.setTypeID( ShadowCasterVisitor );\n\nmodule.exports = ShadowCasterVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowCasterVisitor.js\n// module id = 238\n// module chunks = 0 1 2","'use strict';\nvar BoundingBox = require( 'osg/BoundingBox' );\nvar BoundingSphere = require( 'osg/BoundingSphere' );\nvar Camera = require( 'osg/Camera' );\nvar Geometry = require( 'osg/Geometry' );\nvar Light = require( 'osg/Light' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixMemoryPool = require( 'osg/MatrixMemoryPool' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar Plane = require( 'osg/Plane' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n/**\n * [ComputeFrustumBoundsVisitor get a scene bounds limited by a light and camera frustum]\n */\nvar ComputeMultiFrustumBoundsVisitor = function () {\n\n    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\n    this._matrixStack = [ mat4.create() ];\n    this._reservedMatrixStack = new MatrixMemoryPool();\n    this._bb = new BoundingBox();\n    this._bs = new BoundingSphere();\n\n};\n\n/*\n * TODO: apply world matrix on the traverse instead of per node\n */\nComputeMultiFrustumBoundsVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {\n    reset: function ( traversalMask, worldLightPos, cameraFrustum, cameraNearFar, lightFrustum ) {\n\n        this.setTraversalMask( traversalMask );\n\n        this._cameraFrustum = cameraFrustum;\n        this._lightFrustum = lightFrustum;\n\n        // what plane to exclude from shadowedscene\n        this.getCameraPlaneMaskForLightNear( worldLightPos, cameraFrustum, cameraNearFar ? 6 : 4 );\n\n        this._reservedMatrixStack.reset();\n        this._matrixStack.length = 1;\n        this._bb.init();\n    },\n\n    getBoundingBox: function () {\n        return this._bb;\n    },\n\n\n    getCameraPlaneMaskForLightNear: function ( point, cameraFrustum, len ) {\n        var selectorMask = 0x1;\n        var resultMask = 15;\n        var i;\n\n        for ( i = 0; i < len; ++i ) {\n            resultMask = ( resultMask << 1 ) | 1;\n        }\n\n        var planeList = cameraFrustum.getPlanes();\n        for ( i = 0; i < len; ++i ) {\n            if ( Plane.distanceToPlane( planeList[ i ], point ) < 0.0 ) {\n                // Ligth frustum source poitn is outside this plane.\n                // subsequent checks against this plane not required.\n                // as light position is behind those,\n                // and culling that would cull light near\n                resultMask ^= selectorMask;\n            }\n            selectorMask <<= 1;\n        }\n        this._cameraPlaneMaskedByLightNear = resultMask;\n\n        cameraFrustum.setResultMask( resultMask );\n        cameraFrustum.pushCurrentMask( resultMask );\n        return resultMask;\n    },\n\n    applyTransform: function ( transform ) {\n\n        var matrix = this._reservedMatrixStack.get();\n        var stackLength = this._matrixStack.length;\n        mat4.copy( matrix, this._matrixStack[ stackLength - 1 ] );\n        transform.computeLocalToWorldMatrix( matrix, this );\n\n        var bs = this._bs;\n        transform.getBound().transformMat4( this._bs, matrix );\n\n        // camera cull\n        if ( this._cameraFrustum.getCurrentMask() !== 0 ) {\n            // father bounding sphere is not totally inside\n            // now test this one\n            if ( !this._cameraFrustum.containsBoundingSphere( bs ) )\n                return; // culled\n        }\n\n        // light cull\n        if ( this._lightFrustum.getCurrentMask() !== 0 ) {\n            // father bounding sphere is not totally inside\n            // now test this one\n            if ( !this._lightFrustum.containsBoundingSphere( bs ) )\n                return; // culled\n        }\n\n        this._cameraFrustum.pushCurrentMask();\n        this._lightFrustum.pushCurrentMask();\n\n        this.pushMatrix( matrix );\n\n        this.traverse( transform );\n\n        this._cameraFrustum.popCurrentMask();\n        this._lightFrustum.popCurrentMask();\n\n        this.popMatrix();\n    },\n    applyBoundingBox: ( function () {\n        var bbOut = new BoundingBox();\n        return function ( bbox ) {\n            var stackLength = this._matrixStack.length;\n            var matrix = this._matrixStack[ stackLength - 1 ];\n            if ( mat4.exactEquals( matrix, mat4.IDENTITY ) ) {\n                this._bb.expandByBoundingBox( bbox );\n            } else if ( bbox.valid() ) {\n                bbox.transformMat4( bbOut, matrix );\n                this._bb.expandByBoundingBox( bbOut );\n            }\n        };\n    } )(),\n\n    apply: function ( node ) {\n\n        var typeID = node.getTypeID();\n\n        if ( node instanceof MatrixTransform ) {\n            this.applyTransform( node );\n            return;\n\n        } else if ( typeID === Geometry.getTypeID() ) {\n            var bs = this._bs;\n            var matrix = this._matrixStack[ this._matrixStack.length - 1 ];\n            node.getBound().transformMat4( bs, matrix );\n\n            // camera cull\n            if ( this._cameraFrustum.getCurrentMask() !== 0 ) {\n                // father bounding sphere is not totally inside\n                // now test this one\n                if ( !this._cameraFrustum.containsBoundingSphere( bs ) )\n                    return; // culled\n            }\n\n            // light cull\n            if ( this._lightFrustum.getCurrentMask() !== 0 ) {\n                // father bounding sphere is not totally inside\n                // now test this one\n                if ( !this._lightFrustum.containsBoundingSphere( bs ) )\n                    return; // culled\n            }\n\n            // Visible: we enlarge the bbox\n            this.applyBoundingBox( node.getBoundingBox() );\n\n            return;\n        } else if ( typeID === Camera.getTypeID() ) {\n\n        } else if ( typeID === Light.getTypeID() ) {\n\n        }\n\n\n        this.traverse( node );\n\n    },\n\n    pushMatrix: function ( matrix ) {\n        this._matrixStack.push( matrix );\n    },\n\n    popMatrix: function () {\n        this._matrixStack.pop();\n    },\n\n} );\n\nmodule.exports = ComputeMultiFrustumBoundsVisitor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowFrustumIntersection.js\n// module id = 239\n// module chunks = 0 1 2","'use strict';\nvar Camera = require( 'osg/Camera' );\nvar CullVisitor = require( 'osg/CullVisitor' );\nvar BlendFunc = require( 'osg/BlendFunc' );\nvar ComputeBoundsVisitor = require( 'osg/ComputeBoundsVisitor' );\nvar Depth = require( 'osg/Depth' );\nvar FrameBufferObject = require( 'osg/FrameBufferObject' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Notify = require( 'osg/notify' );\nvar Shape = require( 'osg/shape' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar StateSet = require( 'osg/StateSet' );\nvar Debug = require( 'osgUtil/debug' );\nvar Texture = require( 'osg/Texture' );\nvar Transform = require( 'osg/Transform' );\nvar Uniform = require( 'osg/Uniform' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar PrimitiveSet = require( 'osg/primitiveSet' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar Viewport = require( 'osg/Viewport' );\nvar WebGLCaps = require( 'osg/WebGLCaps' );\nvar ShadowReceiveAttribute = require( 'osgShadow/ShadowReceiveAttribute' );\nvar ShadowCasterVisitor = require( 'osgShadow/ShadowCasterVisitor' );\nvar ShadowFrustumIntersection = require( 'osgShadow/ShadowFrustumIntersection' );\nvar ShadowCastAttribute = require( 'osgShadow/ShadowCastAttribute' );\nvar ShadowTechnique = require( 'osgShadow/ShadowTechnique' );\nvar ShadowTexture = require( 'osgShadow/ShadowTexture' );\n\n\n// Custom camera cull callback\n// we customize it just to avoid to add extra 'virtual' function\n// on the shadowTecnique class\nvar CameraCullCallback = function ( shadowTechnique ) {\n    this._shadowTechnique = shadowTechnique;\n};\n\nCameraCullCallback.prototype = {\n    cull: function ( node, nv ) {\n\n        this._shadowTechnique.getShadowedScene().nodeTraverse( nv );\n\n        var cs = nv.getCurrentCullingSet();\n        var m = nv.getCurrentProjectionMatrix();\n        var near = nv.getComputedNear(),\n            far = nv.getComputedFar();\n\n        mat4.getFrustumPlanes( cs.getFrustum().getPlanes(), m, nv.getCurrentModelViewMatrix(), false );\n        cs.getFrustum().setupMask( 6 );\n\n        this._shadowTechnique.setLightFrustum( cs.getFrustum(), near, far );\n\n\n        return false;\n    }\n};\n\n/**\n *  ShadowMap provides an implementation of shadow textures.\n *  @class ShadowMap\n */\nvar ShadowMap = function ( settings, shadowTexture ) {\n    ShadowTechnique.call( this );\n\n    this._projectionMatrix = mat4.create();\n    this._viewMatrix = mat4.create();\n    this._lightNumberArrayIndex = -1;\n    this._lightUp = vec3.fromValues( 0.0, 0.0, 1.0 );\n\n    this._light = settings.light;\n\n    // data\n    this._cameraShadow = new Camera();\n    this._cameraShadow.setCullCallback( new CameraCullCallback( this ) );\n    this._cameraShadow.setRenderOrder( Camera.PRE_RENDER, 0 );\n    this._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );\n    this._cameraShadow.setClearColor( vec4.fromValues( 1.0, 1.0, 1.0, 1.0 ) );\n\n    if ( shadowTexture ) {\n\n        this._texture = shadowTexture;\n\n    } else {\n\n        this._texture = new ShadowTexture();\n        this._textureUnitBase = 4;\n        this._textureUnit = this._textureUnitBase;\n\n        // see shadowSettings.js header for param explanations\n        this._textureMagFilter = undefined;\n        this._textureMinFilter = undefined;\n\n    }\n\n\n    this._textureSize = 256;\n    var unifRenderSize = Uniform.createFloat2( 'RenderSize' );\n    this._texelSizeUniform = Uniform.createFloat1( 1.0 / this._textureSize, 'texelSize' );\n    this._renderSize = unifRenderSize.getInternalArray();\n    this._renderSize[ 0 ] = this._renderSize[ 1 ] = this._textureSize;\n\n    this._receivingStateset = undefined;\n\n    this._casterStateSet = new StateSet();\n    this._casterStateSet.addUniform( Uniform.createFloat1( 0, 'exponent0' ) );\n    this._casterStateSet.addUniform( Uniform.createFloat1( 0, 'exponent1' ) );\n    this._casterStateSet.addUniform( Uniform.createFloat1( 0.005, 'bias' ) );\n    this._casterStateSet.addUniform( this._texelSizeUniform );\n    this._casterStateSet.addUniform( unifRenderSize );\n\n\n    // make sure no unintended blend happens\n    // if casting semi-transparent (alphablend material with full opaque pixels) shadow\n    this._casterStateSet.setAttributeAndModes( new Depth( Depth.LESS ), StateAttribute.ON | StateAttribute.OVERRIDE );\n    this._casterStateSet.setAttributeAndModes( new BlendFunc(), StateAttribute.ON | StateAttribute.OVERRIDE );\n\n    this._shadowReceiveAttribute = new ShadowReceiveAttribute( this._light.getLightNumber() );\n    this._casterStateSet.setAttributeAndModes( this._shadowReceiveAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );\n\n    // default name, overridable with shadow settings\n    this._shadowCastShaderGeneratorName = 'ShadowCast';\n\n\n    var near = 0.001;\n    var far = 1000;\n    var unifRange = Uniform.createFloat4( 'uShadowDepthRange' );\n    this._casterStateSet.addUniform( unifRange );\n    this._depthRange = unifRange.getInternalArray();\n    this._depthRange[ 0 ] = near;\n    this._depthRange[ 1 ] = far;\n    this._depthRange[ 2 ] = far - near;\n    this._depthRange[ 3 ] = 1.0 / ( far - near );\n\n    this._worldLightPos = vec4.create();\n    this._worldLightPos[ 3 ] = 0;\n    this._worldLightDir = vec4.create();\n    this._worldLightDir[ 3 ] = 1;\n\n    this._castsShadowDrawTraversalMask = 0xffffffff;\n    this._castsShadowBoundsTraversalMask = 0xffffffff;\n\n\n    this._shaderProcessor = undefined;\n\n    // tmp variables\n    this._tmpVec = vec3.create();\n    this._tmpVecBis = vec3.create();\n    this._tmpVecTercio = vec3.create();\n    this._tmpMatrix = mat4.create();\n\n    if ( settings )\n        this.setShadowSettings( settings );\n\n    this._computeFrustumBounds = new ShadowFrustumIntersection();\n    this._computeBoundsVisitor = new ComputeBoundsVisitor();\n\n    // Overridable Visitor so that user can override the visitor to enable disable\n    // in its own shadowmap implementation\n    // settings.userShadowCasterVisitor:\n    // - undefined means using default\n    // - false means no removal visitor needed\n    // - otherwise must be an instance of a class inherited from shadowCaster\n    if ( settings.userShadowCasterVisitor !== false ) {\n\n        this._removeNodesNeverCastingVisitor = settings.userShadowCasterVisitor || new ShadowCasterVisitor( this._castsShadowTraversalMask );\n\n    }\n\n    this._infiniteFrustum = true;\n    var shadowStateAttribute = new ShadowCastAttribute( false, this._shadowReceiveAttribute );\n\n    this._casterStateSet.setAttributeAndModes( shadowStateAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );\n    this._casterStateSet.setShaderGeneratorName( this._shadowCastShaderGeneratorName, StateAttribute.OVERRIDE | StateAttribute.ON );\n\n    this._debug = false;\n};\n\n\n/** @lends ShadowMap.prototype */\nShadowMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( ShadowTechnique.prototype, {\n\n    getDepthRange: function () {\n        return this._depthRange;\n    },\n    setLightFrustum: function ( lf, near, far ) {\n\n        this._lightFrustum = lf;\n\n        this._depthRange[ 0 ] = near;\n        this._depthRange[ 1 ] = far;\n        this.nearFarBounding();\n\n        if ( this._debug ) {\n\n            this._debugGeomFrustum.updateGeometry( this._projectionMatrix, this._depthRange );\n            mat4.invert( this._debugNodeFrustum.getMatrix(), this._viewMatrix );\n\n        }\n\n    },\n    getCamera: function () {\n        return this._cameraShadow;\n    },\n\n    getTexture: function () {\n        return this._texture;\n    },\n\n    isDirty: function () {\n        return this._dirty;\n    },\n    /**\n     * at which Texture unit number we start adding texture shadow\n     */\n    setTextureUnitBase: function ( unitBase ) {\n        this._textureUnitBase = unitBase;\n        this._textureUnit = unitBase;\n    },\n\n    /* Sets  shadowSettings\n     */\n    setShadowSettings: function ( shadowSettings ) {\n\n        if ( !shadowSettings )\n            return;\n\n        this._light = shadowSettings.light;\n        this._shadowCastShaderGeneratorName = shadowSettings.getShadowCastShaderGeneratorName();\n\n        this.setCastsShadowDrawTraversalMask( shadowSettings.castsShadowDrawTraversalMask );\n        this.setCastsShadowBoundsTraversalMask( shadowSettings.castsShadowBoundsTraversalMask );\n\n        this.setLight( this._light );\n        this.setTextureSize( shadowSettings.textureSize );\n        this.setTexturePrecision( shadowSettings.textureType );\n\n        this.setKernelSizePCF( shadowSettings.kernelSizePCF );\n        this.setBias( shadowSettings.bias );\n        this.setNormalBias( shadowSettings.normalBias );\n\n    },\n\n    setCastsShadowDrawTraversalMask: function ( mask ) {\n        this._castsShadowDrawTraversalMask = mask;\n    },\n\n    getCastsShadowDrawTraversalMask: function () {\n        return this._castsDrawShadowTraversalMask;\n    },\n\n    setCastsShadowBoundsTraversalMask: function ( mask ) {\n        this._castsShadowBoundsTraversalMask = mask;\n    },\n\n    getCastsShadowBoundsTraversalMask: function () {\n        return this._castsShadowBoundsTraversalMask;\n    },\n\n    getNormalBias: function () {\n        return this._shadowReceiveAttribute.getNormalBias();\n    },\n\n    setNormalBias: function ( value ) {\n        this._shadowReceiveAttribute.setNormalBias( value );\n    },\n\n\n    getBias: function () {\n        return this._shadowReceiveAttribute.getBias();\n    },\n\n    setBias: function ( value ) {\n        this._shadowReceiveAttribute.setBias( value );\n        this._casterStateSet.getUniformList()[ 'bias' ].getUniform().setFloat( value );\n    },\n\n    getKernelSizePCF: function () {\n        return this._shadowReceiveAttribute.getKernelSizePCF();\n    },\n\n    setKernelSizePCF: function ( value ) {\n        this._shadowReceiveAttribute.setKernelSizePCF( value );\n    },\n\n    setShadowedScene: function ( shadowedScene ) {\n        ShadowTechnique.prototype.setShadowedScene.call( this, shadowedScene );\n        this._receivingStateset = this._shadowedScene.getReceivingStateSet();\n        this.dirty();\n    },\n\n    checkLightNumber: function () {\n        var lightNumber = this._light.getLightNumber();\n\n        // if light number changed we need to remove cleanly\n        // attributes from receiveStateSet\n        // it's because it use a typemember like light attribute\n        // so the number if very important to keep State clean\n        if ( this._shadowReceiveAttribute.getLightNumber() !== lightNumber ) {\n            if ( this._receivingStateset.getAttribute( this._shadowReceiveAttribute.getTypeMember() ) === this._shadowReceiveAttribute )\n                this._receivingStateset.removeAttribute( this._shadowReceiveAttribute.getTypeMember() );\n        }\n\n\n\n        if ( this._texture && !this._texture.hasLightNumber( lightNumber ) ) {\n\n            // remove this._texture, but not if it's not this._texture\n            if ( this._receivingStateset.getTextureAttribute( this._textureUnit, this._texture.getTypeMember() ) === this._texture )\n                this._receivingStateset.removeTextureAttribute( this._textureUnit, this._texture.getTypeMember() );\n        }\n\n    },\n\n    /** initialize the ShadowedScene and local cached data structures.*/\n    init: function ( atlasTexture, lightIndex, textureUnit ) {\n\n        if ( !this._shadowedScene ) return;\n\n        this._filledOnce = false;\n\n        this.checkLightNumber();\n\n        if ( !this._cameraShadow ) {\n            this._cameraShadow = new Camera();\n            this._cameraShadow.setCullCallback( new CameraCullCallback( this ) );\n            this._cameraShadow.setRenderOrder( Camera.PRE_RENDER, 0 );\n            this._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );\n            this._cameraShadow.setClearColor( vec4.fromValues( 1.0, 1.0, 1.0, 1.0 ) );\n        }\n\n        var lightNumber = this._light.getLightNumber();\n\n        if ( !atlasTexture ) {\n\n            this.initTexture();\n\n            this._textureUnit = this._textureUnitBase + lightNumber;\n            this._texture.setLightNumber( lightNumber );\n            this._texture.setName( 'ShadowTexture' + this._textureUnit );\n            this._shadowReceiveAttribute.setAtlas( false );\n\n        } else {\n\n            this._texture = atlasTexture;\n\n            // allow indexing properties in the texture uniforms\n            this._lightNumberArrayIndex = lightIndex;\n            this._textureUnit = textureUnit;\n            this._shadowReceiveAttribute.setAtlas( true );\n\n        }\n\n        this._cameraShadow.setName( 'light_shadow_camera' + this._light.getName() );\n        this._shadowReceiveAttribute.setLightNumber( lightNumber );\n\n\n\n        // Idea is to make sure the null texture is \"binded\" to all shadow casting scene\n        // so we override all existing texture bind in the scene, preventing any texture bind.\n        // When user implements alpha mask casting, they use PROTECTED to prevent OVERRIDE to remove their alpha mask texture needed.\n        var fullOverride = StateAttribute.OVERRIDE | StateAttribute.ON;\n\n\n        this._receivingStateset.setAttributeAndModes( this._shadowReceiveAttribute, fullOverride );\n\n        // prevent unnecessary texture bindings\n        this._preventTextureBindingDuringShadowCasting();\n\n        // Mandatory: prevent binding shadow textures themselves\n        // ( ShadowedScene StateSet is applied  just above in StateSet hierarchy)\n        // that would mean undefined values as it would be read/write access...\n        // So we force it against Texture.null binding done just above (PROTECTED)\n        // and Prevent any under hierarchy bind with OVERRIDE\n        // must be done AFTER the prevent binding.\n        this._casterStateSet.setTextureAttributeAndModes( this._textureUnit, Texture.textureNull, StateAttribute.PROTECTED );\n\n\n        // add shadow texture to the receivers\n        // should make sure somehow that\n        // alpha blender transparent receiver doesn't use it\n        // compiler wise at least\n        this._receivingStateset.setTextureAttributeAndModes( this._textureUnit, this._texture, fullOverride );\n\n        this._dirty = false;\n    },\n    // Make sure we don't bind texture and thus make GPU work for nothing\n    // as shadow casting just output Depth ( no color )\n    // os we set a null texture and OVERRIDE StateAttribute flag\n    // only case you want to use a texture is\n    // alpha masked material, then you have StateAttribute to 'PROTECTED'\n    _preventTextureBindingDuringShadowCasting: function () {\n\n        // prevent unnecessary texture bindings on all texture unit\n        var shouldGetMaxTextureUnits = WebGLCaps.instance().getWebGLParameter( 'MAX_TEXTURE_IMAGE_UNITS' );\n        for ( var k = 0; k < shouldGetMaxTextureUnits; k++ ) {\n            // bind  null texture which OSGJS will not bind,\n            // effectively preventing any other texture bind\n            // just not touching texture unit state.\n            this._casterStateSet.setTextureAttributeAndModes( k, Texture.textureNull, StateAttribute.OVERRIDE | StateAttribute.ON );\n        }\n\n    },\n    valid: function () {\n        // checks\n        return true;\n    },\n\n    updateShadowTechnique: function ( nv, viewportDimension ) {\n\n        var camera = this._cameraShadow;\n        var texture = this._texture;\n\n        if ( camera && texture ) {\n\n            var vp = camera.getViewport();\n\n            if ( !vp ) {\n                vp = new Viewport();\n                camera.setViewport( vp );\n            }\n\n            if ( viewportDimension ) {\n                // if texture size changed update the camera rtt params\n                if ( vp.x() !== viewportDimension[ 0 ] ||\n                    vp.y() !== viewportDimension[ 1 ] ||\n                    vp.width() !== viewportDimension[ 2 ] ||\n                    vp.height() !== viewportDimension[ 3 ] ) {\n\n                    camera.detachAll();\n\n                    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );\n                    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\n\n                    camera.getViewport().setViewport( viewportDimension[ 0 ], viewportDimension[ 1 ], viewportDimension[ 2 ], viewportDimension[ 3 ] );\n                }\n\n            } else {\n                // if texture size changed update the camera rtt params\n                if ( vp.width() !== texture.getWidth() ||\n                    vp.height() !== texture.getHeight() ) {\n\n                    camera.detachAll();\n\n                    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );\n                    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\n\n                    camera.getViewport().setViewport( 0, 0, texture.getWidth(), texture.getHeight() );\n                }\n            }\n        }\n    },\n\n    updateShadowTechnic: function ( /*nv*/) {\n        Notify.log( 'ShadowMap.updateShadowTechnic() is deprecated, use updateShadowTechnique instead' );\n        this.updateShadowTechnique();\n    },\n\n    setTextureFiltering: function () {\n\n        var textureType;\n        var texType = this.getTexturePrecision();\n        switch ( texType ) {\n        case 'HALF_FLOAT':\n            textureType = Texture.HALF_FLOAT;\n            break;\n        case 'FLOAT':\n            textureType = Texture.FLOAT;\n            break;\n        default:\n        case 'UNSIGNED_BYTE':\n            textureType = Texture.UNSIGNED_BYTE;\n            break;\n        }\n\n        this._texture.setInternalFormatType( textureType );\n        this._texture.setMinFilter( Texture.NEAREST );\n        this._texture.setMagFilter( Texture.NEAREST );\n        this._textureMagFilter = Texture.NEAREST;\n        this._textureMinFilter = Texture.NEAREST;\n\n    },\n\n    // internal texture allocation\n    // handle any change like resize, filter param, etc.\n    initTexture: function () {\n\n        if ( !this._dirty ) return;\n\n        if ( !this._texture ) {\n            this._texture = new ShadowTexture();\n            this._textureUnit = this._textureUnitBase;\n        }\n\n\n        this._texture.setTextureSize( this._textureSize, this._textureSize );\n        this._texelSizeUniform.setFloat( 1.0 / this._textureSize );\n        this._renderSize[ 0 ] = this._textureSize;\n        this._renderSize[ 1 ] = this._textureSize;\n\n        var textureFormat;\n        // luminance Float format ?\n        textureFormat = Texture.RGBA;\n\n        this.setTextureFiltering();\n        this._texture.setInternalFormat( textureFormat );\n\n        this._texture.setWrapS( Texture.CLAMP_TO_EDGE );\n        this._texture.setWrapT( Texture.CLAMP_TO_EDGE );\n\n        this._texture.dirty();\n\n    },\n    setTexturePrecision: function ( format ) {\n        if ( format === this._shadowReceiveAttribute.getPrecision() ) return;\n\n        this._shadowReceiveAttribute.setPrecision( format );\n        this.dirty();\n    },\n\n    getTexturePrecision: function () {\n        return this._shadowReceiveAttribute.getPrecision();\n    },\n\n    setTextureSize: function ( mapSize ) {\n\n        if ( mapSize === this._textureSize ) return;\n\n        this._textureSize = mapSize;\n\n        this.dirty();\n    },\n\n    getCasterStateSet: function () {\n        return this._casterStateSet;\n    },\n\n    setLight: function ( light ) {\n\n        if ( !light || light === this._light )\n            return;\n\n        this._light = light;\n        this.dirty();\n    },\n\n    getUp: function ( dir ) {\n        //avoid dir/up wrong angle breaking computation\n\n        // compute a up vector ensuring avoiding parallel vectors\n        // also might reverting to it once got the change here done once\n        // vec3.fromValues( 0.0, 0.0, 1.0 );\n\n        if ( Math.abs( vec3.dot( this._lightUp, dir ) ) >= 1.0 ) {\n            // another camera up\n            // vec3.fromValues( 1.0, 0.0, 0.0 );\n            if ( this._lightUp[ 0 ] === 1.0 ) {\n                this._lightUp[ 0 ] = 0.0;\n                this._lightUp[ 1 ] = 1.0;\n                this._lightUp[ 2 ] = 0.0;\n            } else {\n                this._lightUp[ 0 ] = 1.0;\n                this._lightUp[ 1 ] = 0.0;\n                this._lightUp[ 2 ] = 0.0;\n            }\n        }\n        return this._lightUp;\n    },\n\n    // makes sure we don't have incorrect near/far\n    // or we actually have to render something.\n    // Empty or Bad Frustums\n    // No objects, handle it gracefully\n    nearFarBounding: function () {\n\n        var zNear = this._depthRange[ 0 ];\n        var zFar = this._depthRange[ 1 ];\n\n        var epsilon = ShadowMap.EPSILON;\n        if ( zFar < zNear - epsilon ) {\n            // early out\n            this._emptyCasterScene = true;\n            zFar = 1;\n            zNear = epsilon;\n        } else if ( zNear < epsilon ) {\n            zNear = epsilon;\n        }\n\n        this._depthRange[ 0 ] = zNear;\n        this._depthRange[ 1 ] = zFar;\n\n    },\n\n    makePerspectiveFromBoundingBox: function ( bbox, fov, eyePos, eyeDir, view, projection ) {\n\n        var center = bbox.center( this._tmpVec );\n        var radius = bbox.radius();\n        var epsilon = ShadowMap.EPSILON;\n        var zNear = epsilon;\n        var zFar = 1.0;\n\n        this._radius = radius;\n\n        var distance = vec3.distance( center, eyePos );\n        // inside or not have influence\n        // on using radius for fov\n        if ( distance < -radius ) {\n            // won't render anything the object  is behind..\n            this._emptyCasterScene = true;\n        } else if ( distance <= 0.0 ) {\n            // shhh.. we're inside !\n            // sphere center is behind\n            zNear = epsilon;\n            zFar = distance + radius;\n        } else if ( distance < radius ) {\n            // shhh.. we're inside !\n            // sphere center is in front\n            zNear = epsilon;\n            zFar = distance + radius;\n        } else {\n            //  Sphere totally in front\n            // long distance runner\n            // we must make a nicer zNear here!\n            zNear = distance - radius;\n            zFar = distance + radius;\n        }\n\n        this._depthRange[ 0 ] = zNear;\n        this._depthRange[ 1 ] = zFar;\n        this.nearFarBounding();\n\n        // positional light: spot, point, area\n        //  fov < 180.0\n        // statically defined by spot, only needs zNear zFar estimates\n        var fovRadius = this._depthRange[ 0 ] * Math.tan( fov * Math.PI / 180.0 );\n        // if scene radius is smaller than fov on scene\n        // Tighten and enhance precision\n        fovRadius = fovRadius > radius ? radius : fovRadius;\n\n        var ymax = fovRadius;\n        var ymin = -ymax;\n\n        var xmax = fovRadius;\n        var xmin = -xmax;\n\n        var up = this.getUp( eyeDir );\n\n        if ( this._infiniteFrustum ) {\n            mat4.infiniteFrustum( projection, xmin, xmax, ymin, ymax, this._depthRange[ 0 ] );\n        } else {\n            mat4.frustum( projection, xmin, xmax, ymin, ymax, this._depthRange[ 0 ], this._depthRange[ 1 ] );\n\n        }\n\n        mat4.lookAtDirection( view, eyePos, eyeDir, up );\n\n    },\n\n    makeOrthoFromBoundingBox: function ( bbox, eyeDir, view, projection ) {\n\n        var center = bbox.center( this._tmpVecTercio );\n\n        var radius = bbox.radius();\n        var diameter = radius + radius;\n\n        var zNear = 0.0001;\n        var zFar = diameter + 0.0001;\n\n        // compute eye Pos from a inverted lightDir Ray shot from center of bbox\n        // firs make a RAY then move the eye to the that far pos following the ray\n        var eyePos = this._tmpVec;\n        vec3.scaleAndAdd( eyePos, center, eyeDir, -diameter );\n\n        zNear = radius;\n        zFar += radius;\n\n        var zNearRatio = 0.001;\n        if ( zNear < zFar * zNearRatio ) {\n            zNear = zFar * zNearRatio;\n        }\n\n        var up = this.getUp( eyeDir );\n        mat4.lookAtDirection( view, eyePos, eyeDir, up );\n\n\n        var right, top;\n        top = radius;\n        right = top;\n        mat4.ortho( projection, -right, right, -top, top, zNear, zFar );\n\n        this._depthRange[ 0 ] = zNear;\n        this._depthRange[ 1 ] = zFar;\n\n    },\n    /*\n     * Sync camera and light vision so that\n     * shadow map render using a camera whom\n     * settings come from the light\n     * and the scene being shadowed\n     */\n    aimShadowCastingCamera: function ( cullVisitor, frustumBound ) {\n\n        var light = this._light;\n\n        if ( !light ) {\n            this._emptyCasterScene = true;\n            return;\n        }\n\n        var camera = this._cameraShadow;\n\n        var worldLightPos = this._worldLightPos;\n        var worldLightDir = this._worldLightDir;\n\n        // make sure it's not modified outside our computations\n        // camera matrix can be modified by cullvisitor afterwards...\n        mat4.copy( this._projectionMatrix, camera.getProjectionMatrix() );\n        mat4.copy( this._viewMatrix, camera.getViewMatrix() );\n        var projection = this._projectionMatrix;\n        var view = this._viewMatrix;\n\n        // inject camera world matrix.\n        // from light current world/pos and camera eye pos.\n        // inject camera world matrix.\n        // from light current world/pos\n        // NEED same camera eye pos\n        var positionedAttribute = cullVisitor.getCurrentRenderBin().getPositionedAttribute();\n\n        var lightMatrix;\n        positionedAttribute = positionedAttribute.find( function ( element ) {\n            if ( element.length > 0 && element[ 1 ] === light ) {\n                lightMatrix = element[ 0 ];\n                return true;\n            }\n            return false;\n        } );\n        if ( lightMatrix === undefined ) {\n            Notify.warn( 'light isnt inside children of shadowedScene Node' );\n            this._emptyCasterScene = true;\n            return;\n        }\n\n        var eyeToWorld = this._tmpMatrix;\n        mat4.invert( eyeToWorld, cullVisitor.getCurrentModelViewMatrix() );\n\n        //  light pos & lightTarget in World Space\n        if ( !this._light.isDirectionLight() ) {\n\n            mat4.mul( this._tmpMatrix, eyeToWorld, lightMatrix );\n            var worldMatrix = this._tmpMatrix;\n\n            // same code as light spot shader\n            vec3.transformMat4( worldLightPos, light.getPosition(), worldMatrix );\n            worldMatrix[ 12 ] = 0;\n            worldMatrix[ 13 ] = 0;\n            worldMatrix[ 14 ] = 0;\n            mat4.invert( worldMatrix, worldMatrix );\n            mat4.transpose( worldMatrix, worldMatrix );\n\n            // not a directional light, compute the world light dir\n            vec3.copy( worldLightDir, light.getDirection() );\n            vec4.transformMat4( worldLightDir, worldLightDir, worldMatrix );\n            vec3.normalize( worldLightDir, worldLightDir );\n\n            // and compute a perspective frustum\n            this.makePerspectiveFromBoundingBox( frustumBound, light.getSpotCutoff(), worldLightPos, worldLightDir, view, projection );\n\n\n        } else {\n\n            vec4.transformMat4( worldLightPos, light.getPosition(), lightMatrix );\n            vec4.transformMat4( worldLightPos, worldLightPos, eyeToWorld );\n            // same code as light sun shader\n            // lightpos is a light dir\n            // so we now have to normalize\n            // since the transform to world above\n            vec3.scale( worldLightPos, worldLightPos, -1.0 );\n            vec3.normalize( worldLightPos, worldLightPos );\n            this.makeOrthoFromBoundingBox( frustumBound, worldLightPos, view, projection );\n\n            if ( this._debug ) {\n                // project box by view to get projection debug bbox\n                mat4.invert( this._debugNodeFrustum.getMatrix(), view );\n            }\n        }\n\n        mat4.copy( camera.getProjectionMatrix(), this._projectionMatrix );\n        mat4.copy( camera.getViewMatrix(), this._viewMatrix );\n\n        // set values now\n        this.setShadowUniformsDepthValue();\n\n    },\n\n    // culling is done,\n    // now try for a the tightest frustum\n    // possible for shadowcasting\n    frameShadowCastingFrustum: function ( cullVisitor ) {\n\n        if ( !this._infiniteFrustum ) {\n\n            CullVisitor.prototype.clampProjectionMatrix( this._projectionMatrix, this._depthRange[ 0 ], this._depthRange[ 1 ], cullVisitor.getNearFarRatio(), this._depthRange );\n        }\n\n        this.setShadowUniformsDepthValue();\n\n        // overwrite any cullvisitor wrongness done by any clampProjectionMatrix\n        var camera = this._cameraShadow;\n        mat4.copy( camera.getProjectionMatrix(), this._projectionMatrix );\n        mat4.copy( camera.getViewMatrix(), this._viewMatrix );\n\n    },\n\n    setShadowUniformsDepthValue: function () {\n\n        // set values now\n        this._depthRange[ 2 ] = this._depthRange[ 1 ] - this._depthRange[ 0 ];\n        this._depthRange[ 3 ] = 1.0 / ( this._depthRange[ 2 ] );\n\n        if ( this._lightNumberArrayIndex !== -1 ) {\n            this._texture.setViewMatrix( this._lightNumberArrayIndex, this._viewMatrix );\n            this._texture.setProjectionMatrix( this._lightNumberArrayIndex, this._projectionMatrix );\n            this._texture.setDepthRange( this._lightNumberArrayIndex, this._depthRange );\n        } else {\n            this._texture.setViewMatrix( this._viewMatrix );\n            this._texture.setProjectionMatrix( this._projectionMatrix );\n            this._texture.setDepthRange( this._depthRange );\n        }\n\n    },\n\n    noDraw: function () {\n\n        this._depthRange[ 0 ] = 0.0;\n        this._depthRange[ 1 ] = 0.0;\n        this._depthRange[ 2 ] = 0.0;\n        this._depthRange[ 3 ] = 0.0;\n\n        var castUniforms = this._casterStateSet.getUniformList();\n\n        castUniforms.uShadowDepthRange.getUniform().setVec4( this._depthRange );\n        this._texture.setDepthRange( this._depthRange );\n\n        var camera = this._cameraShadow;\n\n        // make sure it's not modified outside our computations\n        // camera matrix can be modified by cullvisitor afterwards...\n        mat4.copy( this._projectionMatrix, camera.getProjectionMatrix() );\n        mat4.copy( this._viewMatrix, camera.getViewMatrix() );\n\n        if ( this._lightNumberArrayIndex !== -1 ) {\n            this._texture.setViewMatrix( this._lightNumberArrayIndex, this._viewMatrix );\n            this._texture.setProjectionMatrix( this._lightNumberArrayIndex, this._projectionMatrix );\n\n        } else {\n            this._texture.setViewMatrix( this._viewMatrix );\n            this._texture.setProjectionMatrix( this._projectionMatrix );\n        }\n\n        this._filledOnce = true;\n    },\n\n    // Defines the frustum from light param.\n    //\n    cullShadowCasting: function ( cullVisitor ) {\n\n        var bbox;\n\n        if ( this._removeNodesNeverCastingVisitor ) {\n\n            this._removeNodesNeverCastingVisitor.setNoCastMask( ~( this._castsShadowBoundsTraversalMask | this._castsShadowDrawTraversalMask ) );\n            this._removeNodesNeverCastingVisitor.reset();\n            this.getShadowedScene().accept( this._removeNodesNeverCastingVisitor );\n\n        }\n\n        this._computeBoundsVisitor.setTraversalMask( this._castsShadowBoundsTraversalMask );\n        this._computeBoundsVisitor.reset();\n        this.getShadowedScene().accept( this._computeBoundsVisitor );\n        bbox = this._computeBoundsVisitor.getBoundingBox();\n\n        if ( !bbox.valid() ) {\n\n            // nothing to draw Early out.\n            this.noDraw();\n\n            if ( this._removeNodesNeverCastingVisitor ) {\n\n                // remove our flags changes on any bitmask\n                // not to break things\n                this._removeNodesNeverCastingVisitor.restore();\n\n            }\n\n            return;\n\n        }\n\n\n        if ( this._debug ) {\n\n            var min = bbox.getMin();\n            var max = bbox.getMax();\n            bbox.center( this._tmpVec );\n            var matrix = this._debugNodeSceneCast.getMatrix();\n\n            mat4.fromScaling( matrix, [ max[ 0 ] - min[ 0 ],\n                max[ 1 ] - min[ 1 ],\n                max[ 2 ] - min[ 2 ], 1\n            ] );\n            mat4.setTranslation( matrix,\n                this._tmpVec );\n\n        }\n\n        // HERE we get the shadowedScene Current World Matrix\n        // to get any world transform ABOVE the shadowedScene\n        var worldMatrix = cullVisitor.getCurrentModelMatrix();\n        // it does fuck up the results.\n        bbox.transformMat4( bbox, worldMatrix );\n\n        this._emptyCasterScene = false;\n        this.aimShadowCastingCamera( cullVisitor, bbox );\n\n        if ( this._emptyCasterScene ) {\n            // nothing to draw Early out.\n            //console.log( 'shadow early OUT' );\n            this.noDraw();\n\n            if ( this._removeNodesNeverCastingVisitor ) {\n\n                // remove our flags changes on any bitmask\n                // not to break things\n                this._removeNodesNeverCastingVisitor.restore();\n\n            }\n\n            return;\n        }\n\n\n        // get renderer to make the cull program\n        // record the traversal mask on entry so we can reapply it later.\n        var traversalMask = cullVisitor.getTraversalMask();\n\n        cullVisitor.setTraversalMask( this._castsShadowDrawTraversalMask );\n\n        // cast geometries into depth shadow map\n        cullVisitor.pushStateSet( this._casterStateSet );\n\n        this._cameraShadow.setEnableFrustumCulling( true );\n        this._cameraShadow.setComputeNearFar( true );\n\n        if ( this._debug ) {\n            this._debugNode.accept( cullVisitor );\n        }\n\n\n        // do RTT from the camera traversal mimicking light pos/orient\n        this._cameraShadow.accept( cullVisitor );\n\n        // make sure no negative near \n        this.nearFarBounding();\n\n        // Here culling is done, we do have near/far.\n        // and cull/non-culled info\n        // if we wanted a tighter frustum.\n        this.frameShadowCastingFrustum( cullVisitor );\n\n        // disabling to prevent cullvisitor breaking\n        // the projection matrix by \"clamping\" it\n        this._cameraShadow.setComputeNearFar( false );\n\n        if ( this._removeNodesNeverCastingVisitor ) {\n\n            // remove our flags changes on any bitmask\n            // not to break things\n            this._removeNodesNeverCastingVisitor.restore();\n\n        }\n\n        cullVisitor.popStateSet();\n\n        // re-apply the original traversal mask\n        cullVisitor.setTraversalMask( traversalMask );\n        this._filledOnce = true;\n    },\n\n    cleanReceivingStateSet: function () {\n        if ( this._receivingStateset ) {\n\n            if ( this._texture ) {\n                // remove this._texture, but not if it's not this._texture\n                if ( this._receivingStateset.getTextureAttribute( this._textureUnit, this._texture.getTypeMember() ) === this._texture )\n                    this._receivingStateset.removeTextureAttribute( this._textureUnit, this._texture.getTypeMember() );\n            }\n\n            if ( this._receivingStateset.getAttribute( this._shadowReceiveAttribute.getTypeMember() ) === this._shadowReceiveAttribute )\n                this._receivingStateset.removeAttribute( this._shadowReceiveAttribute.getTypeMember() );\n        }\n\n    },\n    cleanSceneGraph: function () {\n        // well release a lot more things when it works\n        this._cameraShadow = undefined;\n        this._filledOnce = false;\n\n\n        this.cleanReceivingStateSet();\n\n        // TODO: need state\n        //this._texture.releaseGLObjects();\n        //this._shadowReceiveAttribute = undefined;\n        this._texture = undefined;\n        this._shadowedScene = undefined;\n    },\n\n    setDebug: function ( enable ) {\n\n        if ( enable && !this._debug ) {\n\n            if ( !this._debugNode ) {\n\n                this._debugGeomFrustum = Debug.createDebugFrustumGeometry();\n\n                this._debugGeomSceneCast = Shape.createBoundingBoxGeometry();\n\n                this._debugGeomSceneCast.getPrimitives()[ 0 ].mode = PrimitiveSet.LINES;\n\n\n                this._debugNode = new MatrixTransform();\n                this._debugNodeFrustum = new MatrixTransform();\n                this._debugNodeSceneCast = new MatrixTransform();\n\n\n                this._debugNodeFrustum.addChild( this._debugGeomFrustum );\n                this._debugNodeSceneCast.addChild( this._debugGeomSceneCast );\n\n                this._debugNode.addChild( this._debugNodeFrustum );\n                this._debugNode.addChild( this._debugNodeSceneCast );\n\n            }\n        }\n        this._debug = enable;\n\n    },\n    getDebug: function () {\n        return this._debug;\n    }\n\n} ), 'osgShadow', 'ShadowMap' );\n\nShadowMap.EPSILON = 5e-3;\n\nMACROUTILS.setTypeID( ShadowMap );\n\nmodule.exports = ShadowMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowMap.js\n// module id = 240\n// module chunks = 0 1 2","'use strict';\n\nvar MACROUTILS = require( 'osg/Utils' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Uniform = require( 'osg/Uniform' );\nvar Notify = require( 'osg/notify' );\n\n\n/**\n * ShadowReceiveAttribute encapsulate Shadow Main State object\n * @class ShadowReceiveAttribute\n * @inherits StateAttribute\n */\nvar ShadowReceiveAttribute = function ( lightNum, disable ) {\n    StateAttribute.call( this );\n\n    this._lightNumber = lightNum;\n\n\n    // see shadowSettings.js header for shadow algo param explanations\n    // hash change var\n\n\n    // shadow depth bias as projected in shadow camera space texture\n    // and viewer camera space projection introduce its bias\n    this._bias = 0.001;\n\n    // shadow normal bias from normal exploding offset technique\n    this._normalBias = undefined;\n    // shader compilation different upon texture precision\n    this._precision = 'UNSIGNED_BYTE';\n    // kernel size & type for pcf\n    this._kernelSizePCF = undefined;\n\n    this._fakePCF = true;\n\n    this._rotateOffset = false;\n\n    this._enable = !disable;\n    this._isAtlasTexture = false;\n};\n\nShadowReceiveAttribute.uniforms = {};\nShadowReceiveAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\n\n    attributeType: 'ShadowReceive',\n\n    cloneType: function () {\n        return new ShadowReceiveAttribute( this._lightNumber, true );\n    },\n\n    getTypeMember: function () {\n        return this.attributeType + this.getLightNumber();\n    },\n\n    getLightNumber: function () {\n        return this._lightNumber;\n    },\n\n    getUniformName: function ( name ) {\n        var prefix = this.getType() + this.getLightNumber().toString();\n        return 'u' + prefix + '_' + name;\n    },\n\n    getAtlas: function () {\n        return this._isAtlasTexture;\n    },\n    setAtlas: function ( v ) {\n        this._isAtlasTexture = v;\n    },\n\n    setBias: function ( bias ) {\n        this._bias = bias;\n    },\n\n    getBias: function () {\n        return this._bias;\n    },\n\n    setNormalBias: function ( bias ) {\n        this._normalBias = bias;\n    },\n\n    getNormalBias: function () {\n        return this._normalBias;\n    },\n\n    getKernelSizePCF: function () {\n        return this._kernelSizePCF;\n    },\n\n    setKernelSizePCF: function ( v ) {\n        this._kernelSizePCF = v;\n    },\n\n    setPrecision: function ( precision ) {\n        this._precision = precision;\n    },\n\n    getPrecision: function () {\n        return this._precision;\n    },\n\n    setLightNumber: function ( lightNum ) {\n        this._lightNumber = lightNum;\n    },\n\n    getOrCreateUniforms: function () {\n        // uniform are once per CLASS attribute, not per instance\n        var obj = ShadowReceiveAttribute;\n\n        var typeMember = this.getTypeMember();\n\n        if ( obj.uniforms[ typeMember ] ) return obj.uniforms[ typeMember ];\n\n        obj.uniforms[ typeMember ] = {\n            bias: Uniform.createFloat( this.getUniformName( 'bias' ) ),\n            normalBias: Uniform.createFloat( this.getUniformName( 'normalBias' ) )\n        };\n\n        return obj.uniforms[ typeMember ];\n    },\n\n    getExtensions: function () {\n        return [ '#extension GL_OES_standard_derivatives : enable' ];\n    },\n\n    // Here to be common between  caster and receiver\n    // (used by shadowMap and shadow node shader)\n    getDefines: function () {\n\n        var textureType = this.getPrecision();\n        var defines = [];\n\n        var isFloat = false;\n\n        if ( textureType !== 'UNSIGNED_BYTE' )\n            isFloat = true;\n\n        var pcf = this.getKernelSizePCF();\n        switch ( pcf ) {\n        case '4Tap(16texFetch)':\n            defines.push( '#define _PCFx4' );\n            break;\n        case '9Tap(36texFetch)':\n            defines.push( '#define _PCFx9' );\n            break;\n        case '16Tap(64texFetch)':\n            defines.push( '#define _PCFx25' );\n            break;\n        default:\n        case '1Tap(4texFetch)':\n            defines.push( '#define _PCFx1' );\n            break;\n        }\n\n        if ( isFloat ) {\n            defines.push( '#define _FLOATTEX' );\n        }\n\n        if ( this.getAtlas() ) {\n            defines.push( '#define _ATLAS_SHADOW' );\n        }\n\n        if ( this.getNormalBias() ) {\n            defines.push( '#define _NORMAL_OFFSET' );\n        }\n\n        return defines;\n    },\n\n    apply: function () {\n\n        if ( !this._enable ) return;\n\n        var uniformMap = this.getOrCreateUniforms();\n\n        uniformMap.normalBias.setFloat( this._normalBias );\n        uniformMap.bias.setFloat( this._bias );\n\n    },\n\n    // need a isEnabled to let the ShaderGenerator to filter\n    // StateAttribute from the shader compilation\n    isEnabled: function () {\n        return this._enable;\n    },\n\n    // Deprecated methods, should be removed in the future\n    isEnable: function () {\n        Notify.log( 'ShadowAttribute.isEnable() is deprecated, use isEnabled() instead' );\n        return this.isEnabled();\n    },\n\n    getHash: function () {\n        return this.getTypeMember() + '_' + this.getKernelSizePCF();\n\n    }\n\n} ), 'osgShadow', 'ShadowReceiveAttribute' );\n\nMACROUTILS.setTypeID( ShadowReceiveAttribute );\n\nmodule.exports = ShadowReceiveAttribute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowReceiveAttribute.js\n// module id = 241\n// module chunks = 0 1 2","'use strict';\nvar Notify = require( 'osg/notify' );\nvar Object = require( 'osg/Object' );\nvar MACROUTILS = require( 'osg/Utils' );\n\n/**\n *  ShadowTechnique provides an implementation interface of shadow techniques.\n *  @class ShadowTechnique\n */\nvar ShadowTechnique = function () {\n    Object.call( this );\n\n    this._shadowedScene = undefined;\n    this._dirty = false;\n    // need to be computed\n    this._enabled = true;\n    // since dirtied, handy for static shadow map\n    this._filledOnce = false;\n};\n\n/** @lends ShadowTechnique.prototype */\nShadowTechnique.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\n\n    dirty: function () {\n        this._dirty = true;\n    },\n\n    getShadowedScene: function () {\n        return this._shadowedScene;\n    },\n\n    setEnabled: function ( enabled ) {\n        this._enabled = enabled;\n    },\n\n    isEnabled: function () {\n        return this._enabled;\n    },\n\n    isFilledOnce: function () {\n        return this._filledOnce;\n    },\n\n    requestRedraw: function () {\n        this._filledOnce = false;\n    },\n\n    setShadowedScene: function ( shadowedScene ) {\n        this._shadowedScene = shadowedScene;\n    },\n\n    init: function () {\n        // well shouldn't be called\n        Notify.log( 'No ShadowTechnique activated: normal rendering activated' );\n    },\n\n    valid: function () {\n        // make sure abstract class not used.\n        return false;\n    },\n\n\n    // update the technic\n    updateShadowTechnique: function ( /*nodeVisitor*/) {},\n\n    cullShadowCasting: function ( /*cullVisitor*/) {},\n\n    cleanSceneGraph: function () {\n        // well shouldn't be called\n        Notify.log( 'No ShadowTechnique activated: normal rendering activated' );\n    }\n\n} ), 'osgShadow', 'ShadowTechnique' );\n\n\nMACROUTILS.setTypeID( ShadowTechnique );\n\nmodule.exports = ShadowTechnique;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowTechnique.js\n// module id = 242\n// module chunks = 0 1 2","'use strict';\n\nvar Notify = require( 'osg/notify' );\nvar Texture = require( 'osg/Texture' );\nvar Uniform = require( 'osg/Uniform' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n\n/**\n * ShadowTexture Attribute encapsulate Texture webgl object\n * with Shadow specificities (no need of texcoord,fragtexcoord)\n * trigger hash change when changing texture precision from float to byt\n * shadowSettings.js header for param explanations\n * @class ShadowTexture\n * @inherits StateAttribute\n */\nvar ShadowTexture = function () {\n\n    Texture.call( this );\n\n    this._uniforms = {};\n    this._mapSize = vec4.create();\n    this._renderSize = vec4.create();\n    this._lightNumber = -1; // default for a valid cloneType\n\n};\n\nShadowTexture.uniforms = {};\n/** @lends Texture.prototype */\nShadowTexture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Texture.prototype, {\n\n    cloneType: function () {\n        return new ShadowTexture();\n    },\n    hasLightNumber: function ( lightNum ) {\n        return this._lightNumber === lightNum;\n    },\n    setLightNumber: function ( lun ) {\n        this._lightNumber = lun;\n    },\n    getLightNumber: function () {\n        return this._lightNumber;\n    },\n\n    getUniformName: function ( name ) {\n        var prefix = 'Shadow_' + this.getType() + this._lightNumber.toString();\n        return 'u' + prefix + '_' + name;\n    },\n\n    getVaryingName: function ( name ) {\n        var prefix = this.getType() + this._lightNumber.toString();\n        return 'v' + prefix + '_' + name;\n    },\n\n    getOrCreateUniforms: function ( unit ) {\n        // uniform are once per CLASS attribute, not per instance\n        var obj = ShadowTexture;\n\n        Notify.assert( unit !== undefined );\n        Notify.assert( this._lightNumber !== -1 );\n\n        if ( obj.uniforms[ unit ] !== undefined ) return obj.uniforms[ unit ];\n\n        var uniforms = obj.uniforms[ unit ] = {\n            ViewMatrix: Uniform.createMat4( this.getUniformName( 'viewMatrix' ) ),\n            ProjectionMatrix: Uniform.createMat4( this.getUniformName( 'projectionMatrix' ) ),\n            DepthRange: Uniform.createFloat4( this.getUniformName( 'depthRange' ) ),\n            MapSize: Uniform.createFloat4( this.getUniformName( 'mapSize' ) ),\n            RenderSize: Uniform.createFloat4( this.getUniformName( 'renderSize' ) )\n        };\n\n        // Dual Uniform of texture, needs:\n        // - Sampler (type of texture)\n        // - Int (texture unit)\n        // tells Shader Program where to find it\n        var name = 'Texture' + unit;\n        var uniform = Uniform.createInt1( unit, name );\n        uniforms[ name ] = uniform;\n\n        return obj.uniforms[ unit ];\n    },\n    setViewMatrix: function ( viewMatrix ) {\n        this._viewMatrix = viewMatrix;\n    },\n\n    setProjectionMatrix: function ( projectionMatrix ) {\n        this._projectionMatrix = projectionMatrix;\n    },\n\n    setDepthRange: function ( depthRange ) {\n        this._depthRange = depthRange;\n    },\n\n    setTextureSize: function ( w, h ) {\n        Texture.prototype.setTextureSize.call( this, w, h );\n        this.dirty();\n        this._mapSize[ 0 ] = w;\n        this._mapSize[ 1 ] = h;\n        this._mapSize[ 2 ] = 1.0 / w;\n        this._mapSize[ 3 ] = 1.0 / h;\n\n        this._renderSize[ 0 ] = w;\n        this._renderSize[ 1 ] = h;\n        this._renderSize[ 2 ] = 1.0 / w;\n        this._renderSize[ 3 ] = 1.0 / h;\n    },\n\n    apply: function ( state, texNumber ) {\n\n        // Texture stuff: call parent class method\n        Texture.prototype.apply.call( this, state, texNumber );\n\n        if ( this._lightNumber === -1 )\n            return;\n\n        // update Uniforms\n        var uniformMap = this.getOrCreateUniforms( texNumber );\n        uniformMap.ViewMatrix.setMatrix4( this._viewMatrix );\n        uniformMap.ProjectionMatrix.setMatrix4( this._projectionMatrix );\n        uniformMap.DepthRange.setFloat4( this._depthRange );\n        uniformMap.MapSize.setFloat4( this._mapSize );\n        uniformMap.RenderSize.setFloat4( this._renderSize );\n\n    },\n\n    getHash: function () {\n        return this.getTypeMember() + '_' + this._lightNumber + '_' + this._type;\n    }\n\n} ), 'osgShadow', 'ShadowTexture' );\n\nMACROUTILS.setTypeID( ShadowTexture );\n\nmodule.exports = ShadowTexture;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowTexture.js\n// module id = 243\n// module chunks = 0 1 2","'use strict';\nvar notify = require( 'osg/notify' );\nvar StateAttribute = require( 'osg/StateAttribute' );\nvar Texture = require( 'osg/Texture' );\nvar Uniform = require( 'osg/Uniform' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar Scissor = require( 'osg/Scissor' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\nvar ShadowTechnique = require( 'osgShadow/ShadowTechnique' );\nvar ShadowTextureAtlas = require( 'osgShadow/ShadowTextureAtlas' );\nvar ShadowMap = require( 'osgShadow/ShadowMap' );\n\n/**\n *  ShadowMapAtlas provides an implementation of shadow textures.\n * here, one shadow\n *  @class ShadowMapAtlas\n */\nvar ShadowMapAtlas = function ( settings ) {\n\n    this._lights = [];\n    this._shadowMaps = [];\n    this._viewportDimension = [];\n\n    ShadowTechnique.apply( this, arguments );\n    this._shadowSettings = settings;\n    this._texture = new ShadowTextureAtlas();\n    this._textureUnitBase = 4;\n    this._textureUnit = this._textureUnitBase;\n\n    // see shadowSettings.js header for param explanations\n    this._textureMagFilter = undefined;\n    this._textureMinFilter = undefined;\n\n\n    this._textureSize = 1024;\n    this._shadowMapSize = 256;\n\n    this._receivingStateset = undefined;\n\n    this._shaderProcessor = undefined;\n\n    if ( settings ) {\n\n        this.setShadowSettings( settings );\n        if ( settings.atlasSize ) this._textureSize = settings.atlasSize;\n        if ( settings.textureSize ) this._shadowMapSize = settings.textureSize;\n\n    }\n\n    this._texelSizeUniform = Uniform.createFloat1( 1.0 / this._textureSize, 'texelSize' );\n\n    var unifRenderSize = Uniform.createFloat2( 'RenderSize' );\n    this._renderSize = unifRenderSize.getInternalArray();\n    this._renderSize[ 0 ] = this._renderSize[ 1 ] = this._textureSize;\n\n    this._numShadowWidth = this._textureSize / this._shadowMapSize;\n    this._numShadowHeight = this._textureSize / this._shadowMapSize;\n\n};\n\n\n/** @lends ShadowMapAtlas.prototype */\nShadowMapAtlas.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( ShadowTechnique.prototype, {\n\n    getTexture: function () {\n        return this._texture;\n    },\n\n    isDirty: function ( ligthtIndex ) {\n        if ( ligthtIndex !== undefined ) {\n            return this._shadowMaps[ ligthtIndex ].isDirty();\n        } else {\n            for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n                if ( this._shadowMaps[ i ].isDirty() ) return true;\n            }\n        }\n        return false;\n    },\n    /**\n     * at which Texture unit number we start adding texture shadow\n     */\n    setTextureUnitBase: function ( unitBase ) {\n        this._textureUnitBase = unitBase;\n        this._textureUnit = unitBase;\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setTextureUnitBase( unitBase );\n        }\n    },\n\n    /* Sets  shadowSettings\n     */\n    setShadowSettings: function ( shadowSettings ) {\n\n        if ( !shadowSettings ) return;\n        this._shadowSettings = shadowSettings;\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ )\n            this._shadowMaps[ i ].setShadowSettings( shadowSettings );\n\n        this.setTextureSize( shadowSettings.textureSize );\n        this.setTexturePrecision( shadowSettings.textureType );\n\n    },\n\n    setCastsShadowDrawTraversalMask: function ( mask ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setCastsShadowDrawTraversalMask( mask );\n        }\n\n    },\n\n    getCastsShadowDrawTraversalMask: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getCastsShadowDrawTraversalMask();\n        } else if ( this._shadowMaps.length !== 0 ) {\n            return this._shadowMaps[ 0 ].getCastsShadowDrawTraversalMask();\n        }\n\n    },\n\n    setCastsShadowBoundsTraversalMask: function ( mask ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setCastsShadowBoundsTraversalMask( mask );\n        }\n\n    },\n\n    getCastsShadowBoundsTraversalMask: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getCastsShadowDrawTraversalMask();\n        } else if ( this._shadowMaps.length !== 0 ) {\n            return this._shadowMaps[ 0 ].getCastsShadowDrawTraversalMask();\n        }\n\n    },\n\n\n    getNormalBias: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getNormalBias();\n        } else if ( this._shadowMaps.length !== 0 ) {\n            return this._shadowMaps[ 0 ].getNormalBias();\n        }\n\n    },\n\n    setNormalBias: function ( value ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setNormalBias( value );\n        }\n\n    },\n\n    getBias: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getBias();\n        } else if ( this._shadowMaps.length !== 0 ) {\n            return this._shadowMaps[ 0 ].getBias();\n        }\n\n    },\n\n    setBias: function ( value ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setBias( value );\n        }\n\n    },\n\n    getKernelSizePCF: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getKernelSizePCF();\n        } else if ( this._shadowMaps.length !== 1 ) {\n            return this._shadowMaps[ 0 ].getKernelSizePCF();\n        }\n\n    },\n\n    setKernelSizePCF: function ( value ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setKernelSizePCF( value );\n        }\n    },\n\n    setShadowedScene: function ( shadowedScene ) {\n\n        ShadowTechnique.prototype.setShadowedScene.call( this, shadowedScene );\n        this._receivingStateset = this._shadowedScene.getReceivingStateSet();\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setShadowedScene( shadowedScene );\n        }\n\n    },\n\n    setTexturePrecision: function ( value ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].setTexturePrecision( value );\n        }\n\n    },\n\n    getTexturePrecision: function ( numShadow ) {\n\n        if ( numShadow !== undefined ) {\n            return this._shadowMaps[ numShadow ].getTexturePrecision();\n        } else if ( this._shadowMaps.length !== 1 ) {\n            return this._shadowMaps[ 0 ].getTexturePrecision();\n        }\n\n    },\n\n\n    setTextureSize: function ( mapSize ) {\n\n        if ( mapSize === this._textureSize ) return;\n\n        //this._textureSize = mapSize;\n        //this._textureSize = settings.atlasSize;\n        this._shadowMapSize = mapSize;\n\n\n        this._numShadowWidth = this._textureSize / this._shadowMapSize;\n        this._numShadowHeight = this._textureSize / this._shadowMapSize;\n\n        this.dirty();\n    },\n\n    getShadowMap: function ( lightNum ) {\n        return this._shadowMaps[ lightNum ];\n    },\n\n    addLight: function ( light ) {\n\n        if ( !light || this._lights.indexOf( light ) !== -1 ) {\n            notify.warn( 'no light or light already added' );\n            return -1;\n        }\n\n        var lightCount = this._lights.length;\n        if ( lightCount === ( this._numShadowWidth * this._numShadowHeight ) ) {\n            notify.warn( 'can\\'t allocate shadow for light ' + light.getLightNumber() + ' ShadowAtlas already full ' );\n            return undefined;\n        }\n\n        this._lights.push( light );\n        this._shadowSettings.setLight( light );\n        var shadowMap = new ShadowMap( this._shadowSettings, this._texture );\n        this._shadowMaps.push( shadowMap );\n\n        var mapSize = this._shadowMapSize;\n        var y = mapSize * ( lightCount % ( this._numShadowWidth ) );\n        var x = mapSize * ( Math.floor( lightCount / ( this._numShadowHeight ) ) );\n\n        shadowMap.setShadowedScene( this._shadowedScene );\n        this._viewportDimension.push( vec4.fromValues( x, y, mapSize, mapSize ) );\n\n        return shadowMap;\n\n    },\n\n\n    /** initialize the ShadowedScene and local cached data structures.*/\n    init: function () {\n\n        if ( !this._shadowedScene ) return;\n\n        this.initTexture();\n        var lightNumberArray = [];\n        for ( var k = 0; k < this._lights.length; k++ ) {\n            lightNumberArray.push( this._lights[ k ].getLightNumber() );\n        }\n        this._texture.setLightNumberArray( lightNumberArray );\n\n        this._textureUnit = this._textureUnitBase;\n        this._texture.setName( 'ShadowTexture' + this._textureUnit );\n\n        this._numShadowWidth = this._textureSize / this._shadowMapSize;\n        this._numShadowHeight = this._textureSize / this._shadowMapSize;\n\n        var unifRenderSize = Uniform.createFloat2( 'RenderSize' );\n        this._texelSizeUniform = Uniform.createFloat1( 1.0 / this._textureSize, 'texelSize' );\n        this._renderSize = unifRenderSize.getInternalArray();\n        this._renderSize[ 0 ] = this._renderSize[ 1 ] = this._textureSize;\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n\n            var mapSize = this._shadowMapSize;\n            var y = mapSize * ( i % ( this._numShadowWidth ) );\n            var x = mapSize * ( Math.floor( i / ( this._numShadowHeight ) ) );\n\n\n            this._viewportDimension[ i ] = vec4.fromValues( x, y, mapSize, mapSize );\n            this._shadowMaps[ i ].init( this._texture, i, this._textureUnitBase );\n            this._texture.setLightShadowMapSize( i, this._viewportDimension[ i ] );\n\n            var st = this._shadowMaps[ i ].getCamera().getOrCreateStateSet();\n            var scissor = new Scissor( x, y, mapSize, mapSize );\n            st.setAttributeAndModes( scissor, StateAttribute.ON | StateAttribute.OVERRIDE );\n\n        }\n\n    },\n    valid: function () {\n        // checks\n        return true;\n    },\n\n    updateShadowTechnique: function ( nv ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].updateShadowTechnique( nv, this._viewportDimension[ i ] );\n        }\n\n    },\n\n    // internal texture allocation\n    // handle any change like resize, filter param, etc.\n    initTexture: function () {\n\n        if ( !this._dirty ) return;\n\n        if ( !this._texture ) {\n            this._texture = new ShadowTextureAtlas();\n            this._textureUnit = this._textureUnitBase;\n        }\n\n\n        this._texture.setTextureSize( this._textureSize, this._textureSize );\n        this._texelSizeUniform.setFloat( 1.0 / this._textureSize );\n        this._renderSize[ 0 ] = this._textureSize;\n        this._renderSize[ 1 ] = this._textureSize;\n\n        var textureFormat;\n        // luminance Float format ?\n        textureFormat = Texture.RGBA;\n\n        ShadowMap.prototype.setTextureFiltering.call( this );\n        this._texture.setInternalFormat( textureFormat );\n\n        this._texture.setWrapS( Texture.CLAMP_TO_EDGE );\n        this._texture.setWrapT( Texture.CLAMP_TO_EDGE );\n\n        this._texture.dirty();\n\n    },\n\n    // Defines the frustum from light param.\n    //\n    cullShadowCasting: function ( cullVisitor ) {\n\n        for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n            this._shadowMaps[ i ].cullShadowCasting( cullVisitor );\n        }\n\n    },\n\n    cleanReceivingStateSet: function () {\n\n        if ( this._receivingStateset ) {\n\n            if ( this._texture ) {\n                // remove this._texture, but not if it's not this._texture\n                if ( this._receivingStateset.getTextureAttribute( this._textureUnit, this._texture.getTypeMember() ) === this._texture )\n                    this._receivingStateset.removeTextureAttribute( this._textureUnit, this._texture.getTypeMember() );\n            }\n\n            for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n                this._shadowMaps[ i ].cleanReceivingStateSet();\n            }\n\n        }\n\n    },\n    cleanSceneGraph: function () {\n        // TODO: need state\n        //this._texture.releaseGLObjects();\n        //this._shadowReceiveAttribute = undefined;\n        this._texture = undefined;\n        this._shadowedScene = undefined;\n    },\n\n    setDebug: function ( enable, lightNum ) {\n\n        if ( !lightNum ) {\n            for ( var i = 0, l = this._shadowMaps.length; i < l; i++ ) {\n                this._shadowMaps[ i ].setDebug( enable );\n            }\n        } else {\n            this._shadowMaps[ lightNum ].setDebug( enable );\n        }\n\n    },\n\n} ), 'osgShadow', 'ShadowMapAtlas' );\n\nMACROUTILS.setTypeID( ShadowMapAtlas );\n\nmodule.exports = ShadowMapAtlas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowMapAtlas.js\n// module id = 244\n// module chunks = 0 1 2","'use strict';\n\nvar notify = require( 'osg/notify' );\nvar Texture = require( 'osg/Texture' );\nvar Uniform = require( 'osg/Uniform' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n\n/**\n * ShadowTexture Attribute encapsulate Texture webgl object\n * with Shadow specificities (no need of texcoord,fragtexcoord)\n * trigger hash change when changing texture precision from float to byt\n * shadowSettings.js header for param explanations\n * @class ShadowTexture\n * @inherits StateAttribute\n */\nvar ShadowTextureAtlas = function () {\n\n    Texture.call( this );\n\n    this._uniforms = {};\n    this._lightNumberArray = []; // default for a valid cloneType\n\n    this._viewMatrices = [];\n    this._projectionMatrices = [];\n    this._depthRanges = [];\n    this._mapSizes = [];\n    this._renderSize = vec4.create();\n\n};\n\nShadowTextureAtlas.uniforms = {};\n/** @lends Texture.prototype */\nShadowTextureAtlas.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Texture.prototype, {\n\n    cloneType: function () {\n        return new ShadowTextureAtlas();\n    },\n\n    gettLightNumberArray: function () {\n        return this._lightNumberArray;\n    },\n\n    hasLightNumber: function ( lightNum ) {\n        return this._lightNumberArray.indexOf( lightNum ) !== -1;\n    },\n\n    setLightNumberArray: function ( lightNumberArray ) {\n\n        this._lightNumberArray = lightNumberArray;\n\n        var l = lightNumberArray.length;\n        this._viewMatrices.length = l;\n        this._projectionMatrices.length = l;\n        this._depthRanges.length = l;\n        this._mapSizes.length = l;\n\n    },\n\n    getUniformName: function ( lightNumber, name ) {\n\n        var prefix = 'Shadow_' + this.getType() + lightNumber.toString();\n        return 'u' + prefix + '_' + name;\n\n    },\n\n    getVaryingName: function ( lightNumber, name ) {\n\n        var prefix = this.getType() + lightNumber.toString();\n        return 'v' + prefix + '_' + name;\n\n    },\n\n    getOrCreateUniforms: function ( unit ) {\n\n        // uniform are once per CLASS attribute, not per instance\n        var obj = ShadowTextureAtlas;\n        notify.assert( unit !== undefined || this._lightNumberArray.length !== 0 );\n\n        if ( obj.uniforms[ unit ] !== undefined ) {\n            return obj.uniforms[ unit ];\n        }\n\n        var uniforms = obj.uniforms[ unit ] = {};\n\n        // shadowmap texture size used for texel space which is viewport independant\n        var renderSizeUniform = Uniform.createFloat4( this.getUniformName( 0, 'renderSize' ) );\n        uniforms[ 'RenderSize' ] = renderSizeUniform;\n\n        for ( var i = 0, l = this._lightNumberArray.length; i < l; i++ ) {\n\n            var lightNumber = this._lightNumberArray[ i ];\n            uniforms[ 'ViewMatrix_' + lightNumber ] = Uniform.createMat4( this.getUniformName( lightNumber, 'viewMatrix' ) );\n            uniforms[ 'ProjectionMatrix_' + lightNumber ] = Uniform.createMat4( this.getUniformName( lightNumber, 'projectionMatrix' ) );\n            uniforms[ 'DepthRange_' + lightNumber ] = Uniform.createFloat4( this.getUniformName( lightNumber, 'depthRange' ) );\n            uniforms[ 'MapSize_' + lightNumber ] = Uniform.createFloat4( this.getUniformName( lightNumber, 'mapSize' ) );\n            uniforms[ 'RenderSize_' + lightNumber ] = renderSizeUniform;\n\n        }\n\n\n        // Dual Uniform of texture, needs:\n        // - Sampler (type of texture)\n        // - Int (texture unit)\n        // tells Shader Program where to find it\n        var name = 'Texture' + unit;\n        var uniform = Uniform.createInt1( unit, name );\n        uniforms[ name ] = uniform;\n\n        return obj.uniforms[ unit ];\n    },\n\n    setViewMatrix: function ( lighNumberArrayIndex, viewMatrix ) {\n        this._viewMatrices[ lighNumberArrayIndex ] = viewMatrix;\n    },\n\n    setProjectionMatrix: function ( lighNumberArrayIndex, projectionMatrix ) {\n        this._projectionMatrices[ lighNumberArrayIndex ] = projectionMatrix;\n    },\n\n    setDepthRange: function ( lighNumberArrayIndex, depthRange ) {\n        this._depthRanges[ lighNumberArrayIndex ] = depthRange;\n    },\n\n    setTextureSize: function ( w, h ) {\n\n        this._renderSize[ 0 ] = w;\n        this._renderSize[ 1 ] = h;\n        this._renderSize[ 2 ] = 1.0 / w;\n        this._renderSize[ 3 ] = 1.0 / h;\n        Texture.prototype.setTextureSize.call( this, w, h );\n        this.dirty();\n\n    },\n\n    setLightShadowMapSize: function ( lighNumberArrayIndex, dimension ) {\n\n        this._mapSizes[ lighNumberArrayIndex ] = dimension;\n\n    },\n\n    apply: function ( state, texUnit ) {\n\n        // Texture stuff: call parent class method\n        Texture.prototype.apply.call( this, state, texUnit );\n\n        if ( this._lightNumberArray.length === 0 )\n            return;\n\n        // update Uniforms\n        var uniformMap = this.getOrCreateUniforms( texUnit );\n\n        for ( var i = 0, l = this._lightNumberArray.length; i < l; i++ ) {\n\n            var lightNumber = this._lightNumberArray[ i ];\n            uniformMap[ 'ViewMatrix_' + lightNumber ].setMatrix4( this._viewMatrices[ i ] );\n            uniformMap[ 'ProjectionMatrix_' + lightNumber ].setMatrix4( this._projectionMatrices[ i ] );\n            uniformMap[ 'DepthRange_' + lightNumber ].setFloat4( this._depthRanges[ i ] );\n            uniformMap[ 'MapSize_' + lightNumber ].setFloat4( this._mapSizes[ i ] );\n            uniformMap[ 'RenderSize_' + lightNumber ].setFloat4( this._renderSize );\n\n        }\n\n        uniformMap[ 'RenderSize' ].setFloat4( this._renderSize );\n\n    },\n\n    getHash: function () {\n\n        var hash = this.getTypeMember();\n        for ( var i = 0, l = this._lightNumberArray.length; i < l; i++ ) {\n            hash += '_' + this._lightNumberArray[ i ];\n        }\n        hash += '_' + this._type;\n        return hash;\n\n    }\n\n} ), 'osgShadow', 'ShadowTextureAtlas' );\n\nMACROUTILS.setTypeID( ShadowTextureAtlas );\n\nmodule.exports = ShadowTextureAtlas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowTextureAtlas.js\n// module id = 245\n// module chunks = 0 1 2","'use strict';\nvar MACROUTILS = require( 'osg/Utils' );\nvar Texture = require( 'osg/Texture' );\n\nvar kernelSizeList = [ '1Tap(4texFetch)', '4Tap(16texFetch)', '9Tap(36texFetch)', '16Tap(64texFetch)' ];\n\n/**\n *  ShadowSettings provides the parameters that the ShadowTechnique should use as a guide for setting up shadowing\n *  @class ShadowSettings\n */\nvar ShadowSettings = function ( options ) {\n\n    this.castsShadowDrawTraversalMask = 0xffffffff;\n    this.castsShadowBoundsTraversalMask = 0xffffffff;\n\n    this.textureSize = 1024;\n\n    // important note:\n    // comparison shadow is: DepthShadow > DephFragment => shadowed\n    // which is d<z\n    // and\n    // Average( (d < z) ) != (Average( z ) < d)\n    // so PCF/NONE technique cannot be prefiltered (bilinear, etc..) with HW filter\n    // on gl/dx desktop there is a sampler2DShadow that allows that taking z in third param\n    // we emulate that with texture2DShadowLerp\n    // which is why some techniques have more texfetch than advertized.\n    // http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html\n\n    // texture precision. (and bandwith implication)\n    this.textureType = 'UNSIGNED_BYTE';\n\n    this.textureFormat = Texture.RGBA;\n\n    // either orthogonal (non-fov) or perpsective (fov)\n    this.shadowProjection = 'fov';\n    // fov size: can be infered from spotlight angle\n    this.fov = 50;\n\n    // PCF algo and kernel size\n    // Band kernelsize gives nxn texFetch\n    // others a n*n*4 (emulating the HW shadowSampler)\n    // ['4Tap(16texFetch)', '9Tap(36texFetch)', '16Tap(64texFetch)']\n    this.kernelSizePCF = '4Tap(4texFetch)';\n\n    // depth offset (shadow acne / peter panning)\n    this.bias = 0.005;\n\n    // normal exploding offset (shadow acne / peter panning)\n    this.normalBias = undefined;\n\n\n    // defaut shader generator name for shadow casting\n    this.shadowCastShaderGeneratorName = 'ShadowCast';\n\n    // if url options override url options\n    MACROUTILS.objectMix( this, options );\n};\n\nShadowSettings.kernelSizeList = kernelSizeList;\n\nShadowSettings.prototype = {\n\n    setCastsShadowDrawTraversalMask: function ( mask ) {\n        this.castsShadowDrawTraversalMask = mask;\n    },\n    getCastsShadowDrawTraversalMask: function () {\n        return this.castsDrawShadowTraversalMask;\n    },\n\n    setCastsShadowBoundsTraversalMask: function ( mask ) {\n        this.castsShadowBoundsTraversalMask = mask;\n    },\n    getCastsShadowBoundsTraversalMask: function () {\n        return this.castsShadowBoundsTraversalMask;\n    },\n\n    setLight: function ( light ) {\n        this.light = light;\n    },\n    getLight: function () {\n        return this.light;\n    },\n\n    setTextureSize: function ( textureSize ) {\n        this.textureSize = textureSize;\n    },\n    getTextureSize: function () {\n        return this.textureSize;\n    },\n    setTextureType: function ( tt ) {\n        this.textureType = tt;\n    },\n    getTextureType: function () {\n        return this.textureType;\n    },\n    setTextureFormat: function ( tf ) {\n        this.textureFormat = tf;\n    },\n    getTextureFormat: function () {\n        return this.textureFormat;\n    },\n    setShadowCastShaderGeneratorName: function ( n ) {\n        this.shadowCastShaderGeneratorName = n;\n    },\n    getShadowCastShaderGeneratorName: function () {\n        return this.shadowCastShaderGeneratorName;\n    }\n\n};\n\nmodule.exports = ShadowSettings;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowSettings.js\n// module id = 246\n// module chunks = 0 1 2","'use strict';\nvar CullVisitor = require( 'osg/CullVisitor' );\nvar mat4 = require( 'osg/glMatrix' ).mat4;\nvar Node = require( 'osg/Node' );\nvar NodeVisitor = require( 'osg/NodeVisitor' );\nvar StateSet = require( 'osg/StateSet' );\nvar MACROUTILS = require( 'osg/Utils' );\nvar vec4 = require( 'osg/glMatrix' ).vec4;\n\n\n/**\n *  ShadowedScene provides a mechanism for decorating a scene that the needs to have shadows cast upon it.\n *  @class ShadowedScene\n *  @{@link [http://trac.openscenegraph.org/projects/osg//wiki/Support/ProgrammingGuide/osgShadow]}\n *  @{@link [http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf]};\n */\nvar ShadowedScene = function () {\n    Node.call( this );\n\n    // TODO: all  techniques (stencil/projTex/map/vol)\n    this._shadowTechniques = [];\n\n    this._optimizedFrustum = false;\n\n    this._frustumReceivers = [ vec4.create(), vec4.create(), vec4.create(), vec4.create(), vec4.create(), vec4.create() ];\n\n    this._tmpMat = mat4.create();\n\n    this._receivingStateset = new StateSet();\n\n};\n\n/** @lends ShadowedScene.prototype */\nShadowedScene.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {\n\n    getReceivingStateSet: function () {\n\n        return this._receivingStateset;\n\n    },\n\n    getShadowTechniques: function () {\n        return this._shadowTechniques;\n    },\n\n    addShadowTechnique: function ( technique ) {\n        if ( this._shadowTechniques.length > 0 ) {\n            if ( this._shadowTechniques.indexOf( technique ) !== -1 ) return;\n        }\n\n        this._shadowTechniques.push( technique );\n\n        if ( technique.valid() ) {\n            technique.setShadowedScene( this );\n            technique.dirty();\n        }\n    },\n    removeShadowTechnique: function ( technique ) {\n\n        if ( this._shadowTechniques.length > 0 ) {\n            var idx = this._shadowTechniques.indexOf( technique );\n            if ( idx !== -1 ) {\n\n                if ( this._shadowTechniques[ idx ].valid() ) {\n                    this._shadowTechniques[ idx ].cleanSceneGraph();\n                }\n                this._shadowTechniques.splice( idx, 1 );\n            }\n        }\n    },\n    /** Clean scene graph from any shadow technique specific nodes, state and drawables.*/\n    cleanSceneGraph: function () {\n        for ( var i = 0, lt = this._shadowTechniques.length; i < lt; i++ ) {\n            if ( this._shadowTechniques[ i ] && this._shadowTechniques[ i ].valid() ) {\n                this._shadowTechniques[ i ].cleanSceneGraph();\n            }\n        }\n    },\n\n    /** Dirty any cache data structures held in the attached ShadowTechnique.*/\n    dirty: function () {\n        for ( var i = 0; i < this._shadowTechniques.length; i++ )\n            this._shadowTechniques[ i ].dirty();\n    },\n\n    nodeTraverse: function ( nv ) {\n        Node.prototype.traverse.call( this, nv );\n    },\n\n    traverse: function ( nv ) {\n\n        // update the scene\n        if ( nv.getVisitorType() === NodeVisitor.CULL_VISITOR ) {\n\n            var i, st, lt = this._shadowTechniques.length;\n\n            // cull Shadowed Scene\n            if ( lt ) nv.pushStateSet( this._receivingStateset );\n            this.nodeTraverse( nv );\n            if ( lt ) nv.popStateSet();\n\n            // cull Casters\n            for ( i = 0; i < lt; i++ ) {\n                st = this._shadowTechniques[ i ];\n                // dirty check for user playing with shadows inside update traverse\n                if ( st && st.valid() ) {\n\n                    // those two checks\n                    // here\n                    // in case people update it from\n                    // any update/cull/callback\n                    if ( st.isDirty() )\n                        st.init();\n\n                    if ( st.isEnabled() || !st.isFilledOnce() ) {\n                        st.updateShadowTechnique( nv );\n                        st.cullShadowCasting( nv );\n                    }\n                }\n            }\n\n        } else {\n            this.nodeTraverse( nv );\n        }\n    }\n\n\n} ), 'osgShadow', 'ShadowedScene' );\nMACROUTILS.setTypeID( ShadowedScene );\n\n// same code like Node\nCullVisitor.prototype[ ShadowedScene.typeID ] = CullVisitor.prototype[ Node.typeID ];\n\nmodule.exports = ShadowedScene;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgShadow/ShadowedScene.js\n// module id = 247\n// module chunks = 0 1 2","'use strict';\nvar Text = require( 'osgText/Text' );\n\nvar osgText = {};\nosgText.Text = Text;\n\nmodule.exports = osgText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgText/osgText.js\n// module id = 248\n// module chunks = 0 1 2","'use strict';\nvar osg = require( 'osgWrappers/serializers/osg' );\nvar osgAnimation = require( 'osgWrappers/serializers/osgAnimation' );\nvar osgText = require( 'osgWrappers/serializers/osgText' );\n\nvar osgWrappers = {};\n\nosgWrappers.osg = osg;\nosgWrappers.osgAnimation = osgAnimation;\nosgWrappers.osgText = osgText;\n\nmodule.exports = osgWrappers;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgWrappers/osgWrappers.js\n// module id = 249\n// module chunks = 0 1 2","'use strict';\nvar ReaderWriterGLTF = require( 'osgPlugins/ReaderWriterGLTF' );\nvar ReaderWriterZIP = require( 'osgPlugins/ReaderWriterZIP' );\n\nvar osgPlugins = {};\n\nosgPlugins.ReaderWriterGLTF = ReaderWriterGLTF;\nosgPlugins.ReaderWriterZIP = ReaderWriterZIP;\n\nmodule.exports = osgPlugins;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgPlugins/osgPlugins.js\n// module id = 250\n// module chunks = 0 1 2","'use strict';\n\nvar P = require( 'bluebird' );\nvar requestFile = require( 'osgDB/requestFile' );\nvar Input = require( 'osgDB/Input' );\nvar Registry = require( 'osgDB/Registry' );\nvar animation = require( 'osgAnimation/animation' );\nvar BasicAnimationManager = require( 'osgAnimation/BasicAnimationManager' );\nvar Skeleton = require( 'osgAnimation/Skeleton' );\nvar Bone = require( 'osgAnimation/Bone' );\nvar StackedTranslate = require( 'osgAnimation/StackedTranslate' );\nvar StackedQuaternion = require( 'osgAnimation/StackedQuaternion' );\nvar StackedScale = require( 'osgAnimation/StackedScale' );\nvar RigGeometry = require( 'osgAnimation/RigGeometry' );\nvar channel = require( 'osgAnimation/channel' );\nvar createQuatChannel = channel.createQuatChannel;\nvar createVec3Channel = channel.createVec3Channel;\nvar BlendFunc = require( 'osg/BlendFunc' );\n\nvar Geometry = require( 'osg/Geometry' );\nvar Texture = require( 'osg/Texture' );\nvar MatrixTransform = require( 'osg/MatrixTransform' );\nvar Material = require( 'osg/Material' );\nvar DrawElements = require( 'osg/DrawElements' );\nvar primitiveSet = require( 'osg/primitiveSet' );\nvar BufferArray = require( 'osg/BufferArray' );\nvar UpdateBone = require( 'osgAnimation/UpdateBone' );\nvar UpdateMatrixTransform = require( 'osgAnimation/UpdateMatrixTransform' );\nvar FileHelper = require( 'osgDB/FileHelper' );\n\nvar Uniform = require( 'osg/Uniform' );\nvar P = require( 'bluebird' );\nvar vec3 = require( 'osg/glMatrix' ).vec3;\nvar quat = require( 'osg/glMatrix' ).quat;\nvar mat4 = require( 'osg/glMatrix' ).mat4;\n\nvar ReaderWriterGLTF = function () {\n\n    // Contains all the needed glTF files (.gltf, .bin, etc...)\n    this._filesMap = undefined;\n    this._loadedFiles = undefined;\n    this._bufferViewCache = undefined;\n    this._basicAnimationManager = undefined;\n    this._visitedNodes = undefined;\n    this._animatedNodes = undefined;\n    this._skeletons = undefined;\n    this._bones = undefined;\n    this._skeletonToInfluenceMap = undefined;\n    this._inputImgReader = undefined;\n    this._localPath = '';\n\n    this.init();\n};\n\nReaderWriterGLTF.WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\n\nReaderWriterGLTF.TYPE_TABLE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\n\nReaderWriterGLTF.TEXTURE_FORMAT = {\n    6406: Texture.ALPHA,\n    6407: Texture.RGB,\n    6408: Texture.RGBA,\n    6409: Texture.LUMINANCE,\n    6410: Texture.LUMINANCE_ALPHA\n};\n\nReaderWriterGLTF.PBR_SPEC_EXT = 'KHR_materials_pbrSpecularGlossiness';\nReaderWriterGLTF.PBR_SPEC_MODE = 'PBR_specular_glossiness';\nReaderWriterGLTF.PBR_METAL_MODE = 'PBR_metal_roughness';\n\nReaderWriterGLTF.ALBEDO_TEXTURE_UNIT = 2;\nReaderWriterGLTF.DIFFUSE_TEXTURE_UNIT = 2;\nReaderWriterGLTF.SPECULAR_GLOSSINESS_TEXTURE_UNIT = 3;\nReaderWriterGLTF.METALLIC_ROUGHNESS_TEXTURE_UNIT = 3;\nReaderWriterGLTF.SPECULAR_TEXTURE_UNIT = 4;\nReaderWriterGLTF.NORMAL_TEXTURE_UNIT = 5;\nReaderWriterGLTF.AO_TEXTURE_UNIT = 6;\n\nReaderWriterGLTF.ALBEDO_UNIFORM = 'albedoMap';\nReaderWriterGLTF.METALLIC_ROUGHNESS_UNIFORM = 'metallicRoughnessMap';\nReaderWriterGLTF.SPECULAR_UNIFORM = 'specularMap';\nReaderWriterGLTF.NORMAL_UNIFORM = 'normalMap';\nReaderWriterGLTF.AO_UNIFORM = 'aoMap';\n\nReaderWriterGLTF.prototype = {\n\n    init: function () {\n\n        this._glTFJSON = undefined;\n        this._bufferViewCache = {};\n        this._basicAnimationManager = undefined;\n        this._localPath = '';\n        this._visitedNodes = {};\n        this._animatedNodes = {};\n        this._skeletons = {};\n        this._bones = {};\n        this._skeletonToInfluenceMap = {};\n        this._stateSetMap = {};\n        this._filesMap = new window.Map();\n        this._inputReader = new Input();\n\n    },\n\n\n\n    loadFile: P.method( function ( uri ) {\n        if ( this._filesMap.has( uri ) )\n            return this._filesMap.get( uri );\n\n        var ext = uri.substr( uri.lastIndexOf( '.' ) + 1 );\n        var fileType = FileHelper.getTypeForExtension( ext );\n\n        var promiseFile;\n        var url = this._localPath + uri;\n        if ( fileType === 'blob' ) {\n            promiseFile = this._inputReader.readImageURL( url, {\n                imageLoadingUsePromise: true\n            } );\n        } else if ( fileType === 'arraybuffer' ) {\n            promiseFile = this._inputReader.readBinaryArrayURL( url, {\n                fileType: fileType\n            } );\n        }\n\n        this._filesMap.set( uri, promiseFile );\n\n        promiseFile.then( function ( file ) {\n            return file;\n        } );\n        return promiseFile;\n    } ),\n\n\n    /**\n     * Loads a osg.BufferArray from a TypeArray obtained by using a glTF accessor.\n     * No memory allocation is done, the result is a subarray obtained from a glTF binary file\n     * @param  {Object} accessor\n     * @param  {osg.BufferArray.ARRAY_BUFFER | osg.BufferArray.ELEMENT_ARRAY_BUFFER} type WebGL buffer type\n     * @param  {TypedArray} BufferType specific TypedArray type used for extraction\n     * @return {osg.BufferArray} OSG readable buffer contaning the extracted data\n     */\n    loadAccessorBuffer: function ( accessor, type ) {\n        var json = this._glTFJSON;\n        var bufferView = json.bufferViews[ accessor.bufferView ];\n        var buffer = json.buffers[ bufferView.buffer ];\n        var filePromise = this.loadFile( buffer.uri );\n        var self = this;\n        return filePromise.then( function ( data ) {\n            return self.assignBuffers( data, accessor, type, bufferView );\n        } );\n    },\n\n\n\n    assignBuffers: P.method( function ( data, accessor, type, bufferView ) {\n        if ( !data )\n            return null;\n\n        var TypedArray = ReaderWriterGLTF.WEBGL_COMPONENT_TYPES[ accessor.componentType ];\n        var typedArray = null;\n\n        if ( !this._bufferViewCache[ accessor.bufferView ] )\n            this._bufferViewCache[ accessor.bufferView ] = data.slice( bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength );\n\n        var bufferViewArray = this._bufferViewCache[ accessor.bufferView ];\n        typedArray = new TypedArray( bufferViewArray, accessor.byteOffset, accessor.count * ReaderWriterGLTF.TYPE_TABLE[ accessor.type ] );\n\n        if ( type )\n            return new BufferArray( type, typedArray, ReaderWriterGLTF.TYPE_TABLE[ accessor.type ], true );\n        return typedArray;\n    } ),\n\n\n    findByKey: function ( obj, key ) {\n        return obj && obj[ key ];\n    },\n\n    registerUpdateCallback: function ( callbackName, node ) {\n\n        var json = this._glTFJSON;\n\n        var animationCallback = null;\n        if ( json.nodes[ callbackName ].jointName )\n            animationCallback = new UpdateBone();\n        else\n            animationCallback = new UpdateMatrixTransform();\n\n        animationCallback.setName( callbackName );\n\n        var translation = vec3.create();\n        mat4.getTranslation( translation, node.getMatrix() );\n\n        var rotationQuat = quat.create();\n        mat4.getRotation( rotationQuat, node.getMatrix() );\n\n        var scale = vec3.create();\n        mat4.getScale( scale, node.getMatrix() );\n\n        animationCallback.getStackedTransforms().push( new StackedTranslate( 'translation', translation ) );\n        animationCallback.getStackedTransforms().push( new StackedQuaternion( 'rotation', rotationQuat ) );\n        animationCallback.getStackedTransforms().push( new StackedScale( 'scale', scale ) );\n\n        node.addUpdateCallback( animationCallback );\n    },\n\n    createTextureAndSetAttrib: P.method( function ( glTFTextureObject, stateSet, location, uniform ) {\n\n        if ( !glTFTextureObject ) return;\n        var json = this._glTFJSON;\n        var glTFTexture = json.textures[ glTFTextureObject.index ];\n        if ( !glTFTexture ) return;\n\n        var image = json.images[ glTFTexture.source ];\n\n        if ( !image ) return;\n        var texture = new Texture();\n        // GLTF texture origin is correct\n        texture.setFlipY( false );\n        texture.setWrapS( 'REPEAT' );\n        texture.setWrapT( 'REPEAT' );\n\n        this.loadFile( image.uri ).then( function ( data ) {\n            if ( !data ) return;\n            texture.setImage( data, ReaderWriterGLTF.TEXTURE_FORMAT[ glTFTexture.format ] );\n            stateSet.setTextureAttributeAndModes( location, texture );\n            if ( uniform ) {\n                stateSet.addUniform( Uniform.createInt( location, uniform ) );\n            }\n            return;\n        } );\n    } ),\n\n    /**\n     * Creates a MatrixTransform node by using\n     * glTF node's properties (matrix, translation, rotation, scale)\n     * @param  {Object} glTFNode glTF node\n     * @return {OSG.MatrixTransform} MatrixTransform node containing the glTF node transform\n     */\n    loadTransform: function ( glTFNode ) {\n\n        var mat = mat4.create();\n        // The transform is given under a matrix form\n        if ( glTFNode.matrix ) {\n            mat4.copy( mat, glTFNode.matrix );\n            return mat;\n        }\n        // The transform is given under the form\n        // translation, rotation, scale\n        var scale = glTFNode.scale || vec3.ONE;\n        var rot = glTFNode.rotation || quat.IDENTITY;\n        var trans = glTFNode.translation || vec3.ZERO;\n\n        mat4.fromRotationTranslationScale( mat, rot, trans, scale );\n        return mat;\n    },\n\n    preprocessChannel: function ( glTFChannel, glTFAnim ) {\n\n        var json = this._glTFJSON;\n        var promisesArray = [];\n\n        var glTFSampler = glTFAnim.samplers[ glTFChannel.sampler ];\n\n        var timeAccessor = json.accessors[ glTFSampler.input ];\n        var valueAccessor = json.accessors[ glTFSampler.output ];\n\n        var timePromise = this.loadAccessorBuffer( timeAccessor, null );\n        var valuePromise = this.loadAccessorBuffer( valueAccessor, null );\n\n        promisesArray.push( timePromise, valuePromise );\n\n        var self = this;\n\n        return P.all( promisesArray ).then( function ( timeAndValue ) {\n\n            var timeKeys = timeAndValue[ 0 ];\n            var valueKeys = timeAndValue[ 1 ];\n\n            var osgChannel = null;\n\n            if ( ReaderWriterGLTF.TYPE_TABLE[ valueAccessor.type ] === 4 ) {\n\n                osgChannel = createQuatChannel( valueKeys, timeKeys, glTFChannel.target.node, glTFSampler.output, null );\n\n            } else if ( ReaderWriterGLTF.TYPE_TABLE[ valueAccessor.type ] === 3 ) {\n\n                osgChannel = createVec3Channel( valueKeys, timeKeys, glTFChannel.target.node, glTFSampler.output, null );\n\n            }\n\n            self._animatedNodes[ glTFChannel.target.node ] = true;\n\n            return osgChannel;\n\n        } );\n    },\n\n    createAnimationFromChannels: function ( channelsPromiseArray, animName ) {\n        return P.all( channelsPromiseArray ).then( function ( channels ) {\n            return animation.createAnimation( channels, animName );\n        } );\n    },\n\n    /**\n     * Loads all the solid animations registering\n     * them in a BasicAnimationManager instance\n     * @return {BasicAnimationManager} the animation manager containing the animations\n     */\n    preprocessAnimations: P.method( function () {\n\n        var json = this._glTFJSON;\n\n        if ( !json.animations )\n            return;\n\n        var animPromiseArray = [];\n\n        var animationsObjectKeys = window.Object.keys( json.animations );\n        for ( var i = 0; i < animationsObjectKeys.length; ++i ) {\n\n            var glTFAnim = json.animations[ animationsObjectKeys[ i ] ];\n\n            var channelsPromiseArray = [];\n            // Creates each OSGJS channel\n            for ( var j = 0; j < glTFAnim.channels.length; ++j ) {\n\n                var glTFChannel = glTFAnim.channels[ j ];\n\n                var osgChannel = this.preprocessChannel( glTFChannel, glTFAnim );\n                channelsPromiseArray.push( osgChannel );\n            }\n\n            var animPromise = this.createAnimationFromChannels( channelsPromiseArray, animationsObjectKeys[ i ] );\n            animPromiseArray.push( animPromise );\n        }\n\n        var self = this;\n        return P.all( animPromiseArray ).then( function ( animations ) {\n\n            var animationManager = new BasicAnimationManager();\n            animationManager.init( animations );\n\n            self._basicAnimationManager = animationManager;\n\n        } );\n\n    } ),\n\n    loadBone: function ( boneId, skin ) {\n\n        var json = this._glTFJSON;\n        var node = json.nodes[ boneId ];\n\n        var self = this;\n\n        var inverseBindMatricesAccessor = json.accessors[ skin.inverseBindMatrices ];\n        var bonePromise = this.loadAccessorBuffer( inverseBindMatricesAccessor, null );\n        return bonePromise.then( function ( data ) {\n\n            // Creates the current bone\n            // initializing it with initial pose\n            for ( var i = 0; i < skin.jointNames.length; ++i ) {\n\n                if ( skin.jointNames[ i ] === node.jointName ) break;\n\n            }\n\n            var boneNode = new Bone( node.jointName );\n            var invMat = data.subarray( i * 16, i * 16 + 16 );\n            boneNode.setInvBindMatrixInSkeletonSpace( invMat );\n\n            self._bones[ boneId ] = boneNode;\n\n            return boneNode;\n        } );\n\n    },\n\n    buildInfluenceMap: function ( rootBoneId, skin ) {\n\n        if ( this._skeletonToInfluenceMap[ rootBoneId ] )\n            return;\n        this._skeletonToInfluenceMap[ rootBoneId ] = {};\n        for ( var j = 0; j < skin.jointNames.length; j++ ) {\n            var jointName = skin.jointNames[ j ];\n            this._skeletonToInfluenceMap[ rootBoneId ][ jointName ] = j;\n        }\n    },\n\n    mapBonesToSkin: function () {\n\n        var json = this._glTFJSON;\n\n        var boneToSkin = {};\n\n        // Maps each bone ID to its skin\n        var skinsKeys = window.Object.keys( json.skins );\n        for ( var i = 0; i < skinsKeys.length; ++i ) {\n\n            var skin = json.skins[ skinsKeys[ i ] ];\n\n            for ( var j = 0; j < skin.jointNames.length; ++j ) {\n\n                var jName = skin.jointNames[ j ];\n\n                var nodesKeys = window.Object.keys( json.nodes );\n                for ( var k = 0; k < nodesKeys.length; ++k ) {\n\n                    var node = json.nodes[ nodesKeys[ k ] ];\n\n                    if ( node.jointName && node.jointName === jName )\n                        boneToSkin[ nodesKeys[ k ] ] = skin;\n                }\n            }\n\n        }\n\n        return boneToSkin;\n\n    },\n\n    preprocessBones: function ( bonesToSkin ) {\n\n        var json = this._glTFJSON;\n        var nodesKeys = window.Object.keys( json.nodes );\n        var promises = [];\n        for ( var i = 0; i < nodesKeys.length; ++i ) {\n            var boneId = nodesKeys[ i ];\n            var boneNode = json.nodes[ boneId ];\n            if ( !boneNode.jointName )\n                continue;\n            var bonePromise = this.loadBone( boneId, bonesToSkin[ boneId ] );\n            promises.push( bonePromise );\n        }\n        return P.all( promises );\n    },\n\n    preprocessSkeletons: P.method( function () {\n\n        var json = this._glTFJSON;\n        if ( !json.skins )\n            return;\n        var bonesToSkin = this.mapBonesToSkin();\n\n        // Saves each skeleton in the skeleton maprep\n        var nodesKeys = window.Object.keys( json.nodes );\n        for ( var j = 0; j < nodesKeys.length; ++j ) {\n\n            var nodeId = nodesKeys[ j ];\n            var node = json.nodes[ nodeId ];\n            var skin = json.skins[ node.skin ];\n\n            if ( !node.skeletons )\n                continue;\n\n            for ( var i = 0; i < node.skeletons.length; ++i ) {\n                var rootBoneId = null;\n                var rootJointId = node.skeletons[ i ];\n                for ( var k = 0; k < nodesKeys.length; ++k ) {\n                    var subnodeId = nodesKeys[ k ];\n                    var subnode = json.nodes[ subnodeId ];\n                    if ( !subnode.jointName )\n                        continue;\n                    var rootJoint = json.nodes[ rootJointId ];\n                    if ( subnode.jointName === rootJoint.jointName ) {\n                        rootBoneId = subnodeId;\n                        break;\n                    }\n                }\n                if ( rootBoneId && !this._skeletons[ rootBoneId ] ) {\n                    this._skeletons[ rootJointId ] = new Skeleton();\n                    // Adds missing bone to the boneMap\n                    bonesToSkin[ rootBoneId ] = skin;\n                }\n                this.buildInfluenceMap( rootJointId, skin );\n            }\n        }\n\n        return this.preprocessBones( bonesToSkin );\n    } ),\n\n    loadPBRMaterial: P.method( function ( materialId, glTFmaterial, geometryNode, extension ) {\n\n        var pbrMetallicRoughness = glTFmaterial.pbrMetallicRoughness;\n        var osgStateSet = geometryNode.getOrCreateStateSet();\n\n        var promises = [];\n        var model = '';\n        if ( pbrMetallicRoughness ) {\n            if ( pbrMetallicRoughness.baseColorTexture )\n                promises.push( this.createTextureAndSetAttrib( pbrMetallicRoughness.baseColorTexture, osgStateSet, ReaderWriterGLTF.ALBEDO_TEXTURE_UNIT, ReaderWriterGLTF.ALBEDO_UNIFORM ) );\n            if ( pbrMetallicRoughness.metallicRoughnessTexture )\n                promises.push( this.createTextureAndSetAttrib( pbrMetallicRoughness.metallicRoughnessTexture, osgStateSet, ReaderWriterGLTF.METALLIC_ROUGHNESS_TEXTURE_UNIT, ReaderWriterGLTF.METALLIC_ROUGHNESS_UNIFORM ) );\n            model = ReaderWriterGLTF.PBR_METAL_MODE;\n        }\n        if ( extension ) {\n            if ( extension.diffuseTexture ) {\n                promises.push( this.createTextureAndSetAttrib( extension.diffuseTexture, osgStateSet, ReaderWriterGLTF.DIFFUSE_TEXTURE_UNIT, ReaderWriterGLTF.ALBEDO_UNIFORM ) );\n            }\n            if ( extension.specularGlossinessTexture ) {\n                promises.push( this.createTextureAndSetAttrib( extension.specularGlossinessTexture, osgStateSet, ReaderWriterGLTF.SPECULAR_GLOSSINESS_TEXTURE_UNIT, ReaderWriterGLTF.METALLIC_ROUGHNESS_UNIFORM ) );\n            }\n            model = ReaderWriterGLTF.PBR_SPEC_MODE;\n        }\n        if ( glTFmaterial.normalTexture )\n            promises.push( this.createTextureAndSetAttrib( glTFmaterial.normalTexture, osgStateSet, ReaderWriterGLTF.NORMAL_TEXTURE_UNIT, ReaderWriterGLTF.NORMAL_UNIFORM ) );\n        if ( glTFmaterial.occlusionTexture )\n            promises.push( this.createTextureAndSetAttrib( glTFmaterial.occlusionTexture, osgStateSet, ReaderWriterGLTF.AO_TEXTURE_UNIT, ReaderWriterGLTF.AO_UNIFORM ) );\n\n        // TODO:Need to check for specular glossiness extension\n        geometryNode.setUserData( {\n            pbrWorklow: model\n        } );\n\n        geometryNode.stateset = osgStateSet;\n        osgStateSet.setRenderingHint( 'TRANSPARENT_BIN' );\n        osgStateSet.setRenderBinDetails( 1000, 'RenderBin' );\n        osgStateSet.setAttributeAndModes( new BlendFunc( 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA' ) );\n        this._stateSetMap[ materialId ] = osgStateSet;\n\n        return P.all( promises );\n    } ),\n\n    loadMaterial: P.method( function ( materialId, geometryNode ) {\n\n        var json = this._glTFJSON;\n        var glTFmaterial = json.materials[ materialId ];\n\n        if ( this._stateSetMap[ materialId ] ) {\n            geometryNode.stateset = this._stateSetMap[ materialId ];\n            return;\n        }\n\n        var extension = this.findByKey( glTFmaterial.extensions, ReaderWriterGLTF.PBR_SPEC_EXT );\n        if ( glTFmaterial.pbrMetallicRoughness || extension )\n            return this.loadPBRMaterial( materialId, glTFmaterial, geometryNode, extension );\n\n        var values = glTFmaterial.values;\n        if ( !values ) return;\n\n        // Handles basic material attributes\n        var osgMaterial = new Material();\n        var osgStateSet = geometryNode.getOrCreateStateSet();\n        osgStateSet.setAttribute( osgMaterial );\n\n        if ( values.ambient )\n            osgMaterial.setAmbient( values.ambient );\n        if ( values.emission )\n            osgMaterial.setEmission( values.emission );\n        if ( values.shininess )\n            osgMaterial.setShininess( values.shininess );\n        if ( values.specular )\n            osgMaterial.setSpecular( values.specular );\n\n        // Create a texture for the diffuse, if any\n        if ( values.diffuse ) {\n\n            if ( typeof ( values.diffuse ) !== 'string' )\n                osgMaterial.setDiffuse( values.diffuse );\n            else\n                return this.createTextureAndSetAttrib( values.diffuse, osgStateSet, 0 );\n        }\n\n        geometryNode.stateset = osgStateSet;\n        this._stateSetMap[ materialId ] = osgStateSet;\n\n        return;\n    } ),\n\n    createGeometry: function ( primitive, skeletonJointId ) {\n\n        var json = this._glTFJSON;\n        var promisesArray = [];\n\n        // Builds the geometry from the extracted vertices & normals\n        var geom = new Geometry();\n        var rigOrGeom = geom;\n\n        var cbSetBuffer = function ( name, buffer ) {\n\n            if ( !buffer )\n                return;\n\n            this.getVertexAttributeList()[ name ] = buffer;\n\n        };\n\n        if ( skeletonJointId ) {\n\n            rigOrGeom = new RigGeometry();\n            rigOrGeom._boneNameID = this._skeletonToInfluenceMap[ skeletonJointId ];\n\n        }\n\n        var attributeWeight = function ( data ) {\n\n            if ( !data )\n                return;\n\n            rigOrGeom.getAttributes().Weights = data;\n\n            var elts = rigOrGeom.getAttributes().Weights.getElements();\n            for ( var i = 0, l = elts.length / 4; i < l; ++i ) {\n                var sum = elts[ i * 4 ] + elts[ i * 4 + 1 ] + elts[ i * 4 + 2 ] + elts[ i * 4 + 3 ];\n                var correc = 1.0 / sum;\n                elts[ i * 4 ] *= correc;\n                elts[ i * 4 + 1 ] *= correc;\n                elts[ i * 4 + 2 ] *= correc;\n                elts[ i * 4 + 3 ] *= correc;\n            }\n\n        };\n\n        // Registers each glTF primitive attributes\n        // into a respective geometry attribute\n        var attributesKeys = window.Object.keys( primitive.attributes );\n        for ( var i = 0; i < attributesKeys.length; ++i ) {\n\n            var accessor = json.accessors[ primitive.attributes[ attributesKeys[ i ] ] ];\n            var promise = this.loadAccessorBuffer( accessor, BufferArray.ARRAY_BUFFER );\n\n            if ( attributesKeys[ i ].indexOf( 'POSITION' ) !== -1 ) {\n\n                promise.then( cbSetBuffer.bind( geom, 'Vertex' ) );\n\n            } else if ( attributesKeys[ i ].indexOf( 'NORMAL' ) !== -1 ) {\n\n                promise.then( cbSetBuffer.bind( geom, 'Normal' ) );\n\n            } else if ( attributesKeys[ i ].indexOf( 'TANGENT' ) !== -1 ) {\n\n                promise.then( cbSetBuffer.bind( geom, 'Tangent' ) );\n\n            } else if ( attributesKeys[ i ].indexOf( 'JOINT' ) !== -1 ) {\n\n                promise.then( cbSetBuffer.bind( rigOrGeom, 'Bones' ) );\n\n            } else if ( attributesKeys[ i ].indexOf( 'WEIGHT' ) !== -1 ) {\n\n                promise.then( attributeWeight );\n\n            } else if ( attributesKeys[ i ].indexOf( 'TEXCOORD' ) !== -1 ) {\n\n                var texCoordId = attributesKeys[ i ].substr( 9 );\n                promise.then( cbSetBuffer.bind( geom, 'TexCoord' + texCoordId ) );\n\n            }\n\n            promisesArray.push( promise );\n\n        }\n\n        var indicesAccessor = json.accessors[ primitive.indices ];\n        var indicesPromise = this.loadAccessorBuffer( indicesAccessor, BufferArray.ELEMENT_ARRAY_BUFFER );\n        indicesPromise.then( function ( data ) {\n\n            if ( !data )\n                return;\n\n            var osgPrimitive = new DrawElements( primitiveSet.TRIANGLES, data );\n            geom.getPrimitives().push( osgPrimitive );\n\n        } );\n\n        promisesArray.push( indicesPromise );\n\n        if ( primitive.material !== undefined )\n            promisesArray.push( this.loadMaterial( primitive.material, geom ) );\n\n        return P.all( promisesArray ).then( function () {\n\n            if ( skeletonJointId ) {\n\n                rigOrGeom.setSourceGeometry( geom );\n                rigOrGeom.mergeChildrenData();\n\n                rigOrGeom.computeBoundingBox = geom.computeBoundingBox;\n            }\n\n            return rigOrGeom;\n\n        } );\n    },\n\n    loadGLTFPrimitives: function ( meshId, resultMeshNode, skeletonJointId ) {\n\n        var json = this._glTFJSON;\n        var mesh = json.meshes[ meshId ];\n\n        var primitives = mesh.primitives;\n\n        var promisesArray = [];\n\n        for ( var i = 0; i < primitives.length; ++i ) {\n\n            var primitive = primitives[ i ];\n            var promiseGeom = this.createGeometry( primitive, skeletonJointId );\n\n            promisesArray.push( promiseGeom );\n\n        }\n\n        return P.all( promisesArray ).then( function ( geoms ) {\n\n            for ( var i = 0; i < geoms.length; ++i )\n                resultMeshNode.addChild( geoms[ i ] );\n\n            return geoms;\n\n        } );\n    },\n\n    loadGLTFNode: P.method( function ( nodeId, root ) {\n\n        if ( this._visitedNodes[ nodeId ] )\n            return;\n\n        var json = this._glTFJSON;\n        var glTFNode = json.nodes[ nodeId ];\n\n        var currentNode = ( glTFNode.jointName ) ? this._bones[ nodeId ] : new MatrixTransform();\n        currentNode.setName( nodeId );\n        mat4.copy( currentNode.getMatrix(), this.loadTransform( glTFNode ) );\n\n        if ( glTFNode.jointName && this._skeletons[ glTFNode.joinName ] ) {\n            var skeleton = this._skeletons[ glTFNode.jointName ];\n            skeleton.addChild( currentNode );\n            root.addChild( skeleton );\n        }\n\n        // Recurses on children before\n        // processing the current node\n        var children = glTFNode.children;\n        var i;\n        var promises = [];\n        if ( children ) {\n            for ( i = 0; i < children.length; ++i ) {\n                var nodePromise = this.loadGLTFNode( children[ i ], currentNode );\n                promises.push( nodePromise );\n            }\n        }\n        // Loads meshes contained in the node\n        // Adds RigGeometry to corresponding skeleton if any\n        if ( glTFNode.mesh !== undefined ) {\n            var meshId = glTFNode.mesh;\n            if ( !glTFNode.skeletons ) {\n                var geomPromise = this.loadGLTFPrimitives( meshId, currentNode, null );\n                promises.push( geomPromise );\n            } else {\n\n                for ( var j = 0; j < glTFNode.skeletons.length; ++j ) {\n                    var rootJointId = glTFNode.skeletons[ j ];\n                    var skeletonNode = this._skeletons[ rootJointId ];\n                    var meshTransformNode = new MatrixTransform();\n                    mat4.copy( meshTransformNode.getMatrix(), currentNode.getMatrix() );\n                    var geomP = this.loadGLTFPrimitives( meshId, meshTransformNode, rootJointId );\n                    skeletonNode.addChild( meshTransformNode );\n                    promises.push( geomP );\n                }\n            }\n        }\n        // Loads solid animations\n        // by adding an update callback\n        if ( this._animatedNodes[ nodeId ] )\n            this.registerUpdateCallback( nodeId, currentNode );\n\n        if ( !this._skeletons[ nodeId ] )\n            root.addChild( currentNode );\n\n        this._visitedNodes[ nodeId ] = true;\n        return P.all( promises );\n    } ),\n\n    readNodeURL: function ( url, options ) {\n        var defer = P.defer();\n        var self = this;\n\n        this.init();\n        if ( options && options.filesMap !== undefined && options.filesMap.size > 0 ) {\n            // it comes from the ZIP plugin or from drag'n drop\n            // So we already have all the files.\n            this._filesMap = options.filesMap;\n            var glTFFile = this._filesMap.get( url );\n            return this.readJSON( glTFFile, url );\n        }\n\n        var index = url.lastIndexOf( '/' );\n        this._localPath = ( index === -1 ) ? '' : url.substr( 0, index + 1 );\n        // Else it is a usual XHR request\n        var filePromise = requestFile( url );\n        filePromise.then( function ( glTFFile ) {\n            defer.resolve( self.readJSON( glTFFile ) );\n        } );\n        return defer.promise;\n    },\n\n    readJSON: P.method( function ( glTFFile, url ) {\n        // Creates the root node\n        // adding a PI / 2 rotation arround the X-axis\n        var root = new MatrixTransform();\n        root.setName( url );\n\n        var json = JSON.parse( glTFFile );\n        if ( !json ) return;\n\n        this._glTFJSON = json;\n\n        var promisesArray = [];\n        // Preprocesses animations\n        var animPromise = this.preprocessAnimations();\n        // Preprocesses skin animations if any\n        var skeletonPromise = this.preprocessSkeletons();\n\n        promisesArray.push( skeletonPromise, animPromise );\n        var self = this;\n        return P.all( promisesArray ).then( function () {\n\n            var promises = [];\n            // Loops through each scene\n            // loading geometry nodes, transform nodes, etc...s\n            var sceneKeys = window.Object.keys( json.scenes );\n            for ( var i = 0; i < sceneKeys.length; ++i ) {\n\n                var scene = json.scenes[ sceneKeys[ i ] ];\n\n                if ( !scene )\n                    continue;\n                for ( var j = 0; j < scene.nodes.length; ++j ) {\n                    var p = self.loadGLTFNode( scene.nodes[ j ], root );\n                    promises.push( p );\n                }\n            }\n\n            // Register the animation manager\n            // if the glTF file contains animations\n            if ( self._basicAnimationManager )\n                root.addUpdateCallback( self._basicAnimationManager );\n\n            return P.all( promises ).then( function () {\n\n                return root;\n\n            } );\n\n        } );\n    } )\n\n};\n\nRegistry.instance().addReaderWriter( 'gltf', new ReaderWriterGLTF() );\n\nmodule.exports = ReaderWriterGLTF;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgPlugins/ReaderWriterGLTF.js\n// module id = 251\n// module chunks = 0 1 2","'use strict';\nvar P = require( 'bluebird' );\nvar requestFile = require( 'osgDB/requestFile.js' );\nvar Notify = require( 'osg/notify' );\nvar Registry = require( 'osgDB/Registry' );\nvar ReaderParser = require( 'osgDB/readerParser' );\nvar FileHelper = require( 'osgDB/FileHelper' );\nvar JSZip = window.JSZip;\n\nvar ReaderWriterZIP = function () {\n    this._options = undefined;\n    this._filesMap = new window.Map();\n    this._fileName = ''; // The file containing the model of the archive ( gltf, glb, osgjs, b3dm, etc )\n};\n\n\nReaderWriterZIP.prototype = {\n\n    readNodeURL: function ( url, options ) {\n        var defer = P.defer();\n        if ( JSZip === undefined ) {\n            Notify.error( 'You need to add JSZip as a dependency' );\n            return defer.reject();\n        }\n        Notify.log( 'starting to read: ' + url );\n        // Check if we already have the file\n        var self = this;\n        if ( options && options.filesMap !== undefined ) {\n            // it comes  from drag'n drop\n            if ( options.filesMap.has( url ) ) {\n                // Now url is a File\n                var file = options.filesMap.get( url );\n                return this.readZipFile( file ).then( function () {\n\n                    if ( !self._fileName.length ) return P.reject( self );\n\n                    // At this point we have the main file name and a Map containing all the resources\n                    return ReaderParser.readNodeURL( self._fileName, {\n                        filesMap: self._filesMap\n                    } );\n                } );\n            }\n        }\n\n        var filePromise = requestFile( url, {\n            responseType: 'blob'\n        } );\n\n        filePromise.then( function ( file ) {\n            self.readZipFile( file ).then( function () {\n                // At this point we have the main file name and a Map containing all the resources\n                defer.resolve( ReaderParser.readNodeURL( self._fileName, {\n                    filesMap: self._filesMap\n                } ) );\n            } );\n        } );\n        return defer.promise;\n    },\n\n    _registerZipImage: function ( fileName, type, extension, fileData ) {\n        var data = fileData;\n        // Is an image\n        if ( type === 'base64' ) {\n            data = new window.Image();\n            data.src = 'data:image/' + extension + ';base64,' + fileData;\n        }\n        this._filesMap.set( fileName, data );\n    },\n\n    readZipFile: function ( fileOrBlob ) {\n        var defer = P.defer();\n        JSZip.loadAsync( fileOrBlob ).then( function ( zip ) {\n            var promisesArray = [];\n\n            for ( var fileName in zip.files ) {\n                var extension = fileName.substr( fileName.lastIndexOf( '.' ) + 1 );\n                // Check if the file is readable by any osgDB plugin\n                var readerWriter = Registry.instance().getReaderWriterForExtension( extension );\n                // We need a hack for osgjs til it is converted to a readerwriter\n                if ( readerWriter !== undefined || extension === 'osgjs' ) {\n                    // So this is the main file to read\n                    this._fileName = fileName;\n                }\n\n                var type = FileHelper.getTypeForExtension( extension );\n                // We don't need to parse this file\n                if ( type === undefined ) continue;\n                if ( type === 'blob' ) type = 'base64'; // Images are base64 encoded in ZIP files\n\n                var p = zip.file( fileName ).async( type ).then( this._registerZipImage.bind( this, fileName, type, extension ) );\n                promisesArray.push( p );\n            }\n\n            P.all( promisesArray ).then( function () {\n                defer.resolve();\n            } );\n        }.bind( this ) );\n\n        return defer.promise;\n\n    }\n\n};\n\nRegistry.instance().addReaderWriter( 'zip', new ReaderWriterZIP() );\n\nmodule.exports = ReaderWriterZIP;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/osgPlugins/ReaderWriterZIP.js\n// module id = 252\n// module chunks = 0 1 2"],"sourceRoot":""}